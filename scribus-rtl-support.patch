diff -rupN orginal/scribus/CMakeLists.txt patched/scribus/CMakeLists.txt
--- orginal/scribus/CMakeLists.txt	2013-02-26 23:28:44.000000000 +0300
+++ patched/scribus/CMakeLists.txt	2014-05-02 00:43:32.844680535 +0300
@@ -9,6 +9,8 @@ ADD_SUBDIRECTORY(colormgmt)
 ADD_SUBDIRECTORY(profiles)
 ADD_SUBDIRECTORY(styles)
 ADD_SUBDIRECTORY(text)
+ADD_SUBDIRECTORY(harfbuzz)
+ADD_SUBDIRECTORY(fribidi)
 ADD_SUBDIRECTORY(fonts)
 ADD_SUBDIRECTORY(desaxe)
 ADD_SUBDIRECTORY(unicodemap)
@@ -454,6 +456,7 @@ SET(SCRIBUS_SOURCES
   pageitem_pathtext.cpp
   pageitem_polygon.cpp
   pageitem_polyline.cpp
+  shaper.cpp
   pageitem_textframe.cpp
   pageitemattributes.cpp
   pageitempointer.cpp
@@ -679,6 +682,8 @@ LINK_DIRECTORIES(
 
 SET(SCRIBUS_COLORMGMT_LIB "scribus_colormgmt_lib")
 SET(SCRIBUS_TEXT_LIB "scribus_text_lib")
+SET(SCRIBUS_HARFBUZZ_LIB "scribus_harfbuzz_lib")
+SET(SCRIBUS_FRIBIDI_LIB "scribus_fribidi_lib")
 SET(SCRIBUS_STYLES_LIB "scribus_styles_lib")
 SET(SCRIBUS_FONTS_LIB "scribus_fonts_lib")
 SET(SCRIBUS_DESAXE_LIB "scribus_desaxe_lib")
@@ -717,6 +722,8 @@ ADD_EXECUTABLE(${EXE_NAME}
   ${SCRIBUS_MAIN_CPP}
   ${SCRIBUS_UI_SOURCES}
   ${SCRIBUS_TEXT_SOURCES}
+  ${SCRIBUS_HARFBUZZ_SOURCES}
+  ${SCRIBUS_FRIBIDI_SOURCES}
   ${SCRIBUS_STYLES_SOURCES}
   ${SCRIBUS_COLORMGMT_SOURCES}
   ${SCRIBUS_FONTS_SOURCES}
@@ -810,6 +817,8 @@ TARGET_LINK_LIBRARIES(${EXE_NAME}
   ${SCRIBUS_TEXT_LIB}
   ${SCRIBUS_STYLES_LIB}
   ${SCRIBUS_FONTS_LIB}
+  ${SCRIBUS_HARFBUZZ_LIB}
+  ${SCRIBUS_FRIBIDI_LIB}
   ${LCMS_LIBRARIES}
 )
 
diff -rupN orginal/scribus/fribidi/arabic-misc.tab.i patched/scribus/fribidi/arabic-misc.tab.i
--- orginal/scribus/fribidi/arabic-misc.tab.i	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/fribidi/arabic-misc.tab.i	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,94 @@
+/* The tables in this file should all be sorted on their first item. */
+
+/* *INDENT-OFF* */
+
+const PairMap mandatory_liga_table[] = {
+  {{0xFEDF, 0xFE82}, 0xFEF5},
+  {{0xFEDF, 0xFE84}, 0xFEF7},
+  {{0xFEDF, 0xFE88}, 0xFEF9},
+  {{0xFEDF, 0xFE8E}, 0xFEFB},
+  {{0xFEE0, 0xFE82}, 0xFEF6},
+  {{0xFEE0, 0xFE84}, 0xFEF8},
+  {{0xFEE0, 0xFE88}, 0xFEFA},
+  {{0xFEE0, 0xFE8E}, 0xFEFC},
+};
+
+
+const PairMap console_liga_table[] = {
+  {{0x0640, 0xFC60}, 0xFCF2},
+  {{0x0640, 0xFC61}, 0xFCF3},
+  {{0x0640, 0xFC62}, 0xFCF4},
+  {{0x0640, 0xFE70}, 0xFE71},
+  {{0x0640, 0xFE76}, 0xFE77},
+  {{0x0640, 0xFE78}, 0xFE79},
+  {{0x0640, 0xFE7A}, 0xFE7B},
+  {{0x0640, 0xFE7C}, 0xFE7D},
+  {{0x0640, 0xFE7E}, 0xFE7F},
+  {{0xFBE8, 0x0654}, 0xFE8B},
+  {{0xFBE9, 0x0654}, 0xFE8C},
+  {{0xFBFC, 0x0654}, 0xFE89},
+  {{0xFBFC, 0x0670}, 0xFC5D},
+  {{0xFBFD, 0x0654}, 0xFE8A},
+  {{0xFBFD, 0x0670}, 0xFC90},
+  {{0xFE7C, 0x0670}, 0xFC63},
+  {{0xFE7C, 0xFE72}, 0xFC5E},
+  {{0xFE7C, 0xFE74}, 0xFC5F},
+  {{0xFE7C, 0xFE76}, 0xFC60},
+  {{0xFE7C, 0xFE78}, 0xFC61},
+  {{0xFE7C, 0xFE7A}, 0xFC62},
+  {{0xFE7D, 0xFE76}, 0xFCF2},
+  {{0xFE7D, 0xFE77}, 0xFCF2},
+  {{0xFE7D, 0xFE78}, 0xFCF3},
+  {{0xFE7D, 0xFE79}, 0xFCF3},
+  {{0xFE7D, 0xFE7A}, 0xFCF4},
+  {{0xFE7D, 0xFE7B}, 0xFCF4},
+  {{0xFE8D, 0x0653}, 0xFE81},
+  {{0xFE8D, 0x0654}, 0xFE83},
+  {{0xFE8D, 0x0655}, 0xFE87},
+  {{0xFE8D, 0xFE70}, 0xFD3D},
+  {{0xFE8E, 0x0653}, 0xFE82},
+  {{0xFE8E, 0x0654}, 0xFE84},
+  {{0xFE8E, 0x0655}, 0xFE88},
+  {{0xFE8E, 0xFE70}, 0xFD3C},
+  {{0xFEE9, 0x0654}, 0xFBA4},
+  {{0xFEEA, 0x0654}, 0xFBA5},
+  {{0xFEED, 0x0654}, 0xFE85},
+  {{0xFEEE, 0x0654}, 0xFE86},
+  {{0xFEEF, 0x0654}, 0xFE89},
+  {{0xFEEF, 0x0670}, 0xFC5D},
+  {{0xFEF0, 0x0654}, 0xFE8A},
+  {{0xFEF0, 0x0670}, 0xFC90},
+  {{0xFEF1, 0x0654}, 0xFE89},
+  {{0xFEF1, 0x0670}, 0xFC5D},
+  {{0xFEF2, 0x0654}, 0xFE8A},
+  {{0xFEF2, 0x0670}, 0xFC90},
+  {{0xFEF3, 0x0654}, 0xFE8B},
+  {{0xFEF4, 0x0654}, 0xFE8C},
+  {{0xFEFB, 0x0653}, 0xFEF5},
+  {{0xFEFB, 0x0654}, 0xFEF7},
+  {{0xFEFB, 0x0655}, 0xFEF9},
+  {{0xFEFC, 0x0653}, 0xFEF6},
+  {{0xFEFC, 0x0654}, 0xFEF8},
+  {{0xFEFC, 0x0655}, 0xFEFA},
+};
+
+
+static const FriBidiChar NSMShap[][4] = {
+  {0xFE70, 0xFE71, 0xFE70, 0xFE71,},
+  {0xFE72, 0xFE72, 0xFE72, 0xFE72,},
+  {0xFE74, 0xFE74, 0xFE74, 0xFE74,},
+  {0xFE76, 0xFE77, 0xFE76, 0xFE77,},
+  {0xFE78, 0xFE79, 0xFE78, 0xFE79,},
+  {0xFE7A, 0xFE7B, 0xFE7A, 0xFE7B,},
+  {0xFE7C, 0xFE7D, 0xFE7C, 0xFE7D,},
+  {0xFE7E, 0xFE7F, 0xFE7E, 0xFE7F,},
+};
+
+/* *INDENT-ON* */
+
+#ifndef FRIBIDI_ACCESS_SHAPE_TABLE
+# define FRIBIDI_ACCESS_SHAPE_TABLE(table,min,max,x,shape) \
+	(((x)<(min)||(x)>(max))?(x):(table)[(x)-(min)][(shape)])
+#endif
+
+#define FRIBIDI_GET_ARABIC_SHAPE_NSM(x,shape) FRIBIDI_ACCESS_SHAPE_TABLE(NSMShap, 0x064B, 0x0652, (x), (shape))
diff -rupN orginal/scribus/fribidi/arabic-shaping.tab.i patched/scribus/fribidi/arabic-shaping.tab.i
--- orginal/scribus/fribidi/arabic-shaping.tab.i	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/fribidi/arabic-shaping.tab.i	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,205 @@
+/* arabic-shaping.tab.i
+ * generated by gen-arabic-shaping-tab (GNU FriBidi 0.19.1)
+ * from the files UnicodeData.txt, (null) of Unicode version 5.1.0. */
+
+/*
+  use FRIBIDI_GET_ARABIC_SHAPE_PRES(key,shape) to access your table
+
+  required memory: 2864
+ */
+
+
+/* *INDENT-OFF* */
+
+static const FriBidiChar ArShap[179][4] = {
+  {0xfe80,0x0621,0x0621,0x0621,},
+  {0xfe81,0xfe82,0x0622,0x0622,},
+  {0xfe83,0xfe84,0x0623,0x0623,},
+  {0xfe85,0xfe86,0x0624,0x0624,},
+  {0xfe87,0xfe88,0x0625,0x0625,},
+  {0xfe89,0xfe8a,0xfe8b,0xfe8c,},
+  {0xfe8d,0xfe8e,0x0627,0x0627,},
+  {0xfe8f,0xfe90,0xfe91,0xfe92,},
+  {0xfe93,0xfe94,0x0629,0x0629,},
+  {0xfe95,0xfe96,0xfe97,0xfe98,},
+  {0xfe99,0xfe9a,0xfe9b,0xfe9c,},
+  {0xfe9d,0xfe9e,0xfe9f,0xfea0,},
+  {0xfea1,0xfea2,0xfea3,0xfea4,},
+  {0xfea5,0xfea6,0xfea7,0xfea8,},
+  {0xfea9,0xfeaa,0x062f,0x062f,},
+  {0xfeab,0xfeac,0x0630,0x0630,},
+  {0xfead,0xfeae,0x0631,0x0631,},
+  {0xfeaf,0xfeb0,0x0632,0x0632,},
+  {0xfeb1,0xfeb2,0xfeb3,0xfeb4,},
+  {0xfeb5,0xfeb6,0xfeb7,0xfeb8,},
+  {0xfeb9,0xfeba,0xfebb,0xfebc,},
+  {0xfebd,0xfebe,0xfebf,0xfec0,},
+  {0xfec1,0xfec2,0xfec3,0xfec4,},
+  {0xfec5,0xfec6,0xfec7,0xfec8,},
+  {0xfec9,0xfeca,0xfecb,0xfecc,},
+  {0xfecd,0xfece,0xfecf,0xfed0,},
+  {0x063b,0x063b,0x063b,0x063b,},
+  {0x063c,0x063c,0x063c,0x063c,},
+  {0x063d,0x063d,0x063d,0x063d,},
+  {0x063e,0x063e,0x063e,0x063e,},
+  {0x063f,0x063f,0x063f,0x063f,},
+  {0x0640,0x0640,0x0640,0x0640,},
+  {0xfed1,0xfed2,0xfed3,0xfed4,},
+  {0xfed5,0xfed6,0xfed7,0xfed8,},
+  {0xfed9,0xfeda,0xfedb,0xfedc,},
+  {0xfedd,0xfede,0xfedf,0xfee0,},
+  {0xfee1,0xfee2,0xfee3,0xfee4,},
+  {0xfee5,0xfee6,0xfee7,0xfee8,},
+  {0xfee9,0xfeea,0xfeeb,0xfeec,},
+  {0xfeed,0xfeee,0x0648,0x0648,},
+  {0xfeef,0xfef0,0xfbe8,0xfbe9,},
+  {0xfef1,0xfef2,0xfef3,0xfef4,},
+  {0x064b,0x064b,0x064b,0x064b,},
+  {0x064c,0x064c,0x064c,0x064c,},
+  {0x064d,0x064d,0x064d,0x064d,},
+  {0x064e,0x064e,0x064e,0x064e,},
+  {0x064f,0x064f,0x064f,0x064f,},
+  {0x0650,0x0650,0x0650,0x0650,},
+  {0x0651,0x0651,0x0651,0x0651,},
+  {0x0652,0x0652,0x0652,0x0652,},
+  {0x0653,0x0653,0x0653,0x0653,},
+  {0x0654,0x0654,0x0654,0x0654,},
+  {0x0655,0x0655,0x0655,0x0655,},
+  {0x0656,0x0656,0x0656,0x0656,},
+  {0x0657,0x0657,0x0657,0x0657,},
+  {0x0658,0x0658,0x0658,0x0658,},
+  {0x0659,0x0659,0x0659,0x0659,},
+  {0x065a,0x065a,0x065a,0x065a,},
+  {0x065b,0x065b,0x065b,0x065b,},
+  {0x065c,0x065c,0x065c,0x065c,},
+  {0x065d,0x065d,0x065d,0x065d,},
+  {0x065e,0x065e,0x065e,0x065e,},
+  {0x065f,0x065f,0x065f,0x065f,},
+  {0x0660,0x0660,0x0660,0x0660,},
+  {0x0661,0x0661,0x0661,0x0661,},
+  {0x0662,0x0662,0x0662,0x0662,},
+  {0x0663,0x0663,0x0663,0x0663,},
+  {0x0664,0x0664,0x0664,0x0664,},
+  {0x0665,0x0665,0x0665,0x0665,},
+  {0x0666,0x0666,0x0666,0x0666,},
+  {0x0667,0x0667,0x0667,0x0667,},
+  {0x0668,0x0668,0x0668,0x0668,},
+  {0x0669,0x0669,0x0669,0x0669,},
+  {0x066a,0x066a,0x066a,0x066a,},
+  {0x066b,0x066b,0x066b,0x066b,},
+  {0x066c,0x066c,0x066c,0x066c,},
+  {0x066d,0x066d,0x066d,0x066d,},
+  {0x066e,0x066e,0x066e,0x066e,},
+  {0x066f,0x066f,0x066f,0x066f,},
+  {0x0670,0x0670,0x0670,0x0670,},
+  {0xfb50,0xfb51,0x0671,0x0671,},
+  {0x0672,0x0672,0x0672,0x0672,},
+  {0x0673,0x0673,0x0673,0x0673,},
+  {0x0674,0x0674,0x0674,0x0674,},
+  {0x0675,0x0675,0x0675,0x0675,},
+  {0x0676,0x0676,0x0676,0x0676,},
+  {0xfbdd,0x0677,0x0677,0x0677,},
+  {0x0678,0x0678,0x0678,0x0678,},
+  {0xfb66,0xfb67,0xfb68,0xfb69,},
+  {0xfb5e,0xfb5f,0xfb60,0xfb61,},
+  {0xfb52,0xfb53,0xfb54,0xfb55,},
+  {0x067c,0x067c,0x067c,0x067c,},
+  {0x067d,0x067d,0x067d,0x067d,},
+  {0xfb56,0xfb57,0xfb58,0xfb59,},
+  {0xfb62,0xfb63,0xfb64,0xfb65,},
+  {0xfb5a,0xfb5b,0xfb5c,0xfb5d,},
+  {0x0681,0x0681,0x0681,0x0681,},
+  {0x0682,0x0682,0x0682,0x0682,},
+  {0xfb76,0xfb77,0xfb78,0xfb79,},
+  {0xfb72,0xfb73,0xfb74,0xfb75,},
+  {0x0685,0x0685,0x0685,0x0685,},
+  {0xfb7a,0xfb7b,0xfb7c,0xfb7d,},
+  {0xfb7e,0xfb7f,0xfb80,0xfb81,},
+  {0xfb88,0xfb89,0x0688,0x0688,},
+  {0x0689,0x0689,0x0689,0x0689,},
+  {0x068a,0x068a,0x068a,0x068a,},
+  {0x068b,0x068b,0x068b,0x068b,},
+  {0xfb84,0xfb85,0x068c,0x068c,},
+  {0xfb82,0xfb83,0x068d,0x068d,},
+  {0xfb86,0xfb87,0x068e,0x068e,},
+  {0x068f,0x068f,0x068f,0x068f,},
+  {0x0690,0x0690,0x0690,0x0690,},
+  {0xfb8c,0xfb8d,0x0691,0x0691,},
+  {0x0692,0x0692,0x0692,0x0692,},
+  {0x0693,0x0693,0x0693,0x0693,},
+  {0x0694,0x0694,0x0694,0x0694,},
+  {0x0695,0x0695,0x0695,0x0695,},
+  {0x0696,0x0696,0x0696,0x0696,},
+  {0x0697,0x0697,0x0697,0x0697,},
+  {0xfb8a,0xfb8b,0x0698,0x0698,},
+  {0x0699,0x0699,0x0699,0x0699,},
+  {0x069a,0x069a,0x069a,0x069a,},
+  {0x069b,0x069b,0x069b,0x069b,},
+  {0x069c,0x069c,0x069c,0x069c,},
+  {0x069d,0x069d,0x069d,0x069d,},
+  {0x069e,0x069e,0x069e,0x069e,},
+  {0x069f,0x069f,0x069f,0x069f,},
+  {0x06a0,0x06a0,0x06a0,0x06a0,},
+  {0x06a1,0x06a1,0x06a1,0x06a1,},
+  {0x06a2,0x06a2,0x06a2,0x06a2,},
+  {0x06a3,0x06a3,0x06a3,0x06a3,},
+  {0xfb6a,0xfb6b,0xfb6c,0xfb6d,},
+  {0x06a5,0x06a5,0x06a5,0x06a5,},
+  {0xfb6e,0xfb6f,0xfb70,0xfb71,},
+  {0x06a7,0x06a7,0x06a7,0x06a7,},
+  {0x06a8,0x06a8,0x06a8,0x06a8,},
+  {0xfb8e,0xfb8f,0xfb90,0xfb91,},
+  {0x06aa,0x06aa,0x06aa,0x06aa,},
+  {0x06ab,0x06ab,0x06ab,0x06ab,},
+  {0x06ac,0x06ac,0x06ac,0x06ac,},
+  {0xfbd3,0xfbd4,0xfbd5,0xfbd6,},
+  {0x06ae,0x06ae,0x06ae,0x06ae,},
+  {0xfb92,0xfb93,0xfb94,0xfb95,},
+  {0x06b0,0x06b0,0x06b0,0x06b0,},
+  {0xfb9a,0xfb9b,0xfb9c,0xfb9d,},
+  {0x06b2,0x06b2,0x06b2,0x06b2,},
+  {0xfb96,0xfb97,0xfb98,0xfb99,},
+  {0x06b4,0x06b4,0x06b4,0x06b4,},
+  {0x06b5,0x06b5,0x06b5,0x06b5,},
+  {0x06b6,0x06b6,0x06b6,0x06b6,},
+  {0x06b7,0x06b7,0x06b7,0x06b7,},
+  {0x06b8,0x06b8,0x06b8,0x06b8,},
+  {0x06b9,0x06b9,0x06b9,0x06b9,},
+  {0xfb9e,0xfb9f,0x06ba,0x06ba,},
+  {0xfba0,0xfba1,0xfba2,0xfba3,},
+  {0x06bc,0x06bc,0x06bc,0x06bc,},
+  {0x06bd,0x06bd,0x06bd,0x06bd,},
+  {0xfbaa,0xfbab,0xfbac,0xfbad,},
+  {0x06bf,0x06bf,0x06bf,0x06bf,},
+  {0xfba4,0xfba5,0x06c0,0x06c0,},
+  {0xfba6,0xfba7,0xfba8,0xfba9,},
+  {0x06c2,0x06c2,0x06c2,0x06c2,},
+  {0x06c3,0x06c3,0x06c3,0x06c3,},
+  {0x06c4,0x06c4,0x06c4,0x06c4,},
+  {0xfbe0,0xfbe1,0x06c5,0x06c5,},
+  {0xfbd9,0xfbda,0x06c6,0x06c6,},
+  {0xfbd7,0xfbd8,0x06c7,0x06c7,},
+  {0xfbdb,0xfbdc,0x06c8,0x06c8,},
+  {0xfbe2,0xfbe3,0x06c9,0x06c9,},
+  {0x06ca,0x06ca,0x06ca,0x06ca,},
+  {0xfbde,0xfbdf,0x06cb,0x06cb,},
+  {0xfbfc,0xfbfd,0xfbfe,0xfbff,},
+  {0x06cd,0x06cd,0x06cd,0x06cd,},
+  {0x06ce,0x06ce,0x06ce,0x06ce,},
+  {0x06cf,0x06cf,0x06cf,0x06cf,},
+  {0xfbe4,0xfbe5,0xfbe6,0xfbe7,},
+  {0x06d1,0x06d1,0x06d1,0x06d1,},
+  {0xfbae,0xfbaf,0x06d2,0x06d2,},
+  {0xfbb0,0xfbb1,0x06d3,0x06d3,},
+};
+
+/* *INDENT-ON* */
+
+#ifndef FRIBIDI_ACCESS_SHAPE_TABLE
+# define FRIBIDI_ACCESS_SHAPE_TABLE(table,min,max,x,shape) \
+	(((x)<(min)||(x)>(max))?(x):(table)[(x)-(min)][(shape)])
+#endif
+
+#define FRIBIDI_GET_ARABIC_SHAPE_PRES(x,shape) FRIBIDI_ACCESS_SHAPE_TABLE(ArShap, 0x0621, 0x06d3, (x), (shape))
+
+/* End of generated arabic-shaping.tab.i */
diff -rupN orginal/scribus/fribidi/AUTHORS patched/scribus/fribidi/AUTHORS
--- orginal/scribus/fribidi/AUTHORS	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/fribidi/AUTHORS	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,40 @@
+behdad: Behdad Esfahbod <behdad@gnu.org>
+#
+# Behdad Esfahbod is the only author that actually codes these days.  He
+# maintains the package too.  He has revised all of the code written by
+# others, and has written much of the code himself.  He's listed (or should
+# be listed) on every file in the package as one of the authors.  Behdad
+# designs, implements, documents, maintains, ...
+#
+
+dov-g: Dov Grobgeld <dov@imagic.weizmann.ac.il>
+#
+# Dov Grobgeld originally wrote FriBidi.  The 0.1.* releases were all done
+# by him.  After that, Dov rarely touched the code, but contributed ideas. 
+# All files that he has originally authored have him listed as an author in
+# the header of the file.
+#
+
+roozbeh: Roozbeh Pournader <roozbeh@gnu.org>
+#
+# Roozbeh Pournader hasn't contributed much code to FriBidi personally; but
+# has maintained, promoted, and supported the project for a while.  He has
+# helped with making GNU FriBidi standards compliant, and has sometimes
+# lobbied with the Unicode Consortium when needed.  Roozbeh was supposed to
+# be a co-maintainer of GNU FriBidi, but he's not doing that yet.
+#
+
+
+#
+# Note: Other people have contributed significant amounts of code, but
+# usually the code has faded out because of restructuring and redesigning
+# things around GNU FriBidi.  As an example, the FriBidiEnv patch by Omer
+# Zak, made itself into FriBidi CVS for a couple of years, but was finally
+# implemented in a better way by Behdad.
+#
+# Note: GNU getopt is distributed with and used in GNU FriBidi under bin/, but
+# is not part of GNU FriBidi.
+#
+# Note: Parts of the Unicode Character Database are distributed with and used
+# in GNU FriBidi under gen.tab/unidata/, but are not part of GNU FriBidi.
+#
diff -rupN orginal/scribus/fribidi/bidi-types.h patched/scribus/fribidi/bidi-types.h
--- orginal/scribus/fribidi/bidi-types.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/fribidi/bidi-types.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,61 @@
+/* FriBidi
+ * bidi-types.h - define internal bidi types
+ *
+ * $Id: bidi-types.h,v 1.7 2006/01/31 03:23:12 behdad Exp $
+ * $Author: behdad $
+ * $Date: 2006/01/31 03:23:12 $
+ * $Revision: 1.7 $
+ * $Source: /cvs/fribidi/fribidi2/lib/bidi-types.h,v $
+ *
+ * Author:
+ *   Behdad Esfahbod, 2001, 2002, 2004
+ *
+ * Copyright (C) 2004 Sharif FarsiWeb, Inc.
+ * Copyright (C) 2001,2002 Behdad Esfahbod
+ * 
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ * 
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library, in a file named COPYING; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA
+ *
+ * For licensing issues, contact <license@farsiweb.info>.
+ */
+#ifndef _BIDI_TYPES_H
+#define _BIDI_TYPES_H
+
+#include "common.h"
+
+#include <fribidi-types.h>
+#include <fribidi-bidi-types.h>
+
+#include <fribidi-begindecls.h>
+
+#define FRIBIDI_LEVEL_INVALID FRIBIDI_BIDI_MAX_RESOLVED_LEVELS
+#define FRIBIDI_SENTINEL -1
+
+#if DEBUG+0
+
+#define fribidi_char_from_bidi_type FRIBIDI_PRIVATESPACE(char_from_bidi_type)
+char
+fribidi_char_from_bidi_type (
+  FriBidiCharType t		/* input bidi type */
+) FRIBIDI_GNUC_HIDDEN;
+
+#endif /* DEBUG */
+
+#include <fribidi-enddecls.h>
+
+#endif /* !_BIDI_TYPES_H */
+/* Editor directions:
+ * vim:textwidth=78:tabstop=8:shiftwidth=2:autoindent:cindent
+ */
diff -rupN orginal/scribus/fribidi/bidi-type.tab.i patched/scribus/fribidi/bidi-type.tab.i
--- orginal/scribus/fribidi/bidi-type.tab.i	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/fribidi/bidi-type.tab.i	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,5532 @@
+/* bidi-type.tab.i
+ * generated by gen-bidi-type-tab (GNU FriBidi 0.19.1)
+ * from the file UnicodeData.txt of Unicode version 5.1.0. */
+
+#define PACKTAB_UINT8 fribidi_uint8
+#define PACKTAB_UINT16 fribidi_uint16
+#define PACKTAB_UINT32 fribidi_uint32
+
+/*
+  generated by packtab.c version 3
+
+  use FRIBIDI_GET_BIDI_TYPE(key) to access your table
+
+  assumed sizeof(unsigned char): 1
+  required memory: 25856
+  lookups: 2
+  partition shape: Bid[4352][256]
+  different table entries: 1 67
+*/
+
+/* *INDENT-OFF* */
+
+static const unsigned char BidLev1[256*67] = {
+#define BidLev1_0000 0x0
+   BN, BN, BN, BN, BN, BN, BN, BN, BN, SS, BS, SS, WS, BS, BN, BN,
+   BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BS, BS, BS, SS,
+   WS, ON, ON, ET, ET, ET, ON, ON, ON, ON, ON, ES, CS, ES, CS, CS,
+   EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, CS, ON, ON, ON, ON, ON,
+   ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON, ON, ON, ON, ON,
+   ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON, ON, ON, ON, BN,
+   BN, BN, BN, BN, BN, BS, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
+   BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
+   CS, ON, ET, ET, ET, ET, ON, ON, ON, ON,LTR, ON, ON, BN, ON, ON,
+   ET, ET, EN, EN, ON,LTR, ON, ON, ON, EN,LTR, ON, ON, ON, ON, ON,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+#define BidLev1_0100 0x100
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+#define BidLev1_0200 0x200
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON, ON,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+  LTR,LTR, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+  LTR,LTR,LTR,LTR,LTR, ON, ON, ON, ON, ON, ON, ON, ON, ON,LTR, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+#define BidLev1_0300 0x300
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  LTR,LTR,LTR,LTR, ON, ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON,LTR,
+  LTR,LTR,LTR,LTR, ON, ON,LTR, ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR, ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+#define BidLev1_0400 0x400
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,NSM,NSM,NSM,NSM,NSM,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+#define BidLev1_0500 0x500
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON,LTR,LTR,LTR,LTR,LTR,
+  RTL,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,RTL,NSM,
+  RTL,NSM,NSM,RTL,NSM,NSM,RTL,NSM,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+#define BidLev1_0600 0x600
+   AN, AN, AN, AN, AL, AL, ON, ON, AL, ET, ET, AL, CS, AL, ON, ON,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM, AL,
+   AN, AN, AN, AN, AN, AN, AN, AN, AN, AN, ET, AN, AN, AL, AL, AL,
+  NSM, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL,NSM,NSM,NSM,NSM,NSM,NSM,NSM, AN,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM, AL, AL,NSM,NSM, ON,NSM,NSM,NSM,NSM, AL, AL,
+   EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, AL, AL, AL, AL, AL, AL,
+#define BidLev1_0700 0x700
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, BN,
+   AL,NSM, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,RTL,RTL, ON, ON, ON, ON,RTL,RTL,RTL,RTL,RTL,RTL,
+#define BidLev1_0800 0x800
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+#define BidLev1_0900 0x900
+  LTR,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,LTR,LTR,LTR,
+  LTR,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,LTR,LTR,LTR,LTR,NSM,LTR,LTR,
+  LTR,NSM,NSM,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,LTR,LTR,LTR,
+  LTR,NSM,NSM,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR, ET, ET,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+#define BidLev1_0A00 0xA00
+  LTR,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,LTR,LTR,LTR,
+  LTR,NSM,NSM,LTR,LTR,LTR,LTR,NSM,NSM,LTR,LTR,NSM,NSM,NSM,LTR,LTR,
+  LTR,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  NSM,NSM,LTR,LTR,LTR,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,LTR,LTR,LTR,
+  LTR,NSM,NSM,NSM,NSM,NSM,LTR,NSM,NSM,LTR,LTR,LTR,LTR,NSM,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR, ET,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+#define BidLev1_0B00 0xB00
+  LTR,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,LTR,LTR,NSM,
+  LTR,NSM,NSM,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR, ON, ON, ON, ON, ON, ON, ET, ON,LTR,LTR,LTR,LTR,LTR,
+#define BidLev1_0C00 0xC00
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,NSM,
+  NSM,LTR,LTR,LTR,LTR,LTR,NSM,NSM,NSM,LTR,NSM,NSM,NSM,NSM,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON, ON, ON, ON, ON, ON, ON,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,NSM,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR, ON, ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+#define BidLev1_0D00 0xD00
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,NSM,NSM,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,NSM,NSM,NSM,LTR,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+#define BidLev1_0E00 0xE00
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,NSM,LTR,LTR,NSM,NSM,NSM,NSM,NSM,NSM,NSM,LTR,LTR,LTR,LTR, ET,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,NSM,LTR,LTR,NSM,NSM,NSM,NSM,NSM,NSM,LTR,NSM,NSM,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,NSM,NSM,NSM,NSM,NSM,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+#define BidLev1_0F00 0xF00
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,NSM,LTR,NSM,LTR,NSM, ON, ON, ON, ON,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,LTR,
+  NSM,NSM,NSM,NSM,NSM,LTR,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,LTR,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+#define BidLev1_1000 0x1000
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,NSM,NSM,
+  NSM,LTR,NSM,NSM,NSM,NSM,NSM,NSM,LTR,NSM,NSM,LTR,LTR,NSM,NSM,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,NSM,LTR,LTR,LTR,LTR,NSM,NSM,
+  NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,NSM,NSM,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,NSM,LTR,LTR,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,NSM,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+#define BidLev1_1300 0x1100
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+#define BidLev1_1600 0x1200
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+   WS,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON, ON,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+#define BidLev1_1700 0x1300
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,NSM,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,NSM,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,NSM,NSM,NSM,NSM,NSM,NSM,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,NSM,LTR,LTR,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ET,LTR,NSM,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,LTR,LTR,LTR,LTR,LTR,LTR,
+#define BidLev1_1800 0x1400
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,NSM,NSM,NSM, WS,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+#define BidLev1_1900 0x1500
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  NSM,NSM,NSM,LTR,LTR,LTR,LTR,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,NSM,LTR,LTR,LTR,LTR,LTR,LTR,NSM,NSM,NSM,LTR,LTR,LTR,LTR,
+   ON,LTR,LTR,LTR, ON, ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+#define BidLev1_1A00 0x1600
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+#define BidLev1_1B00 0x1700
+  NSM,NSM,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,NSM,LTR,NSM,NSM,NSM,NSM,NSM,LTR,NSM,LTR,LTR,LTR,
+  LTR,LTR,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,NSM,NSM,NSM,NSM,LTR,LTR,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+#define BidLev1_1C00 0x1800
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,LTR,LTR,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+#define BidLev1_1D00 0x1900
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,NSM,
+#define BidLev1_1F00 0x1A00
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON,LTR, ON,
+   ON, ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON, ON, ON,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON, ON, ON,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON, ON, ON,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON, ON,LTR,
+#define BidLev1_2000 0x1B00
+   WS, WS, WS, WS, WS, WS, WS, WS, WS, WS, WS, BN, BN, BN,LTR,RTL,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, WS, BS,LRE,RLE,PDF,LRO,RLO, CS,
+   ET, ET, ET, ET, ET, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, CS, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, WS,
+   BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
+   EN,LTR,LTR,LTR, EN, EN, EN, EN, EN, EN, ES, ES, ON, ON, ON,LTR,
+   EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, ES, ES, ON, ON, ON,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+   ET, ET, ET, ET, ET, ET, ET, ET, ET, ET, ET, ET, ET, ET, ET, ET,
+   ET, ET, ET, ET, ET, ET,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+#define BidLev1_2100 0x1C00
+   ON, ON,LTR, ON, ON, ON, ON,LTR, ON, ON,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR, ON,LTR, ON, ON, ON,LTR,LTR,LTR,LTR,LTR, ON, ON,
+   ON, ON, ON, ON,LTR, ON,LTR, ON,LTR, ON,LTR,LTR,LTR,LTR, ET,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON, ON,LTR,LTR,LTR,LTR,
+   ON, ON, ON, ON, ON,LTR,LTR,LTR,LTR,LTR, ON, ON, ON, ON,LTR,LTR,
+  LTR,LTR,LTR, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+#define BidLev1_2200 0x1D00
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ES, ET, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+#define BidLev1_2300 0x1E00
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON,LTR, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+#define BidLev1_2400 0x1F00
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, EN, EN, EN, EN, EN, EN, EN, EN,
+   EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, EN,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+#define BidLev1_2500 0x2000
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+#define BidLev1_2600 0x2100
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,LTR,LTR,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,LTR, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,LTR,LTR,LTR,
+   ON, ON, ON, ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+#define BidLev1_2700 0x2200
+  LTR, ON, ON, ON, ON,LTR, ON, ON, ON, ON,LTR,LTR, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON,LTR, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,LTR, ON,LTR, ON,
+   ON, ON, ON,LTR,LTR,LTR, ON,LTR, ON, ON, ON, ON, ON, ON, ON,LTR,
+  LTR, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON,LTR,LTR,LTR, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+  LTR, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,LTR,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,LTR, ON,LTR,LTR,LTR,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+#define BidLev1_2B00 0x2300
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,LTR,LTR,LTR,
+   ON, ON, ON, ON, ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+#define BidLev1_2C00 0x2400
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR, ON, ON, ON, ON, ON, ON,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON, ON, ON, ON, ON, ON, ON,
+#define BidLev1_2D00 0x2500
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+#define BidLev1_2E00 0x2600
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,LTR, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+#define BidLev1_2F00 0x2700
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,LTR,LTR,LTR,LTR,
+#define BidLev1_3000 0x2800
+   WS, ON, ON, ON, ON,LTR,LTR,LTR, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,NSM,NSM,NSM,NSM,NSM,
+   ON,LTR,LTR,LTR,LTR,LTR, ON, ON,LTR,LTR,LTR,LTR,LTR, ON, ON, ON,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,NSM, ON, ON,LTR,LTR,LTR,
+   ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON,LTR,LTR,LTR,LTR,
+#define BidLev1_3100 0x2900
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+#define BidLev1_3200 0x2A00
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON, ON,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON, ON, ON,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON, ON, ON, ON,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+#define BidLev1_3300 0x2B00
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON, ON, ON, ON,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON, ON,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON,
+#define BidLev1_4D00 0x2C00
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+#define BidLev1_A400 0x2D00
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+#define BidLev1_A600 0x2E00
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON, ON, ON,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,
+  NSM,NSM,NSM, ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,NSM, ON, ON,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+#define BidLev1_A700 0x2F00
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+#define BidLev1_A800 0x3000
+  LTR,LTR,NSM,LTR,LTR,LTR,NSM,LTR,LTR,LTR,LTR,NSM,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,NSM,NSM,LTR, ON, ON, ON, ON,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR, ON, ON, ON, ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+#define BidLev1_A900 0x3100
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+#define BidLev1_AA00 0x3200
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,NSM,NSM,NSM,NSM,NSM,LTR,
+  LTR,NSM,NSM,LTR,LTR,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+#define BidLev1_FB00 0x3300
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,RTL,NSM,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL, ES,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+#define BidLev1_FC00 0x3400
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+#define BidLev1_FD00 0x3500
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, ON, ON,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
+   BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, ON, AL, AL,
+#define BidLev1_FE00 0x3600
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,LTR,LTR,LTR,LTR,LTR,LTR,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   CS, ON, CS,LTR, ON, CS, ON, ON, ON, ON, ON, ON, ON, ON, ON, ET,
+   ON, ON, ES, ES, ON, ON, ON,LTR, ON, ET, ET, ON,LTR,LTR,LTR,LTR,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, BN,
+#define BidLev1_FF00 0x3700
+  LTR, ON, ON, ET, ET, ET, ON, ON, ON, ON, ON, ES, CS, ES, CS, CS,
+   EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, CS, ON, ON, ON, ON, ON,
+   ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON, ON, ON, ON, ON,
+   ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+   ET, ET, ON, ON, ON, ET, ET,LTR, ON, ON, ON, ON, ON, ON, ON,LTR,
+   BN, BN, BN, BN, BN, BN, BN, BN, BN, ON, ON, ON, ON, ON, BN, BN,
+#define BidLev1_10100 0x3800
+  LTR, ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,LTR,LTR,LTR,LTR,LTR,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,LTR,LTR,
+#define BidLev1_10900 0x3900
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL, ON,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+#define BidLev1_10A00 0x3A00
+  RTL,NSM,NSM,NSM,RTL,NSM,NSM,RTL,RTL,RTL,RTL,RTL,NSM,NSM,NSM,NSM,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,NSM,NSM,NSM,RTL,RTL,RTL,RTL,NSM,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+#define BidLev1_1D100 0x3B00
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR, BN, BN, BN, BN, BN, BN, BN, BN,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,LTR,LTR,NSM,NSM,NSM,NSM,NSM,NSM,NSM,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,NSM,NSM,NSM,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+#define BidLev1_1D200 0x3C00
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON,NSM,NSM,NSM, ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+#define BidLev1_1D300 0x3D00
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+#define BidLev1_1D700 0x3E00
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, EN, EN,
+   EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, EN,
+   EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, EN,
+   EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, EN,
+#define BidLev1_1F000 0x3F00
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,LTR,LTR,LTR,LTR,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+#define BidLev1_1FF00 0x4000
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, BN, BN,
+#define BidLev1_E0000 0x4100
+   BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
+   BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
+   BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
+   BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
+   BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
+   BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
+   BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
+   BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
+   BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
+   BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
+   BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
+   BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
+   BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
+   BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
+   BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
+   BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
+#define BidLev1_E0100 0x4200
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+   BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
+};
+
+static const PACKTAB_UINT16 BidLev0[4352*1] = {
+#define BidLev0_0000 0x0
+  BidLev1_0000,  /* 0000..00FF */
+  BidLev1_0100,  /* 0100..01FF */
+  BidLev1_0200,  /* 0200..02FF */
+  BidLev1_0300,  /* 0300..03FF */
+  BidLev1_0400,  /* 0400..04FF */
+  BidLev1_0500,  /* 0500..05FF */
+  BidLev1_0600,  /* 0600..06FF */
+  BidLev1_0700,  /* 0700..07FF */
+  BidLev1_0800,  /* 0800..08FF */
+  BidLev1_0900,  /* 0900..09FF */
+  BidLev1_0A00,  /* 0A00..0AFF */
+  BidLev1_0B00,  /* 0B00..0BFF */
+  BidLev1_0C00,  /* 0C00..0CFF */
+  BidLev1_0D00,  /* 0D00..0DFF */
+  BidLev1_0E00,  /* 0E00..0EFF */
+  BidLev1_0F00,  /* 0F00..0FFF */
+  BidLev1_1000,  /* 1000..10FF */
+  BidLev1_0100,  /* 1100..11FF */
+  BidLev1_0100,  /* 1200..12FF */
+  BidLev1_1300,  /* 1300..13FF */
+  BidLev1_0100,  /* 1400..14FF */
+  BidLev1_0100,  /* 1500..15FF */
+  BidLev1_1600,  /* 1600..16FF */
+  BidLev1_1700,  /* 1700..17FF */
+  BidLev1_1800,  /* 1800..18FF */
+  BidLev1_1900,  /* 1900..19FF */
+  BidLev1_1A00,  /* 1A00..1AFF */
+  BidLev1_1B00,  /* 1B00..1BFF */
+  BidLev1_1C00,  /* 1C00..1CFF */
+  BidLev1_1D00,  /* 1D00..1DFF */
+  BidLev1_0100,  /* 1E00..1EFF */
+  BidLev1_1F00,  /* 1F00..1FFF */
+  BidLev1_2000,  /* 2000..20FF */
+  BidLev1_2100,  /* 2100..21FF */
+  BidLev1_2200,  /* 2200..22FF */
+  BidLev1_2300,  /* 2300..23FF */
+  BidLev1_2400,  /* 2400..24FF */
+  BidLev1_2500,  /* 2500..25FF */
+  BidLev1_2600,  /* 2600..26FF */
+  BidLev1_2700,  /* 2700..27FF */
+  BidLev1_0100,  /* 2800..28FF */
+  BidLev1_2500,  /* 2900..29FF */
+  BidLev1_2500,  /* 2A00..2AFF */
+  BidLev1_2B00,  /* 2B00..2BFF */
+  BidLev1_2C00,  /* 2C00..2CFF */
+  BidLev1_2D00,  /* 2D00..2DFF */
+  BidLev1_2E00,  /* 2E00..2EFF */
+  BidLev1_2F00,  /* 2F00..2FFF */
+  BidLev1_3000,  /* 3000..30FF */
+  BidLev1_3100,  /* 3100..31FF */
+  BidLev1_3200,  /* 3200..32FF */
+  BidLev1_3300,  /* 3300..33FF */
+  BidLev1_0100,  /* 3400..34FF */
+  BidLev1_0100,  /* 3500..35FF */
+  BidLev1_0100,  /* 3600..36FF */
+  BidLev1_0100,  /* 3700..37FF */
+  BidLev1_0100,  /* 3800..38FF */
+  BidLev1_0100,  /* 3900..39FF */
+  BidLev1_0100,  /* 3A00..3AFF */
+  BidLev1_0100,  /* 3B00..3BFF */
+  BidLev1_0100,  /* 3C00..3CFF */
+  BidLev1_0100,  /* 3D00..3DFF */
+  BidLev1_0100,  /* 3E00..3EFF */
+  BidLev1_0100,  /* 3F00..3FFF */
+  BidLev1_0100,  /* 4000..40FF */
+  BidLev1_0100,  /* 4100..41FF */
+  BidLev1_0100,  /* 4200..42FF */
+  BidLev1_0100,  /* 4300..43FF */
+  BidLev1_0100,  /* 4400..44FF */
+  BidLev1_0100,  /* 4500..45FF */
+  BidLev1_0100,  /* 4600..46FF */
+  BidLev1_0100,  /* 4700..47FF */
+  BidLev1_0100,  /* 4800..48FF */
+  BidLev1_0100,  /* 4900..49FF */
+  BidLev1_0100,  /* 4A00..4AFF */
+  BidLev1_0100,  /* 4B00..4BFF */
+  BidLev1_0100,  /* 4C00..4CFF */
+  BidLev1_4D00,  /* 4D00..4DFF */
+  BidLev1_0100,  /* 4E00..4EFF */
+  BidLev1_0100,  /* 4F00..4FFF */
+  BidLev1_0100,  /* 5000..50FF */
+  BidLev1_0100,  /* 5100..51FF */
+  BidLev1_0100,  /* 5200..52FF */
+  BidLev1_0100,  /* 5300..53FF */
+  BidLev1_0100,  /* 5400..54FF */
+  BidLev1_0100,  /* 5500..55FF */
+  BidLev1_0100,  /* 5600..56FF */
+  BidLev1_0100,  /* 5700..57FF */
+  BidLev1_0100,  /* 5800..58FF */
+  BidLev1_0100,  /* 5900..59FF */
+  BidLev1_0100,  /* 5A00..5AFF */
+  BidLev1_0100,  /* 5B00..5BFF */
+  BidLev1_0100,  /* 5C00..5CFF */
+  BidLev1_0100,  /* 5D00..5DFF */
+  BidLev1_0100,  /* 5E00..5EFF */
+  BidLev1_0100,  /* 5F00..5FFF */
+  BidLev1_0100,  /* 6000..60FF */
+  BidLev1_0100,  /* 6100..61FF */
+  BidLev1_0100,  /* 6200..62FF */
+  BidLev1_0100,  /* 6300..63FF */
+  BidLev1_0100,  /* 6400..64FF */
+  BidLev1_0100,  /* 6500..65FF */
+  BidLev1_0100,  /* 6600..66FF */
+  BidLev1_0100,  /* 6700..67FF */
+  BidLev1_0100,  /* 6800..68FF */
+  BidLev1_0100,  /* 6900..69FF */
+  BidLev1_0100,  /* 6A00..6AFF */
+  BidLev1_0100,  /* 6B00..6BFF */
+  BidLev1_0100,  /* 6C00..6CFF */
+  BidLev1_0100,  /* 6D00..6DFF */
+  BidLev1_0100,  /* 6E00..6EFF */
+  BidLev1_0100,  /* 6F00..6FFF */
+  BidLev1_0100,  /* 7000..70FF */
+  BidLev1_0100,  /* 7100..71FF */
+  BidLev1_0100,  /* 7200..72FF */
+  BidLev1_0100,  /* 7300..73FF */
+  BidLev1_0100,  /* 7400..74FF */
+  BidLev1_0100,  /* 7500..75FF */
+  BidLev1_0100,  /* 7600..76FF */
+  BidLev1_0100,  /* 7700..77FF */
+  BidLev1_0100,  /* 7800..78FF */
+  BidLev1_0100,  /* 7900..79FF */
+  BidLev1_0100,  /* 7A00..7AFF */
+  BidLev1_0100,  /* 7B00..7BFF */
+  BidLev1_0100,  /* 7C00..7CFF */
+  BidLev1_0100,  /* 7D00..7DFF */
+  BidLev1_0100,  /* 7E00..7EFF */
+  BidLev1_0100,  /* 7F00..7FFF */
+  BidLev1_0100,  /* 8000..80FF */
+  BidLev1_0100,  /* 8100..81FF */
+  BidLev1_0100,  /* 8200..82FF */
+  BidLev1_0100,  /* 8300..83FF */
+  BidLev1_0100,  /* 8400..84FF */
+  BidLev1_0100,  /* 8500..85FF */
+  BidLev1_0100,  /* 8600..86FF */
+  BidLev1_0100,  /* 8700..87FF */
+  BidLev1_0100,  /* 8800..88FF */
+  BidLev1_0100,  /* 8900..89FF */
+  BidLev1_0100,  /* 8A00..8AFF */
+  BidLev1_0100,  /* 8B00..8BFF */
+  BidLev1_0100,  /* 8C00..8CFF */
+  BidLev1_0100,  /* 8D00..8DFF */
+  BidLev1_0100,  /* 8E00..8EFF */
+  BidLev1_0100,  /* 8F00..8FFF */
+  BidLev1_0100,  /* 9000..90FF */
+  BidLev1_0100,  /* 9100..91FF */
+  BidLev1_0100,  /* 9200..92FF */
+  BidLev1_0100,  /* 9300..93FF */
+  BidLev1_0100,  /* 9400..94FF */
+  BidLev1_0100,  /* 9500..95FF */
+  BidLev1_0100,  /* 9600..96FF */
+  BidLev1_0100,  /* 9700..97FF */
+  BidLev1_0100,  /* 9800..98FF */
+  BidLev1_0100,  /* 9900..99FF */
+  BidLev1_0100,  /* 9A00..9AFF */
+  BidLev1_0100,  /* 9B00..9BFF */
+  BidLev1_0100,  /* 9C00..9CFF */
+  BidLev1_0100,  /* 9D00..9DFF */
+  BidLev1_0100,  /* 9E00..9EFF */
+  BidLev1_0100,  /* 9F00..9FFF */
+  BidLev1_0100,  /* A000..A0FF */
+  BidLev1_0100,  /* A100..A1FF */
+  BidLev1_0100,  /* A200..A2FF */
+  BidLev1_0100,  /* A300..A3FF */
+  BidLev1_A400,  /* A400..A4FF */
+  BidLev1_0100,  /* A500..A5FF */
+  BidLev1_A600,  /* A600..A6FF */
+  BidLev1_A700,  /* A700..A7FF */
+  BidLev1_A800,  /* A800..A8FF */
+  BidLev1_A900,  /* A900..A9FF */
+  BidLev1_AA00,  /* AA00..AAFF */
+  BidLev1_0100,  /* AB00..ABFF */
+  BidLev1_0100,  /* AC00..ACFF */
+  BidLev1_0100,  /* AD00..ADFF */
+  BidLev1_0100,  /* AE00..AEFF */
+  BidLev1_0100,  /* AF00..AFFF */
+  BidLev1_0100,  /* B000..B0FF */
+  BidLev1_0100,  /* B100..B1FF */
+  BidLev1_0100,  /* B200..B2FF */
+  BidLev1_0100,  /* B300..B3FF */
+  BidLev1_0100,  /* B400..B4FF */
+  BidLev1_0100,  /* B500..B5FF */
+  BidLev1_0100,  /* B600..B6FF */
+  BidLev1_0100,  /* B700..B7FF */
+  BidLev1_0100,  /* B800..B8FF */
+  BidLev1_0100,  /* B900..B9FF */
+  BidLev1_0100,  /* BA00..BAFF */
+  BidLev1_0100,  /* BB00..BBFF */
+  BidLev1_0100,  /* BC00..BCFF */
+  BidLev1_0100,  /* BD00..BDFF */
+  BidLev1_0100,  /* BE00..BEFF */
+  BidLev1_0100,  /* BF00..BFFF */
+  BidLev1_0100,  /* C000..C0FF */
+  BidLev1_0100,  /* C100..C1FF */
+  BidLev1_0100,  /* C200..C2FF */
+  BidLev1_0100,  /* C300..C3FF */
+  BidLev1_0100,  /* C400..C4FF */
+  BidLev1_0100,  /* C500..C5FF */
+  BidLev1_0100,  /* C600..C6FF */
+  BidLev1_0100,  /* C700..C7FF */
+  BidLev1_0100,  /* C800..C8FF */
+  BidLev1_0100,  /* C900..C9FF */
+  BidLev1_0100,  /* CA00..CAFF */
+  BidLev1_0100,  /* CB00..CBFF */
+  BidLev1_0100,  /* CC00..CCFF */
+  BidLev1_0100,  /* CD00..CDFF */
+  BidLev1_0100,  /* CE00..CEFF */
+  BidLev1_0100,  /* CF00..CFFF */
+  BidLev1_0100,  /* D000..D0FF */
+  BidLev1_0100,  /* D100..D1FF */
+  BidLev1_0100,  /* D200..D2FF */
+  BidLev1_0100,  /* D300..D3FF */
+  BidLev1_0100,  /* D400..D4FF */
+  BidLev1_0100,  /* D500..D5FF */
+  BidLev1_0100,  /* D600..D6FF */
+  BidLev1_0100,  /* D700..D7FF */
+  BidLev1_0100,  /* D800..D8FF */
+  BidLev1_0100,  /* D900..D9FF */
+  BidLev1_0100,  /* DA00..DAFF */
+  BidLev1_0100,  /* DB00..DBFF */
+  BidLev1_0100,  /* DC00..DCFF */
+  BidLev1_0100,  /* DD00..DDFF */
+  BidLev1_0100,  /* DE00..DEFF */
+  BidLev1_0100,  /* DF00..DFFF */
+  BidLev1_0100,  /* E000..E0FF */
+  BidLev1_0100,  /* E100..E1FF */
+  BidLev1_0100,  /* E200..E2FF */
+  BidLev1_0100,  /* E300..E3FF */
+  BidLev1_0100,  /* E400..E4FF */
+  BidLev1_0100,  /* E500..E5FF */
+  BidLev1_0100,  /* E600..E6FF */
+  BidLev1_0100,  /* E700..E7FF */
+  BidLev1_0100,  /* E800..E8FF */
+  BidLev1_0100,  /* E900..E9FF */
+  BidLev1_0100,  /* EA00..EAFF */
+  BidLev1_0100,  /* EB00..EBFF */
+  BidLev1_0100,  /* EC00..ECFF */
+  BidLev1_0100,  /* ED00..EDFF */
+  BidLev1_0100,  /* EE00..EEFF */
+  BidLev1_0100,  /* EF00..EFFF */
+  BidLev1_0100,  /* F000..F0FF */
+  BidLev1_0100,  /* F100..F1FF */
+  BidLev1_0100,  /* F200..F2FF */
+  BidLev1_0100,  /* F300..F3FF */
+  BidLev1_0100,  /* F400..F4FF */
+  BidLev1_0100,  /* F500..F5FF */
+  BidLev1_0100,  /* F600..F6FF */
+  BidLev1_0100,  /* F700..F7FF */
+  BidLev1_0100,  /* F800..F8FF */
+  BidLev1_0100,  /* F900..F9FF */
+  BidLev1_0100,  /* FA00..FAFF */
+  BidLev1_FB00,  /* FB00..FBFF */
+  BidLev1_FC00,  /* FC00..FCFF */
+  BidLev1_FD00,  /* FD00..FDFF */
+  BidLev1_FE00,  /* FE00..FEFF */
+  BidLev1_FF00,  /* FF00..FFFF */
+  BidLev1_0100,  /* 10000..100FF */
+  BidLev1_10100,  /* 10100..101FF */
+  BidLev1_0100,  /* 10200..102FF */
+  BidLev1_0100,  /* 10300..103FF */
+  BidLev1_0100,  /* 10400..104FF */
+  BidLev1_0100,  /* 10500..105FF */
+  BidLev1_0100,  /* 10600..106FF */
+  BidLev1_0100,  /* 10700..107FF */
+  BidLev1_0800,  /* 10800..108FF */
+  BidLev1_10900,  /* 10900..109FF */
+  BidLev1_10A00,  /* 10A00..10AFF */
+  BidLev1_0800,  /* 10B00..10BFF */
+  BidLev1_0800,  /* 10C00..10CFF */
+  BidLev1_0800,  /* 10D00..10DFF */
+  BidLev1_0800,  /* 10E00..10EFF */
+  BidLev1_0800,  /* 10F00..10FFF */
+  BidLev1_0100,  /* 11000..110FF */
+  BidLev1_0100,  /* 11100..111FF */
+  BidLev1_0100,  /* 11200..112FF */
+  BidLev1_0100,  /* 11300..113FF */
+  BidLev1_0100,  /* 11400..114FF */
+  BidLev1_0100,  /* 11500..115FF */
+  BidLev1_0100,  /* 11600..116FF */
+  BidLev1_0100,  /* 11700..117FF */
+  BidLev1_0100,  /* 11800..118FF */
+  BidLev1_0100,  /* 11900..119FF */
+  BidLev1_0100,  /* 11A00..11AFF */
+  BidLev1_0100,  /* 11B00..11BFF */
+  BidLev1_0100,  /* 11C00..11CFF */
+  BidLev1_0100,  /* 11D00..11DFF */
+  BidLev1_0100,  /* 11E00..11EFF */
+  BidLev1_0100,  /* 11F00..11FFF */
+  BidLev1_0100,  /* 12000..120FF */
+  BidLev1_0100,  /* 12100..121FF */
+  BidLev1_0100,  /* 12200..122FF */
+  BidLev1_0100,  /* 12300..123FF */
+  BidLev1_0100,  /* 12400..124FF */
+  BidLev1_0100,  /* 12500..125FF */
+  BidLev1_0100,  /* 12600..126FF */
+  BidLev1_0100,  /* 12700..127FF */
+  BidLev1_0100,  /* 12800..128FF */
+  BidLev1_0100,  /* 12900..129FF */
+  BidLev1_0100,  /* 12A00..12AFF */
+  BidLev1_0100,  /* 12B00..12BFF */
+  BidLev1_0100,  /* 12C00..12CFF */
+  BidLev1_0100,  /* 12D00..12DFF */
+  BidLev1_0100,  /* 12E00..12EFF */
+  BidLev1_0100,  /* 12F00..12FFF */
+  BidLev1_0100,  /* 13000..130FF */
+  BidLev1_0100,  /* 13100..131FF */
+  BidLev1_0100,  /* 13200..132FF */
+  BidLev1_0100,  /* 13300..133FF */
+  BidLev1_0100,  /* 13400..134FF */
+  BidLev1_0100,  /* 13500..135FF */
+  BidLev1_0100,  /* 13600..136FF */
+  BidLev1_0100,  /* 13700..137FF */
+  BidLev1_0100,  /* 13800..138FF */
+  BidLev1_0100,  /* 13900..139FF */
+  BidLev1_0100,  /* 13A00..13AFF */
+  BidLev1_0100,  /* 13B00..13BFF */
+  BidLev1_0100,  /* 13C00..13CFF */
+  BidLev1_0100,  /* 13D00..13DFF */
+  BidLev1_0100,  /* 13E00..13EFF */
+  BidLev1_0100,  /* 13F00..13FFF */
+  BidLev1_0100,  /* 14000..140FF */
+  BidLev1_0100,  /* 14100..141FF */
+  BidLev1_0100,  /* 14200..142FF */
+  BidLev1_0100,  /* 14300..143FF */
+  BidLev1_0100,  /* 14400..144FF */
+  BidLev1_0100,  /* 14500..145FF */
+  BidLev1_0100,  /* 14600..146FF */
+  BidLev1_0100,  /* 14700..147FF */
+  BidLev1_0100,  /* 14800..148FF */
+  BidLev1_0100,  /* 14900..149FF */
+  BidLev1_0100,  /* 14A00..14AFF */
+  BidLev1_0100,  /* 14B00..14BFF */
+  BidLev1_0100,  /* 14C00..14CFF */
+  BidLev1_0100,  /* 14D00..14DFF */
+  BidLev1_0100,  /* 14E00..14EFF */
+  BidLev1_0100,  /* 14F00..14FFF */
+  BidLev1_0100,  /* 15000..150FF */
+  BidLev1_0100,  /* 15100..151FF */
+  BidLev1_0100,  /* 15200..152FF */
+  BidLev1_0100,  /* 15300..153FF */
+  BidLev1_0100,  /* 15400..154FF */
+  BidLev1_0100,  /* 15500..155FF */
+  BidLev1_0100,  /* 15600..156FF */
+  BidLev1_0100,  /* 15700..157FF */
+  BidLev1_0100,  /* 15800..158FF */
+  BidLev1_0100,  /* 15900..159FF */
+  BidLev1_0100,  /* 15A00..15AFF */
+  BidLev1_0100,  /* 15B00..15BFF */
+  BidLev1_0100,  /* 15C00..15CFF */
+  BidLev1_0100,  /* 15D00..15DFF */
+  BidLev1_0100,  /* 15E00..15EFF */
+  BidLev1_0100,  /* 15F00..15FFF */
+  BidLev1_0100,  /* 16000..160FF */
+  BidLev1_0100,  /* 16100..161FF */
+  BidLev1_0100,  /* 16200..162FF */
+  BidLev1_0100,  /* 16300..163FF */
+  BidLev1_0100,  /* 16400..164FF */
+  BidLev1_0100,  /* 16500..165FF */
+  BidLev1_0100,  /* 16600..166FF */
+  BidLev1_0100,  /* 16700..167FF */
+  BidLev1_0100,  /* 16800..168FF */
+  BidLev1_0100,  /* 16900..169FF */
+  BidLev1_0100,  /* 16A00..16AFF */
+  BidLev1_0100,  /* 16B00..16BFF */
+  BidLev1_0100,  /* 16C00..16CFF */
+  BidLev1_0100,  /* 16D00..16DFF */
+  BidLev1_0100,  /* 16E00..16EFF */
+  BidLev1_0100,  /* 16F00..16FFF */
+  BidLev1_0100,  /* 17000..170FF */
+  BidLev1_0100,  /* 17100..171FF */
+  BidLev1_0100,  /* 17200..172FF */
+  BidLev1_0100,  /* 17300..173FF */
+  BidLev1_0100,  /* 17400..174FF */
+  BidLev1_0100,  /* 17500..175FF */
+  BidLev1_0100,  /* 17600..176FF */
+  BidLev1_0100,  /* 17700..177FF */
+  BidLev1_0100,  /* 17800..178FF */
+  BidLev1_0100,  /* 17900..179FF */
+  BidLev1_0100,  /* 17A00..17AFF */
+  BidLev1_0100,  /* 17B00..17BFF */
+  BidLev1_0100,  /* 17C00..17CFF */
+  BidLev1_0100,  /* 17D00..17DFF */
+  BidLev1_0100,  /* 17E00..17EFF */
+  BidLev1_0100,  /* 17F00..17FFF */
+  BidLev1_0100,  /* 18000..180FF */
+  BidLev1_0100,  /* 18100..181FF */
+  BidLev1_0100,  /* 18200..182FF */
+  BidLev1_0100,  /* 18300..183FF */
+  BidLev1_0100,  /* 18400..184FF */
+  BidLev1_0100,  /* 18500..185FF */
+  BidLev1_0100,  /* 18600..186FF */
+  BidLev1_0100,  /* 18700..187FF */
+  BidLev1_0100,  /* 18800..188FF */
+  BidLev1_0100,  /* 18900..189FF */
+  BidLev1_0100,  /* 18A00..18AFF */
+  BidLev1_0100,  /* 18B00..18BFF */
+  BidLev1_0100,  /* 18C00..18CFF */
+  BidLev1_0100,  /* 18D00..18DFF */
+  BidLev1_0100,  /* 18E00..18EFF */
+  BidLev1_0100,  /* 18F00..18FFF */
+  BidLev1_0100,  /* 19000..190FF */
+  BidLev1_0100,  /* 19100..191FF */
+  BidLev1_0100,  /* 19200..192FF */
+  BidLev1_0100,  /* 19300..193FF */
+  BidLev1_0100,  /* 19400..194FF */
+  BidLev1_0100,  /* 19500..195FF */
+  BidLev1_0100,  /* 19600..196FF */
+  BidLev1_0100,  /* 19700..197FF */
+  BidLev1_0100,  /* 19800..198FF */
+  BidLev1_0100,  /* 19900..199FF */
+  BidLev1_0100,  /* 19A00..19AFF */
+  BidLev1_0100,  /* 19B00..19BFF */
+  BidLev1_0100,  /* 19C00..19CFF */
+  BidLev1_0100,  /* 19D00..19DFF */
+  BidLev1_0100,  /* 19E00..19EFF */
+  BidLev1_0100,  /* 19F00..19FFF */
+  BidLev1_0100,  /* 1A000..1A0FF */
+  BidLev1_0100,  /* 1A100..1A1FF */
+  BidLev1_0100,  /* 1A200..1A2FF */
+  BidLev1_0100,  /* 1A300..1A3FF */
+  BidLev1_0100,  /* 1A400..1A4FF */
+  BidLev1_0100,  /* 1A500..1A5FF */
+  BidLev1_0100,  /* 1A600..1A6FF */
+  BidLev1_0100,  /* 1A700..1A7FF */
+  BidLev1_0100,  /* 1A800..1A8FF */
+  BidLev1_0100,  /* 1A900..1A9FF */
+  BidLev1_0100,  /* 1AA00..1AAFF */
+  BidLev1_0100,  /* 1AB00..1ABFF */
+  BidLev1_0100,  /* 1AC00..1ACFF */
+  BidLev1_0100,  /* 1AD00..1ADFF */
+  BidLev1_0100,  /* 1AE00..1AEFF */
+  BidLev1_0100,  /* 1AF00..1AFFF */
+  BidLev1_0100,  /* 1B000..1B0FF */
+  BidLev1_0100,  /* 1B100..1B1FF */
+  BidLev1_0100,  /* 1B200..1B2FF */
+  BidLev1_0100,  /* 1B300..1B3FF */
+  BidLev1_0100,  /* 1B400..1B4FF */
+  BidLev1_0100,  /* 1B500..1B5FF */
+  BidLev1_0100,  /* 1B600..1B6FF */
+  BidLev1_0100,  /* 1B700..1B7FF */
+  BidLev1_0100,  /* 1B800..1B8FF */
+  BidLev1_0100,  /* 1B900..1B9FF */
+  BidLev1_0100,  /* 1BA00..1BAFF */
+  BidLev1_0100,  /* 1BB00..1BBFF */
+  BidLev1_0100,  /* 1BC00..1BCFF */
+  BidLev1_0100,  /* 1BD00..1BDFF */
+  BidLev1_0100,  /* 1BE00..1BEFF */
+  BidLev1_0100,  /* 1BF00..1BFFF */
+  BidLev1_0100,  /* 1C000..1C0FF */
+  BidLev1_0100,  /* 1C100..1C1FF */
+  BidLev1_0100,  /* 1C200..1C2FF */
+  BidLev1_0100,  /* 1C300..1C3FF */
+  BidLev1_0100,  /* 1C400..1C4FF */
+  BidLev1_0100,  /* 1C500..1C5FF */
+  BidLev1_0100,  /* 1C600..1C6FF */
+  BidLev1_0100,  /* 1C700..1C7FF */
+  BidLev1_0100,  /* 1C800..1C8FF */
+  BidLev1_0100,  /* 1C900..1C9FF */
+  BidLev1_0100,  /* 1CA00..1CAFF */
+  BidLev1_0100,  /* 1CB00..1CBFF */
+  BidLev1_0100,  /* 1CC00..1CCFF */
+  BidLev1_0100,  /* 1CD00..1CDFF */
+  BidLev1_0100,  /* 1CE00..1CEFF */
+  BidLev1_0100,  /* 1CF00..1CFFF */
+  BidLev1_0100,  /* 1D000..1D0FF */
+  BidLev1_1D100,  /* 1D100..1D1FF */
+  BidLev1_1D200,  /* 1D200..1D2FF */
+  BidLev1_1D300,  /* 1D300..1D3FF */
+  BidLev1_0100,  /* 1D400..1D4FF */
+  BidLev1_0100,  /* 1D500..1D5FF */
+  BidLev1_0100,  /* 1D600..1D6FF */
+  BidLev1_1D700,  /* 1D700..1D7FF */
+  BidLev1_0100,  /* 1D800..1D8FF */
+  BidLev1_0100,  /* 1D900..1D9FF */
+  BidLev1_0100,  /* 1DA00..1DAFF */
+  BidLev1_0100,  /* 1DB00..1DBFF */
+  BidLev1_0100,  /* 1DC00..1DCFF */
+  BidLev1_0100,  /* 1DD00..1DDFF */
+  BidLev1_0100,  /* 1DE00..1DEFF */
+  BidLev1_0100,  /* 1DF00..1DFFF */
+  BidLev1_0100,  /* 1E000..1E0FF */
+  BidLev1_0100,  /* 1E100..1E1FF */
+  BidLev1_0100,  /* 1E200..1E2FF */
+  BidLev1_0100,  /* 1E300..1E3FF */
+  BidLev1_0100,  /* 1E400..1E4FF */
+  BidLev1_0100,  /* 1E500..1E5FF */
+  BidLev1_0100,  /* 1E600..1E6FF */
+  BidLev1_0100,  /* 1E700..1E7FF */
+  BidLev1_0100,  /* 1E800..1E8FF */
+  BidLev1_0100,  /* 1E900..1E9FF */
+  BidLev1_0100,  /* 1EA00..1EAFF */
+  BidLev1_0100,  /* 1EB00..1EBFF */
+  BidLev1_0100,  /* 1EC00..1ECFF */
+  BidLev1_0100,  /* 1ED00..1EDFF */
+  BidLev1_0100,  /* 1EE00..1EEFF */
+  BidLev1_0100,  /* 1EF00..1EFFF */
+  BidLev1_1F000,  /* 1F000..1F0FF */
+  BidLev1_0100,  /* 1F100..1F1FF */
+  BidLev1_0100,  /* 1F200..1F2FF */
+  BidLev1_0100,  /* 1F300..1F3FF */
+  BidLev1_0100,  /* 1F400..1F4FF */
+  BidLev1_0100,  /* 1F500..1F5FF */
+  BidLev1_0100,  /* 1F600..1F6FF */
+  BidLev1_0100,  /* 1F700..1F7FF */
+  BidLev1_0100,  /* 1F800..1F8FF */
+  BidLev1_0100,  /* 1F900..1F9FF */
+  BidLev1_0100,  /* 1FA00..1FAFF */
+  BidLev1_0100,  /* 1FB00..1FBFF */
+  BidLev1_0100,  /* 1FC00..1FCFF */
+  BidLev1_0100,  /* 1FD00..1FDFF */
+  BidLev1_0100,  /* 1FE00..1FEFF */
+  BidLev1_1FF00,  /* 1FF00..1FFFF */
+  BidLev1_0100,  /* 20000..200FF */
+  BidLev1_0100,  /* 20100..201FF */
+  BidLev1_0100,  /* 20200..202FF */
+  BidLev1_0100,  /* 20300..203FF */
+  BidLev1_0100,  /* 20400..204FF */
+  BidLev1_0100,  /* 20500..205FF */
+  BidLev1_0100,  /* 20600..206FF */
+  BidLev1_0100,  /* 20700..207FF */
+  BidLev1_0100,  /* 20800..208FF */
+  BidLev1_0100,  /* 20900..209FF */
+  BidLev1_0100,  /* 20A00..20AFF */
+  BidLev1_0100,  /* 20B00..20BFF */
+  BidLev1_0100,  /* 20C00..20CFF */
+  BidLev1_0100,  /* 20D00..20DFF */
+  BidLev1_0100,  /* 20E00..20EFF */
+  BidLev1_0100,  /* 20F00..20FFF */
+  BidLev1_0100,  /* 21000..210FF */
+  BidLev1_0100,  /* 21100..211FF */
+  BidLev1_0100,  /* 21200..212FF */
+  BidLev1_0100,  /* 21300..213FF */
+  BidLev1_0100,  /* 21400..214FF */
+  BidLev1_0100,  /* 21500..215FF */
+  BidLev1_0100,  /* 21600..216FF */
+  BidLev1_0100,  /* 21700..217FF */
+  BidLev1_0100,  /* 21800..218FF */
+  BidLev1_0100,  /* 21900..219FF */
+  BidLev1_0100,  /* 21A00..21AFF */
+  BidLev1_0100,  /* 21B00..21BFF */
+  BidLev1_0100,  /* 21C00..21CFF */
+  BidLev1_0100,  /* 21D00..21DFF */
+  BidLev1_0100,  /* 21E00..21EFF */
+  BidLev1_0100,  /* 21F00..21FFF */
+  BidLev1_0100,  /* 22000..220FF */
+  BidLev1_0100,  /* 22100..221FF */
+  BidLev1_0100,  /* 22200..222FF */
+  BidLev1_0100,  /* 22300..223FF */
+  BidLev1_0100,  /* 22400..224FF */
+  BidLev1_0100,  /* 22500..225FF */
+  BidLev1_0100,  /* 22600..226FF */
+  BidLev1_0100,  /* 22700..227FF */
+  BidLev1_0100,  /* 22800..228FF */
+  BidLev1_0100,  /* 22900..229FF */
+  BidLev1_0100,  /* 22A00..22AFF */
+  BidLev1_0100,  /* 22B00..22BFF */
+  BidLev1_0100,  /* 22C00..22CFF */
+  BidLev1_0100,  /* 22D00..22DFF */
+  BidLev1_0100,  /* 22E00..22EFF */
+  BidLev1_0100,  /* 22F00..22FFF */
+  BidLev1_0100,  /* 23000..230FF */
+  BidLev1_0100,  /* 23100..231FF */
+  BidLev1_0100,  /* 23200..232FF */
+  BidLev1_0100,  /* 23300..233FF */
+  BidLev1_0100,  /* 23400..234FF */
+  BidLev1_0100,  /* 23500..235FF */
+  BidLev1_0100,  /* 23600..236FF */
+  BidLev1_0100,  /* 23700..237FF */
+  BidLev1_0100,  /* 23800..238FF */
+  BidLev1_0100,  /* 23900..239FF */
+  BidLev1_0100,  /* 23A00..23AFF */
+  BidLev1_0100,  /* 23B00..23BFF */
+  BidLev1_0100,  /* 23C00..23CFF */
+  BidLev1_0100,  /* 23D00..23DFF */
+  BidLev1_0100,  /* 23E00..23EFF */
+  BidLev1_0100,  /* 23F00..23FFF */
+  BidLev1_0100,  /* 24000..240FF */
+  BidLev1_0100,  /* 24100..241FF */
+  BidLev1_0100,  /* 24200..242FF */
+  BidLev1_0100,  /* 24300..243FF */
+  BidLev1_0100,  /* 24400..244FF */
+  BidLev1_0100,  /* 24500..245FF */
+  BidLev1_0100,  /* 24600..246FF */
+  BidLev1_0100,  /* 24700..247FF */
+  BidLev1_0100,  /* 24800..248FF */
+  BidLev1_0100,  /* 24900..249FF */
+  BidLev1_0100,  /* 24A00..24AFF */
+  BidLev1_0100,  /* 24B00..24BFF */
+  BidLev1_0100,  /* 24C00..24CFF */
+  BidLev1_0100,  /* 24D00..24DFF */
+  BidLev1_0100,  /* 24E00..24EFF */
+  BidLev1_0100,  /* 24F00..24FFF */
+  BidLev1_0100,  /* 25000..250FF */
+  BidLev1_0100,  /* 25100..251FF */
+  BidLev1_0100,  /* 25200..252FF */
+  BidLev1_0100,  /* 25300..253FF */
+  BidLev1_0100,  /* 25400..254FF */
+  BidLev1_0100,  /* 25500..255FF */
+  BidLev1_0100,  /* 25600..256FF */
+  BidLev1_0100,  /* 25700..257FF */
+  BidLev1_0100,  /* 25800..258FF */
+  BidLev1_0100,  /* 25900..259FF */
+  BidLev1_0100,  /* 25A00..25AFF */
+  BidLev1_0100,  /* 25B00..25BFF */
+  BidLev1_0100,  /* 25C00..25CFF */
+  BidLev1_0100,  /* 25D00..25DFF */
+  BidLev1_0100,  /* 25E00..25EFF */
+  BidLev1_0100,  /* 25F00..25FFF */
+  BidLev1_0100,  /* 26000..260FF */
+  BidLev1_0100,  /* 26100..261FF */
+  BidLev1_0100,  /* 26200..262FF */
+  BidLev1_0100,  /* 26300..263FF */
+  BidLev1_0100,  /* 26400..264FF */
+  BidLev1_0100,  /* 26500..265FF */
+  BidLev1_0100,  /* 26600..266FF */
+  BidLev1_0100,  /* 26700..267FF */
+  BidLev1_0100,  /* 26800..268FF */
+  BidLev1_0100,  /* 26900..269FF */
+  BidLev1_0100,  /* 26A00..26AFF */
+  BidLev1_0100,  /* 26B00..26BFF */
+  BidLev1_0100,  /* 26C00..26CFF */
+  BidLev1_0100,  /* 26D00..26DFF */
+  BidLev1_0100,  /* 26E00..26EFF */
+  BidLev1_0100,  /* 26F00..26FFF */
+  BidLev1_0100,  /* 27000..270FF */
+  BidLev1_0100,  /* 27100..271FF */
+  BidLev1_0100,  /* 27200..272FF */
+  BidLev1_0100,  /* 27300..273FF */
+  BidLev1_0100,  /* 27400..274FF */
+  BidLev1_0100,  /* 27500..275FF */
+  BidLev1_0100,  /* 27600..276FF */
+  BidLev1_0100,  /* 27700..277FF */
+  BidLev1_0100,  /* 27800..278FF */
+  BidLev1_0100,  /* 27900..279FF */
+  BidLev1_0100,  /* 27A00..27AFF */
+  BidLev1_0100,  /* 27B00..27BFF */
+  BidLev1_0100,  /* 27C00..27CFF */
+  BidLev1_0100,  /* 27D00..27DFF */
+  BidLev1_0100,  /* 27E00..27EFF */
+  BidLev1_0100,  /* 27F00..27FFF */
+  BidLev1_0100,  /* 28000..280FF */
+  BidLev1_0100,  /* 28100..281FF */
+  BidLev1_0100,  /* 28200..282FF */
+  BidLev1_0100,  /* 28300..283FF */
+  BidLev1_0100,  /* 28400..284FF */
+  BidLev1_0100,  /* 28500..285FF */
+  BidLev1_0100,  /* 28600..286FF */
+  BidLev1_0100,  /* 28700..287FF */
+  BidLev1_0100,  /* 28800..288FF */
+  BidLev1_0100,  /* 28900..289FF */
+  BidLev1_0100,  /* 28A00..28AFF */
+  BidLev1_0100,  /* 28B00..28BFF */
+  BidLev1_0100,  /* 28C00..28CFF */
+  BidLev1_0100,  /* 28D00..28DFF */
+  BidLev1_0100,  /* 28E00..28EFF */
+  BidLev1_0100,  /* 28F00..28FFF */
+  BidLev1_0100,  /* 29000..290FF */
+  BidLev1_0100,  /* 29100..291FF */
+  BidLev1_0100,  /* 29200..292FF */
+  BidLev1_0100,  /* 29300..293FF */
+  BidLev1_0100,  /* 29400..294FF */
+  BidLev1_0100,  /* 29500..295FF */
+  BidLev1_0100,  /* 29600..296FF */
+  BidLev1_0100,  /* 29700..297FF */
+  BidLev1_0100,  /* 29800..298FF */
+  BidLev1_0100,  /* 29900..299FF */
+  BidLev1_0100,  /* 29A00..29AFF */
+  BidLev1_0100,  /* 29B00..29BFF */
+  BidLev1_0100,  /* 29C00..29CFF */
+  BidLev1_0100,  /* 29D00..29DFF */
+  BidLev1_0100,  /* 29E00..29EFF */
+  BidLev1_0100,  /* 29F00..29FFF */
+  BidLev1_0100,  /* 2A000..2A0FF */
+  BidLev1_0100,  /* 2A100..2A1FF */
+  BidLev1_0100,  /* 2A200..2A2FF */
+  BidLev1_0100,  /* 2A300..2A3FF */
+  BidLev1_0100,  /* 2A400..2A4FF */
+  BidLev1_0100,  /* 2A500..2A5FF */
+  BidLev1_0100,  /* 2A600..2A6FF */
+  BidLev1_0100,  /* 2A700..2A7FF */
+  BidLev1_0100,  /* 2A800..2A8FF */
+  BidLev1_0100,  /* 2A900..2A9FF */
+  BidLev1_0100,  /* 2AA00..2AAFF */
+  BidLev1_0100,  /* 2AB00..2ABFF */
+  BidLev1_0100,  /* 2AC00..2ACFF */
+  BidLev1_0100,  /* 2AD00..2ADFF */
+  BidLev1_0100,  /* 2AE00..2AEFF */
+  BidLev1_0100,  /* 2AF00..2AFFF */
+  BidLev1_0100,  /* 2B000..2B0FF */
+  BidLev1_0100,  /* 2B100..2B1FF */
+  BidLev1_0100,  /* 2B200..2B2FF */
+  BidLev1_0100,  /* 2B300..2B3FF */
+  BidLev1_0100,  /* 2B400..2B4FF */
+  BidLev1_0100,  /* 2B500..2B5FF */
+  BidLev1_0100,  /* 2B600..2B6FF */
+  BidLev1_0100,  /* 2B700..2B7FF */
+  BidLev1_0100,  /* 2B800..2B8FF */
+  BidLev1_0100,  /* 2B900..2B9FF */
+  BidLev1_0100,  /* 2BA00..2BAFF */
+  BidLev1_0100,  /* 2BB00..2BBFF */
+  BidLev1_0100,  /* 2BC00..2BCFF */
+  BidLev1_0100,  /* 2BD00..2BDFF */
+  BidLev1_0100,  /* 2BE00..2BEFF */
+  BidLev1_0100,  /* 2BF00..2BFFF */
+  BidLev1_0100,  /* 2C000..2C0FF */
+  BidLev1_0100,  /* 2C100..2C1FF */
+  BidLev1_0100,  /* 2C200..2C2FF */
+  BidLev1_0100,  /* 2C300..2C3FF */
+  BidLev1_0100,  /* 2C400..2C4FF */
+  BidLev1_0100,  /* 2C500..2C5FF */
+  BidLev1_0100,  /* 2C600..2C6FF */
+  BidLev1_0100,  /* 2C700..2C7FF */
+  BidLev1_0100,  /* 2C800..2C8FF */
+  BidLev1_0100,  /* 2C900..2C9FF */
+  BidLev1_0100,  /* 2CA00..2CAFF */
+  BidLev1_0100,  /* 2CB00..2CBFF */
+  BidLev1_0100,  /* 2CC00..2CCFF */
+  BidLev1_0100,  /* 2CD00..2CDFF */
+  BidLev1_0100,  /* 2CE00..2CEFF */
+  BidLev1_0100,  /* 2CF00..2CFFF */
+  BidLev1_0100,  /* 2D000..2D0FF */
+  BidLev1_0100,  /* 2D100..2D1FF */
+  BidLev1_0100,  /* 2D200..2D2FF */
+  BidLev1_0100,  /* 2D300..2D3FF */
+  BidLev1_0100,  /* 2D400..2D4FF */
+  BidLev1_0100,  /* 2D500..2D5FF */
+  BidLev1_0100,  /* 2D600..2D6FF */
+  BidLev1_0100,  /* 2D700..2D7FF */
+  BidLev1_0100,  /* 2D800..2D8FF */
+  BidLev1_0100,  /* 2D900..2D9FF */
+  BidLev1_0100,  /* 2DA00..2DAFF */
+  BidLev1_0100,  /* 2DB00..2DBFF */
+  BidLev1_0100,  /* 2DC00..2DCFF */
+  BidLev1_0100,  /* 2DD00..2DDFF */
+  BidLev1_0100,  /* 2DE00..2DEFF */
+  BidLev1_0100,  /* 2DF00..2DFFF */
+  BidLev1_0100,  /* 2E000..2E0FF */
+  BidLev1_0100,  /* 2E100..2E1FF */
+  BidLev1_0100,  /* 2E200..2E2FF */
+  BidLev1_0100,  /* 2E300..2E3FF */
+  BidLev1_0100,  /* 2E400..2E4FF */
+  BidLev1_0100,  /* 2E500..2E5FF */
+  BidLev1_0100,  /* 2E600..2E6FF */
+  BidLev1_0100,  /* 2E700..2E7FF */
+  BidLev1_0100,  /* 2E800..2E8FF */
+  BidLev1_0100,  /* 2E900..2E9FF */
+  BidLev1_0100,  /* 2EA00..2EAFF */
+  BidLev1_0100,  /* 2EB00..2EBFF */
+  BidLev1_0100,  /* 2EC00..2ECFF */
+  BidLev1_0100,  /* 2ED00..2EDFF */
+  BidLev1_0100,  /* 2EE00..2EEFF */
+  BidLev1_0100,  /* 2EF00..2EFFF */
+  BidLev1_0100,  /* 2F000..2F0FF */
+  BidLev1_0100,  /* 2F100..2F1FF */
+  BidLev1_0100,  /* 2F200..2F2FF */
+  BidLev1_0100,  /* 2F300..2F3FF */
+  BidLev1_0100,  /* 2F400..2F4FF */
+  BidLev1_0100,  /* 2F500..2F5FF */
+  BidLev1_0100,  /* 2F600..2F6FF */
+  BidLev1_0100,  /* 2F700..2F7FF */
+  BidLev1_0100,  /* 2F800..2F8FF */
+  BidLev1_0100,  /* 2F900..2F9FF */
+  BidLev1_0100,  /* 2FA00..2FAFF */
+  BidLev1_0100,  /* 2FB00..2FBFF */
+  BidLev1_0100,  /* 2FC00..2FCFF */
+  BidLev1_0100,  /* 2FD00..2FDFF */
+  BidLev1_0100,  /* 2FE00..2FEFF */
+  BidLev1_1FF00,  /* 2FF00..2FFFF */
+  BidLev1_0100,  /* 30000..300FF */
+  BidLev1_0100,  /* 30100..301FF */
+  BidLev1_0100,  /* 30200..302FF */
+  BidLev1_0100,  /* 30300..303FF */
+  BidLev1_0100,  /* 30400..304FF */
+  BidLev1_0100,  /* 30500..305FF */
+  BidLev1_0100,  /* 30600..306FF */
+  BidLev1_0100,  /* 30700..307FF */
+  BidLev1_0100,  /* 30800..308FF */
+  BidLev1_0100,  /* 30900..309FF */
+  BidLev1_0100,  /* 30A00..30AFF */
+  BidLev1_0100,  /* 30B00..30BFF */
+  BidLev1_0100,  /* 30C00..30CFF */
+  BidLev1_0100,  /* 30D00..30DFF */
+  BidLev1_0100,  /* 30E00..30EFF */
+  BidLev1_0100,  /* 30F00..30FFF */
+  BidLev1_0100,  /* 31000..310FF */
+  BidLev1_0100,  /* 31100..311FF */
+  BidLev1_0100,  /* 31200..312FF */
+  BidLev1_0100,  /* 31300..313FF */
+  BidLev1_0100,  /* 31400..314FF */
+  BidLev1_0100,  /* 31500..315FF */
+  BidLev1_0100,  /* 31600..316FF */
+  BidLev1_0100,  /* 31700..317FF */
+  BidLev1_0100,  /* 31800..318FF */
+  BidLev1_0100,  /* 31900..319FF */
+  BidLev1_0100,  /* 31A00..31AFF */
+  BidLev1_0100,  /* 31B00..31BFF */
+  BidLev1_0100,  /* 31C00..31CFF */
+  BidLev1_0100,  /* 31D00..31DFF */
+  BidLev1_0100,  /* 31E00..31EFF */
+  BidLev1_0100,  /* 31F00..31FFF */
+  BidLev1_0100,  /* 32000..320FF */
+  BidLev1_0100,  /* 32100..321FF */
+  BidLev1_0100,  /* 32200..322FF */
+  BidLev1_0100,  /* 32300..323FF */
+  BidLev1_0100,  /* 32400..324FF */
+  BidLev1_0100,  /* 32500..325FF */
+  BidLev1_0100,  /* 32600..326FF */
+  BidLev1_0100,  /* 32700..327FF */
+  BidLev1_0100,  /* 32800..328FF */
+  BidLev1_0100,  /* 32900..329FF */
+  BidLev1_0100,  /* 32A00..32AFF */
+  BidLev1_0100,  /* 32B00..32BFF */
+  BidLev1_0100,  /* 32C00..32CFF */
+  BidLev1_0100,  /* 32D00..32DFF */
+  BidLev1_0100,  /* 32E00..32EFF */
+  BidLev1_0100,  /* 32F00..32FFF */
+  BidLev1_0100,  /* 33000..330FF */
+  BidLev1_0100,  /* 33100..331FF */
+  BidLev1_0100,  /* 33200..332FF */
+  BidLev1_0100,  /* 33300..333FF */
+  BidLev1_0100,  /* 33400..334FF */
+  BidLev1_0100,  /* 33500..335FF */
+  BidLev1_0100,  /* 33600..336FF */
+  BidLev1_0100,  /* 33700..337FF */
+  BidLev1_0100,  /* 33800..338FF */
+  BidLev1_0100,  /* 33900..339FF */
+  BidLev1_0100,  /* 33A00..33AFF */
+  BidLev1_0100,  /* 33B00..33BFF */
+  BidLev1_0100,  /* 33C00..33CFF */
+  BidLev1_0100,  /* 33D00..33DFF */
+  BidLev1_0100,  /* 33E00..33EFF */
+  BidLev1_0100,  /* 33F00..33FFF */
+  BidLev1_0100,  /* 34000..340FF */
+  BidLev1_0100,  /* 34100..341FF */
+  BidLev1_0100,  /* 34200..342FF */
+  BidLev1_0100,  /* 34300..343FF */
+  BidLev1_0100,  /* 34400..344FF */
+  BidLev1_0100,  /* 34500..345FF */
+  BidLev1_0100,  /* 34600..346FF */
+  BidLev1_0100,  /* 34700..347FF */
+  BidLev1_0100,  /* 34800..348FF */
+  BidLev1_0100,  /* 34900..349FF */
+  BidLev1_0100,  /* 34A00..34AFF */
+  BidLev1_0100,  /* 34B00..34BFF */
+  BidLev1_0100,  /* 34C00..34CFF */
+  BidLev1_0100,  /* 34D00..34DFF */
+  BidLev1_0100,  /* 34E00..34EFF */
+  BidLev1_0100,  /* 34F00..34FFF */
+  BidLev1_0100,  /* 35000..350FF */
+  BidLev1_0100,  /* 35100..351FF */
+  BidLev1_0100,  /* 35200..352FF */
+  BidLev1_0100,  /* 35300..353FF */
+  BidLev1_0100,  /* 35400..354FF */
+  BidLev1_0100,  /* 35500..355FF */
+  BidLev1_0100,  /* 35600..356FF */
+  BidLev1_0100,  /* 35700..357FF */
+  BidLev1_0100,  /* 35800..358FF */
+  BidLev1_0100,  /* 35900..359FF */
+  BidLev1_0100,  /* 35A00..35AFF */
+  BidLev1_0100,  /* 35B00..35BFF */
+  BidLev1_0100,  /* 35C00..35CFF */
+  BidLev1_0100,  /* 35D00..35DFF */
+  BidLev1_0100,  /* 35E00..35EFF */
+  BidLev1_0100,  /* 35F00..35FFF */
+  BidLev1_0100,  /* 36000..360FF */
+  BidLev1_0100,  /* 36100..361FF */
+  BidLev1_0100,  /* 36200..362FF */
+  BidLev1_0100,  /* 36300..363FF */
+  BidLev1_0100,  /* 36400..364FF */
+  BidLev1_0100,  /* 36500..365FF */
+  BidLev1_0100,  /* 36600..366FF */
+  BidLev1_0100,  /* 36700..367FF */
+  BidLev1_0100,  /* 36800..368FF */
+  BidLev1_0100,  /* 36900..369FF */
+  BidLev1_0100,  /* 36A00..36AFF */
+  BidLev1_0100,  /* 36B00..36BFF */
+  BidLev1_0100,  /* 36C00..36CFF */
+  BidLev1_0100,  /* 36D00..36DFF */
+  BidLev1_0100,  /* 36E00..36EFF */
+  BidLev1_0100,  /* 36F00..36FFF */
+  BidLev1_0100,  /* 37000..370FF */
+  BidLev1_0100,  /* 37100..371FF */
+  BidLev1_0100,  /* 37200..372FF */
+  BidLev1_0100,  /* 37300..373FF */
+  BidLev1_0100,  /* 37400..374FF */
+  BidLev1_0100,  /* 37500..375FF */
+  BidLev1_0100,  /* 37600..376FF */
+  BidLev1_0100,  /* 37700..377FF */
+  BidLev1_0100,  /* 37800..378FF */
+  BidLev1_0100,  /* 37900..379FF */
+  BidLev1_0100,  /* 37A00..37AFF */
+  BidLev1_0100,  /* 37B00..37BFF */
+  BidLev1_0100,  /* 37C00..37CFF */
+  BidLev1_0100,  /* 37D00..37DFF */
+  BidLev1_0100,  /* 37E00..37EFF */
+  BidLev1_0100,  /* 37F00..37FFF */
+  BidLev1_0100,  /* 38000..380FF */
+  BidLev1_0100,  /* 38100..381FF */
+  BidLev1_0100,  /* 38200..382FF */
+  BidLev1_0100,  /* 38300..383FF */
+  BidLev1_0100,  /* 38400..384FF */
+  BidLev1_0100,  /* 38500..385FF */
+  BidLev1_0100,  /* 38600..386FF */
+  BidLev1_0100,  /* 38700..387FF */
+  BidLev1_0100,  /* 38800..388FF */
+  BidLev1_0100,  /* 38900..389FF */
+  BidLev1_0100,  /* 38A00..38AFF */
+  BidLev1_0100,  /* 38B00..38BFF */
+  BidLev1_0100,  /* 38C00..38CFF */
+  BidLev1_0100,  /* 38D00..38DFF */
+  BidLev1_0100,  /* 38E00..38EFF */
+  BidLev1_0100,  /* 38F00..38FFF */
+  BidLev1_0100,  /* 39000..390FF */
+  BidLev1_0100,  /* 39100..391FF */
+  BidLev1_0100,  /* 39200..392FF */
+  BidLev1_0100,  /* 39300..393FF */
+  BidLev1_0100,  /* 39400..394FF */
+  BidLev1_0100,  /* 39500..395FF */
+  BidLev1_0100,  /* 39600..396FF */
+  BidLev1_0100,  /* 39700..397FF */
+  BidLev1_0100,  /* 39800..398FF */
+  BidLev1_0100,  /* 39900..399FF */
+  BidLev1_0100,  /* 39A00..39AFF */
+  BidLev1_0100,  /* 39B00..39BFF */
+  BidLev1_0100,  /* 39C00..39CFF */
+  BidLev1_0100,  /* 39D00..39DFF */
+  BidLev1_0100,  /* 39E00..39EFF */
+  BidLev1_0100,  /* 39F00..39FFF */
+  BidLev1_0100,  /* 3A000..3A0FF */
+  BidLev1_0100,  /* 3A100..3A1FF */
+  BidLev1_0100,  /* 3A200..3A2FF */
+  BidLev1_0100,  /* 3A300..3A3FF */
+  BidLev1_0100,  /* 3A400..3A4FF */
+  BidLev1_0100,  /* 3A500..3A5FF */
+  BidLev1_0100,  /* 3A600..3A6FF */
+  BidLev1_0100,  /* 3A700..3A7FF */
+  BidLev1_0100,  /* 3A800..3A8FF */
+  BidLev1_0100,  /* 3A900..3A9FF */
+  BidLev1_0100,  /* 3AA00..3AAFF */
+  BidLev1_0100,  /* 3AB00..3ABFF */
+  BidLev1_0100,  /* 3AC00..3ACFF */
+  BidLev1_0100,  /* 3AD00..3ADFF */
+  BidLev1_0100,  /* 3AE00..3AEFF */
+  BidLev1_0100,  /* 3AF00..3AFFF */
+  BidLev1_0100,  /* 3B000..3B0FF */
+  BidLev1_0100,  /* 3B100..3B1FF */
+  BidLev1_0100,  /* 3B200..3B2FF */
+  BidLev1_0100,  /* 3B300..3B3FF */
+  BidLev1_0100,  /* 3B400..3B4FF */
+  BidLev1_0100,  /* 3B500..3B5FF */
+  BidLev1_0100,  /* 3B600..3B6FF */
+  BidLev1_0100,  /* 3B700..3B7FF */
+  BidLev1_0100,  /* 3B800..3B8FF */
+  BidLev1_0100,  /* 3B900..3B9FF */
+  BidLev1_0100,  /* 3BA00..3BAFF */
+  BidLev1_0100,  /* 3BB00..3BBFF */
+  BidLev1_0100,  /* 3BC00..3BCFF */
+  BidLev1_0100,  /* 3BD00..3BDFF */
+  BidLev1_0100,  /* 3BE00..3BEFF */
+  BidLev1_0100,  /* 3BF00..3BFFF */
+  BidLev1_0100,  /* 3C000..3C0FF */
+  BidLev1_0100,  /* 3C100..3C1FF */
+  BidLev1_0100,  /* 3C200..3C2FF */
+  BidLev1_0100,  /* 3C300..3C3FF */
+  BidLev1_0100,  /* 3C400..3C4FF */
+  BidLev1_0100,  /* 3C500..3C5FF */
+  BidLev1_0100,  /* 3C600..3C6FF */
+  BidLev1_0100,  /* 3C700..3C7FF */
+  BidLev1_0100,  /* 3C800..3C8FF */
+  BidLev1_0100,  /* 3C900..3C9FF */
+  BidLev1_0100,  /* 3CA00..3CAFF */
+  BidLev1_0100,  /* 3CB00..3CBFF */
+  BidLev1_0100,  /* 3CC00..3CCFF */
+  BidLev1_0100,  /* 3CD00..3CDFF */
+  BidLev1_0100,  /* 3CE00..3CEFF */
+  BidLev1_0100,  /* 3CF00..3CFFF */
+  BidLev1_0100,  /* 3D000..3D0FF */
+  BidLev1_0100,  /* 3D100..3D1FF */
+  BidLev1_0100,  /* 3D200..3D2FF */
+  BidLev1_0100,  /* 3D300..3D3FF */
+  BidLev1_0100,  /* 3D400..3D4FF */
+  BidLev1_0100,  /* 3D500..3D5FF */
+  BidLev1_0100,  /* 3D600..3D6FF */
+  BidLev1_0100,  /* 3D700..3D7FF */
+  BidLev1_0100,  /* 3D800..3D8FF */
+  BidLev1_0100,  /* 3D900..3D9FF */
+  BidLev1_0100,  /* 3DA00..3DAFF */
+  BidLev1_0100,  /* 3DB00..3DBFF */
+  BidLev1_0100,  /* 3DC00..3DCFF */
+  BidLev1_0100,  /* 3DD00..3DDFF */
+  BidLev1_0100,  /* 3DE00..3DEFF */
+  BidLev1_0100,  /* 3DF00..3DFFF */
+  BidLev1_0100,  /* 3E000..3E0FF */
+  BidLev1_0100,  /* 3E100..3E1FF */
+  BidLev1_0100,  /* 3E200..3E2FF */
+  BidLev1_0100,  /* 3E300..3E3FF */
+  BidLev1_0100,  /* 3E400..3E4FF */
+  BidLev1_0100,  /* 3E500..3E5FF */
+  BidLev1_0100,  /* 3E600..3E6FF */
+  BidLev1_0100,  /* 3E700..3E7FF */
+  BidLev1_0100,  /* 3E800..3E8FF */
+  BidLev1_0100,  /* 3E900..3E9FF */
+  BidLev1_0100,  /* 3EA00..3EAFF */
+  BidLev1_0100,  /* 3EB00..3EBFF */
+  BidLev1_0100,  /* 3EC00..3ECFF */
+  BidLev1_0100,  /* 3ED00..3EDFF */
+  BidLev1_0100,  /* 3EE00..3EEFF */
+  BidLev1_0100,  /* 3EF00..3EFFF */
+  BidLev1_0100,  /* 3F000..3F0FF */
+  BidLev1_0100,  /* 3F100..3F1FF */
+  BidLev1_0100,  /* 3F200..3F2FF */
+  BidLev1_0100,  /* 3F300..3F3FF */
+  BidLev1_0100,  /* 3F400..3F4FF */
+  BidLev1_0100,  /* 3F500..3F5FF */
+  BidLev1_0100,  /* 3F600..3F6FF */
+  BidLev1_0100,  /* 3F700..3F7FF */
+  BidLev1_0100,  /* 3F800..3F8FF */
+  BidLev1_0100,  /* 3F900..3F9FF */
+  BidLev1_0100,  /* 3FA00..3FAFF */
+  BidLev1_0100,  /* 3FB00..3FBFF */
+  BidLev1_0100,  /* 3FC00..3FCFF */
+  BidLev1_0100,  /* 3FD00..3FDFF */
+  BidLev1_0100,  /* 3FE00..3FEFF */
+  BidLev1_1FF00,  /* 3FF00..3FFFF */
+  BidLev1_0100,  /* 40000..400FF */
+  BidLev1_0100,  /* 40100..401FF */
+  BidLev1_0100,  /* 40200..402FF */
+  BidLev1_0100,  /* 40300..403FF */
+  BidLev1_0100,  /* 40400..404FF */
+  BidLev1_0100,  /* 40500..405FF */
+  BidLev1_0100,  /* 40600..406FF */
+  BidLev1_0100,  /* 40700..407FF */
+  BidLev1_0100,  /* 40800..408FF */
+  BidLev1_0100,  /* 40900..409FF */
+  BidLev1_0100,  /* 40A00..40AFF */
+  BidLev1_0100,  /* 40B00..40BFF */
+  BidLev1_0100,  /* 40C00..40CFF */
+  BidLev1_0100,  /* 40D00..40DFF */
+  BidLev1_0100,  /* 40E00..40EFF */
+  BidLev1_0100,  /* 40F00..40FFF */
+  BidLev1_0100,  /* 41000..410FF */
+  BidLev1_0100,  /* 41100..411FF */
+  BidLev1_0100,  /* 41200..412FF */
+  BidLev1_0100,  /* 41300..413FF */
+  BidLev1_0100,  /* 41400..414FF */
+  BidLev1_0100,  /* 41500..415FF */
+  BidLev1_0100,  /* 41600..416FF */
+  BidLev1_0100,  /* 41700..417FF */
+  BidLev1_0100,  /* 41800..418FF */
+  BidLev1_0100,  /* 41900..419FF */
+  BidLev1_0100,  /* 41A00..41AFF */
+  BidLev1_0100,  /* 41B00..41BFF */
+  BidLev1_0100,  /* 41C00..41CFF */
+  BidLev1_0100,  /* 41D00..41DFF */
+  BidLev1_0100,  /* 41E00..41EFF */
+  BidLev1_0100,  /* 41F00..41FFF */
+  BidLev1_0100,  /* 42000..420FF */
+  BidLev1_0100,  /* 42100..421FF */
+  BidLev1_0100,  /* 42200..422FF */
+  BidLev1_0100,  /* 42300..423FF */
+  BidLev1_0100,  /* 42400..424FF */
+  BidLev1_0100,  /* 42500..425FF */
+  BidLev1_0100,  /* 42600..426FF */
+  BidLev1_0100,  /* 42700..427FF */
+  BidLev1_0100,  /* 42800..428FF */
+  BidLev1_0100,  /* 42900..429FF */
+  BidLev1_0100,  /* 42A00..42AFF */
+  BidLev1_0100,  /* 42B00..42BFF */
+  BidLev1_0100,  /* 42C00..42CFF */
+  BidLev1_0100,  /* 42D00..42DFF */
+  BidLev1_0100,  /* 42E00..42EFF */
+  BidLev1_0100,  /* 42F00..42FFF */
+  BidLev1_0100,  /* 43000..430FF */
+  BidLev1_0100,  /* 43100..431FF */
+  BidLev1_0100,  /* 43200..432FF */
+  BidLev1_0100,  /* 43300..433FF */
+  BidLev1_0100,  /* 43400..434FF */
+  BidLev1_0100,  /* 43500..435FF */
+  BidLev1_0100,  /* 43600..436FF */
+  BidLev1_0100,  /* 43700..437FF */
+  BidLev1_0100,  /* 43800..438FF */
+  BidLev1_0100,  /* 43900..439FF */
+  BidLev1_0100,  /* 43A00..43AFF */
+  BidLev1_0100,  /* 43B00..43BFF */
+  BidLev1_0100,  /* 43C00..43CFF */
+  BidLev1_0100,  /* 43D00..43DFF */
+  BidLev1_0100,  /* 43E00..43EFF */
+  BidLev1_0100,  /* 43F00..43FFF */
+  BidLev1_0100,  /* 44000..440FF */
+  BidLev1_0100,  /* 44100..441FF */
+  BidLev1_0100,  /* 44200..442FF */
+  BidLev1_0100,  /* 44300..443FF */
+  BidLev1_0100,  /* 44400..444FF */
+  BidLev1_0100,  /* 44500..445FF */
+  BidLev1_0100,  /* 44600..446FF */
+  BidLev1_0100,  /* 44700..447FF */
+  BidLev1_0100,  /* 44800..448FF */
+  BidLev1_0100,  /* 44900..449FF */
+  BidLev1_0100,  /* 44A00..44AFF */
+  BidLev1_0100,  /* 44B00..44BFF */
+  BidLev1_0100,  /* 44C00..44CFF */
+  BidLev1_0100,  /* 44D00..44DFF */
+  BidLev1_0100,  /* 44E00..44EFF */
+  BidLev1_0100,  /* 44F00..44FFF */
+  BidLev1_0100,  /* 45000..450FF */
+  BidLev1_0100,  /* 45100..451FF */
+  BidLev1_0100,  /* 45200..452FF */
+  BidLev1_0100,  /* 45300..453FF */
+  BidLev1_0100,  /* 45400..454FF */
+  BidLev1_0100,  /* 45500..455FF */
+  BidLev1_0100,  /* 45600..456FF */
+  BidLev1_0100,  /* 45700..457FF */
+  BidLev1_0100,  /* 45800..458FF */
+  BidLev1_0100,  /* 45900..459FF */
+  BidLev1_0100,  /* 45A00..45AFF */
+  BidLev1_0100,  /* 45B00..45BFF */
+  BidLev1_0100,  /* 45C00..45CFF */
+  BidLev1_0100,  /* 45D00..45DFF */
+  BidLev1_0100,  /* 45E00..45EFF */
+  BidLev1_0100,  /* 45F00..45FFF */
+  BidLev1_0100,  /* 46000..460FF */
+  BidLev1_0100,  /* 46100..461FF */
+  BidLev1_0100,  /* 46200..462FF */
+  BidLev1_0100,  /* 46300..463FF */
+  BidLev1_0100,  /* 46400..464FF */
+  BidLev1_0100,  /* 46500..465FF */
+  BidLev1_0100,  /* 46600..466FF */
+  BidLev1_0100,  /* 46700..467FF */
+  BidLev1_0100,  /* 46800..468FF */
+  BidLev1_0100,  /* 46900..469FF */
+  BidLev1_0100,  /* 46A00..46AFF */
+  BidLev1_0100,  /* 46B00..46BFF */
+  BidLev1_0100,  /* 46C00..46CFF */
+  BidLev1_0100,  /* 46D00..46DFF */
+  BidLev1_0100,  /* 46E00..46EFF */
+  BidLev1_0100,  /* 46F00..46FFF */
+  BidLev1_0100,  /* 47000..470FF */
+  BidLev1_0100,  /* 47100..471FF */
+  BidLev1_0100,  /* 47200..472FF */
+  BidLev1_0100,  /* 47300..473FF */
+  BidLev1_0100,  /* 47400..474FF */
+  BidLev1_0100,  /* 47500..475FF */
+  BidLev1_0100,  /* 47600..476FF */
+  BidLev1_0100,  /* 47700..477FF */
+  BidLev1_0100,  /* 47800..478FF */
+  BidLev1_0100,  /* 47900..479FF */
+  BidLev1_0100,  /* 47A00..47AFF */
+  BidLev1_0100,  /* 47B00..47BFF */
+  BidLev1_0100,  /* 47C00..47CFF */
+  BidLev1_0100,  /* 47D00..47DFF */
+  BidLev1_0100,  /* 47E00..47EFF */
+  BidLev1_0100,  /* 47F00..47FFF */
+  BidLev1_0100,  /* 48000..480FF */
+  BidLev1_0100,  /* 48100..481FF */
+  BidLev1_0100,  /* 48200..482FF */
+  BidLev1_0100,  /* 48300..483FF */
+  BidLev1_0100,  /* 48400..484FF */
+  BidLev1_0100,  /* 48500..485FF */
+  BidLev1_0100,  /* 48600..486FF */
+  BidLev1_0100,  /* 48700..487FF */
+  BidLev1_0100,  /* 48800..488FF */
+  BidLev1_0100,  /* 48900..489FF */
+  BidLev1_0100,  /* 48A00..48AFF */
+  BidLev1_0100,  /* 48B00..48BFF */
+  BidLev1_0100,  /* 48C00..48CFF */
+  BidLev1_0100,  /* 48D00..48DFF */
+  BidLev1_0100,  /* 48E00..48EFF */
+  BidLev1_0100,  /* 48F00..48FFF */
+  BidLev1_0100,  /* 49000..490FF */
+  BidLev1_0100,  /* 49100..491FF */
+  BidLev1_0100,  /* 49200..492FF */
+  BidLev1_0100,  /* 49300..493FF */
+  BidLev1_0100,  /* 49400..494FF */
+  BidLev1_0100,  /* 49500..495FF */
+  BidLev1_0100,  /* 49600..496FF */
+  BidLev1_0100,  /* 49700..497FF */
+  BidLev1_0100,  /* 49800..498FF */
+  BidLev1_0100,  /* 49900..499FF */
+  BidLev1_0100,  /* 49A00..49AFF */
+  BidLev1_0100,  /* 49B00..49BFF */
+  BidLev1_0100,  /* 49C00..49CFF */
+  BidLev1_0100,  /* 49D00..49DFF */
+  BidLev1_0100,  /* 49E00..49EFF */
+  BidLev1_0100,  /* 49F00..49FFF */
+  BidLev1_0100,  /* 4A000..4A0FF */
+  BidLev1_0100,  /* 4A100..4A1FF */
+  BidLev1_0100,  /* 4A200..4A2FF */
+  BidLev1_0100,  /* 4A300..4A3FF */
+  BidLev1_0100,  /* 4A400..4A4FF */
+  BidLev1_0100,  /* 4A500..4A5FF */
+  BidLev1_0100,  /* 4A600..4A6FF */
+  BidLev1_0100,  /* 4A700..4A7FF */
+  BidLev1_0100,  /* 4A800..4A8FF */
+  BidLev1_0100,  /* 4A900..4A9FF */
+  BidLev1_0100,  /* 4AA00..4AAFF */
+  BidLev1_0100,  /* 4AB00..4ABFF */
+  BidLev1_0100,  /* 4AC00..4ACFF */
+  BidLev1_0100,  /* 4AD00..4ADFF */
+  BidLev1_0100,  /* 4AE00..4AEFF */
+  BidLev1_0100,  /* 4AF00..4AFFF */
+  BidLev1_0100,  /* 4B000..4B0FF */
+  BidLev1_0100,  /* 4B100..4B1FF */
+  BidLev1_0100,  /* 4B200..4B2FF */
+  BidLev1_0100,  /* 4B300..4B3FF */
+  BidLev1_0100,  /* 4B400..4B4FF */
+  BidLev1_0100,  /* 4B500..4B5FF */
+  BidLev1_0100,  /* 4B600..4B6FF */
+  BidLev1_0100,  /* 4B700..4B7FF */
+  BidLev1_0100,  /* 4B800..4B8FF */
+  BidLev1_0100,  /* 4B900..4B9FF */
+  BidLev1_0100,  /* 4BA00..4BAFF */
+  BidLev1_0100,  /* 4BB00..4BBFF */
+  BidLev1_0100,  /* 4BC00..4BCFF */
+  BidLev1_0100,  /* 4BD00..4BDFF */
+  BidLev1_0100,  /* 4BE00..4BEFF */
+  BidLev1_0100,  /* 4BF00..4BFFF */
+  BidLev1_0100,  /* 4C000..4C0FF */
+  BidLev1_0100,  /* 4C100..4C1FF */
+  BidLev1_0100,  /* 4C200..4C2FF */
+  BidLev1_0100,  /* 4C300..4C3FF */
+  BidLev1_0100,  /* 4C400..4C4FF */
+  BidLev1_0100,  /* 4C500..4C5FF */
+  BidLev1_0100,  /* 4C600..4C6FF */
+  BidLev1_0100,  /* 4C700..4C7FF */
+  BidLev1_0100,  /* 4C800..4C8FF */
+  BidLev1_0100,  /* 4C900..4C9FF */
+  BidLev1_0100,  /* 4CA00..4CAFF */
+  BidLev1_0100,  /* 4CB00..4CBFF */
+  BidLev1_0100,  /* 4CC00..4CCFF */
+  BidLev1_0100,  /* 4CD00..4CDFF */
+  BidLev1_0100,  /* 4CE00..4CEFF */
+  BidLev1_0100,  /* 4CF00..4CFFF */
+  BidLev1_0100,  /* 4D000..4D0FF */
+  BidLev1_0100,  /* 4D100..4D1FF */
+  BidLev1_0100,  /* 4D200..4D2FF */
+  BidLev1_0100,  /* 4D300..4D3FF */
+  BidLev1_0100,  /* 4D400..4D4FF */
+  BidLev1_0100,  /* 4D500..4D5FF */
+  BidLev1_0100,  /* 4D600..4D6FF */
+  BidLev1_0100,  /* 4D700..4D7FF */
+  BidLev1_0100,  /* 4D800..4D8FF */
+  BidLev1_0100,  /* 4D900..4D9FF */
+  BidLev1_0100,  /* 4DA00..4DAFF */
+  BidLev1_0100,  /* 4DB00..4DBFF */
+  BidLev1_0100,  /* 4DC00..4DCFF */
+  BidLev1_0100,  /* 4DD00..4DDFF */
+  BidLev1_0100,  /* 4DE00..4DEFF */
+  BidLev1_0100,  /* 4DF00..4DFFF */
+  BidLev1_0100,  /* 4E000..4E0FF */
+  BidLev1_0100,  /* 4E100..4E1FF */
+  BidLev1_0100,  /* 4E200..4E2FF */
+  BidLev1_0100,  /* 4E300..4E3FF */
+  BidLev1_0100,  /* 4E400..4E4FF */
+  BidLev1_0100,  /* 4E500..4E5FF */
+  BidLev1_0100,  /* 4E600..4E6FF */
+  BidLev1_0100,  /* 4E700..4E7FF */
+  BidLev1_0100,  /* 4E800..4E8FF */
+  BidLev1_0100,  /* 4E900..4E9FF */
+  BidLev1_0100,  /* 4EA00..4EAFF */
+  BidLev1_0100,  /* 4EB00..4EBFF */
+  BidLev1_0100,  /* 4EC00..4ECFF */
+  BidLev1_0100,  /* 4ED00..4EDFF */
+  BidLev1_0100,  /* 4EE00..4EEFF */
+  BidLev1_0100,  /* 4EF00..4EFFF */
+  BidLev1_0100,  /* 4F000..4F0FF */
+  BidLev1_0100,  /* 4F100..4F1FF */
+  BidLev1_0100,  /* 4F200..4F2FF */
+  BidLev1_0100,  /* 4F300..4F3FF */
+  BidLev1_0100,  /* 4F400..4F4FF */
+  BidLev1_0100,  /* 4F500..4F5FF */
+  BidLev1_0100,  /* 4F600..4F6FF */
+  BidLev1_0100,  /* 4F700..4F7FF */
+  BidLev1_0100,  /* 4F800..4F8FF */
+  BidLev1_0100,  /* 4F900..4F9FF */
+  BidLev1_0100,  /* 4FA00..4FAFF */
+  BidLev1_0100,  /* 4FB00..4FBFF */
+  BidLev1_0100,  /* 4FC00..4FCFF */
+  BidLev1_0100,  /* 4FD00..4FDFF */
+  BidLev1_0100,  /* 4FE00..4FEFF */
+  BidLev1_1FF00,  /* 4FF00..4FFFF */
+  BidLev1_0100,  /* 50000..500FF */
+  BidLev1_0100,  /* 50100..501FF */
+  BidLev1_0100,  /* 50200..502FF */
+  BidLev1_0100,  /* 50300..503FF */
+  BidLev1_0100,  /* 50400..504FF */
+  BidLev1_0100,  /* 50500..505FF */
+  BidLev1_0100,  /* 50600..506FF */
+  BidLev1_0100,  /* 50700..507FF */
+  BidLev1_0100,  /* 50800..508FF */
+  BidLev1_0100,  /* 50900..509FF */
+  BidLev1_0100,  /* 50A00..50AFF */
+  BidLev1_0100,  /* 50B00..50BFF */
+  BidLev1_0100,  /* 50C00..50CFF */
+  BidLev1_0100,  /* 50D00..50DFF */
+  BidLev1_0100,  /* 50E00..50EFF */
+  BidLev1_0100,  /* 50F00..50FFF */
+  BidLev1_0100,  /* 51000..510FF */
+  BidLev1_0100,  /* 51100..511FF */
+  BidLev1_0100,  /* 51200..512FF */
+  BidLev1_0100,  /* 51300..513FF */
+  BidLev1_0100,  /* 51400..514FF */
+  BidLev1_0100,  /* 51500..515FF */
+  BidLev1_0100,  /* 51600..516FF */
+  BidLev1_0100,  /* 51700..517FF */
+  BidLev1_0100,  /* 51800..518FF */
+  BidLev1_0100,  /* 51900..519FF */
+  BidLev1_0100,  /* 51A00..51AFF */
+  BidLev1_0100,  /* 51B00..51BFF */
+  BidLev1_0100,  /* 51C00..51CFF */
+  BidLev1_0100,  /* 51D00..51DFF */
+  BidLev1_0100,  /* 51E00..51EFF */
+  BidLev1_0100,  /* 51F00..51FFF */
+  BidLev1_0100,  /* 52000..520FF */
+  BidLev1_0100,  /* 52100..521FF */
+  BidLev1_0100,  /* 52200..522FF */
+  BidLev1_0100,  /* 52300..523FF */
+  BidLev1_0100,  /* 52400..524FF */
+  BidLev1_0100,  /* 52500..525FF */
+  BidLev1_0100,  /* 52600..526FF */
+  BidLev1_0100,  /* 52700..527FF */
+  BidLev1_0100,  /* 52800..528FF */
+  BidLev1_0100,  /* 52900..529FF */
+  BidLev1_0100,  /* 52A00..52AFF */
+  BidLev1_0100,  /* 52B00..52BFF */
+  BidLev1_0100,  /* 52C00..52CFF */
+  BidLev1_0100,  /* 52D00..52DFF */
+  BidLev1_0100,  /* 52E00..52EFF */
+  BidLev1_0100,  /* 52F00..52FFF */
+  BidLev1_0100,  /* 53000..530FF */
+  BidLev1_0100,  /* 53100..531FF */
+  BidLev1_0100,  /* 53200..532FF */
+  BidLev1_0100,  /* 53300..533FF */
+  BidLev1_0100,  /* 53400..534FF */
+  BidLev1_0100,  /* 53500..535FF */
+  BidLev1_0100,  /* 53600..536FF */
+  BidLev1_0100,  /* 53700..537FF */
+  BidLev1_0100,  /* 53800..538FF */
+  BidLev1_0100,  /* 53900..539FF */
+  BidLev1_0100,  /* 53A00..53AFF */
+  BidLev1_0100,  /* 53B00..53BFF */
+  BidLev1_0100,  /* 53C00..53CFF */
+  BidLev1_0100,  /* 53D00..53DFF */
+  BidLev1_0100,  /* 53E00..53EFF */
+  BidLev1_0100,  /* 53F00..53FFF */
+  BidLev1_0100,  /* 54000..540FF */
+  BidLev1_0100,  /* 54100..541FF */
+  BidLev1_0100,  /* 54200..542FF */
+  BidLev1_0100,  /* 54300..543FF */
+  BidLev1_0100,  /* 54400..544FF */
+  BidLev1_0100,  /* 54500..545FF */
+  BidLev1_0100,  /* 54600..546FF */
+  BidLev1_0100,  /* 54700..547FF */
+  BidLev1_0100,  /* 54800..548FF */
+  BidLev1_0100,  /* 54900..549FF */
+  BidLev1_0100,  /* 54A00..54AFF */
+  BidLev1_0100,  /* 54B00..54BFF */
+  BidLev1_0100,  /* 54C00..54CFF */
+  BidLev1_0100,  /* 54D00..54DFF */
+  BidLev1_0100,  /* 54E00..54EFF */
+  BidLev1_0100,  /* 54F00..54FFF */
+  BidLev1_0100,  /* 55000..550FF */
+  BidLev1_0100,  /* 55100..551FF */
+  BidLev1_0100,  /* 55200..552FF */
+  BidLev1_0100,  /* 55300..553FF */
+  BidLev1_0100,  /* 55400..554FF */
+  BidLev1_0100,  /* 55500..555FF */
+  BidLev1_0100,  /* 55600..556FF */
+  BidLev1_0100,  /* 55700..557FF */
+  BidLev1_0100,  /* 55800..558FF */
+  BidLev1_0100,  /* 55900..559FF */
+  BidLev1_0100,  /* 55A00..55AFF */
+  BidLev1_0100,  /* 55B00..55BFF */
+  BidLev1_0100,  /* 55C00..55CFF */
+  BidLev1_0100,  /* 55D00..55DFF */
+  BidLev1_0100,  /* 55E00..55EFF */
+  BidLev1_0100,  /* 55F00..55FFF */
+  BidLev1_0100,  /* 56000..560FF */
+  BidLev1_0100,  /* 56100..561FF */
+  BidLev1_0100,  /* 56200..562FF */
+  BidLev1_0100,  /* 56300..563FF */
+  BidLev1_0100,  /* 56400..564FF */
+  BidLev1_0100,  /* 56500..565FF */
+  BidLev1_0100,  /* 56600..566FF */
+  BidLev1_0100,  /* 56700..567FF */
+  BidLev1_0100,  /* 56800..568FF */
+  BidLev1_0100,  /* 56900..569FF */
+  BidLev1_0100,  /* 56A00..56AFF */
+  BidLev1_0100,  /* 56B00..56BFF */
+  BidLev1_0100,  /* 56C00..56CFF */
+  BidLev1_0100,  /* 56D00..56DFF */
+  BidLev1_0100,  /* 56E00..56EFF */
+  BidLev1_0100,  /* 56F00..56FFF */
+  BidLev1_0100,  /* 57000..570FF */
+  BidLev1_0100,  /* 57100..571FF */
+  BidLev1_0100,  /* 57200..572FF */
+  BidLev1_0100,  /* 57300..573FF */
+  BidLev1_0100,  /* 57400..574FF */
+  BidLev1_0100,  /* 57500..575FF */
+  BidLev1_0100,  /* 57600..576FF */
+  BidLev1_0100,  /* 57700..577FF */
+  BidLev1_0100,  /* 57800..578FF */
+  BidLev1_0100,  /* 57900..579FF */
+  BidLev1_0100,  /* 57A00..57AFF */
+  BidLev1_0100,  /* 57B00..57BFF */
+  BidLev1_0100,  /* 57C00..57CFF */
+  BidLev1_0100,  /* 57D00..57DFF */
+  BidLev1_0100,  /* 57E00..57EFF */
+  BidLev1_0100,  /* 57F00..57FFF */
+  BidLev1_0100,  /* 58000..580FF */
+  BidLev1_0100,  /* 58100..581FF */
+  BidLev1_0100,  /* 58200..582FF */
+  BidLev1_0100,  /* 58300..583FF */
+  BidLev1_0100,  /* 58400..584FF */
+  BidLev1_0100,  /* 58500..585FF */
+  BidLev1_0100,  /* 58600..586FF */
+  BidLev1_0100,  /* 58700..587FF */
+  BidLev1_0100,  /* 58800..588FF */
+  BidLev1_0100,  /* 58900..589FF */
+  BidLev1_0100,  /* 58A00..58AFF */
+  BidLev1_0100,  /* 58B00..58BFF */
+  BidLev1_0100,  /* 58C00..58CFF */
+  BidLev1_0100,  /* 58D00..58DFF */
+  BidLev1_0100,  /* 58E00..58EFF */
+  BidLev1_0100,  /* 58F00..58FFF */
+  BidLev1_0100,  /* 59000..590FF */
+  BidLev1_0100,  /* 59100..591FF */
+  BidLev1_0100,  /* 59200..592FF */
+  BidLev1_0100,  /* 59300..593FF */
+  BidLev1_0100,  /* 59400..594FF */
+  BidLev1_0100,  /* 59500..595FF */
+  BidLev1_0100,  /* 59600..596FF */
+  BidLev1_0100,  /* 59700..597FF */
+  BidLev1_0100,  /* 59800..598FF */
+  BidLev1_0100,  /* 59900..599FF */
+  BidLev1_0100,  /* 59A00..59AFF */
+  BidLev1_0100,  /* 59B00..59BFF */
+  BidLev1_0100,  /* 59C00..59CFF */
+  BidLev1_0100,  /* 59D00..59DFF */
+  BidLev1_0100,  /* 59E00..59EFF */
+  BidLev1_0100,  /* 59F00..59FFF */
+  BidLev1_0100,  /* 5A000..5A0FF */
+  BidLev1_0100,  /* 5A100..5A1FF */
+  BidLev1_0100,  /* 5A200..5A2FF */
+  BidLev1_0100,  /* 5A300..5A3FF */
+  BidLev1_0100,  /* 5A400..5A4FF */
+  BidLev1_0100,  /* 5A500..5A5FF */
+  BidLev1_0100,  /* 5A600..5A6FF */
+  BidLev1_0100,  /* 5A700..5A7FF */
+  BidLev1_0100,  /* 5A800..5A8FF */
+  BidLev1_0100,  /* 5A900..5A9FF */
+  BidLev1_0100,  /* 5AA00..5AAFF */
+  BidLev1_0100,  /* 5AB00..5ABFF */
+  BidLev1_0100,  /* 5AC00..5ACFF */
+  BidLev1_0100,  /* 5AD00..5ADFF */
+  BidLev1_0100,  /* 5AE00..5AEFF */
+  BidLev1_0100,  /* 5AF00..5AFFF */
+  BidLev1_0100,  /* 5B000..5B0FF */
+  BidLev1_0100,  /* 5B100..5B1FF */
+  BidLev1_0100,  /* 5B200..5B2FF */
+  BidLev1_0100,  /* 5B300..5B3FF */
+  BidLev1_0100,  /* 5B400..5B4FF */
+  BidLev1_0100,  /* 5B500..5B5FF */
+  BidLev1_0100,  /* 5B600..5B6FF */
+  BidLev1_0100,  /* 5B700..5B7FF */
+  BidLev1_0100,  /* 5B800..5B8FF */
+  BidLev1_0100,  /* 5B900..5B9FF */
+  BidLev1_0100,  /* 5BA00..5BAFF */
+  BidLev1_0100,  /* 5BB00..5BBFF */
+  BidLev1_0100,  /* 5BC00..5BCFF */
+  BidLev1_0100,  /* 5BD00..5BDFF */
+  BidLev1_0100,  /* 5BE00..5BEFF */
+  BidLev1_0100,  /* 5BF00..5BFFF */
+  BidLev1_0100,  /* 5C000..5C0FF */
+  BidLev1_0100,  /* 5C100..5C1FF */
+  BidLev1_0100,  /* 5C200..5C2FF */
+  BidLev1_0100,  /* 5C300..5C3FF */
+  BidLev1_0100,  /* 5C400..5C4FF */
+  BidLev1_0100,  /* 5C500..5C5FF */
+  BidLev1_0100,  /* 5C600..5C6FF */
+  BidLev1_0100,  /* 5C700..5C7FF */
+  BidLev1_0100,  /* 5C800..5C8FF */
+  BidLev1_0100,  /* 5C900..5C9FF */
+  BidLev1_0100,  /* 5CA00..5CAFF */
+  BidLev1_0100,  /* 5CB00..5CBFF */
+  BidLev1_0100,  /* 5CC00..5CCFF */
+  BidLev1_0100,  /* 5CD00..5CDFF */
+  BidLev1_0100,  /* 5CE00..5CEFF */
+  BidLev1_0100,  /* 5CF00..5CFFF */
+  BidLev1_0100,  /* 5D000..5D0FF */
+  BidLev1_0100,  /* 5D100..5D1FF */
+  BidLev1_0100,  /* 5D200..5D2FF */
+  BidLev1_0100,  /* 5D300..5D3FF */
+  BidLev1_0100,  /* 5D400..5D4FF */
+  BidLev1_0100,  /* 5D500..5D5FF */
+  BidLev1_0100,  /* 5D600..5D6FF */
+  BidLev1_0100,  /* 5D700..5D7FF */
+  BidLev1_0100,  /* 5D800..5D8FF */
+  BidLev1_0100,  /* 5D900..5D9FF */
+  BidLev1_0100,  /* 5DA00..5DAFF */
+  BidLev1_0100,  /* 5DB00..5DBFF */
+  BidLev1_0100,  /* 5DC00..5DCFF */
+  BidLev1_0100,  /* 5DD00..5DDFF */
+  BidLev1_0100,  /* 5DE00..5DEFF */
+  BidLev1_0100,  /* 5DF00..5DFFF */
+  BidLev1_0100,  /* 5E000..5E0FF */
+  BidLev1_0100,  /* 5E100..5E1FF */
+  BidLev1_0100,  /* 5E200..5E2FF */
+  BidLev1_0100,  /* 5E300..5E3FF */
+  BidLev1_0100,  /* 5E400..5E4FF */
+  BidLev1_0100,  /* 5E500..5E5FF */
+  BidLev1_0100,  /* 5E600..5E6FF */
+  BidLev1_0100,  /* 5E700..5E7FF */
+  BidLev1_0100,  /* 5E800..5E8FF */
+  BidLev1_0100,  /* 5E900..5E9FF */
+  BidLev1_0100,  /* 5EA00..5EAFF */
+  BidLev1_0100,  /* 5EB00..5EBFF */
+  BidLev1_0100,  /* 5EC00..5ECFF */
+  BidLev1_0100,  /* 5ED00..5EDFF */
+  BidLev1_0100,  /* 5EE00..5EEFF */
+  BidLev1_0100,  /* 5EF00..5EFFF */
+  BidLev1_0100,  /* 5F000..5F0FF */
+  BidLev1_0100,  /* 5F100..5F1FF */
+  BidLev1_0100,  /* 5F200..5F2FF */
+  BidLev1_0100,  /* 5F300..5F3FF */
+  BidLev1_0100,  /* 5F400..5F4FF */
+  BidLev1_0100,  /* 5F500..5F5FF */
+  BidLev1_0100,  /* 5F600..5F6FF */
+  BidLev1_0100,  /* 5F700..5F7FF */
+  BidLev1_0100,  /* 5F800..5F8FF */
+  BidLev1_0100,  /* 5F900..5F9FF */
+  BidLev1_0100,  /* 5FA00..5FAFF */
+  BidLev1_0100,  /* 5FB00..5FBFF */
+  BidLev1_0100,  /* 5FC00..5FCFF */
+  BidLev1_0100,  /* 5FD00..5FDFF */
+  BidLev1_0100,  /* 5FE00..5FEFF */
+  BidLev1_1FF00,  /* 5FF00..5FFFF */
+  BidLev1_0100,  /* 60000..600FF */
+  BidLev1_0100,  /* 60100..601FF */
+  BidLev1_0100,  /* 60200..602FF */
+  BidLev1_0100,  /* 60300..603FF */
+  BidLev1_0100,  /* 60400..604FF */
+  BidLev1_0100,  /* 60500..605FF */
+  BidLev1_0100,  /* 60600..606FF */
+  BidLev1_0100,  /* 60700..607FF */
+  BidLev1_0100,  /* 60800..608FF */
+  BidLev1_0100,  /* 60900..609FF */
+  BidLev1_0100,  /* 60A00..60AFF */
+  BidLev1_0100,  /* 60B00..60BFF */
+  BidLev1_0100,  /* 60C00..60CFF */
+  BidLev1_0100,  /* 60D00..60DFF */
+  BidLev1_0100,  /* 60E00..60EFF */
+  BidLev1_0100,  /* 60F00..60FFF */
+  BidLev1_0100,  /* 61000..610FF */
+  BidLev1_0100,  /* 61100..611FF */
+  BidLev1_0100,  /* 61200..612FF */
+  BidLev1_0100,  /* 61300..613FF */
+  BidLev1_0100,  /* 61400..614FF */
+  BidLev1_0100,  /* 61500..615FF */
+  BidLev1_0100,  /* 61600..616FF */
+  BidLev1_0100,  /* 61700..617FF */
+  BidLev1_0100,  /* 61800..618FF */
+  BidLev1_0100,  /* 61900..619FF */
+  BidLev1_0100,  /* 61A00..61AFF */
+  BidLev1_0100,  /* 61B00..61BFF */
+  BidLev1_0100,  /* 61C00..61CFF */
+  BidLev1_0100,  /* 61D00..61DFF */
+  BidLev1_0100,  /* 61E00..61EFF */
+  BidLev1_0100,  /* 61F00..61FFF */
+  BidLev1_0100,  /* 62000..620FF */
+  BidLev1_0100,  /* 62100..621FF */
+  BidLev1_0100,  /* 62200..622FF */
+  BidLev1_0100,  /* 62300..623FF */
+  BidLev1_0100,  /* 62400..624FF */
+  BidLev1_0100,  /* 62500..625FF */
+  BidLev1_0100,  /* 62600..626FF */
+  BidLev1_0100,  /* 62700..627FF */
+  BidLev1_0100,  /* 62800..628FF */
+  BidLev1_0100,  /* 62900..629FF */
+  BidLev1_0100,  /* 62A00..62AFF */
+  BidLev1_0100,  /* 62B00..62BFF */
+  BidLev1_0100,  /* 62C00..62CFF */
+  BidLev1_0100,  /* 62D00..62DFF */
+  BidLev1_0100,  /* 62E00..62EFF */
+  BidLev1_0100,  /* 62F00..62FFF */
+  BidLev1_0100,  /* 63000..630FF */
+  BidLev1_0100,  /* 63100..631FF */
+  BidLev1_0100,  /* 63200..632FF */
+  BidLev1_0100,  /* 63300..633FF */
+  BidLev1_0100,  /* 63400..634FF */
+  BidLev1_0100,  /* 63500..635FF */
+  BidLev1_0100,  /* 63600..636FF */
+  BidLev1_0100,  /* 63700..637FF */
+  BidLev1_0100,  /* 63800..638FF */
+  BidLev1_0100,  /* 63900..639FF */
+  BidLev1_0100,  /* 63A00..63AFF */
+  BidLev1_0100,  /* 63B00..63BFF */
+  BidLev1_0100,  /* 63C00..63CFF */
+  BidLev1_0100,  /* 63D00..63DFF */
+  BidLev1_0100,  /* 63E00..63EFF */
+  BidLev1_0100,  /* 63F00..63FFF */
+  BidLev1_0100,  /* 64000..640FF */
+  BidLev1_0100,  /* 64100..641FF */
+  BidLev1_0100,  /* 64200..642FF */
+  BidLev1_0100,  /* 64300..643FF */
+  BidLev1_0100,  /* 64400..644FF */
+  BidLev1_0100,  /* 64500..645FF */
+  BidLev1_0100,  /* 64600..646FF */
+  BidLev1_0100,  /* 64700..647FF */
+  BidLev1_0100,  /* 64800..648FF */
+  BidLev1_0100,  /* 64900..649FF */
+  BidLev1_0100,  /* 64A00..64AFF */
+  BidLev1_0100,  /* 64B00..64BFF */
+  BidLev1_0100,  /* 64C00..64CFF */
+  BidLev1_0100,  /* 64D00..64DFF */
+  BidLev1_0100,  /* 64E00..64EFF */
+  BidLev1_0100,  /* 64F00..64FFF */
+  BidLev1_0100,  /* 65000..650FF */
+  BidLev1_0100,  /* 65100..651FF */
+  BidLev1_0100,  /* 65200..652FF */
+  BidLev1_0100,  /* 65300..653FF */
+  BidLev1_0100,  /* 65400..654FF */
+  BidLev1_0100,  /* 65500..655FF */
+  BidLev1_0100,  /* 65600..656FF */
+  BidLev1_0100,  /* 65700..657FF */
+  BidLev1_0100,  /* 65800..658FF */
+  BidLev1_0100,  /* 65900..659FF */
+  BidLev1_0100,  /* 65A00..65AFF */
+  BidLev1_0100,  /* 65B00..65BFF */
+  BidLev1_0100,  /* 65C00..65CFF */
+  BidLev1_0100,  /* 65D00..65DFF */
+  BidLev1_0100,  /* 65E00..65EFF */
+  BidLev1_0100,  /* 65F00..65FFF */
+  BidLev1_0100,  /* 66000..660FF */
+  BidLev1_0100,  /* 66100..661FF */
+  BidLev1_0100,  /* 66200..662FF */
+  BidLev1_0100,  /* 66300..663FF */
+  BidLev1_0100,  /* 66400..664FF */
+  BidLev1_0100,  /* 66500..665FF */
+  BidLev1_0100,  /* 66600..666FF */
+  BidLev1_0100,  /* 66700..667FF */
+  BidLev1_0100,  /* 66800..668FF */
+  BidLev1_0100,  /* 66900..669FF */
+  BidLev1_0100,  /* 66A00..66AFF */
+  BidLev1_0100,  /* 66B00..66BFF */
+  BidLev1_0100,  /* 66C00..66CFF */
+  BidLev1_0100,  /* 66D00..66DFF */
+  BidLev1_0100,  /* 66E00..66EFF */
+  BidLev1_0100,  /* 66F00..66FFF */
+  BidLev1_0100,  /* 67000..670FF */
+  BidLev1_0100,  /* 67100..671FF */
+  BidLev1_0100,  /* 67200..672FF */
+  BidLev1_0100,  /* 67300..673FF */
+  BidLev1_0100,  /* 67400..674FF */
+  BidLev1_0100,  /* 67500..675FF */
+  BidLev1_0100,  /* 67600..676FF */
+  BidLev1_0100,  /* 67700..677FF */
+  BidLev1_0100,  /* 67800..678FF */
+  BidLev1_0100,  /* 67900..679FF */
+  BidLev1_0100,  /* 67A00..67AFF */
+  BidLev1_0100,  /* 67B00..67BFF */
+  BidLev1_0100,  /* 67C00..67CFF */
+  BidLev1_0100,  /* 67D00..67DFF */
+  BidLev1_0100,  /* 67E00..67EFF */
+  BidLev1_0100,  /* 67F00..67FFF */
+  BidLev1_0100,  /* 68000..680FF */
+  BidLev1_0100,  /* 68100..681FF */
+  BidLev1_0100,  /* 68200..682FF */
+  BidLev1_0100,  /* 68300..683FF */
+  BidLev1_0100,  /* 68400..684FF */
+  BidLev1_0100,  /* 68500..685FF */
+  BidLev1_0100,  /* 68600..686FF */
+  BidLev1_0100,  /* 68700..687FF */
+  BidLev1_0100,  /* 68800..688FF */
+  BidLev1_0100,  /* 68900..689FF */
+  BidLev1_0100,  /* 68A00..68AFF */
+  BidLev1_0100,  /* 68B00..68BFF */
+  BidLev1_0100,  /* 68C00..68CFF */
+  BidLev1_0100,  /* 68D00..68DFF */
+  BidLev1_0100,  /* 68E00..68EFF */
+  BidLev1_0100,  /* 68F00..68FFF */
+  BidLev1_0100,  /* 69000..690FF */
+  BidLev1_0100,  /* 69100..691FF */
+  BidLev1_0100,  /* 69200..692FF */
+  BidLev1_0100,  /* 69300..693FF */
+  BidLev1_0100,  /* 69400..694FF */
+  BidLev1_0100,  /* 69500..695FF */
+  BidLev1_0100,  /* 69600..696FF */
+  BidLev1_0100,  /* 69700..697FF */
+  BidLev1_0100,  /* 69800..698FF */
+  BidLev1_0100,  /* 69900..699FF */
+  BidLev1_0100,  /* 69A00..69AFF */
+  BidLev1_0100,  /* 69B00..69BFF */
+  BidLev1_0100,  /* 69C00..69CFF */
+  BidLev1_0100,  /* 69D00..69DFF */
+  BidLev1_0100,  /* 69E00..69EFF */
+  BidLev1_0100,  /* 69F00..69FFF */
+  BidLev1_0100,  /* 6A000..6A0FF */
+  BidLev1_0100,  /* 6A100..6A1FF */
+  BidLev1_0100,  /* 6A200..6A2FF */
+  BidLev1_0100,  /* 6A300..6A3FF */
+  BidLev1_0100,  /* 6A400..6A4FF */
+  BidLev1_0100,  /* 6A500..6A5FF */
+  BidLev1_0100,  /* 6A600..6A6FF */
+  BidLev1_0100,  /* 6A700..6A7FF */
+  BidLev1_0100,  /* 6A800..6A8FF */
+  BidLev1_0100,  /* 6A900..6A9FF */
+  BidLev1_0100,  /* 6AA00..6AAFF */
+  BidLev1_0100,  /* 6AB00..6ABFF */
+  BidLev1_0100,  /* 6AC00..6ACFF */
+  BidLev1_0100,  /* 6AD00..6ADFF */
+  BidLev1_0100,  /* 6AE00..6AEFF */
+  BidLev1_0100,  /* 6AF00..6AFFF */
+  BidLev1_0100,  /* 6B000..6B0FF */
+  BidLev1_0100,  /* 6B100..6B1FF */
+  BidLev1_0100,  /* 6B200..6B2FF */
+  BidLev1_0100,  /* 6B300..6B3FF */
+  BidLev1_0100,  /* 6B400..6B4FF */
+  BidLev1_0100,  /* 6B500..6B5FF */
+  BidLev1_0100,  /* 6B600..6B6FF */
+  BidLev1_0100,  /* 6B700..6B7FF */
+  BidLev1_0100,  /* 6B800..6B8FF */
+  BidLev1_0100,  /* 6B900..6B9FF */
+  BidLev1_0100,  /* 6BA00..6BAFF */
+  BidLev1_0100,  /* 6BB00..6BBFF */
+  BidLev1_0100,  /* 6BC00..6BCFF */
+  BidLev1_0100,  /* 6BD00..6BDFF */
+  BidLev1_0100,  /* 6BE00..6BEFF */
+  BidLev1_0100,  /* 6BF00..6BFFF */
+  BidLev1_0100,  /* 6C000..6C0FF */
+  BidLev1_0100,  /* 6C100..6C1FF */
+  BidLev1_0100,  /* 6C200..6C2FF */
+  BidLev1_0100,  /* 6C300..6C3FF */
+  BidLev1_0100,  /* 6C400..6C4FF */
+  BidLev1_0100,  /* 6C500..6C5FF */
+  BidLev1_0100,  /* 6C600..6C6FF */
+  BidLev1_0100,  /* 6C700..6C7FF */
+  BidLev1_0100,  /* 6C800..6C8FF */
+  BidLev1_0100,  /* 6C900..6C9FF */
+  BidLev1_0100,  /* 6CA00..6CAFF */
+  BidLev1_0100,  /* 6CB00..6CBFF */
+  BidLev1_0100,  /* 6CC00..6CCFF */
+  BidLev1_0100,  /* 6CD00..6CDFF */
+  BidLev1_0100,  /* 6CE00..6CEFF */
+  BidLev1_0100,  /* 6CF00..6CFFF */
+  BidLev1_0100,  /* 6D000..6D0FF */
+  BidLev1_0100,  /* 6D100..6D1FF */
+  BidLev1_0100,  /* 6D200..6D2FF */
+  BidLev1_0100,  /* 6D300..6D3FF */
+  BidLev1_0100,  /* 6D400..6D4FF */
+  BidLev1_0100,  /* 6D500..6D5FF */
+  BidLev1_0100,  /* 6D600..6D6FF */
+  BidLev1_0100,  /* 6D700..6D7FF */
+  BidLev1_0100,  /* 6D800..6D8FF */
+  BidLev1_0100,  /* 6D900..6D9FF */
+  BidLev1_0100,  /* 6DA00..6DAFF */
+  BidLev1_0100,  /* 6DB00..6DBFF */
+  BidLev1_0100,  /* 6DC00..6DCFF */
+  BidLev1_0100,  /* 6DD00..6DDFF */
+  BidLev1_0100,  /* 6DE00..6DEFF */
+  BidLev1_0100,  /* 6DF00..6DFFF */
+  BidLev1_0100,  /* 6E000..6E0FF */
+  BidLev1_0100,  /* 6E100..6E1FF */
+  BidLev1_0100,  /* 6E200..6E2FF */
+  BidLev1_0100,  /* 6E300..6E3FF */
+  BidLev1_0100,  /* 6E400..6E4FF */
+  BidLev1_0100,  /* 6E500..6E5FF */
+  BidLev1_0100,  /* 6E600..6E6FF */
+  BidLev1_0100,  /* 6E700..6E7FF */
+  BidLev1_0100,  /* 6E800..6E8FF */
+  BidLev1_0100,  /* 6E900..6E9FF */
+  BidLev1_0100,  /* 6EA00..6EAFF */
+  BidLev1_0100,  /* 6EB00..6EBFF */
+  BidLev1_0100,  /* 6EC00..6ECFF */
+  BidLev1_0100,  /* 6ED00..6EDFF */
+  BidLev1_0100,  /* 6EE00..6EEFF */
+  BidLev1_0100,  /* 6EF00..6EFFF */
+  BidLev1_0100,  /* 6F000..6F0FF */
+  BidLev1_0100,  /* 6F100..6F1FF */
+  BidLev1_0100,  /* 6F200..6F2FF */
+  BidLev1_0100,  /* 6F300..6F3FF */
+  BidLev1_0100,  /* 6F400..6F4FF */
+  BidLev1_0100,  /* 6F500..6F5FF */
+  BidLev1_0100,  /* 6F600..6F6FF */
+  BidLev1_0100,  /* 6F700..6F7FF */
+  BidLev1_0100,  /* 6F800..6F8FF */
+  BidLev1_0100,  /* 6F900..6F9FF */
+  BidLev1_0100,  /* 6FA00..6FAFF */
+  BidLev1_0100,  /* 6FB00..6FBFF */
+  BidLev1_0100,  /* 6FC00..6FCFF */
+  BidLev1_0100,  /* 6FD00..6FDFF */
+  BidLev1_0100,  /* 6FE00..6FEFF */
+  BidLev1_1FF00,  /* 6FF00..6FFFF */
+  BidLev1_0100,  /* 70000..700FF */
+  BidLev1_0100,  /* 70100..701FF */
+  BidLev1_0100,  /* 70200..702FF */
+  BidLev1_0100,  /* 70300..703FF */
+  BidLev1_0100,  /* 70400..704FF */
+  BidLev1_0100,  /* 70500..705FF */
+  BidLev1_0100,  /* 70600..706FF */
+  BidLev1_0100,  /* 70700..707FF */
+  BidLev1_0100,  /* 70800..708FF */
+  BidLev1_0100,  /* 70900..709FF */
+  BidLev1_0100,  /* 70A00..70AFF */
+  BidLev1_0100,  /* 70B00..70BFF */
+  BidLev1_0100,  /* 70C00..70CFF */
+  BidLev1_0100,  /* 70D00..70DFF */
+  BidLev1_0100,  /* 70E00..70EFF */
+  BidLev1_0100,  /* 70F00..70FFF */
+  BidLev1_0100,  /* 71000..710FF */
+  BidLev1_0100,  /* 71100..711FF */
+  BidLev1_0100,  /* 71200..712FF */
+  BidLev1_0100,  /* 71300..713FF */
+  BidLev1_0100,  /* 71400..714FF */
+  BidLev1_0100,  /* 71500..715FF */
+  BidLev1_0100,  /* 71600..716FF */
+  BidLev1_0100,  /* 71700..717FF */
+  BidLev1_0100,  /* 71800..718FF */
+  BidLev1_0100,  /* 71900..719FF */
+  BidLev1_0100,  /* 71A00..71AFF */
+  BidLev1_0100,  /* 71B00..71BFF */
+  BidLev1_0100,  /* 71C00..71CFF */
+  BidLev1_0100,  /* 71D00..71DFF */
+  BidLev1_0100,  /* 71E00..71EFF */
+  BidLev1_0100,  /* 71F00..71FFF */
+  BidLev1_0100,  /* 72000..720FF */
+  BidLev1_0100,  /* 72100..721FF */
+  BidLev1_0100,  /* 72200..722FF */
+  BidLev1_0100,  /* 72300..723FF */
+  BidLev1_0100,  /* 72400..724FF */
+  BidLev1_0100,  /* 72500..725FF */
+  BidLev1_0100,  /* 72600..726FF */
+  BidLev1_0100,  /* 72700..727FF */
+  BidLev1_0100,  /* 72800..728FF */
+  BidLev1_0100,  /* 72900..729FF */
+  BidLev1_0100,  /* 72A00..72AFF */
+  BidLev1_0100,  /* 72B00..72BFF */
+  BidLev1_0100,  /* 72C00..72CFF */
+  BidLev1_0100,  /* 72D00..72DFF */
+  BidLev1_0100,  /* 72E00..72EFF */
+  BidLev1_0100,  /* 72F00..72FFF */
+  BidLev1_0100,  /* 73000..730FF */
+  BidLev1_0100,  /* 73100..731FF */
+  BidLev1_0100,  /* 73200..732FF */
+  BidLev1_0100,  /* 73300..733FF */
+  BidLev1_0100,  /* 73400..734FF */
+  BidLev1_0100,  /* 73500..735FF */
+  BidLev1_0100,  /* 73600..736FF */
+  BidLev1_0100,  /* 73700..737FF */
+  BidLev1_0100,  /* 73800..738FF */
+  BidLev1_0100,  /* 73900..739FF */
+  BidLev1_0100,  /* 73A00..73AFF */
+  BidLev1_0100,  /* 73B00..73BFF */
+  BidLev1_0100,  /* 73C00..73CFF */
+  BidLev1_0100,  /* 73D00..73DFF */
+  BidLev1_0100,  /* 73E00..73EFF */
+  BidLev1_0100,  /* 73F00..73FFF */
+  BidLev1_0100,  /* 74000..740FF */
+  BidLev1_0100,  /* 74100..741FF */
+  BidLev1_0100,  /* 74200..742FF */
+  BidLev1_0100,  /* 74300..743FF */
+  BidLev1_0100,  /* 74400..744FF */
+  BidLev1_0100,  /* 74500..745FF */
+  BidLev1_0100,  /* 74600..746FF */
+  BidLev1_0100,  /* 74700..747FF */
+  BidLev1_0100,  /* 74800..748FF */
+  BidLev1_0100,  /* 74900..749FF */
+  BidLev1_0100,  /* 74A00..74AFF */
+  BidLev1_0100,  /* 74B00..74BFF */
+  BidLev1_0100,  /* 74C00..74CFF */
+  BidLev1_0100,  /* 74D00..74DFF */
+  BidLev1_0100,  /* 74E00..74EFF */
+  BidLev1_0100,  /* 74F00..74FFF */
+  BidLev1_0100,  /* 75000..750FF */
+  BidLev1_0100,  /* 75100..751FF */
+  BidLev1_0100,  /* 75200..752FF */
+  BidLev1_0100,  /* 75300..753FF */
+  BidLev1_0100,  /* 75400..754FF */
+  BidLev1_0100,  /* 75500..755FF */
+  BidLev1_0100,  /* 75600..756FF */
+  BidLev1_0100,  /* 75700..757FF */
+  BidLev1_0100,  /* 75800..758FF */
+  BidLev1_0100,  /* 75900..759FF */
+  BidLev1_0100,  /* 75A00..75AFF */
+  BidLev1_0100,  /* 75B00..75BFF */
+  BidLev1_0100,  /* 75C00..75CFF */
+  BidLev1_0100,  /* 75D00..75DFF */
+  BidLev1_0100,  /* 75E00..75EFF */
+  BidLev1_0100,  /* 75F00..75FFF */
+  BidLev1_0100,  /* 76000..760FF */
+  BidLev1_0100,  /* 76100..761FF */
+  BidLev1_0100,  /* 76200..762FF */
+  BidLev1_0100,  /* 76300..763FF */
+  BidLev1_0100,  /* 76400..764FF */
+  BidLev1_0100,  /* 76500..765FF */
+  BidLev1_0100,  /* 76600..766FF */
+  BidLev1_0100,  /* 76700..767FF */
+  BidLev1_0100,  /* 76800..768FF */
+  BidLev1_0100,  /* 76900..769FF */
+  BidLev1_0100,  /* 76A00..76AFF */
+  BidLev1_0100,  /* 76B00..76BFF */
+  BidLev1_0100,  /* 76C00..76CFF */
+  BidLev1_0100,  /* 76D00..76DFF */
+  BidLev1_0100,  /* 76E00..76EFF */
+  BidLev1_0100,  /* 76F00..76FFF */
+  BidLev1_0100,  /* 77000..770FF */
+  BidLev1_0100,  /* 77100..771FF */
+  BidLev1_0100,  /* 77200..772FF */
+  BidLev1_0100,  /* 77300..773FF */
+  BidLev1_0100,  /* 77400..774FF */
+  BidLev1_0100,  /* 77500..775FF */
+  BidLev1_0100,  /* 77600..776FF */
+  BidLev1_0100,  /* 77700..777FF */
+  BidLev1_0100,  /* 77800..778FF */
+  BidLev1_0100,  /* 77900..779FF */
+  BidLev1_0100,  /* 77A00..77AFF */
+  BidLev1_0100,  /* 77B00..77BFF */
+  BidLev1_0100,  /* 77C00..77CFF */
+  BidLev1_0100,  /* 77D00..77DFF */
+  BidLev1_0100,  /* 77E00..77EFF */
+  BidLev1_0100,  /* 77F00..77FFF */
+  BidLev1_0100,  /* 78000..780FF */
+  BidLev1_0100,  /* 78100..781FF */
+  BidLev1_0100,  /* 78200..782FF */
+  BidLev1_0100,  /* 78300..783FF */
+  BidLev1_0100,  /* 78400..784FF */
+  BidLev1_0100,  /* 78500..785FF */
+  BidLev1_0100,  /* 78600..786FF */
+  BidLev1_0100,  /* 78700..787FF */
+  BidLev1_0100,  /* 78800..788FF */
+  BidLev1_0100,  /* 78900..789FF */
+  BidLev1_0100,  /* 78A00..78AFF */
+  BidLev1_0100,  /* 78B00..78BFF */
+  BidLev1_0100,  /* 78C00..78CFF */
+  BidLev1_0100,  /* 78D00..78DFF */
+  BidLev1_0100,  /* 78E00..78EFF */
+  BidLev1_0100,  /* 78F00..78FFF */
+  BidLev1_0100,  /* 79000..790FF */
+  BidLev1_0100,  /* 79100..791FF */
+  BidLev1_0100,  /* 79200..792FF */
+  BidLev1_0100,  /* 79300..793FF */
+  BidLev1_0100,  /* 79400..794FF */
+  BidLev1_0100,  /* 79500..795FF */
+  BidLev1_0100,  /* 79600..796FF */
+  BidLev1_0100,  /* 79700..797FF */
+  BidLev1_0100,  /* 79800..798FF */
+  BidLev1_0100,  /* 79900..799FF */
+  BidLev1_0100,  /* 79A00..79AFF */
+  BidLev1_0100,  /* 79B00..79BFF */
+  BidLev1_0100,  /* 79C00..79CFF */
+  BidLev1_0100,  /* 79D00..79DFF */
+  BidLev1_0100,  /* 79E00..79EFF */
+  BidLev1_0100,  /* 79F00..79FFF */
+  BidLev1_0100,  /* 7A000..7A0FF */
+  BidLev1_0100,  /* 7A100..7A1FF */
+  BidLev1_0100,  /* 7A200..7A2FF */
+  BidLev1_0100,  /* 7A300..7A3FF */
+  BidLev1_0100,  /* 7A400..7A4FF */
+  BidLev1_0100,  /* 7A500..7A5FF */
+  BidLev1_0100,  /* 7A600..7A6FF */
+  BidLev1_0100,  /* 7A700..7A7FF */
+  BidLev1_0100,  /* 7A800..7A8FF */
+  BidLev1_0100,  /* 7A900..7A9FF */
+  BidLev1_0100,  /* 7AA00..7AAFF */
+  BidLev1_0100,  /* 7AB00..7ABFF */
+  BidLev1_0100,  /* 7AC00..7ACFF */
+  BidLev1_0100,  /* 7AD00..7ADFF */
+  BidLev1_0100,  /* 7AE00..7AEFF */
+  BidLev1_0100,  /* 7AF00..7AFFF */
+  BidLev1_0100,  /* 7B000..7B0FF */
+  BidLev1_0100,  /* 7B100..7B1FF */
+  BidLev1_0100,  /* 7B200..7B2FF */
+  BidLev1_0100,  /* 7B300..7B3FF */
+  BidLev1_0100,  /* 7B400..7B4FF */
+  BidLev1_0100,  /* 7B500..7B5FF */
+  BidLev1_0100,  /* 7B600..7B6FF */
+  BidLev1_0100,  /* 7B700..7B7FF */
+  BidLev1_0100,  /* 7B800..7B8FF */
+  BidLev1_0100,  /* 7B900..7B9FF */
+  BidLev1_0100,  /* 7BA00..7BAFF */
+  BidLev1_0100,  /* 7BB00..7BBFF */
+  BidLev1_0100,  /* 7BC00..7BCFF */
+  BidLev1_0100,  /* 7BD00..7BDFF */
+  BidLev1_0100,  /* 7BE00..7BEFF */
+  BidLev1_0100,  /* 7BF00..7BFFF */
+  BidLev1_0100,  /* 7C000..7C0FF */
+  BidLev1_0100,  /* 7C100..7C1FF */
+  BidLev1_0100,  /* 7C200..7C2FF */
+  BidLev1_0100,  /* 7C300..7C3FF */
+  BidLev1_0100,  /* 7C400..7C4FF */
+  BidLev1_0100,  /* 7C500..7C5FF */
+  BidLev1_0100,  /* 7C600..7C6FF */
+  BidLev1_0100,  /* 7C700..7C7FF */
+  BidLev1_0100,  /* 7C800..7C8FF */
+  BidLev1_0100,  /* 7C900..7C9FF */
+  BidLev1_0100,  /* 7CA00..7CAFF */
+  BidLev1_0100,  /* 7CB00..7CBFF */
+  BidLev1_0100,  /* 7CC00..7CCFF */
+  BidLev1_0100,  /* 7CD00..7CDFF */
+  BidLev1_0100,  /* 7CE00..7CEFF */
+  BidLev1_0100,  /* 7CF00..7CFFF */
+  BidLev1_0100,  /* 7D000..7D0FF */
+  BidLev1_0100,  /* 7D100..7D1FF */
+  BidLev1_0100,  /* 7D200..7D2FF */
+  BidLev1_0100,  /* 7D300..7D3FF */
+  BidLev1_0100,  /* 7D400..7D4FF */
+  BidLev1_0100,  /* 7D500..7D5FF */
+  BidLev1_0100,  /* 7D600..7D6FF */
+  BidLev1_0100,  /* 7D700..7D7FF */
+  BidLev1_0100,  /* 7D800..7D8FF */
+  BidLev1_0100,  /* 7D900..7D9FF */
+  BidLev1_0100,  /* 7DA00..7DAFF */
+  BidLev1_0100,  /* 7DB00..7DBFF */
+  BidLev1_0100,  /* 7DC00..7DCFF */
+  BidLev1_0100,  /* 7DD00..7DDFF */
+  BidLev1_0100,  /* 7DE00..7DEFF */
+  BidLev1_0100,  /* 7DF00..7DFFF */
+  BidLev1_0100,  /* 7E000..7E0FF */
+  BidLev1_0100,  /* 7E100..7E1FF */
+  BidLev1_0100,  /* 7E200..7E2FF */
+  BidLev1_0100,  /* 7E300..7E3FF */
+  BidLev1_0100,  /* 7E400..7E4FF */
+  BidLev1_0100,  /* 7E500..7E5FF */
+  BidLev1_0100,  /* 7E600..7E6FF */
+  BidLev1_0100,  /* 7E700..7E7FF */
+  BidLev1_0100,  /* 7E800..7E8FF */
+  BidLev1_0100,  /* 7E900..7E9FF */
+  BidLev1_0100,  /* 7EA00..7EAFF */
+  BidLev1_0100,  /* 7EB00..7EBFF */
+  BidLev1_0100,  /* 7EC00..7ECFF */
+  BidLev1_0100,  /* 7ED00..7EDFF */
+  BidLev1_0100,  /* 7EE00..7EEFF */
+  BidLev1_0100,  /* 7EF00..7EFFF */
+  BidLev1_0100,  /* 7F000..7F0FF */
+  BidLev1_0100,  /* 7F100..7F1FF */
+  BidLev1_0100,  /* 7F200..7F2FF */
+  BidLev1_0100,  /* 7F300..7F3FF */
+  BidLev1_0100,  /* 7F400..7F4FF */
+  BidLev1_0100,  /* 7F500..7F5FF */
+  BidLev1_0100,  /* 7F600..7F6FF */
+  BidLev1_0100,  /* 7F700..7F7FF */
+  BidLev1_0100,  /* 7F800..7F8FF */
+  BidLev1_0100,  /* 7F900..7F9FF */
+  BidLev1_0100,  /* 7FA00..7FAFF */
+  BidLev1_0100,  /* 7FB00..7FBFF */
+  BidLev1_0100,  /* 7FC00..7FCFF */
+  BidLev1_0100,  /* 7FD00..7FDFF */
+  BidLev1_0100,  /* 7FE00..7FEFF */
+  BidLev1_1FF00,  /* 7FF00..7FFFF */
+  BidLev1_0100,  /* 80000..800FF */
+  BidLev1_0100,  /* 80100..801FF */
+  BidLev1_0100,  /* 80200..802FF */
+  BidLev1_0100,  /* 80300..803FF */
+  BidLev1_0100,  /* 80400..804FF */
+  BidLev1_0100,  /* 80500..805FF */
+  BidLev1_0100,  /* 80600..806FF */
+  BidLev1_0100,  /* 80700..807FF */
+  BidLev1_0100,  /* 80800..808FF */
+  BidLev1_0100,  /* 80900..809FF */
+  BidLev1_0100,  /* 80A00..80AFF */
+  BidLev1_0100,  /* 80B00..80BFF */
+  BidLev1_0100,  /* 80C00..80CFF */
+  BidLev1_0100,  /* 80D00..80DFF */
+  BidLev1_0100,  /* 80E00..80EFF */
+  BidLev1_0100,  /* 80F00..80FFF */
+  BidLev1_0100,  /* 81000..810FF */
+  BidLev1_0100,  /* 81100..811FF */
+  BidLev1_0100,  /* 81200..812FF */
+  BidLev1_0100,  /* 81300..813FF */
+  BidLev1_0100,  /* 81400..814FF */
+  BidLev1_0100,  /* 81500..815FF */
+  BidLev1_0100,  /* 81600..816FF */
+  BidLev1_0100,  /* 81700..817FF */
+  BidLev1_0100,  /* 81800..818FF */
+  BidLev1_0100,  /* 81900..819FF */
+  BidLev1_0100,  /* 81A00..81AFF */
+  BidLev1_0100,  /* 81B00..81BFF */
+  BidLev1_0100,  /* 81C00..81CFF */
+  BidLev1_0100,  /* 81D00..81DFF */
+  BidLev1_0100,  /* 81E00..81EFF */
+  BidLev1_0100,  /* 81F00..81FFF */
+  BidLev1_0100,  /* 82000..820FF */
+  BidLev1_0100,  /* 82100..821FF */
+  BidLev1_0100,  /* 82200..822FF */
+  BidLev1_0100,  /* 82300..823FF */
+  BidLev1_0100,  /* 82400..824FF */
+  BidLev1_0100,  /* 82500..825FF */
+  BidLev1_0100,  /* 82600..826FF */
+  BidLev1_0100,  /* 82700..827FF */
+  BidLev1_0100,  /* 82800..828FF */
+  BidLev1_0100,  /* 82900..829FF */
+  BidLev1_0100,  /* 82A00..82AFF */
+  BidLev1_0100,  /* 82B00..82BFF */
+  BidLev1_0100,  /* 82C00..82CFF */
+  BidLev1_0100,  /* 82D00..82DFF */
+  BidLev1_0100,  /* 82E00..82EFF */
+  BidLev1_0100,  /* 82F00..82FFF */
+  BidLev1_0100,  /* 83000..830FF */
+  BidLev1_0100,  /* 83100..831FF */
+  BidLev1_0100,  /* 83200..832FF */
+  BidLev1_0100,  /* 83300..833FF */
+  BidLev1_0100,  /* 83400..834FF */
+  BidLev1_0100,  /* 83500..835FF */
+  BidLev1_0100,  /* 83600..836FF */
+  BidLev1_0100,  /* 83700..837FF */
+  BidLev1_0100,  /* 83800..838FF */
+  BidLev1_0100,  /* 83900..839FF */
+  BidLev1_0100,  /* 83A00..83AFF */
+  BidLev1_0100,  /* 83B00..83BFF */
+  BidLev1_0100,  /* 83C00..83CFF */
+  BidLev1_0100,  /* 83D00..83DFF */
+  BidLev1_0100,  /* 83E00..83EFF */
+  BidLev1_0100,  /* 83F00..83FFF */
+  BidLev1_0100,  /* 84000..840FF */
+  BidLev1_0100,  /* 84100..841FF */
+  BidLev1_0100,  /* 84200..842FF */
+  BidLev1_0100,  /* 84300..843FF */
+  BidLev1_0100,  /* 84400..844FF */
+  BidLev1_0100,  /* 84500..845FF */
+  BidLev1_0100,  /* 84600..846FF */
+  BidLev1_0100,  /* 84700..847FF */
+  BidLev1_0100,  /* 84800..848FF */
+  BidLev1_0100,  /* 84900..849FF */
+  BidLev1_0100,  /* 84A00..84AFF */
+  BidLev1_0100,  /* 84B00..84BFF */
+  BidLev1_0100,  /* 84C00..84CFF */
+  BidLev1_0100,  /* 84D00..84DFF */
+  BidLev1_0100,  /* 84E00..84EFF */
+  BidLev1_0100,  /* 84F00..84FFF */
+  BidLev1_0100,  /* 85000..850FF */
+  BidLev1_0100,  /* 85100..851FF */
+  BidLev1_0100,  /* 85200..852FF */
+  BidLev1_0100,  /* 85300..853FF */
+  BidLev1_0100,  /* 85400..854FF */
+  BidLev1_0100,  /* 85500..855FF */
+  BidLev1_0100,  /* 85600..856FF */
+  BidLev1_0100,  /* 85700..857FF */
+  BidLev1_0100,  /* 85800..858FF */
+  BidLev1_0100,  /* 85900..859FF */
+  BidLev1_0100,  /* 85A00..85AFF */
+  BidLev1_0100,  /* 85B00..85BFF */
+  BidLev1_0100,  /* 85C00..85CFF */
+  BidLev1_0100,  /* 85D00..85DFF */
+  BidLev1_0100,  /* 85E00..85EFF */
+  BidLev1_0100,  /* 85F00..85FFF */
+  BidLev1_0100,  /* 86000..860FF */
+  BidLev1_0100,  /* 86100..861FF */
+  BidLev1_0100,  /* 86200..862FF */
+  BidLev1_0100,  /* 86300..863FF */
+  BidLev1_0100,  /* 86400..864FF */
+  BidLev1_0100,  /* 86500..865FF */
+  BidLev1_0100,  /* 86600..866FF */
+  BidLev1_0100,  /* 86700..867FF */
+  BidLev1_0100,  /* 86800..868FF */
+  BidLev1_0100,  /* 86900..869FF */
+  BidLev1_0100,  /* 86A00..86AFF */
+  BidLev1_0100,  /* 86B00..86BFF */
+  BidLev1_0100,  /* 86C00..86CFF */
+  BidLev1_0100,  /* 86D00..86DFF */
+  BidLev1_0100,  /* 86E00..86EFF */
+  BidLev1_0100,  /* 86F00..86FFF */
+  BidLev1_0100,  /* 87000..870FF */
+  BidLev1_0100,  /* 87100..871FF */
+  BidLev1_0100,  /* 87200..872FF */
+  BidLev1_0100,  /* 87300..873FF */
+  BidLev1_0100,  /* 87400..874FF */
+  BidLev1_0100,  /* 87500..875FF */
+  BidLev1_0100,  /* 87600..876FF */
+  BidLev1_0100,  /* 87700..877FF */
+  BidLev1_0100,  /* 87800..878FF */
+  BidLev1_0100,  /* 87900..879FF */
+  BidLev1_0100,  /* 87A00..87AFF */
+  BidLev1_0100,  /* 87B00..87BFF */
+  BidLev1_0100,  /* 87C00..87CFF */
+  BidLev1_0100,  /* 87D00..87DFF */
+  BidLev1_0100,  /* 87E00..87EFF */
+  BidLev1_0100,  /* 87F00..87FFF */
+  BidLev1_0100,  /* 88000..880FF */
+  BidLev1_0100,  /* 88100..881FF */
+  BidLev1_0100,  /* 88200..882FF */
+  BidLev1_0100,  /* 88300..883FF */
+  BidLev1_0100,  /* 88400..884FF */
+  BidLev1_0100,  /* 88500..885FF */
+  BidLev1_0100,  /* 88600..886FF */
+  BidLev1_0100,  /* 88700..887FF */
+  BidLev1_0100,  /* 88800..888FF */
+  BidLev1_0100,  /* 88900..889FF */
+  BidLev1_0100,  /* 88A00..88AFF */
+  BidLev1_0100,  /* 88B00..88BFF */
+  BidLev1_0100,  /* 88C00..88CFF */
+  BidLev1_0100,  /* 88D00..88DFF */
+  BidLev1_0100,  /* 88E00..88EFF */
+  BidLev1_0100,  /* 88F00..88FFF */
+  BidLev1_0100,  /* 89000..890FF */
+  BidLev1_0100,  /* 89100..891FF */
+  BidLev1_0100,  /* 89200..892FF */
+  BidLev1_0100,  /* 89300..893FF */
+  BidLev1_0100,  /* 89400..894FF */
+  BidLev1_0100,  /* 89500..895FF */
+  BidLev1_0100,  /* 89600..896FF */
+  BidLev1_0100,  /* 89700..897FF */
+  BidLev1_0100,  /* 89800..898FF */
+  BidLev1_0100,  /* 89900..899FF */
+  BidLev1_0100,  /* 89A00..89AFF */
+  BidLev1_0100,  /* 89B00..89BFF */
+  BidLev1_0100,  /* 89C00..89CFF */
+  BidLev1_0100,  /* 89D00..89DFF */
+  BidLev1_0100,  /* 89E00..89EFF */
+  BidLev1_0100,  /* 89F00..89FFF */
+  BidLev1_0100,  /* 8A000..8A0FF */
+  BidLev1_0100,  /* 8A100..8A1FF */
+  BidLev1_0100,  /* 8A200..8A2FF */
+  BidLev1_0100,  /* 8A300..8A3FF */
+  BidLev1_0100,  /* 8A400..8A4FF */
+  BidLev1_0100,  /* 8A500..8A5FF */
+  BidLev1_0100,  /* 8A600..8A6FF */
+  BidLev1_0100,  /* 8A700..8A7FF */
+  BidLev1_0100,  /* 8A800..8A8FF */
+  BidLev1_0100,  /* 8A900..8A9FF */
+  BidLev1_0100,  /* 8AA00..8AAFF */
+  BidLev1_0100,  /* 8AB00..8ABFF */
+  BidLev1_0100,  /* 8AC00..8ACFF */
+  BidLev1_0100,  /* 8AD00..8ADFF */
+  BidLev1_0100,  /* 8AE00..8AEFF */
+  BidLev1_0100,  /* 8AF00..8AFFF */
+  BidLev1_0100,  /* 8B000..8B0FF */
+  BidLev1_0100,  /* 8B100..8B1FF */
+  BidLev1_0100,  /* 8B200..8B2FF */
+  BidLev1_0100,  /* 8B300..8B3FF */
+  BidLev1_0100,  /* 8B400..8B4FF */
+  BidLev1_0100,  /* 8B500..8B5FF */
+  BidLev1_0100,  /* 8B600..8B6FF */
+  BidLev1_0100,  /* 8B700..8B7FF */
+  BidLev1_0100,  /* 8B800..8B8FF */
+  BidLev1_0100,  /* 8B900..8B9FF */
+  BidLev1_0100,  /* 8BA00..8BAFF */
+  BidLev1_0100,  /* 8BB00..8BBFF */
+  BidLev1_0100,  /* 8BC00..8BCFF */
+  BidLev1_0100,  /* 8BD00..8BDFF */
+  BidLev1_0100,  /* 8BE00..8BEFF */
+  BidLev1_0100,  /* 8BF00..8BFFF */
+  BidLev1_0100,  /* 8C000..8C0FF */
+  BidLev1_0100,  /* 8C100..8C1FF */
+  BidLev1_0100,  /* 8C200..8C2FF */
+  BidLev1_0100,  /* 8C300..8C3FF */
+  BidLev1_0100,  /* 8C400..8C4FF */
+  BidLev1_0100,  /* 8C500..8C5FF */
+  BidLev1_0100,  /* 8C600..8C6FF */
+  BidLev1_0100,  /* 8C700..8C7FF */
+  BidLev1_0100,  /* 8C800..8C8FF */
+  BidLev1_0100,  /* 8C900..8C9FF */
+  BidLev1_0100,  /* 8CA00..8CAFF */
+  BidLev1_0100,  /* 8CB00..8CBFF */
+  BidLev1_0100,  /* 8CC00..8CCFF */
+  BidLev1_0100,  /* 8CD00..8CDFF */
+  BidLev1_0100,  /* 8CE00..8CEFF */
+  BidLev1_0100,  /* 8CF00..8CFFF */
+  BidLev1_0100,  /* 8D000..8D0FF */
+  BidLev1_0100,  /* 8D100..8D1FF */
+  BidLev1_0100,  /* 8D200..8D2FF */
+  BidLev1_0100,  /* 8D300..8D3FF */
+  BidLev1_0100,  /* 8D400..8D4FF */
+  BidLev1_0100,  /* 8D500..8D5FF */
+  BidLev1_0100,  /* 8D600..8D6FF */
+  BidLev1_0100,  /* 8D700..8D7FF */
+  BidLev1_0100,  /* 8D800..8D8FF */
+  BidLev1_0100,  /* 8D900..8D9FF */
+  BidLev1_0100,  /* 8DA00..8DAFF */
+  BidLev1_0100,  /* 8DB00..8DBFF */
+  BidLev1_0100,  /* 8DC00..8DCFF */
+  BidLev1_0100,  /* 8DD00..8DDFF */
+  BidLev1_0100,  /* 8DE00..8DEFF */
+  BidLev1_0100,  /* 8DF00..8DFFF */
+  BidLev1_0100,  /* 8E000..8E0FF */
+  BidLev1_0100,  /* 8E100..8E1FF */
+  BidLev1_0100,  /* 8E200..8E2FF */
+  BidLev1_0100,  /* 8E300..8E3FF */
+  BidLev1_0100,  /* 8E400..8E4FF */
+  BidLev1_0100,  /* 8E500..8E5FF */
+  BidLev1_0100,  /* 8E600..8E6FF */
+  BidLev1_0100,  /* 8E700..8E7FF */
+  BidLev1_0100,  /* 8E800..8E8FF */
+  BidLev1_0100,  /* 8E900..8E9FF */
+  BidLev1_0100,  /* 8EA00..8EAFF */
+  BidLev1_0100,  /* 8EB00..8EBFF */
+  BidLev1_0100,  /* 8EC00..8ECFF */
+  BidLev1_0100,  /* 8ED00..8EDFF */
+  BidLev1_0100,  /* 8EE00..8EEFF */
+  BidLev1_0100,  /* 8EF00..8EFFF */
+  BidLev1_0100,  /* 8F000..8F0FF */
+  BidLev1_0100,  /* 8F100..8F1FF */
+  BidLev1_0100,  /* 8F200..8F2FF */
+  BidLev1_0100,  /* 8F300..8F3FF */
+  BidLev1_0100,  /* 8F400..8F4FF */
+  BidLev1_0100,  /* 8F500..8F5FF */
+  BidLev1_0100,  /* 8F600..8F6FF */
+  BidLev1_0100,  /* 8F700..8F7FF */
+  BidLev1_0100,  /* 8F800..8F8FF */
+  BidLev1_0100,  /* 8F900..8F9FF */
+  BidLev1_0100,  /* 8FA00..8FAFF */
+  BidLev1_0100,  /* 8FB00..8FBFF */
+  BidLev1_0100,  /* 8FC00..8FCFF */
+  BidLev1_0100,  /* 8FD00..8FDFF */
+  BidLev1_0100,  /* 8FE00..8FEFF */
+  BidLev1_1FF00,  /* 8FF00..8FFFF */
+  BidLev1_0100,  /* 90000..900FF */
+  BidLev1_0100,  /* 90100..901FF */
+  BidLev1_0100,  /* 90200..902FF */
+  BidLev1_0100,  /* 90300..903FF */
+  BidLev1_0100,  /* 90400..904FF */
+  BidLev1_0100,  /* 90500..905FF */
+  BidLev1_0100,  /* 90600..906FF */
+  BidLev1_0100,  /* 90700..907FF */
+  BidLev1_0100,  /* 90800..908FF */
+  BidLev1_0100,  /* 90900..909FF */
+  BidLev1_0100,  /* 90A00..90AFF */
+  BidLev1_0100,  /* 90B00..90BFF */
+  BidLev1_0100,  /* 90C00..90CFF */
+  BidLev1_0100,  /* 90D00..90DFF */
+  BidLev1_0100,  /* 90E00..90EFF */
+  BidLev1_0100,  /* 90F00..90FFF */
+  BidLev1_0100,  /* 91000..910FF */
+  BidLev1_0100,  /* 91100..911FF */
+  BidLev1_0100,  /* 91200..912FF */
+  BidLev1_0100,  /* 91300..913FF */
+  BidLev1_0100,  /* 91400..914FF */
+  BidLev1_0100,  /* 91500..915FF */
+  BidLev1_0100,  /* 91600..916FF */
+  BidLev1_0100,  /* 91700..917FF */
+  BidLev1_0100,  /* 91800..918FF */
+  BidLev1_0100,  /* 91900..919FF */
+  BidLev1_0100,  /* 91A00..91AFF */
+  BidLev1_0100,  /* 91B00..91BFF */
+  BidLev1_0100,  /* 91C00..91CFF */
+  BidLev1_0100,  /* 91D00..91DFF */
+  BidLev1_0100,  /* 91E00..91EFF */
+  BidLev1_0100,  /* 91F00..91FFF */
+  BidLev1_0100,  /* 92000..920FF */
+  BidLev1_0100,  /* 92100..921FF */
+  BidLev1_0100,  /* 92200..922FF */
+  BidLev1_0100,  /* 92300..923FF */
+  BidLev1_0100,  /* 92400..924FF */
+  BidLev1_0100,  /* 92500..925FF */
+  BidLev1_0100,  /* 92600..926FF */
+  BidLev1_0100,  /* 92700..927FF */
+  BidLev1_0100,  /* 92800..928FF */
+  BidLev1_0100,  /* 92900..929FF */
+  BidLev1_0100,  /* 92A00..92AFF */
+  BidLev1_0100,  /* 92B00..92BFF */
+  BidLev1_0100,  /* 92C00..92CFF */
+  BidLev1_0100,  /* 92D00..92DFF */
+  BidLev1_0100,  /* 92E00..92EFF */
+  BidLev1_0100,  /* 92F00..92FFF */
+  BidLev1_0100,  /* 93000..930FF */
+  BidLev1_0100,  /* 93100..931FF */
+  BidLev1_0100,  /* 93200..932FF */
+  BidLev1_0100,  /* 93300..933FF */
+  BidLev1_0100,  /* 93400..934FF */
+  BidLev1_0100,  /* 93500..935FF */
+  BidLev1_0100,  /* 93600..936FF */
+  BidLev1_0100,  /* 93700..937FF */
+  BidLev1_0100,  /* 93800..938FF */
+  BidLev1_0100,  /* 93900..939FF */
+  BidLev1_0100,  /* 93A00..93AFF */
+  BidLev1_0100,  /* 93B00..93BFF */
+  BidLev1_0100,  /* 93C00..93CFF */
+  BidLev1_0100,  /* 93D00..93DFF */
+  BidLev1_0100,  /* 93E00..93EFF */
+  BidLev1_0100,  /* 93F00..93FFF */
+  BidLev1_0100,  /* 94000..940FF */
+  BidLev1_0100,  /* 94100..941FF */
+  BidLev1_0100,  /* 94200..942FF */
+  BidLev1_0100,  /* 94300..943FF */
+  BidLev1_0100,  /* 94400..944FF */
+  BidLev1_0100,  /* 94500..945FF */
+  BidLev1_0100,  /* 94600..946FF */
+  BidLev1_0100,  /* 94700..947FF */
+  BidLev1_0100,  /* 94800..948FF */
+  BidLev1_0100,  /* 94900..949FF */
+  BidLev1_0100,  /* 94A00..94AFF */
+  BidLev1_0100,  /* 94B00..94BFF */
+  BidLev1_0100,  /* 94C00..94CFF */
+  BidLev1_0100,  /* 94D00..94DFF */
+  BidLev1_0100,  /* 94E00..94EFF */
+  BidLev1_0100,  /* 94F00..94FFF */
+  BidLev1_0100,  /* 95000..950FF */
+  BidLev1_0100,  /* 95100..951FF */
+  BidLev1_0100,  /* 95200..952FF */
+  BidLev1_0100,  /* 95300..953FF */
+  BidLev1_0100,  /* 95400..954FF */
+  BidLev1_0100,  /* 95500..955FF */
+  BidLev1_0100,  /* 95600..956FF */
+  BidLev1_0100,  /* 95700..957FF */
+  BidLev1_0100,  /* 95800..958FF */
+  BidLev1_0100,  /* 95900..959FF */
+  BidLev1_0100,  /* 95A00..95AFF */
+  BidLev1_0100,  /* 95B00..95BFF */
+  BidLev1_0100,  /* 95C00..95CFF */
+  BidLev1_0100,  /* 95D00..95DFF */
+  BidLev1_0100,  /* 95E00..95EFF */
+  BidLev1_0100,  /* 95F00..95FFF */
+  BidLev1_0100,  /* 96000..960FF */
+  BidLev1_0100,  /* 96100..961FF */
+  BidLev1_0100,  /* 96200..962FF */
+  BidLev1_0100,  /* 96300..963FF */
+  BidLev1_0100,  /* 96400..964FF */
+  BidLev1_0100,  /* 96500..965FF */
+  BidLev1_0100,  /* 96600..966FF */
+  BidLev1_0100,  /* 96700..967FF */
+  BidLev1_0100,  /* 96800..968FF */
+  BidLev1_0100,  /* 96900..969FF */
+  BidLev1_0100,  /* 96A00..96AFF */
+  BidLev1_0100,  /* 96B00..96BFF */
+  BidLev1_0100,  /* 96C00..96CFF */
+  BidLev1_0100,  /* 96D00..96DFF */
+  BidLev1_0100,  /* 96E00..96EFF */
+  BidLev1_0100,  /* 96F00..96FFF */
+  BidLev1_0100,  /* 97000..970FF */
+  BidLev1_0100,  /* 97100..971FF */
+  BidLev1_0100,  /* 97200..972FF */
+  BidLev1_0100,  /* 97300..973FF */
+  BidLev1_0100,  /* 97400..974FF */
+  BidLev1_0100,  /* 97500..975FF */
+  BidLev1_0100,  /* 97600..976FF */
+  BidLev1_0100,  /* 97700..977FF */
+  BidLev1_0100,  /* 97800..978FF */
+  BidLev1_0100,  /* 97900..979FF */
+  BidLev1_0100,  /* 97A00..97AFF */
+  BidLev1_0100,  /* 97B00..97BFF */
+  BidLev1_0100,  /* 97C00..97CFF */
+  BidLev1_0100,  /* 97D00..97DFF */
+  BidLev1_0100,  /* 97E00..97EFF */
+  BidLev1_0100,  /* 97F00..97FFF */
+  BidLev1_0100,  /* 98000..980FF */
+  BidLev1_0100,  /* 98100..981FF */
+  BidLev1_0100,  /* 98200..982FF */
+  BidLev1_0100,  /* 98300..983FF */
+  BidLev1_0100,  /* 98400..984FF */
+  BidLev1_0100,  /* 98500..985FF */
+  BidLev1_0100,  /* 98600..986FF */
+  BidLev1_0100,  /* 98700..987FF */
+  BidLev1_0100,  /* 98800..988FF */
+  BidLev1_0100,  /* 98900..989FF */
+  BidLev1_0100,  /* 98A00..98AFF */
+  BidLev1_0100,  /* 98B00..98BFF */
+  BidLev1_0100,  /* 98C00..98CFF */
+  BidLev1_0100,  /* 98D00..98DFF */
+  BidLev1_0100,  /* 98E00..98EFF */
+  BidLev1_0100,  /* 98F00..98FFF */
+  BidLev1_0100,  /* 99000..990FF */
+  BidLev1_0100,  /* 99100..991FF */
+  BidLev1_0100,  /* 99200..992FF */
+  BidLev1_0100,  /* 99300..993FF */
+  BidLev1_0100,  /* 99400..994FF */
+  BidLev1_0100,  /* 99500..995FF */
+  BidLev1_0100,  /* 99600..996FF */
+  BidLev1_0100,  /* 99700..997FF */
+  BidLev1_0100,  /* 99800..998FF */
+  BidLev1_0100,  /* 99900..999FF */
+  BidLev1_0100,  /* 99A00..99AFF */
+  BidLev1_0100,  /* 99B00..99BFF */
+  BidLev1_0100,  /* 99C00..99CFF */
+  BidLev1_0100,  /* 99D00..99DFF */
+  BidLev1_0100,  /* 99E00..99EFF */
+  BidLev1_0100,  /* 99F00..99FFF */
+  BidLev1_0100,  /* 9A000..9A0FF */
+  BidLev1_0100,  /* 9A100..9A1FF */
+  BidLev1_0100,  /* 9A200..9A2FF */
+  BidLev1_0100,  /* 9A300..9A3FF */
+  BidLev1_0100,  /* 9A400..9A4FF */
+  BidLev1_0100,  /* 9A500..9A5FF */
+  BidLev1_0100,  /* 9A600..9A6FF */
+  BidLev1_0100,  /* 9A700..9A7FF */
+  BidLev1_0100,  /* 9A800..9A8FF */
+  BidLev1_0100,  /* 9A900..9A9FF */
+  BidLev1_0100,  /* 9AA00..9AAFF */
+  BidLev1_0100,  /* 9AB00..9ABFF */
+  BidLev1_0100,  /* 9AC00..9ACFF */
+  BidLev1_0100,  /* 9AD00..9ADFF */
+  BidLev1_0100,  /* 9AE00..9AEFF */
+  BidLev1_0100,  /* 9AF00..9AFFF */
+  BidLev1_0100,  /* 9B000..9B0FF */
+  BidLev1_0100,  /* 9B100..9B1FF */
+  BidLev1_0100,  /* 9B200..9B2FF */
+  BidLev1_0100,  /* 9B300..9B3FF */
+  BidLev1_0100,  /* 9B400..9B4FF */
+  BidLev1_0100,  /* 9B500..9B5FF */
+  BidLev1_0100,  /* 9B600..9B6FF */
+  BidLev1_0100,  /* 9B700..9B7FF */
+  BidLev1_0100,  /* 9B800..9B8FF */
+  BidLev1_0100,  /* 9B900..9B9FF */
+  BidLev1_0100,  /* 9BA00..9BAFF */
+  BidLev1_0100,  /* 9BB00..9BBFF */
+  BidLev1_0100,  /* 9BC00..9BCFF */
+  BidLev1_0100,  /* 9BD00..9BDFF */
+  BidLev1_0100,  /* 9BE00..9BEFF */
+  BidLev1_0100,  /* 9BF00..9BFFF */
+  BidLev1_0100,  /* 9C000..9C0FF */
+  BidLev1_0100,  /* 9C100..9C1FF */
+  BidLev1_0100,  /* 9C200..9C2FF */
+  BidLev1_0100,  /* 9C300..9C3FF */
+  BidLev1_0100,  /* 9C400..9C4FF */
+  BidLev1_0100,  /* 9C500..9C5FF */
+  BidLev1_0100,  /* 9C600..9C6FF */
+  BidLev1_0100,  /* 9C700..9C7FF */
+  BidLev1_0100,  /* 9C800..9C8FF */
+  BidLev1_0100,  /* 9C900..9C9FF */
+  BidLev1_0100,  /* 9CA00..9CAFF */
+  BidLev1_0100,  /* 9CB00..9CBFF */
+  BidLev1_0100,  /* 9CC00..9CCFF */
+  BidLev1_0100,  /* 9CD00..9CDFF */
+  BidLev1_0100,  /* 9CE00..9CEFF */
+  BidLev1_0100,  /* 9CF00..9CFFF */
+  BidLev1_0100,  /* 9D000..9D0FF */
+  BidLev1_0100,  /* 9D100..9D1FF */
+  BidLev1_0100,  /* 9D200..9D2FF */
+  BidLev1_0100,  /* 9D300..9D3FF */
+  BidLev1_0100,  /* 9D400..9D4FF */
+  BidLev1_0100,  /* 9D500..9D5FF */
+  BidLev1_0100,  /* 9D600..9D6FF */
+  BidLev1_0100,  /* 9D700..9D7FF */
+  BidLev1_0100,  /* 9D800..9D8FF */
+  BidLev1_0100,  /* 9D900..9D9FF */
+  BidLev1_0100,  /* 9DA00..9DAFF */
+  BidLev1_0100,  /* 9DB00..9DBFF */
+  BidLev1_0100,  /* 9DC00..9DCFF */
+  BidLev1_0100,  /* 9DD00..9DDFF */
+  BidLev1_0100,  /* 9DE00..9DEFF */
+  BidLev1_0100,  /* 9DF00..9DFFF */
+  BidLev1_0100,  /* 9E000..9E0FF */
+  BidLev1_0100,  /* 9E100..9E1FF */
+  BidLev1_0100,  /* 9E200..9E2FF */
+  BidLev1_0100,  /* 9E300..9E3FF */
+  BidLev1_0100,  /* 9E400..9E4FF */
+  BidLev1_0100,  /* 9E500..9E5FF */
+  BidLev1_0100,  /* 9E600..9E6FF */
+  BidLev1_0100,  /* 9E700..9E7FF */
+  BidLev1_0100,  /* 9E800..9E8FF */
+  BidLev1_0100,  /* 9E900..9E9FF */
+  BidLev1_0100,  /* 9EA00..9EAFF */
+  BidLev1_0100,  /* 9EB00..9EBFF */
+  BidLev1_0100,  /* 9EC00..9ECFF */
+  BidLev1_0100,  /* 9ED00..9EDFF */
+  BidLev1_0100,  /* 9EE00..9EEFF */
+  BidLev1_0100,  /* 9EF00..9EFFF */
+  BidLev1_0100,  /* 9F000..9F0FF */
+  BidLev1_0100,  /* 9F100..9F1FF */
+  BidLev1_0100,  /* 9F200..9F2FF */
+  BidLev1_0100,  /* 9F300..9F3FF */
+  BidLev1_0100,  /* 9F400..9F4FF */
+  BidLev1_0100,  /* 9F500..9F5FF */
+  BidLev1_0100,  /* 9F600..9F6FF */
+  BidLev1_0100,  /* 9F700..9F7FF */
+  BidLev1_0100,  /* 9F800..9F8FF */
+  BidLev1_0100,  /* 9F900..9F9FF */
+  BidLev1_0100,  /* 9FA00..9FAFF */
+  BidLev1_0100,  /* 9FB00..9FBFF */
+  BidLev1_0100,  /* 9FC00..9FCFF */
+  BidLev1_0100,  /* 9FD00..9FDFF */
+  BidLev1_0100,  /* 9FE00..9FEFF */
+  BidLev1_1FF00,  /* 9FF00..9FFFF */
+  BidLev1_0100,  /* A0000..A00FF */
+  BidLev1_0100,  /* A0100..A01FF */
+  BidLev1_0100,  /* A0200..A02FF */
+  BidLev1_0100,  /* A0300..A03FF */
+  BidLev1_0100,  /* A0400..A04FF */
+  BidLev1_0100,  /* A0500..A05FF */
+  BidLev1_0100,  /* A0600..A06FF */
+  BidLev1_0100,  /* A0700..A07FF */
+  BidLev1_0100,  /* A0800..A08FF */
+  BidLev1_0100,  /* A0900..A09FF */
+  BidLev1_0100,  /* A0A00..A0AFF */
+  BidLev1_0100,  /* A0B00..A0BFF */
+  BidLev1_0100,  /* A0C00..A0CFF */
+  BidLev1_0100,  /* A0D00..A0DFF */
+  BidLev1_0100,  /* A0E00..A0EFF */
+  BidLev1_0100,  /* A0F00..A0FFF */
+  BidLev1_0100,  /* A1000..A10FF */
+  BidLev1_0100,  /* A1100..A11FF */
+  BidLev1_0100,  /* A1200..A12FF */
+  BidLev1_0100,  /* A1300..A13FF */
+  BidLev1_0100,  /* A1400..A14FF */
+  BidLev1_0100,  /* A1500..A15FF */
+  BidLev1_0100,  /* A1600..A16FF */
+  BidLev1_0100,  /* A1700..A17FF */
+  BidLev1_0100,  /* A1800..A18FF */
+  BidLev1_0100,  /* A1900..A19FF */
+  BidLev1_0100,  /* A1A00..A1AFF */
+  BidLev1_0100,  /* A1B00..A1BFF */
+  BidLev1_0100,  /* A1C00..A1CFF */
+  BidLev1_0100,  /* A1D00..A1DFF */
+  BidLev1_0100,  /* A1E00..A1EFF */
+  BidLev1_0100,  /* A1F00..A1FFF */
+  BidLev1_0100,  /* A2000..A20FF */
+  BidLev1_0100,  /* A2100..A21FF */
+  BidLev1_0100,  /* A2200..A22FF */
+  BidLev1_0100,  /* A2300..A23FF */
+  BidLev1_0100,  /* A2400..A24FF */
+  BidLev1_0100,  /* A2500..A25FF */
+  BidLev1_0100,  /* A2600..A26FF */
+  BidLev1_0100,  /* A2700..A27FF */
+  BidLev1_0100,  /* A2800..A28FF */
+  BidLev1_0100,  /* A2900..A29FF */
+  BidLev1_0100,  /* A2A00..A2AFF */
+  BidLev1_0100,  /* A2B00..A2BFF */
+  BidLev1_0100,  /* A2C00..A2CFF */
+  BidLev1_0100,  /* A2D00..A2DFF */
+  BidLev1_0100,  /* A2E00..A2EFF */
+  BidLev1_0100,  /* A2F00..A2FFF */
+  BidLev1_0100,  /* A3000..A30FF */
+  BidLev1_0100,  /* A3100..A31FF */
+  BidLev1_0100,  /* A3200..A32FF */
+  BidLev1_0100,  /* A3300..A33FF */
+  BidLev1_0100,  /* A3400..A34FF */
+  BidLev1_0100,  /* A3500..A35FF */
+  BidLev1_0100,  /* A3600..A36FF */
+  BidLev1_0100,  /* A3700..A37FF */
+  BidLev1_0100,  /* A3800..A38FF */
+  BidLev1_0100,  /* A3900..A39FF */
+  BidLev1_0100,  /* A3A00..A3AFF */
+  BidLev1_0100,  /* A3B00..A3BFF */
+  BidLev1_0100,  /* A3C00..A3CFF */
+  BidLev1_0100,  /* A3D00..A3DFF */
+  BidLev1_0100,  /* A3E00..A3EFF */
+  BidLev1_0100,  /* A3F00..A3FFF */
+  BidLev1_0100,  /* A4000..A40FF */
+  BidLev1_0100,  /* A4100..A41FF */
+  BidLev1_0100,  /* A4200..A42FF */
+  BidLev1_0100,  /* A4300..A43FF */
+  BidLev1_0100,  /* A4400..A44FF */
+  BidLev1_0100,  /* A4500..A45FF */
+  BidLev1_0100,  /* A4600..A46FF */
+  BidLev1_0100,  /* A4700..A47FF */
+  BidLev1_0100,  /* A4800..A48FF */
+  BidLev1_0100,  /* A4900..A49FF */
+  BidLev1_0100,  /* A4A00..A4AFF */
+  BidLev1_0100,  /* A4B00..A4BFF */
+  BidLev1_0100,  /* A4C00..A4CFF */
+  BidLev1_0100,  /* A4D00..A4DFF */
+  BidLev1_0100,  /* A4E00..A4EFF */
+  BidLev1_0100,  /* A4F00..A4FFF */
+  BidLev1_0100,  /* A5000..A50FF */
+  BidLev1_0100,  /* A5100..A51FF */
+  BidLev1_0100,  /* A5200..A52FF */
+  BidLev1_0100,  /* A5300..A53FF */
+  BidLev1_0100,  /* A5400..A54FF */
+  BidLev1_0100,  /* A5500..A55FF */
+  BidLev1_0100,  /* A5600..A56FF */
+  BidLev1_0100,  /* A5700..A57FF */
+  BidLev1_0100,  /* A5800..A58FF */
+  BidLev1_0100,  /* A5900..A59FF */
+  BidLev1_0100,  /* A5A00..A5AFF */
+  BidLev1_0100,  /* A5B00..A5BFF */
+  BidLev1_0100,  /* A5C00..A5CFF */
+  BidLev1_0100,  /* A5D00..A5DFF */
+  BidLev1_0100,  /* A5E00..A5EFF */
+  BidLev1_0100,  /* A5F00..A5FFF */
+  BidLev1_0100,  /* A6000..A60FF */
+  BidLev1_0100,  /* A6100..A61FF */
+  BidLev1_0100,  /* A6200..A62FF */
+  BidLev1_0100,  /* A6300..A63FF */
+  BidLev1_0100,  /* A6400..A64FF */
+  BidLev1_0100,  /* A6500..A65FF */
+  BidLev1_0100,  /* A6600..A66FF */
+  BidLev1_0100,  /* A6700..A67FF */
+  BidLev1_0100,  /* A6800..A68FF */
+  BidLev1_0100,  /* A6900..A69FF */
+  BidLev1_0100,  /* A6A00..A6AFF */
+  BidLev1_0100,  /* A6B00..A6BFF */
+  BidLev1_0100,  /* A6C00..A6CFF */
+  BidLev1_0100,  /* A6D00..A6DFF */
+  BidLev1_0100,  /* A6E00..A6EFF */
+  BidLev1_0100,  /* A6F00..A6FFF */
+  BidLev1_0100,  /* A7000..A70FF */
+  BidLev1_0100,  /* A7100..A71FF */
+  BidLev1_0100,  /* A7200..A72FF */
+  BidLev1_0100,  /* A7300..A73FF */
+  BidLev1_0100,  /* A7400..A74FF */
+  BidLev1_0100,  /* A7500..A75FF */
+  BidLev1_0100,  /* A7600..A76FF */
+  BidLev1_0100,  /* A7700..A77FF */
+  BidLev1_0100,  /* A7800..A78FF */
+  BidLev1_0100,  /* A7900..A79FF */
+  BidLev1_0100,  /* A7A00..A7AFF */
+  BidLev1_0100,  /* A7B00..A7BFF */
+  BidLev1_0100,  /* A7C00..A7CFF */
+  BidLev1_0100,  /* A7D00..A7DFF */
+  BidLev1_0100,  /* A7E00..A7EFF */
+  BidLev1_0100,  /* A7F00..A7FFF */
+  BidLev1_0100,  /* A8000..A80FF */
+  BidLev1_0100,  /* A8100..A81FF */
+  BidLev1_0100,  /* A8200..A82FF */
+  BidLev1_0100,  /* A8300..A83FF */
+  BidLev1_0100,  /* A8400..A84FF */
+  BidLev1_0100,  /* A8500..A85FF */
+  BidLev1_0100,  /* A8600..A86FF */
+  BidLev1_0100,  /* A8700..A87FF */
+  BidLev1_0100,  /* A8800..A88FF */
+  BidLev1_0100,  /* A8900..A89FF */
+  BidLev1_0100,  /* A8A00..A8AFF */
+  BidLev1_0100,  /* A8B00..A8BFF */
+  BidLev1_0100,  /* A8C00..A8CFF */
+  BidLev1_0100,  /* A8D00..A8DFF */
+  BidLev1_0100,  /* A8E00..A8EFF */
+  BidLev1_0100,  /* A8F00..A8FFF */
+  BidLev1_0100,  /* A9000..A90FF */
+  BidLev1_0100,  /* A9100..A91FF */
+  BidLev1_0100,  /* A9200..A92FF */
+  BidLev1_0100,  /* A9300..A93FF */
+  BidLev1_0100,  /* A9400..A94FF */
+  BidLev1_0100,  /* A9500..A95FF */
+  BidLev1_0100,  /* A9600..A96FF */
+  BidLev1_0100,  /* A9700..A97FF */
+  BidLev1_0100,  /* A9800..A98FF */
+  BidLev1_0100,  /* A9900..A99FF */
+  BidLev1_0100,  /* A9A00..A9AFF */
+  BidLev1_0100,  /* A9B00..A9BFF */
+  BidLev1_0100,  /* A9C00..A9CFF */
+  BidLev1_0100,  /* A9D00..A9DFF */
+  BidLev1_0100,  /* A9E00..A9EFF */
+  BidLev1_0100,  /* A9F00..A9FFF */
+  BidLev1_0100,  /* AA000..AA0FF */
+  BidLev1_0100,  /* AA100..AA1FF */
+  BidLev1_0100,  /* AA200..AA2FF */
+  BidLev1_0100,  /* AA300..AA3FF */
+  BidLev1_0100,  /* AA400..AA4FF */
+  BidLev1_0100,  /* AA500..AA5FF */
+  BidLev1_0100,  /* AA600..AA6FF */
+  BidLev1_0100,  /* AA700..AA7FF */
+  BidLev1_0100,  /* AA800..AA8FF */
+  BidLev1_0100,  /* AA900..AA9FF */
+  BidLev1_0100,  /* AAA00..AAAFF */
+  BidLev1_0100,  /* AAB00..AABFF */
+  BidLev1_0100,  /* AAC00..AACFF */
+  BidLev1_0100,  /* AAD00..AADFF */
+  BidLev1_0100,  /* AAE00..AAEFF */
+  BidLev1_0100,  /* AAF00..AAFFF */
+  BidLev1_0100,  /* AB000..AB0FF */
+  BidLev1_0100,  /* AB100..AB1FF */
+  BidLev1_0100,  /* AB200..AB2FF */
+  BidLev1_0100,  /* AB300..AB3FF */
+  BidLev1_0100,  /* AB400..AB4FF */
+  BidLev1_0100,  /* AB500..AB5FF */
+  BidLev1_0100,  /* AB600..AB6FF */
+  BidLev1_0100,  /* AB700..AB7FF */
+  BidLev1_0100,  /* AB800..AB8FF */
+  BidLev1_0100,  /* AB900..AB9FF */
+  BidLev1_0100,  /* ABA00..ABAFF */
+  BidLev1_0100,  /* ABB00..ABBFF */
+  BidLev1_0100,  /* ABC00..ABCFF */
+  BidLev1_0100,  /* ABD00..ABDFF */
+  BidLev1_0100,  /* ABE00..ABEFF */
+  BidLev1_0100,  /* ABF00..ABFFF */
+  BidLev1_0100,  /* AC000..AC0FF */
+  BidLev1_0100,  /* AC100..AC1FF */
+  BidLev1_0100,  /* AC200..AC2FF */
+  BidLev1_0100,  /* AC300..AC3FF */
+  BidLev1_0100,  /* AC400..AC4FF */
+  BidLev1_0100,  /* AC500..AC5FF */
+  BidLev1_0100,  /* AC600..AC6FF */
+  BidLev1_0100,  /* AC700..AC7FF */
+  BidLev1_0100,  /* AC800..AC8FF */
+  BidLev1_0100,  /* AC900..AC9FF */
+  BidLev1_0100,  /* ACA00..ACAFF */
+  BidLev1_0100,  /* ACB00..ACBFF */
+  BidLev1_0100,  /* ACC00..ACCFF */
+  BidLev1_0100,  /* ACD00..ACDFF */
+  BidLev1_0100,  /* ACE00..ACEFF */
+  BidLev1_0100,  /* ACF00..ACFFF */
+  BidLev1_0100,  /* AD000..AD0FF */
+  BidLev1_0100,  /* AD100..AD1FF */
+  BidLev1_0100,  /* AD200..AD2FF */
+  BidLev1_0100,  /* AD300..AD3FF */
+  BidLev1_0100,  /* AD400..AD4FF */
+  BidLev1_0100,  /* AD500..AD5FF */
+  BidLev1_0100,  /* AD600..AD6FF */
+  BidLev1_0100,  /* AD700..AD7FF */
+  BidLev1_0100,  /* AD800..AD8FF */
+  BidLev1_0100,  /* AD900..AD9FF */
+  BidLev1_0100,  /* ADA00..ADAFF */
+  BidLev1_0100,  /* ADB00..ADBFF */
+  BidLev1_0100,  /* ADC00..ADCFF */
+  BidLev1_0100,  /* ADD00..ADDFF */
+  BidLev1_0100,  /* ADE00..ADEFF */
+  BidLev1_0100,  /* ADF00..ADFFF */
+  BidLev1_0100,  /* AE000..AE0FF */
+  BidLev1_0100,  /* AE100..AE1FF */
+  BidLev1_0100,  /* AE200..AE2FF */
+  BidLev1_0100,  /* AE300..AE3FF */
+  BidLev1_0100,  /* AE400..AE4FF */
+  BidLev1_0100,  /* AE500..AE5FF */
+  BidLev1_0100,  /* AE600..AE6FF */
+  BidLev1_0100,  /* AE700..AE7FF */
+  BidLev1_0100,  /* AE800..AE8FF */
+  BidLev1_0100,  /* AE900..AE9FF */
+  BidLev1_0100,  /* AEA00..AEAFF */
+  BidLev1_0100,  /* AEB00..AEBFF */
+  BidLev1_0100,  /* AEC00..AECFF */
+  BidLev1_0100,  /* AED00..AEDFF */
+  BidLev1_0100,  /* AEE00..AEEFF */
+  BidLev1_0100,  /* AEF00..AEFFF */
+  BidLev1_0100,  /* AF000..AF0FF */
+  BidLev1_0100,  /* AF100..AF1FF */
+  BidLev1_0100,  /* AF200..AF2FF */
+  BidLev1_0100,  /* AF300..AF3FF */
+  BidLev1_0100,  /* AF400..AF4FF */
+  BidLev1_0100,  /* AF500..AF5FF */
+  BidLev1_0100,  /* AF600..AF6FF */
+  BidLev1_0100,  /* AF700..AF7FF */
+  BidLev1_0100,  /* AF800..AF8FF */
+  BidLev1_0100,  /* AF900..AF9FF */
+  BidLev1_0100,  /* AFA00..AFAFF */
+  BidLev1_0100,  /* AFB00..AFBFF */
+  BidLev1_0100,  /* AFC00..AFCFF */
+  BidLev1_0100,  /* AFD00..AFDFF */
+  BidLev1_0100,  /* AFE00..AFEFF */
+  BidLev1_1FF00,  /* AFF00..AFFFF */
+  BidLev1_0100,  /* B0000..B00FF */
+  BidLev1_0100,  /* B0100..B01FF */
+  BidLev1_0100,  /* B0200..B02FF */
+  BidLev1_0100,  /* B0300..B03FF */
+  BidLev1_0100,  /* B0400..B04FF */
+  BidLev1_0100,  /* B0500..B05FF */
+  BidLev1_0100,  /* B0600..B06FF */
+  BidLev1_0100,  /* B0700..B07FF */
+  BidLev1_0100,  /* B0800..B08FF */
+  BidLev1_0100,  /* B0900..B09FF */
+  BidLev1_0100,  /* B0A00..B0AFF */
+  BidLev1_0100,  /* B0B00..B0BFF */
+  BidLev1_0100,  /* B0C00..B0CFF */
+  BidLev1_0100,  /* B0D00..B0DFF */
+  BidLev1_0100,  /* B0E00..B0EFF */
+  BidLev1_0100,  /* B0F00..B0FFF */
+  BidLev1_0100,  /* B1000..B10FF */
+  BidLev1_0100,  /* B1100..B11FF */
+  BidLev1_0100,  /* B1200..B12FF */
+  BidLev1_0100,  /* B1300..B13FF */
+  BidLev1_0100,  /* B1400..B14FF */
+  BidLev1_0100,  /* B1500..B15FF */
+  BidLev1_0100,  /* B1600..B16FF */
+  BidLev1_0100,  /* B1700..B17FF */
+  BidLev1_0100,  /* B1800..B18FF */
+  BidLev1_0100,  /* B1900..B19FF */
+  BidLev1_0100,  /* B1A00..B1AFF */
+  BidLev1_0100,  /* B1B00..B1BFF */
+  BidLev1_0100,  /* B1C00..B1CFF */
+  BidLev1_0100,  /* B1D00..B1DFF */
+  BidLev1_0100,  /* B1E00..B1EFF */
+  BidLev1_0100,  /* B1F00..B1FFF */
+  BidLev1_0100,  /* B2000..B20FF */
+  BidLev1_0100,  /* B2100..B21FF */
+  BidLev1_0100,  /* B2200..B22FF */
+  BidLev1_0100,  /* B2300..B23FF */
+  BidLev1_0100,  /* B2400..B24FF */
+  BidLev1_0100,  /* B2500..B25FF */
+  BidLev1_0100,  /* B2600..B26FF */
+  BidLev1_0100,  /* B2700..B27FF */
+  BidLev1_0100,  /* B2800..B28FF */
+  BidLev1_0100,  /* B2900..B29FF */
+  BidLev1_0100,  /* B2A00..B2AFF */
+  BidLev1_0100,  /* B2B00..B2BFF */
+  BidLev1_0100,  /* B2C00..B2CFF */
+  BidLev1_0100,  /* B2D00..B2DFF */
+  BidLev1_0100,  /* B2E00..B2EFF */
+  BidLev1_0100,  /* B2F00..B2FFF */
+  BidLev1_0100,  /* B3000..B30FF */
+  BidLev1_0100,  /* B3100..B31FF */
+  BidLev1_0100,  /* B3200..B32FF */
+  BidLev1_0100,  /* B3300..B33FF */
+  BidLev1_0100,  /* B3400..B34FF */
+  BidLev1_0100,  /* B3500..B35FF */
+  BidLev1_0100,  /* B3600..B36FF */
+  BidLev1_0100,  /* B3700..B37FF */
+  BidLev1_0100,  /* B3800..B38FF */
+  BidLev1_0100,  /* B3900..B39FF */
+  BidLev1_0100,  /* B3A00..B3AFF */
+  BidLev1_0100,  /* B3B00..B3BFF */
+  BidLev1_0100,  /* B3C00..B3CFF */
+  BidLev1_0100,  /* B3D00..B3DFF */
+  BidLev1_0100,  /* B3E00..B3EFF */
+  BidLev1_0100,  /* B3F00..B3FFF */
+  BidLev1_0100,  /* B4000..B40FF */
+  BidLev1_0100,  /* B4100..B41FF */
+  BidLev1_0100,  /* B4200..B42FF */
+  BidLev1_0100,  /* B4300..B43FF */
+  BidLev1_0100,  /* B4400..B44FF */
+  BidLev1_0100,  /* B4500..B45FF */
+  BidLev1_0100,  /* B4600..B46FF */
+  BidLev1_0100,  /* B4700..B47FF */
+  BidLev1_0100,  /* B4800..B48FF */
+  BidLev1_0100,  /* B4900..B49FF */
+  BidLev1_0100,  /* B4A00..B4AFF */
+  BidLev1_0100,  /* B4B00..B4BFF */
+  BidLev1_0100,  /* B4C00..B4CFF */
+  BidLev1_0100,  /* B4D00..B4DFF */
+  BidLev1_0100,  /* B4E00..B4EFF */
+  BidLev1_0100,  /* B4F00..B4FFF */
+  BidLev1_0100,  /* B5000..B50FF */
+  BidLev1_0100,  /* B5100..B51FF */
+  BidLev1_0100,  /* B5200..B52FF */
+  BidLev1_0100,  /* B5300..B53FF */
+  BidLev1_0100,  /* B5400..B54FF */
+  BidLev1_0100,  /* B5500..B55FF */
+  BidLev1_0100,  /* B5600..B56FF */
+  BidLev1_0100,  /* B5700..B57FF */
+  BidLev1_0100,  /* B5800..B58FF */
+  BidLev1_0100,  /* B5900..B59FF */
+  BidLev1_0100,  /* B5A00..B5AFF */
+  BidLev1_0100,  /* B5B00..B5BFF */
+  BidLev1_0100,  /* B5C00..B5CFF */
+  BidLev1_0100,  /* B5D00..B5DFF */
+  BidLev1_0100,  /* B5E00..B5EFF */
+  BidLev1_0100,  /* B5F00..B5FFF */
+  BidLev1_0100,  /* B6000..B60FF */
+  BidLev1_0100,  /* B6100..B61FF */
+  BidLev1_0100,  /* B6200..B62FF */
+  BidLev1_0100,  /* B6300..B63FF */
+  BidLev1_0100,  /* B6400..B64FF */
+  BidLev1_0100,  /* B6500..B65FF */
+  BidLev1_0100,  /* B6600..B66FF */
+  BidLev1_0100,  /* B6700..B67FF */
+  BidLev1_0100,  /* B6800..B68FF */
+  BidLev1_0100,  /* B6900..B69FF */
+  BidLev1_0100,  /* B6A00..B6AFF */
+  BidLev1_0100,  /* B6B00..B6BFF */
+  BidLev1_0100,  /* B6C00..B6CFF */
+  BidLev1_0100,  /* B6D00..B6DFF */
+  BidLev1_0100,  /* B6E00..B6EFF */
+  BidLev1_0100,  /* B6F00..B6FFF */
+  BidLev1_0100,  /* B7000..B70FF */
+  BidLev1_0100,  /* B7100..B71FF */
+  BidLev1_0100,  /* B7200..B72FF */
+  BidLev1_0100,  /* B7300..B73FF */
+  BidLev1_0100,  /* B7400..B74FF */
+  BidLev1_0100,  /* B7500..B75FF */
+  BidLev1_0100,  /* B7600..B76FF */
+  BidLev1_0100,  /* B7700..B77FF */
+  BidLev1_0100,  /* B7800..B78FF */
+  BidLev1_0100,  /* B7900..B79FF */
+  BidLev1_0100,  /* B7A00..B7AFF */
+  BidLev1_0100,  /* B7B00..B7BFF */
+  BidLev1_0100,  /* B7C00..B7CFF */
+  BidLev1_0100,  /* B7D00..B7DFF */
+  BidLev1_0100,  /* B7E00..B7EFF */
+  BidLev1_0100,  /* B7F00..B7FFF */
+  BidLev1_0100,  /* B8000..B80FF */
+  BidLev1_0100,  /* B8100..B81FF */
+  BidLev1_0100,  /* B8200..B82FF */
+  BidLev1_0100,  /* B8300..B83FF */
+  BidLev1_0100,  /* B8400..B84FF */
+  BidLev1_0100,  /* B8500..B85FF */
+  BidLev1_0100,  /* B8600..B86FF */
+  BidLev1_0100,  /* B8700..B87FF */
+  BidLev1_0100,  /* B8800..B88FF */
+  BidLev1_0100,  /* B8900..B89FF */
+  BidLev1_0100,  /* B8A00..B8AFF */
+  BidLev1_0100,  /* B8B00..B8BFF */
+  BidLev1_0100,  /* B8C00..B8CFF */
+  BidLev1_0100,  /* B8D00..B8DFF */
+  BidLev1_0100,  /* B8E00..B8EFF */
+  BidLev1_0100,  /* B8F00..B8FFF */
+  BidLev1_0100,  /* B9000..B90FF */
+  BidLev1_0100,  /* B9100..B91FF */
+  BidLev1_0100,  /* B9200..B92FF */
+  BidLev1_0100,  /* B9300..B93FF */
+  BidLev1_0100,  /* B9400..B94FF */
+  BidLev1_0100,  /* B9500..B95FF */
+  BidLev1_0100,  /* B9600..B96FF */
+  BidLev1_0100,  /* B9700..B97FF */
+  BidLev1_0100,  /* B9800..B98FF */
+  BidLev1_0100,  /* B9900..B99FF */
+  BidLev1_0100,  /* B9A00..B9AFF */
+  BidLev1_0100,  /* B9B00..B9BFF */
+  BidLev1_0100,  /* B9C00..B9CFF */
+  BidLev1_0100,  /* B9D00..B9DFF */
+  BidLev1_0100,  /* B9E00..B9EFF */
+  BidLev1_0100,  /* B9F00..B9FFF */
+  BidLev1_0100,  /* BA000..BA0FF */
+  BidLev1_0100,  /* BA100..BA1FF */
+  BidLev1_0100,  /* BA200..BA2FF */
+  BidLev1_0100,  /* BA300..BA3FF */
+  BidLev1_0100,  /* BA400..BA4FF */
+  BidLev1_0100,  /* BA500..BA5FF */
+  BidLev1_0100,  /* BA600..BA6FF */
+  BidLev1_0100,  /* BA700..BA7FF */
+  BidLev1_0100,  /* BA800..BA8FF */
+  BidLev1_0100,  /* BA900..BA9FF */
+  BidLev1_0100,  /* BAA00..BAAFF */
+  BidLev1_0100,  /* BAB00..BABFF */
+  BidLev1_0100,  /* BAC00..BACFF */
+  BidLev1_0100,  /* BAD00..BADFF */
+  BidLev1_0100,  /* BAE00..BAEFF */
+  BidLev1_0100,  /* BAF00..BAFFF */
+  BidLev1_0100,  /* BB000..BB0FF */
+  BidLev1_0100,  /* BB100..BB1FF */
+  BidLev1_0100,  /* BB200..BB2FF */
+  BidLev1_0100,  /* BB300..BB3FF */
+  BidLev1_0100,  /* BB400..BB4FF */
+  BidLev1_0100,  /* BB500..BB5FF */
+  BidLev1_0100,  /* BB600..BB6FF */
+  BidLev1_0100,  /* BB700..BB7FF */
+  BidLev1_0100,  /* BB800..BB8FF */
+  BidLev1_0100,  /* BB900..BB9FF */
+  BidLev1_0100,  /* BBA00..BBAFF */
+  BidLev1_0100,  /* BBB00..BBBFF */
+  BidLev1_0100,  /* BBC00..BBCFF */
+  BidLev1_0100,  /* BBD00..BBDFF */
+  BidLev1_0100,  /* BBE00..BBEFF */
+  BidLev1_0100,  /* BBF00..BBFFF */
+  BidLev1_0100,  /* BC000..BC0FF */
+  BidLev1_0100,  /* BC100..BC1FF */
+  BidLev1_0100,  /* BC200..BC2FF */
+  BidLev1_0100,  /* BC300..BC3FF */
+  BidLev1_0100,  /* BC400..BC4FF */
+  BidLev1_0100,  /* BC500..BC5FF */
+  BidLev1_0100,  /* BC600..BC6FF */
+  BidLev1_0100,  /* BC700..BC7FF */
+  BidLev1_0100,  /* BC800..BC8FF */
+  BidLev1_0100,  /* BC900..BC9FF */
+  BidLev1_0100,  /* BCA00..BCAFF */
+  BidLev1_0100,  /* BCB00..BCBFF */
+  BidLev1_0100,  /* BCC00..BCCFF */
+  BidLev1_0100,  /* BCD00..BCDFF */
+  BidLev1_0100,  /* BCE00..BCEFF */
+  BidLev1_0100,  /* BCF00..BCFFF */
+  BidLev1_0100,  /* BD000..BD0FF */
+  BidLev1_0100,  /* BD100..BD1FF */
+  BidLev1_0100,  /* BD200..BD2FF */
+  BidLev1_0100,  /* BD300..BD3FF */
+  BidLev1_0100,  /* BD400..BD4FF */
+  BidLev1_0100,  /* BD500..BD5FF */
+  BidLev1_0100,  /* BD600..BD6FF */
+  BidLev1_0100,  /* BD700..BD7FF */
+  BidLev1_0100,  /* BD800..BD8FF */
+  BidLev1_0100,  /* BD900..BD9FF */
+  BidLev1_0100,  /* BDA00..BDAFF */
+  BidLev1_0100,  /* BDB00..BDBFF */
+  BidLev1_0100,  /* BDC00..BDCFF */
+  BidLev1_0100,  /* BDD00..BDDFF */
+  BidLev1_0100,  /* BDE00..BDEFF */
+  BidLev1_0100,  /* BDF00..BDFFF */
+  BidLev1_0100,  /* BE000..BE0FF */
+  BidLev1_0100,  /* BE100..BE1FF */
+  BidLev1_0100,  /* BE200..BE2FF */
+  BidLev1_0100,  /* BE300..BE3FF */
+  BidLev1_0100,  /* BE400..BE4FF */
+  BidLev1_0100,  /* BE500..BE5FF */
+  BidLev1_0100,  /* BE600..BE6FF */
+  BidLev1_0100,  /* BE700..BE7FF */
+  BidLev1_0100,  /* BE800..BE8FF */
+  BidLev1_0100,  /* BE900..BE9FF */
+  BidLev1_0100,  /* BEA00..BEAFF */
+  BidLev1_0100,  /* BEB00..BEBFF */
+  BidLev1_0100,  /* BEC00..BECFF */
+  BidLev1_0100,  /* BED00..BEDFF */
+  BidLev1_0100,  /* BEE00..BEEFF */
+  BidLev1_0100,  /* BEF00..BEFFF */
+  BidLev1_0100,  /* BF000..BF0FF */
+  BidLev1_0100,  /* BF100..BF1FF */
+  BidLev1_0100,  /* BF200..BF2FF */
+  BidLev1_0100,  /* BF300..BF3FF */
+  BidLev1_0100,  /* BF400..BF4FF */
+  BidLev1_0100,  /* BF500..BF5FF */
+  BidLev1_0100,  /* BF600..BF6FF */
+  BidLev1_0100,  /* BF700..BF7FF */
+  BidLev1_0100,  /* BF800..BF8FF */
+  BidLev1_0100,  /* BF900..BF9FF */
+  BidLev1_0100,  /* BFA00..BFAFF */
+  BidLev1_0100,  /* BFB00..BFBFF */
+  BidLev1_0100,  /* BFC00..BFCFF */
+  BidLev1_0100,  /* BFD00..BFDFF */
+  BidLev1_0100,  /* BFE00..BFEFF */
+  BidLev1_1FF00,  /* BFF00..BFFFF */
+  BidLev1_0100,  /* C0000..C00FF */
+  BidLev1_0100,  /* C0100..C01FF */
+  BidLev1_0100,  /* C0200..C02FF */
+  BidLev1_0100,  /* C0300..C03FF */
+  BidLev1_0100,  /* C0400..C04FF */
+  BidLev1_0100,  /* C0500..C05FF */
+  BidLev1_0100,  /* C0600..C06FF */
+  BidLev1_0100,  /* C0700..C07FF */
+  BidLev1_0100,  /* C0800..C08FF */
+  BidLev1_0100,  /* C0900..C09FF */
+  BidLev1_0100,  /* C0A00..C0AFF */
+  BidLev1_0100,  /* C0B00..C0BFF */
+  BidLev1_0100,  /* C0C00..C0CFF */
+  BidLev1_0100,  /* C0D00..C0DFF */
+  BidLev1_0100,  /* C0E00..C0EFF */
+  BidLev1_0100,  /* C0F00..C0FFF */
+  BidLev1_0100,  /* C1000..C10FF */
+  BidLev1_0100,  /* C1100..C11FF */
+  BidLev1_0100,  /* C1200..C12FF */
+  BidLev1_0100,  /* C1300..C13FF */
+  BidLev1_0100,  /* C1400..C14FF */
+  BidLev1_0100,  /* C1500..C15FF */
+  BidLev1_0100,  /* C1600..C16FF */
+  BidLev1_0100,  /* C1700..C17FF */
+  BidLev1_0100,  /* C1800..C18FF */
+  BidLev1_0100,  /* C1900..C19FF */
+  BidLev1_0100,  /* C1A00..C1AFF */
+  BidLev1_0100,  /* C1B00..C1BFF */
+  BidLev1_0100,  /* C1C00..C1CFF */
+  BidLev1_0100,  /* C1D00..C1DFF */
+  BidLev1_0100,  /* C1E00..C1EFF */
+  BidLev1_0100,  /* C1F00..C1FFF */
+  BidLev1_0100,  /* C2000..C20FF */
+  BidLev1_0100,  /* C2100..C21FF */
+  BidLev1_0100,  /* C2200..C22FF */
+  BidLev1_0100,  /* C2300..C23FF */
+  BidLev1_0100,  /* C2400..C24FF */
+  BidLev1_0100,  /* C2500..C25FF */
+  BidLev1_0100,  /* C2600..C26FF */
+  BidLev1_0100,  /* C2700..C27FF */
+  BidLev1_0100,  /* C2800..C28FF */
+  BidLev1_0100,  /* C2900..C29FF */
+  BidLev1_0100,  /* C2A00..C2AFF */
+  BidLev1_0100,  /* C2B00..C2BFF */
+  BidLev1_0100,  /* C2C00..C2CFF */
+  BidLev1_0100,  /* C2D00..C2DFF */
+  BidLev1_0100,  /* C2E00..C2EFF */
+  BidLev1_0100,  /* C2F00..C2FFF */
+  BidLev1_0100,  /* C3000..C30FF */
+  BidLev1_0100,  /* C3100..C31FF */
+  BidLev1_0100,  /* C3200..C32FF */
+  BidLev1_0100,  /* C3300..C33FF */
+  BidLev1_0100,  /* C3400..C34FF */
+  BidLev1_0100,  /* C3500..C35FF */
+  BidLev1_0100,  /* C3600..C36FF */
+  BidLev1_0100,  /* C3700..C37FF */
+  BidLev1_0100,  /* C3800..C38FF */
+  BidLev1_0100,  /* C3900..C39FF */
+  BidLev1_0100,  /* C3A00..C3AFF */
+  BidLev1_0100,  /* C3B00..C3BFF */
+  BidLev1_0100,  /* C3C00..C3CFF */
+  BidLev1_0100,  /* C3D00..C3DFF */
+  BidLev1_0100,  /* C3E00..C3EFF */
+  BidLev1_0100,  /* C3F00..C3FFF */
+  BidLev1_0100,  /* C4000..C40FF */
+  BidLev1_0100,  /* C4100..C41FF */
+  BidLev1_0100,  /* C4200..C42FF */
+  BidLev1_0100,  /* C4300..C43FF */
+  BidLev1_0100,  /* C4400..C44FF */
+  BidLev1_0100,  /* C4500..C45FF */
+  BidLev1_0100,  /* C4600..C46FF */
+  BidLev1_0100,  /* C4700..C47FF */
+  BidLev1_0100,  /* C4800..C48FF */
+  BidLev1_0100,  /* C4900..C49FF */
+  BidLev1_0100,  /* C4A00..C4AFF */
+  BidLev1_0100,  /* C4B00..C4BFF */
+  BidLev1_0100,  /* C4C00..C4CFF */
+  BidLev1_0100,  /* C4D00..C4DFF */
+  BidLev1_0100,  /* C4E00..C4EFF */
+  BidLev1_0100,  /* C4F00..C4FFF */
+  BidLev1_0100,  /* C5000..C50FF */
+  BidLev1_0100,  /* C5100..C51FF */
+  BidLev1_0100,  /* C5200..C52FF */
+  BidLev1_0100,  /* C5300..C53FF */
+  BidLev1_0100,  /* C5400..C54FF */
+  BidLev1_0100,  /* C5500..C55FF */
+  BidLev1_0100,  /* C5600..C56FF */
+  BidLev1_0100,  /* C5700..C57FF */
+  BidLev1_0100,  /* C5800..C58FF */
+  BidLev1_0100,  /* C5900..C59FF */
+  BidLev1_0100,  /* C5A00..C5AFF */
+  BidLev1_0100,  /* C5B00..C5BFF */
+  BidLev1_0100,  /* C5C00..C5CFF */
+  BidLev1_0100,  /* C5D00..C5DFF */
+  BidLev1_0100,  /* C5E00..C5EFF */
+  BidLev1_0100,  /* C5F00..C5FFF */
+  BidLev1_0100,  /* C6000..C60FF */
+  BidLev1_0100,  /* C6100..C61FF */
+  BidLev1_0100,  /* C6200..C62FF */
+  BidLev1_0100,  /* C6300..C63FF */
+  BidLev1_0100,  /* C6400..C64FF */
+  BidLev1_0100,  /* C6500..C65FF */
+  BidLev1_0100,  /* C6600..C66FF */
+  BidLev1_0100,  /* C6700..C67FF */
+  BidLev1_0100,  /* C6800..C68FF */
+  BidLev1_0100,  /* C6900..C69FF */
+  BidLev1_0100,  /* C6A00..C6AFF */
+  BidLev1_0100,  /* C6B00..C6BFF */
+  BidLev1_0100,  /* C6C00..C6CFF */
+  BidLev1_0100,  /* C6D00..C6DFF */
+  BidLev1_0100,  /* C6E00..C6EFF */
+  BidLev1_0100,  /* C6F00..C6FFF */
+  BidLev1_0100,  /* C7000..C70FF */
+  BidLev1_0100,  /* C7100..C71FF */
+  BidLev1_0100,  /* C7200..C72FF */
+  BidLev1_0100,  /* C7300..C73FF */
+  BidLev1_0100,  /* C7400..C74FF */
+  BidLev1_0100,  /* C7500..C75FF */
+  BidLev1_0100,  /* C7600..C76FF */
+  BidLev1_0100,  /* C7700..C77FF */
+  BidLev1_0100,  /* C7800..C78FF */
+  BidLev1_0100,  /* C7900..C79FF */
+  BidLev1_0100,  /* C7A00..C7AFF */
+  BidLev1_0100,  /* C7B00..C7BFF */
+  BidLev1_0100,  /* C7C00..C7CFF */
+  BidLev1_0100,  /* C7D00..C7DFF */
+  BidLev1_0100,  /* C7E00..C7EFF */
+  BidLev1_0100,  /* C7F00..C7FFF */
+  BidLev1_0100,  /* C8000..C80FF */
+  BidLev1_0100,  /* C8100..C81FF */
+  BidLev1_0100,  /* C8200..C82FF */
+  BidLev1_0100,  /* C8300..C83FF */
+  BidLev1_0100,  /* C8400..C84FF */
+  BidLev1_0100,  /* C8500..C85FF */
+  BidLev1_0100,  /* C8600..C86FF */
+  BidLev1_0100,  /* C8700..C87FF */
+  BidLev1_0100,  /* C8800..C88FF */
+  BidLev1_0100,  /* C8900..C89FF */
+  BidLev1_0100,  /* C8A00..C8AFF */
+  BidLev1_0100,  /* C8B00..C8BFF */
+  BidLev1_0100,  /* C8C00..C8CFF */
+  BidLev1_0100,  /* C8D00..C8DFF */
+  BidLev1_0100,  /* C8E00..C8EFF */
+  BidLev1_0100,  /* C8F00..C8FFF */
+  BidLev1_0100,  /* C9000..C90FF */
+  BidLev1_0100,  /* C9100..C91FF */
+  BidLev1_0100,  /* C9200..C92FF */
+  BidLev1_0100,  /* C9300..C93FF */
+  BidLev1_0100,  /* C9400..C94FF */
+  BidLev1_0100,  /* C9500..C95FF */
+  BidLev1_0100,  /* C9600..C96FF */
+  BidLev1_0100,  /* C9700..C97FF */
+  BidLev1_0100,  /* C9800..C98FF */
+  BidLev1_0100,  /* C9900..C99FF */
+  BidLev1_0100,  /* C9A00..C9AFF */
+  BidLev1_0100,  /* C9B00..C9BFF */
+  BidLev1_0100,  /* C9C00..C9CFF */
+  BidLev1_0100,  /* C9D00..C9DFF */
+  BidLev1_0100,  /* C9E00..C9EFF */
+  BidLev1_0100,  /* C9F00..C9FFF */
+  BidLev1_0100,  /* CA000..CA0FF */
+  BidLev1_0100,  /* CA100..CA1FF */
+  BidLev1_0100,  /* CA200..CA2FF */
+  BidLev1_0100,  /* CA300..CA3FF */
+  BidLev1_0100,  /* CA400..CA4FF */
+  BidLev1_0100,  /* CA500..CA5FF */
+  BidLev1_0100,  /* CA600..CA6FF */
+  BidLev1_0100,  /* CA700..CA7FF */
+  BidLev1_0100,  /* CA800..CA8FF */
+  BidLev1_0100,  /* CA900..CA9FF */
+  BidLev1_0100,  /* CAA00..CAAFF */
+  BidLev1_0100,  /* CAB00..CABFF */
+  BidLev1_0100,  /* CAC00..CACFF */
+  BidLev1_0100,  /* CAD00..CADFF */
+  BidLev1_0100,  /* CAE00..CAEFF */
+  BidLev1_0100,  /* CAF00..CAFFF */
+  BidLev1_0100,  /* CB000..CB0FF */
+  BidLev1_0100,  /* CB100..CB1FF */
+  BidLev1_0100,  /* CB200..CB2FF */
+  BidLev1_0100,  /* CB300..CB3FF */
+  BidLev1_0100,  /* CB400..CB4FF */
+  BidLev1_0100,  /* CB500..CB5FF */
+  BidLev1_0100,  /* CB600..CB6FF */
+  BidLev1_0100,  /* CB700..CB7FF */
+  BidLev1_0100,  /* CB800..CB8FF */
+  BidLev1_0100,  /* CB900..CB9FF */
+  BidLev1_0100,  /* CBA00..CBAFF */
+  BidLev1_0100,  /* CBB00..CBBFF */
+  BidLev1_0100,  /* CBC00..CBCFF */
+  BidLev1_0100,  /* CBD00..CBDFF */
+  BidLev1_0100,  /* CBE00..CBEFF */
+  BidLev1_0100,  /* CBF00..CBFFF */
+  BidLev1_0100,  /* CC000..CC0FF */
+  BidLev1_0100,  /* CC100..CC1FF */
+  BidLev1_0100,  /* CC200..CC2FF */
+  BidLev1_0100,  /* CC300..CC3FF */
+  BidLev1_0100,  /* CC400..CC4FF */
+  BidLev1_0100,  /* CC500..CC5FF */
+  BidLev1_0100,  /* CC600..CC6FF */
+  BidLev1_0100,  /* CC700..CC7FF */
+  BidLev1_0100,  /* CC800..CC8FF */
+  BidLev1_0100,  /* CC900..CC9FF */
+  BidLev1_0100,  /* CCA00..CCAFF */
+  BidLev1_0100,  /* CCB00..CCBFF */
+  BidLev1_0100,  /* CCC00..CCCFF */
+  BidLev1_0100,  /* CCD00..CCDFF */
+  BidLev1_0100,  /* CCE00..CCEFF */
+  BidLev1_0100,  /* CCF00..CCFFF */
+  BidLev1_0100,  /* CD000..CD0FF */
+  BidLev1_0100,  /* CD100..CD1FF */
+  BidLev1_0100,  /* CD200..CD2FF */
+  BidLev1_0100,  /* CD300..CD3FF */
+  BidLev1_0100,  /* CD400..CD4FF */
+  BidLev1_0100,  /* CD500..CD5FF */
+  BidLev1_0100,  /* CD600..CD6FF */
+  BidLev1_0100,  /* CD700..CD7FF */
+  BidLev1_0100,  /* CD800..CD8FF */
+  BidLev1_0100,  /* CD900..CD9FF */
+  BidLev1_0100,  /* CDA00..CDAFF */
+  BidLev1_0100,  /* CDB00..CDBFF */
+  BidLev1_0100,  /* CDC00..CDCFF */
+  BidLev1_0100,  /* CDD00..CDDFF */
+  BidLev1_0100,  /* CDE00..CDEFF */
+  BidLev1_0100,  /* CDF00..CDFFF */
+  BidLev1_0100,  /* CE000..CE0FF */
+  BidLev1_0100,  /* CE100..CE1FF */
+  BidLev1_0100,  /* CE200..CE2FF */
+  BidLev1_0100,  /* CE300..CE3FF */
+  BidLev1_0100,  /* CE400..CE4FF */
+  BidLev1_0100,  /* CE500..CE5FF */
+  BidLev1_0100,  /* CE600..CE6FF */
+  BidLev1_0100,  /* CE700..CE7FF */
+  BidLev1_0100,  /* CE800..CE8FF */
+  BidLev1_0100,  /* CE900..CE9FF */
+  BidLev1_0100,  /* CEA00..CEAFF */
+  BidLev1_0100,  /* CEB00..CEBFF */
+  BidLev1_0100,  /* CEC00..CECFF */
+  BidLev1_0100,  /* CED00..CEDFF */
+  BidLev1_0100,  /* CEE00..CEEFF */
+  BidLev1_0100,  /* CEF00..CEFFF */
+  BidLev1_0100,  /* CF000..CF0FF */
+  BidLev1_0100,  /* CF100..CF1FF */
+  BidLev1_0100,  /* CF200..CF2FF */
+  BidLev1_0100,  /* CF300..CF3FF */
+  BidLev1_0100,  /* CF400..CF4FF */
+  BidLev1_0100,  /* CF500..CF5FF */
+  BidLev1_0100,  /* CF600..CF6FF */
+  BidLev1_0100,  /* CF700..CF7FF */
+  BidLev1_0100,  /* CF800..CF8FF */
+  BidLev1_0100,  /* CF900..CF9FF */
+  BidLev1_0100,  /* CFA00..CFAFF */
+  BidLev1_0100,  /* CFB00..CFBFF */
+  BidLev1_0100,  /* CFC00..CFCFF */
+  BidLev1_0100,  /* CFD00..CFDFF */
+  BidLev1_0100,  /* CFE00..CFEFF */
+  BidLev1_1FF00,  /* CFF00..CFFFF */
+  BidLev1_0100,  /* D0000..D00FF */
+  BidLev1_0100,  /* D0100..D01FF */
+  BidLev1_0100,  /* D0200..D02FF */
+  BidLev1_0100,  /* D0300..D03FF */
+  BidLev1_0100,  /* D0400..D04FF */
+  BidLev1_0100,  /* D0500..D05FF */
+  BidLev1_0100,  /* D0600..D06FF */
+  BidLev1_0100,  /* D0700..D07FF */
+  BidLev1_0100,  /* D0800..D08FF */
+  BidLev1_0100,  /* D0900..D09FF */
+  BidLev1_0100,  /* D0A00..D0AFF */
+  BidLev1_0100,  /* D0B00..D0BFF */
+  BidLev1_0100,  /* D0C00..D0CFF */
+  BidLev1_0100,  /* D0D00..D0DFF */
+  BidLev1_0100,  /* D0E00..D0EFF */
+  BidLev1_0100,  /* D0F00..D0FFF */
+  BidLev1_0100,  /* D1000..D10FF */
+  BidLev1_0100,  /* D1100..D11FF */
+  BidLev1_0100,  /* D1200..D12FF */
+  BidLev1_0100,  /* D1300..D13FF */
+  BidLev1_0100,  /* D1400..D14FF */
+  BidLev1_0100,  /* D1500..D15FF */
+  BidLev1_0100,  /* D1600..D16FF */
+  BidLev1_0100,  /* D1700..D17FF */
+  BidLev1_0100,  /* D1800..D18FF */
+  BidLev1_0100,  /* D1900..D19FF */
+  BidLev1_0100,  /* D1A00..D1AFF */
+  BidLev1_0100,  /* D1B00..D1BFF */
+  BidLev1_0100,  /* D1C00..D1CFF */
+  BidLev1_0100,  /* D1D00..D1DFF */
+  BidLev1_0100,  /* D1E00..D1EFF */
+  BidLev1_0100,  /* D1F00..D1FFF */
+  BidLev1_0100,  /* D2000..D20FF */
+  BidLev1_0100,  /* D2100..D21FF */
+  BidLev1_0100,  /* D2200..D22FF */
+  BidLev1_0100,  /* D2300..D23FF */
+  BidLev1_0100,  /* D2400..D24FF */
+  BidLev1_0100,  /* D2500..D25FF */
+  BidLev1_0100,  /* D2600..D26FF */
+  BidLev1_0100,  /* D2700..D27FF */
+  BidLev1_0100,  /* D2800..D28FF */
+  BidLev1_0100,  /* D2900..D29FF */
+  BidLev1_0100,  /* D2A00..D2AFF */
+  BidLev1_0100,  /* D2B00..D2BFF */
+  BidLev1_0100,  /* D2C00..D2CFF */
+  BidLev1_0100,  /* D2D00..D2DFF */
+  BidLev1_0100,  /* D2E00..D2EFF */
+  BidLev1_0100,  /* D2F00..D2FFF */
+  BidLev1_0100,  /* D3000..D30FF */
+  BidLev1_0100,  /* D3100..D31FF */
+  BidLev1_0100,  /* D3200..D32FF */
+  BidLev1_0100,  /* D3300..D33FF */
+  BidLev1_0100,  /* D3400..D34FF */
+  BidLev1_0100,  /* D3500..D35FF */
+  BidLev1_0100,  /* D3600..D36FF */
+  BidLev1_0100,  /* D3700..D37FF */
+  BidLev1_0100,  /* D3800..D38FF */
+  BidLev1_0100,  /* D3900..D39FF */
+  BidLev1_0100,  /* D3A00..D3AFF */
+  BidLev1_0100,  /* D3B00..D3BFF */
+  BidLev1_0100,  /* D3C00..D3CFF */
+  BidLev1_0100,  /* D3D00..D3DFF */
+  BidLev1_0100,  /* D3E00..D3EFF */
+  BidLev1_0100,  /* D3F00..D3FFF */
+  BidLev1_0100,  /* D4000..D40FF */
+  BidLev1_0100,  /* D4100..D41FF */
+  BidLev1_0100,  /* D4200..D42FF */
+  BidLev1_0100,  /* D4300..D43FF */
+  BidLev1_0100,  /* D4400..D44FF */
+  BidLev1_0100,  /* D4500..D45FF */
+  BidLev1_0100,  /* D4600..D46FF */
+  BidLev1_0100,  /* D4700..D47FF */
+  BidLev1_0100,  /* D4800..D48FF */
+  BidLev1_0100,  /* D4900..D49FF */
+  BidLev1_0100,  /* D4A00..D4AFF */
+  BidLev1_0100,  /* D4B00..D4BFF */
+  BidLev1_0100,  /* D4C00..D4CFF */
+  BidLev1_0100,  /* D4D00..D4DFF */
+  BidLev1_0100,  /* D4E00..D4EFF */
+  BidLev1_0100,  /* D4F00..D4FFF */
+  BidLev1_0100,  /* D5000..D50FF */
+  BidLev1_0100,  /* D5100..D51FF */
+  BidLev1_0100,  /* D5200..D52FF */
+  BidLev1_0100,  /* D5300..D53FF */
+  BidLev1_0100,  /* D5400..D54FF */
+  BidLev1_0100,  /* D5500..D55FF */
+  BidLev1_0100,  /* D5600..D56FF */
+  BidLev1_0100,  /* D5700..D57FF */
+  BidLev1_0100,  /* D5800..D58FF */
+  BidLev1_0100,  /* D5900..D59FF */
+  BidLev1_0100,  /* D5A00..D5AFF */
+  BidLev1_0100,  /* D5B00..D5BFF */
+  BidLev1_0100,  /* D5C00..D5CFF */
+  BidLev1_0100,  /* D5D00..D5DFF */
+  BidLev1_0100,  /* D5E00..D5EFF */
+  BidLev1_0100,  /* D5F00..D5FFF */
+  BidLev1_0100,  /* D6000..D60FF */
+  BidLev1_0100,  /* D6100..D61FF */
+  BidLev1_0100,  /* D6200..D62FF */
+  BidLev1_0100,  /* D6300..D63FF */
+  BidLev1_0100,  /* D6400..D64FF */
+  BidLev1_0100,  /* D6500..D65FF */
+  BidLev1_0100,  /* D6600..D66FF */
+  BidLev1_0100,  /* D6700..D67FF */
+  BidLev1_0100,  /* D6800..D68FF */
+  BidLev1_0100,  /* D6900..D69FF */
+  BidLev1_0100,  /* D6A00..D6AFF */
+  BidLev1_0100,  /* D6B00..D6BFF */
+  BidLev1_0100,  /* D6C00..D6CFF */
+  BidLev1_0100,  /* D6D00..D6DFF */
+  BidLev1_0100,  /* D6E00..D6EFF */
+  BidLev1_0100,  /* D6F00..D6FFF */
+  BidLev1_0100,  /* D7000..D70FF */
+  BidLev1_0100,  /* D7100..D71FF */
+  BidLev1_0100,  /* D7200..D72FF */
+  BidLev1_0100,  /* D7300..D73FF */
+  BidLev1_0100,  /* D7400..D74FF */
+  BidLev1_0100,  /* D7500..D75FF */
+  BidLev1_0100,  /* D7600..D76FF */
+  BidLev1_0100,  /* D7700..D77FF */
+  BidLev1_0100,  /* D7800..D78FF */
+  BidLev1_0100,  /* D7900..D79FF */
+  BidLev1_0100,  /* D7A00..D7AFF */
+  BidLev1_0100,  /* D7B00..D7BFF */
+  BidLev1_0100,  /* D7C00..D7CFF */
+  BidLev1_0100,  /* D7D00..D7DFF */
+  BidLev1_0100,  /* D7E00..D7EFF */
+  BidLev1_0100,  /* D7F00..D7FFF */
+  BidLev1_0100,  /* D8000..D80FF */
+  BidLev1_0100,  /* D8100..D81FF */
+  BidLev1_0100,  /* D8200..D82FF */
+  BidLev1_0100,  /* D8300..D83FF */
+  BidLev1_0100,  /* D8400..D84FF */
+  BidLev1_0100,  /* D8500..D85FF */
+  BidLev1_0100,  /* D8600..D86FF */
+  BidLev1_0100,  /* D8700..D87FF */
+  BidLev1_0100,  /* D8800..D88FF */
+  BidLev1_0100,  /* D8900..D89FF */
+  BidLev1_0100,  /* D8A00..D8AFF */
+  BidLev1_0100,  /* D8B00..D8BFF */
+  BidLev1_0100,  /* D8C00..D8CFF */
+  BidLev1_0100,  /* D8D00..D8DFF */
+  BidLev1_0100,  /* D8E00..D8EFF */
+  BidLev1_0100,  /* D8F00..D8FFF */
+  BidLev1_0100,  /* D9000..D90FF */
+  BidLev1_0100,  /* D9100..D91FF */
+  BidLev1_0100,  /* D9200..D92FF */
+  BidLev1_0100,  /* D9300..D93FF */
+  BidLev1_0100,  /* D9400..D94FF */
+  BidLev1_0100,  /* D9500..D95FF */
+  BidLev1_0100,  /* D9600..D96FF */
+  BidLev1_0100,  /* D9700..D97FF */
+  BidLev1_0100,  /* D9800..D98FF */
+  BidLev1_0100,  /* D9900..D99FF */
+  BidLev1_0100,  /* D9A00..D9AFF */
+  BidLev1_0100,  /* D9B00..D9BFF */
+  BidLev1_0100,  /* D9C00..D9CFF */
+  BidLev1_0100,  /* D9D00..D9DFF */
+  BidLev1_0100,  /* D9E00..D9EFF */
+  BidLev1_0100,  /* D9F00..D9FFF */
+  BidLev1_0100,  /* DA000..DA0FF */
+  BidLev1_0100,  /* DA100..DA1FF */
+  BidLev1_0100,  /* DA200..DA2FF */
+  BidLev1_0100,  /* DA300..DA3FF */
+  BidLev1_0100,  /* DA400..DA4FF */
+  BidLev1_0100,  /* DA500..DA5FF */
+  BidLev1_0100,  /* DA600..DA6FF */
+  BidLev1_0100,  /* DA700..DA7FF */
+  BidLev1_0100,  /* DA800..DA8FF */
+  BidLev1_0100,  /* DA900..DA9FF */
+  BidLev1_0100,  /* DAA00..DAAFF */
+  BidLev1_0100,  /* DAB00..DABFF */
+  BidLev1_0100,  /* DAC00..DACFF */
+  BidLev1_0100,  /* DAD00..DADFF */
+  BidLev1_0100,  /* DAE00..DAEFF */
+  BidLev1_0100,  /* DAF00..DAFFF */
+  BidLev1_0100,  /* DB000..DB0FF */
+  BidLev1_0100,  /* DB100..DB1FF */
+  BidLev1_0100,  /* DB200..DB2FF */
+  BidLev1_0100,  /* DB300..DB3FF */
+  BidLev1_0100,  /* DB400..DB4FF */
+  BidLev1_0100,  /* DB500..DB5FF */
+  BidLev1_0100,  /* DB600..DB6FF */
+  BidLev1_0100,  /* DB700..DB7FF */
+  BidLev1_0100,  /* DB800..DB8FF */
+  BidLev1_0100,  /* DB900..DB9FF */
+  BidLev1_0100,  /* DBA00..DBAFF */
+  BidLev1_0100,  /* DBB00..DBBFF */
+  BidLev1_0100,  /* DBC00..DBCFF */
+  BidLev1_0100,  /* DBD00..DBDFF */
+  BidLev1_0100,  /* DBE00..DBEFF */
+  BidLev1_0100,  /* DBF00..DBFFF */
+  BidLev1_0100,  /* DC000..DC0FF */
+  BidLev1_0100,  /* DC100..DC1FF */
+  BidLev1_0100,  /* DC200..DC2FF */
+  BidLev1_0100,  /* DC300..DC3FF */
+  BidLev1_0100,  /* DC400..DC4FF */
+  BidLev1_0100,  /* DC500..DC5FF */
+  BidLev1_0100,  /* DC600..DC6FF */
+  BidLev1_0100,  /* DC700..DC7FF */
+  BidLev1_0100,  /* DC800..DC8FF */
+  BidLev1_0100,  /* DC900..DC9FF */
+  BidLev1_0100,  /* DCA00..DCAFF */
+  BidLev1_0100,  /* DCB00..DCBFF */
+  BidLev1_0100,  /* DCC00..DCCFF */
+  BidLev1_0100,  /* DCD00..DCDFF */
+  BidLev1_0100,  /* DCE00..DCEFF */
+  BidLev1_0100,  /* DCF00..DCFFF */
+  BidLev1_0100,  /* DD000..DD0FF */
+  BidLev1_0100,  /* DD100..DD1FF */
+  BidLev1_0100,  /* DD200..DD2FF */
+  BidLev1_0100,  /* DD300..DD3FF */
+  BidLev1_0100,  /* DD400..DD4FF */
+  BidLev1_0100,  /* DD500..DD5FF */
+  BidLev1_0100,  /* DD600..DD6FF */
+  BidLev1_0100,  /* DD700..DD7FF */
+  BidLev1_0100,  /* DD800..DD8FF */
+  BidLev1_0100,  /* DD900..DD9FF */
+  BidLev1_0100,  /* DDA00..DDAFF */
+  BidLev1_0100,  /* DDB00..DDBFF */
+  BidLev1_0100,  /* DDC00..DDCFF */
+  BidLev1_0100,  /* DDD00..DDDFF */
+  BidLev1_0100,  /* DDE00..DDEFF */
+  BidLev1_0100,  /* DDF00..DDFFF */
+  BidLev1_0100,  /* DE000..DE0FF */
+  BidLev1_0100,  /* DE100..DE1FF */
+  BidLev1_0100,  /* DE200..DE2FF */
+  BidLev1_0100,  /* DE300..DE3FF */
+  BidLev1_0100,  /* DE400..DE4FF */
+  BidLev1_0100,  /* DE500..DE5FF */
+  BidLev1_0100,  /* DE600..DE6FF */
+  BidLev1_0100,  /* DE700..DE7FF */
+  BidLev1_0100,  /* DE800..DE8FF */
+  BidLev1_0100,  /* DE900..DE9FF */
+  BidLev1_0100,  /* DEA00..DEAFF */
+  BidLev1_0100,  /* DEB00..DEBFF */
+  BidLev1_0100,  /* DEC00..DECFF */
+  BidLev1_0100,  /* DED00..DEDFF */
+  BidLev1_0100,  /* DEE00..DEEFF */
+  BidLev1_0100,  /* DEF00..DEFFF */
+  BidLev1_0100,  /* DF000..DF0FF */
+  BidLev1_0100,  /* DF100..DF1FF */
+  BidLev1_0100,  /* DF200..DF2FF */
+  BidLev1_0100,  /* DF300..DF3FF */
+  BidLev1_0100,  /* DF400..DF4FF */
+  BidLev1_0100,  /* DF500..DF5FF */
+  BidLev1_0100,  /* DF600..DF6FF */
+  BidLev1_0100,  /* DF700..DF7FF */
+  BidLev1_0100,  /* DF800..DF8FF */
+  BidLev1_0100,  /* DF900..DF9FF */
+  BidLev1_0100,  /* DFA00..DFAFF */
+  BidLev1_0100,  /* DFB00..DFBFF */
+  BidLev1_0100,  /* DFC00..DFCFF */
+  BidLev1_0100,  /* DFD00..DFDFF */
+  BidLev1_0100,  /* DFE00..DFEFF */
+  BidLev1_1FF00,  /* DFF00..DFFFF */
+  BidLev1_E0000,  /* E0000..E00FF */
+  BidLev1_E0100,  /* E0100..E01FF */
+  BidLev1_E0000,  /* E0200..E02FF */
+  BidLev1_E0000,  /* E0300..E03FF */
+  BidLev1_E0000,  /* E0400..E04FF */
+  BidLev1_E0000,  /* E0500..E05FF */
+  BidLev1_E0000,  /* E0600..E06FF */
+  BidLev1_E0000,  /* E0700..E07FF */
+  BidLev1_E0000,  /* E0800..E08FF */
+  BidLev1_E0000,  /* E0900..E09FF */
+  BidLev1_E0000,  /* E0A00..E0AFF */
+  BidLev1_E0000,  /* E0B00..E0BFF */
+  BidLev1_E0000,  /* E0C00..E0CFF */
+  BidLev1_E0000,  /* E0D00..E0DFF */
+  BidLev1_E0000,  /* E0E00..E0EFF */
+  BidLev1_E0000,  /* E0F00..E0FFF */
+  BidLev1_0100,  /* E1000..E10FF */
+  BidLev1_0100,  /* E1100..E11FF */
+  BidLev1_0100,  /* E1200..E12FF */
+  BidLev1_0100,  /* E1300..E13FF */
+  BidLev1_0100,  /* E1400..E14FF */
+  BidLev1_0100,  /* E1500..E15FF */
+  BidLev1_0100,  /* E1600..E16FF */
+  BidLev1_0100,  /* E1700..E17FF */
+  BidLev1_0100,  /* E1800..E18FF */
+  BidLev1_0100,  /* E1900..E19FF */
+  BidLev1_0100,  /* E1A00..E1AFF */
+  BidLev1_0100,  /* E1B00..E1BFF */
+  BidLev1_0100,  /* E1C00..E1CFF */
+  BidLev1_0100,  /* E1D00..E1DFF */
+  BidLev1_0100,  /* E1E00..E1EFF */
+  BidLev1_0100,  /* E1F00..E1FFF */
+  BidLev1_0100,  /* E2000..E20FF */
+  BidLev1_0100,  /* E2100..E21FF */
+  BidLev1_0100,  /* E2200..E22FF */
+  BidLev1_0100,  /* E2300..E23FF */
+  BidLev1_0100,  /* E2400..E24FF */
+  BidLev1_0100,  /* E2500..E25FF */
+  BidLev1_0100,  /* E2600..E26FF */
+  BidLev1_0100,  /* E2700..E27FF */
+  BidLev1_0100,  /* E2800..E28FF */
+  BidLev1_0100,  /* E2900..E29FF */
+  BidLev1_0100,  /* E2A00..E2AFF */
+  BidLev1_0100,  /* E2B00..E2BFF */
+  BidLev1_0100,  /* E2C00..E2CFF */
+  BidLev1_0100,  /* E2D00..E2DFF */
+  BidLev1_0100,  /* E2E00..E2EFF */
+  BidLev1_0100,  /* E2F00..E2FFF */
+  BidLev1_0100,  /* E3000..E30FF */
+  BidLev1_0100,  /* E3100..E31FF */
+  BidLev1_0100,  /* E3200..E32FF */
+  BidLev1_0100,  /* E3300..E33FF */
+  BidLev1_0100,  /* E3400..E34FF */
+  BidLev1_0100,  /* E3500..E35FF */
+  BidLev1_0100,  /* E3600..E36FF */
+  BidLev1_0100,  /* E3700..E37FF */
+  BidLev1_0100,  /* E3800..E38FF */
+  BidLev1_0100,  /* E3900..E39FF */
+  BidLev1_0100,  /* E3A00..E3AFF */
+  BidLev1_0100,  /* E3B00..E3BFF */
+  BidLev1_0100,  /* E3C00..E3CFF */
+  BidLev1_0100,  /* E3D00..E3DFF */
+  BidLev1_0100,  /* E3E00..E3EFF */
+  BidLev1_0100,  /* E3F00..E3FFF */
+  BidLev1_0100,  /* E4000..E40FF */
+  BidLev1_0100,  /* E4100..E41FF */
+  BidLev1_0100,  /* E4200..E42FF */
+  BidLev1_0100,  /* E4300..E43FF */
+  BidLev1_0100,  /* E4400..E44FF */
+  BidLev1_0100,  /* E4500..E45FF */
+  BidLev1_0100,  /* E4600..E46FF */
+  BidLev1_0100,  /* E4700..E47FF */
+  BidLev1_0100,  /* E4800..E48FF */
+  BidLev1_0100,  /* E4900..E49FF */
+  BidLev1_0100,  /* E4A00..E4AFF */
+  BidLev1_0100,  /* E4B00..E4BFF */
+  BidLev1_0100,  /* E4C00..E4CFF */
+  BidLev1_0100,  /* E4D00..E4DFF */
+  BidLev1_0100,  /* E4E00..E4EFF */
+  BidLev1_0100,  /* E4F00..E4FFF */
+  BidLev1_0100,  /* E5000..E50FF */
+  BidLev1_0100,  /* E5100..E51FF */
+  BidLev1_0100,  /* E5200..E52FF */
+  BidLev1_0100,  /* E5300..E53FF */
+  BidLev1_0100,  /* E5400..E54FF */
+  BidLev1_0100,  /* E5500..E55FF */
+  BidLev1_0100,  /* E5600..E56FF */
+  BidLev1_0100,  /* E5700..E57FF */
+  BidLev1_0100,  /* E5800..E58FF */
+  BidLev1_0100,  /* E5900..E59FF */
+  BidLev1_0100,  /* E5A00..E5AFF */
+  BidLev1_0100,  /* E5B00..E5BFF */
+  BidLev1_0100,  /* E5C00..E5CFF */
+  BidLev1_0100,  /* E5D00..E5DFF */
+  BidLev1_0100,  /* E5E00..E5EFF */
+  BidLev1_0100,  /* E5F00..E5FFF */
+  BidLev1_0100,  /* E6000..E60FF */
+  BidLev1_0100,  /* E6100..E61FF */
+  BidLev1_0100,  /* E6200..E62FF */
+  BidLev1_0100,  /* E6300..E63FF */
+  BidLev1_0100,  /* E6400..E64FF */
+  BidLev1_0100,  /* E6500..E65FF */
+  BidLev1_0100,  /* E6600..E66FF */
+  BidLev1_0100,  /* E6700..E67FF */
+  BidLev1_0100,  /* E6800..E68FF */
+  BidLev1_0100,  /* E6900..E69FF */
+  BidLev1_0100,  /* E6A00..E6AFF */
+  BidLev1_0100,  /* E6B00..E6BFF */
+  BidLev1_0100,  /* E6C00..E6CFF */
+  BidLev1_0100,  /* E6D00..E6DFF */
+  BidLev1_0100,  /* E6E00..E6EFF */
+  BidLev1_0100,  /* E6F00..E6FFF */
+  BidLev1_0100,  /* E7000..E70FF */
+  BidLev1_0100,  /* E7100..E71FF */
+  BidLev1_0100,  /* E7200..E72FF */
+  BidLev1_0100,  /* E7300..E73FF */
+  BidLev1_0100,  /* E7400..E74FF */
+  BidLev1_0100,  /* E7500..E75FF */
+  BidLev1_0100,  /* E7600..E76FF */
+  BidLev1_0100,  /* E7700..E77FF */
+  BidLev1_0100,  /* E7800..E78FF */
+  BidLev1_0100,  /* E7900..E79FF */
+  BidLev1_0100,  /* E7A00..E7AFF */
+  BidLev1_0100,  /* E7B00..E7BFF */
+  BidLev1_0100,  /* E7C00..E7CFF */
+  BidLev1_0100,  /* E7D00..E7DFF */
+  BidLev1_0100,  /* E7E00..E7EFF */
+  BidLev1_0100,  /* E7F00..E7FFF */
+  BidLev1_0100,  /* E8000..E80FF */
+  BidLev1_0100,  /* E8100..E81FF */
+  BidLev1_0100,  /* E8200..E82FF */
+  BidLev1_0100,  /* E8300..E83FF */
+  BidLev1_0100,  /* E8400..E84FF */
+  BidLev1_0100,  /* E8500..E85FF */
+  BidLev1_0100,  /* E8600..E86FF */
+  BidLev1_0100,  /* E8700..E87FF */
+  BidLev1_0100,  /* E8800..E88FF */
+  BidLev1_0100,  /* E8900..E89FF */
+  BidLev1_0100,  /* E8A00..E8AFF */
+  BidLev1_0100,  /* E8B00..E8BFF */
+  BidLev1_0100,  /* E8C00..E8CFF */
+  BidLev1_0100,  /* E8D00..E8DFF */
+  BidLev1_0100,  /* E8E00..E8EFF */
+  BidLev1_0100,  /* E8F00..E8FFF */
+  BidLev1_0100,  /* E9000..E90FF */
+  BidLev1_0100,  /* E9100..E91FF */
+  BidLev1_0100,  /* E9200..E92FF */
+  BidLev1_0100,  /* E9300..E93FF */
+  BidLev1_0100,  /* E9400..E94FF */
+  BidLev1_0100,  /* E9500..E95FF */
+  BidLev1_0100,  /* E9600..E96FF */
+  BidLev1_0100,  /* E9700..E97FF */
+  BidLev1_0100,  /* E9800..E98FF */
+  BidLev1_0100,  /* E9900..E99FF */
+  BidLev1_0100,  /* E9A00..E9AFF */
+  BidLev1_0100,  /* E9B00..E9BFF */
+  BidLev1_0100,  /* E9C00..E9CFF */
+  BidLev1_0100,  /* E9D00..E9DFF */
+  BidLev1_0100,  /* E9E00..E9EFF */
+  BidLev1_0100,  /* E9F00..E9FFF */
+  BidLev1_0100,  /* EA000..EA0FF */
+  BidLev1_0100,  /* EA100..EA1FF */
+  BidLev1_0100,  /* EA200..EA2FF */
+  BidLev1_0100,  /* EA300..EA3FF */
+  BidLev1_0100,  /* EA400..EA4FF */
+  BidLev1_0100,  /* EA500..EA5FF */
+  BidLev1_0100,  /* EA600..EA6FF */
+  BidLev1_0100,  /* EA700..EA7FF */
+  BidLev1_0100,  /* EA800..EA8FF */
+  BidLev1_0100,  /* EA900..EA9FF */
+  BidLev1_0100,  /* EAA00..EAAFF */
+  BidLev1_0100,  /* EAB00..EABFF */
+  BidLev1_0100,  /* EAC00..EACFF */
+  BidLev1_0100,  /* EAD00..EADFF */
+  BidLev1_0100,  /* EAE00..EAEFF */
+  BidLev1_0100,  /* EAF00..EAFFF */
+  BidLev1_0100,  /* EB000..EB0FF */
+  BidLev1_0100,  /* EB100..EB1FF */
+  BidLev1_0100,  /* EB200..EB2FF */
+  BidLev1_0100,  /* EB300..EB3FF */
+  BidLev1_0100,  /* EB400..EB4FF */
+  BidLev1_0100,  /* EB500..EB5FF */
+  BidLev1_0100,  /* EB600..EB6FF */
+  BidLev1_0100,  /* EB700..EB7FF */
+  BidLev1_0100,  /* EB800..EB8FF */
+  BidLev1_0100,  /* EB900..EB9FF */
+  BidLev1_0100,  /* EBA00..EBAFF */
+  BidLev1_0100,  /* EBB00..EBBFF */
+  BidLev1_0100,  /* EBC00..EBCFF */
+  BidLev1_0100,  /* EBD00..EBDFF */
+  BidLev1_0100,  /* EBE00..EBEFF */
+  BidLev1_0100,  /* EBF00..EBFFF */
+  BidLev1_0100,  /* EC000..EC0FF */
+  BidLev1_0100,  /* EC100..EC1FF */
+  BidLev1_0100,  /* EC200..EC2FF */
+  BidLev1_0100,  /* EC300..EC3FF */
+  BidLev1_0100,  /* EC400..EC4FF */
+  BidLev1_0100,  /* EC500..EC5FF */
+  BidLev1_0100,  /* EC600..EC6FF */
+  BidLev1_0100,  /* EC700..EC7FF */
+  BidLev1_0100,  /* EC800..EC8FF */
+  BidLev1_0100,  /* EC900..EC9FF */
+  BidLev1_0100,  /* ECA00..ECAFF */
+  BidLev1_0100,  /* ECB00..ECBFF */
+  BidLev1_0100,  /* ECC00..ECCFF */
+  BidLev1_0100,  /* ECD00..ECDFF */
+  BidLev1_0100,  /* ECE00..ECEFF */
+  BidLev1_0100,  /* ECF00..ECFFF */
+  BidLev1_0100,  /* ED000..ED0FF */
+  BidLev1_0100,  /* ED100..ED1FF */
+  BidLev1_0100,  /* ED200..ED2FF */
+  BidLev1_0100,  /* ED300..ED3FF */
+  BidLev1_0100,  /* ED400..ED4FF */
+  BidLev1_0100,  /* ED500..ED5FF */
+  BidLev1_0100,  /* ED600..ED6FF */
+  BidLev1_0100,  /* ED700..ED7FF */
+  BidLev1_0100,  /* ED800..ED8FF */
+  BidLev1_0100,  /* ED900..ED9FF */
+  BidLev1_0100,  /* EDA00..EDAFF */
+  BidLev1_0100,  /* EDB00..EDBFF */
+  BidLev1_0100,  /* EDC00..EDCFF */
+  BidLev1_0100,  /* EDD00..EDDFF */
+  BidLev1_0100,  /* EDE00..EDEFF */
+  BidLev1_0100,  /* EDF00..EDFFF */
+  BidLev1_0100,  /* EE000..EE0FF */
+  BidLev1_0100,  /* EE100..EE1FF */
+  BidLev1_0100,  /* EE200..EE2FF */
+  BidLev1_0100,  /* EE300..EE3FF */
+  BidLev1_0100,  /* EE400..EE4FF */
+  BidLev1_0100,  /* EE500..EE5FF */
+  BidLev1_0100,  /* EE600..EE6FF */
+  BidLev1_0100,  /* EE700..EE7FF */
+  BidLev1_0100,  /* EE800..EE8FF */
+  BidLev1_0100,  /* EE900..EE9FF */
+  BidLev1_0100,  /* EEA00..EEAFF */
+  BidLev1_0100,  /* EEB00..EEBFF */
+  BidLev1_0100,  /* EEC00..EECFF */
+  BidLev1_0100,  /* EED00..EEDFF */
+  BidLev1_0100,  /* EEE00..EEEFF */
+  BidLev1_0100,  /* EEF00..EEFFF */
+  BidLev1_0100,  /* EF000..EF0FF */
+  BidLev1_0100,  /* EF100..EF1FF */
+  BidLev1_0100,  /* EF200..EF2FF */
+  BidLev1_0100,  /* EF300..EF3FF */
+  BidLev1_0100,  /* EF400..EF4FF */
+  BidLev1_0100,  /* EF500..EF5FF */
+  BidLev1_0100,  /* EF600..EF6FF */
+  BidLev1_0100,  /* EF700..EF7FF */
+  BidLev1_0100,  /* EF800..EF8FF */
+  BidLev1_0100,  /* EF900..EF9FF */
+  BidLev1_0100,  /* EFA00..EFAFF */
+  BidLev1_0100,  /* EFB00..EFBFF */
+  BidLev1_0100,  /* EFC00..EFCFF */
+  BidLev1_0100,  /* EFD00..EFDFF */
+  BidLev1_0100,  /* EFE00..EFEFF */
+  BidLev1_1FF00,  /* EFF00..EFFFF */
+  BidLev1_0100,  /* F0000..F00FF */
+  BidLev1_0100,  /* F0100..F01FF */
+  BidLev1_0100,  /* F0200..F02FF */
+  BidLev1_0100,  /* F0300..F03FF */
+  BidLev1_0100,  /* F0400..F04FF */
+  BidLev1_0100,  /* F0500..F05FF */
+  BidLev1_0100,  /* F0600..F06FF */
+  BidLev1_0100,  /* F0700..F07FF */
+  BidLev1_0100,  /* F0800..F08FF */
+  BidLev1_0100,  /* F0900..F09FF */
+  BidLev1_0100,  /* F0A00..F0AFF */
+  BidLev1_0100,  /* F0B00..F0BFF */
+  BidLev1_0100,  /* F0C00..F0CFF */
+  BidLev1_0100,  /* F0D00..F0DFF */
+  BidLev1_0100,  /* F0E00..F0EFF */
+  BidLev1_0100,  /* F0F00..F0FFF */
+  BidLev1_0100,  /* F1000..F10FF */
+  BidLev1_0100,  /* F1100..F11FF */
+  BidLev1_0100,  /* F1200..F12FF */
+  BidLev1_0100,  /* F1300..F13FF */
+  BidLev1_0100,  /* F1400..F14FF */
+  BidLev1_0100,  /* F1500..F15FF */
+  BidLev1_0100,  /* F1600..F16FF */
+  BidLev1_0100,  /* F1700..F17FF */
+  BidLev1_0100,  /* F1800..F18FF */
+  BidLev1_0100,  /* F1900..F19FF */
+  BidLev1_0100,  /* F1A00..F1AFF */
+  BidLev1_0100,  /* F1B00..F1BFF */
+  BidLev1_0100,  /* F1C00..F1CFF */
+  BidLev1_0100,  /* F1D00..F1DFF */
+  BidLev1_0100,  /* F1E00..F1EFF */
+  BidLev1_0100,  /* F1F00..F1FFF */
+  BidLev1_0100,  /* F2000..F20FF */
+  BidLev1_0100,  /* F2100..F21FF */
+  BidLev1_0100,  /* F2200..F22FF */
+  BidLev1_0100,  /* F2300..F23FF */
+  BidLev1_0100,  /* F2400..F24FF */
+  BidLev1_0100,  /* F2500..F25FF */
+  BidLev1_0100,  /* F2600..F26FF */
+  BidLev1_0100,  /* F2700..F27FF */
+  BidLev1_0100,  /* F2800..F28FF */
+  BidLev1_0100,  /* F2900..F29FF */
+  BidLev1_0100,  /* F2A00..F2AFF */
+  BidLev1_0100,  /* F2B00..F2BFF */
+  BidLev1_0100,  /* F2C00..F2CFF */
+  BidLev1_0100,  /* F2D00..F2DFF */
+  BidLev1_0100,  /* F2E00..F2EFF */
+  BidLev1_0100,  /* F2F00..F2FFF */
+  BidLev1_0100,  /* F3000..F30FF */
+  BidLev1_0100,  /* F3100..F31FF */
+  BidLev1_0100,  /* F3200..F32FF */
+  BidLev1_0100,  /* F3300..F33FF */
+  BidLev1_0100,  /* F3400..F34FF */
+  BidLev1_0100,  /* F3500..F35FF */
+  BidLev1_0100,  /* F3600..F36FF */
+  BidLev1_0100,  /* F3700..F37FF */
+  BidLev1_0100,  /* F3800..F38FF */
+  BidLev1_0100,  /* F3900..F39FF */
+  BidLev1_0100,  /* F3A00..F3AFF */
+  BidLev1_0100,  /* F3B00..F3BFF */
+  BidLev1_0100,  /* F3C00..F3CFF */
+  BidLev1_0100,  /* F3D00..F3DFF */
+  BidLev1_0100,  /* F3E00..F3EFF */
+  BidLev1_0100,  /* F3F00..F3FFF */
+  BidLev1_0100,  /* F4000..F40FF */
+  BidLev1_0100,  /* F4100..F41FF */
+  BidLev1_0100,  /* F4200..F42FF */
+  BidLev1_0100,  /* F4300..F43FF */
+  BidLev1_0100,  /* F4400..F44FF */
+  BidLev1_0100,  /* F4500..F45FF */
+  BidLev1_0100,  /* F4600..F46FF */
+  BidLev1_0100,  /* F4700..F47FF */
+  BidLev1_0100,  /* F4800..F48FF */
+  BidLev1_0100,  /* F4900..F49FF */
+  BidLev1_0100,  /* F4A00..F4AFF */
+  BidLev1_0100,  /* F4B00..F4BFF */
+  BidLev1_0100,  /* F4C00..F4CFF */
+  BidLev1_0100,  /* F4D00..F4DFF */
+  BidLev1_0100,  /* F4E00..F4EFF */
+  BidLev1_0100,  /* F4F00..F4FFF */
+  BidLev1_0100,  /* F5000..F50FF */
+  BidLev1_0100,  /* F5100..F51FF */
+  BidLev1_0100,  /* F5200..F52FF */
+  BidLev1_0100,  /* F5300..F53FF */
+  BidLev1_0100,  /* F5400..F54FF */
+  BidLev1_0100,  /* F5500..F55FF */
+  BidLev1_0100,  /* F5600..F56FF */
+  BidLev1_0100,  /* F5700..F57FF */
+  BidLev1_0100,  /* F5800..F58FF */
+  BidLev1_0100,  /* F5900..F59FF */
+  BidLev1_0100,  /* F5A00..F5AFF */
+  BidLev1_0100,  /* F5B00..F5BFF */
+  BidLev1_0100,  /* F5C00..F5CFF */
+  BidLev1_0100,  /* F5D00..F5DFF */
+  BidLev1_0100,  /* F5E00..F5EFF */
+  BidLev1_0100,  /* F5F00..F5FFF */
+  BidLev1_0100,  /* F6000..F60FF */
+  BidLev1_0100,  /* F6100..F61FF */
+  BidLev1_0100,  /* F6200..F62FF */
+  BidLev1_0100,  /* F6300..F63FF */
+  BidLev1_0100,  /* F6400..F64FF */
+  BidLev1_0100,  /* F6500..F65FF */
+  BidLev1_0100,  /* F6600..F66FF */
+  BidLev1_0100,  /* F6700..F67FF */
+  BidLev1_0100,  /* F6800..F68FF */
+  BidLev1_0100,  /* F6900..F69FF */
+  BidLev1_0100,  /* F6A00..F6AFF */
+  BidLev1_0100,  /* F6B00..F6BFF */
+  BidLev1_0100,  /* F6C00..F6CFF */
+  BidLev1_0100,  /* F6D00..F6DFF */
+  BidLev1_0100,  /* F6E00..F6EFF */
+  BidLev1_0100,  /* F6F00..F6FFF */
+  BidLev1_0100,  /* F7000..F70FF */
+  BidLev1_0100,  /* F7100..F71FF */
+  BidLev1_0100,  /* F7200..F72FF */
+  BidLev1_0100,  /* F7300..F73FF */
+  BidLev1_0100,  /* F7400..F74FF */
+  BidLev1_0100,  /* F7500..F75FF */
+  BidLev1_0100,  /* F7600..F76FF */
+  BidLev1_0100,  /* F7700..F77FF */
+  BidLev1_0100,  /* F7800..F78FF */
+  BidLev1_0100,  /* F7900..F79FF */
+  BidLev1_0100,  /* F7A00..F7AFF */
+  BidLev1_0100,  /* F7B00..F7BFF */
+  BidLev1_0100,  /* F7C00..F7CFF */
+  BidLev1_0100,  /* F7D00..F7DFF */
+  BidLev1_0100,  /* F7E00..F7EFF */
+  BidLev1_0100,  /* F7F00..F7FFF */
+  BidLev1_0100,  /* F8000..F80FF */
+  BidLev1_0100,  /* F8100..F81FF */
+  BidLev1_0100,  /* F8200..F82FF */
+  BidLev1_0100,  /* F8300..F83FF */
+  BidLev1_0100,  /* F8400..F84FF */
+  BidLev1_0100,  /* F8500..F85FF */
+  BidLev1_0100,  /* F8600..F86FF */
+  BidLev1_0100,  /* F8700..F87FF */
+  BidLev1_0100,  /* F8800..F88FF */
+  BidLev1_0100,  /* F8900..F89FF */
+  BidLev1_0100,  /* F8A00..F8AFF */
+  BidLev1_0100,  /* F8B00..F8BFF */
+  BidLev1_0100,  /* F8C00..F8CFF */
+  BidLev1_0100,  /* F8D00..F8DFF */
+  BidLev1_0100,  /* F8E00..F8EFF */
+  BidLev1_0100,  /* F8F00..F8FFF */
+  BidLev1_0100,  /* F9000..F90FF */
+  BidLev1_0100,  /* F9100..F91FF */
+  BidLev1_0100,  /* F9200..F92FF */
+  BidLev1_0100,  /* F9300..F93FF */
+  BidLev1_0100,  /* F9400..F94FF */
+  BidLev1_0100,  /* F9500..F95FF */
+  BidLev1_0100,  /* F9600..F96FF */
+  BidLev1_0100,  /* F9700..F97FF */
+  BidLev1_0100,  /* F9800..F98FF */
+  BidLev1_0100,  /* F9900..F99FF */
+  BidLev1_0100,  /* F9A00..F9AFF */
+  BidLev1_0100,  /* F9B00..F9BFF */
+  BidLev1_0100,  /* F9C00..F9CFF */
+  BidLev1_0100,  /* F9D00..F9DFF */
+  BidLev1_0100,  /* F9E00..F9EFF */
+  BidLev1_0100,  /* F9F00..F9FFF */
+  BidLev1_0100,  /* FA000..FA0FF */
+  BidLev1_0100,  /* FA100..FA1FF */
+  BidLev1_0100,  /* FA200..FA2FF */
+  BidLev1_0100,  /* FA300..FA3FF */
+  BidLev1_0100,  /* FA400..FA4FF */
+  BidLev1_0100,  /* FA500..FA5FF */
+  BidLev1_0100,  /* FA600..FA6FF */
+  BidLev1_0100,  /* FA700..FA7FF */
+  BidLev1_0100,  /* FA800..FA8FF */
+  BidLev1_0100,  /* FA900..FA9FF */
+  BidLev1_0100,  /* FAA00..FAAFF */
+  BidLev1_0100,  /* FAB00..FABFF */
+  BidLev1_0100,  /* FAC00..FACFF */
+  BidLev1_0100,  /* FAD00..FADFF */
+  BidLev1_0100,  /* FAE00..FAEFF */
+  BidLev1_0100,  /* FAF00..FAFFF */
+  BidLev1_0100,  /* FB000..FB0FF */
+  BidLev1_0100,  /* FB100..FB1FF */
+  BidLev1_0100,  /* FB200..FB2FF */
+  BidLev1_0100,  /* FB300..FB3FF */
+  BidLev1_0100,  /* FB400..FB4FF */
+  BidLev1_0100,  /* FB500..FB5FF */
+  BidLev1_0100,  /* FB600..FB6FF */
+  BidLev1_0100,  /* FB700..FB7FF */
+  BidLev1_0100,  /* FB800..FB8FF */
+  BidLev1_0100,  /* FB900..FB9FF */
+  BidLev1_0100,  /* FBA00..FBAFF */
+  BidLev1_0100,  /* FBB00..FBBFF */
+  BidLev1_0100,  /* FBC00..FBCFF */
+  BidLev1_0100,  /* FBD00..FBDFF */
+  BidLev1_0100,  /* FBE00..FBEFF */
+  BidLev1_0100,  /* FBF00..FBFFF */
+  BidLev1_0100,  /* FC000..FC0FF */
+  BidLev1_0100,  /* FC100..FC1FF */
+  BidLev1_0100,  /* FC200..FC2FF */
+  BidLev1_0100,  /* FC300..FC3FF */
+  BidLev1_0100,  /* FC400..FC4FF */
+  BidLev1_0100,  /* FC500..FC5FF */
+  BidLev1_0100,  /* FC600..FC6FF */
+  BidLev1_0100,  /* FC700..FC7FF */
+  BidLev1_0100,  /* FC800..FC8FF */
+  BidLev1_0100,  /* FC900..FC9FF */
+  BidLev1_0100,  /* FCA00..FCAFF */
+  BidLev1_0100,  /* FCB00..FCBFF */
+  BidLev1_0100,  /* FCC00..FCCFF */
+  BidLev1_0100,  /* FCD00..FCDFF */
+  BidLev1_0100,  /* FCE00..FCEFF */
+  BidLev1_0100,  /* FCF00..FCFFF */
+  BidLev1_0100,  /* FD000..FD0FF */
+  BidLev1_0100,  /* FD100..FD1FF */
+  BidLev1_0100,  /* FD200..FD2FF */
+  BidLev1_0100,  /* FD300..FD3FF */
+  BidLev1_0100,  /* FD400..FD4FF */
+  BidLev1_0100,  /* FD500..FD5FF */
+  BidLev1_0100,  /* FD600..FD6FF */
+  BidLev1_0100,  /* FD700..FD7FF */
+  BidLev1_0100,  /* FD800..FD8FF */
+  BidLev1_0100,  /* FD900..FD9FF */
+  BidLev1_0100,  /* FDA00..FDAFF */
+  BidLev1_0100,  /* FDB00..FDBFF */
+  BidLev1_0100,  /* FDC00..FDCFF */
+  BidLev1_0100,  /* FDD00..FDDFF */
+  BidLev1_0100,  /* FDE00..FDEFF */
+  BidLev1_0100,  /* FDF00..FDFFF */
+  BidLev1_0100,  /* FE000..FE0FF */
+  BidLev1_0100,  /* FE100..FE1FF */
+  BidLev1_0100,  /* FE200..FE2FF */
+  BidLev1_0100,  /* FE300..FE3FF */
+  BidLev1_0100,  /* FE400..FE4FF */
+  BidLev1_0100,  /* FE500..FE5FF */
+  BidLev1_0100,  /* FE600..FE6FF */
+  BidLev1_0100,  /* FE700..FE7FF */
+  BidLev1_0100,  /* FE800..FE8FF */
+  BidLev1_0100,  /* FE900..FE9FF */
+  BidLev1_0100,  /* FEA00..FEAFF */
+  BidLev1_0100,  /* FEB00..FEBFF */
+  BidLev1_0100,  /* FEC00..FECFF */
+  BidLev1_0100,  /* FED00..FEDFF */
+  BidLev1_0100,  /* FEE00..FEEFF */
+  BidLev1_0100,  /* FEF00..FEFFF */
+  BidLev1_0100,  /* FF000..FF0FF */
+  BidLev1_0100,  /* FF100..FF1FF */
+  BidLev1_0100,  /* FF200..FF2FF */
+  BidLev1_0100,  /* FF300..FF3FF */
+  BidLev1_0100,  /* FF400..FF4FF */
+  BidLev1_0100,  /* FF500..FF5FF */
+  BidLev1_0100,  /* FF600..FF6FF */
+  BidLev1_0100,  /* FF700..FF7FF */
+  BidLev1_0100,  /* FF800..FF8FF */
+  BidLev1_0100,  /* FF900..FF9FF */
+  BidLev1_0100,  /* FFA00..FFAFF */
+  BidLev1_0100,  /* FFB00..FFBFF */
+  BidLev1_0100,  /* FFC00..FFCFF */
+  BidLev1_0100,  /* FFD00..FFDFF */
+  BidLev1_0100,  /* FFE00..FFEFF */
+  BidLev1_1FF00,  /* FFF00..FFFFF */
+  BidLev1_0100,  /* 100000..1000FF */
+  BidLev1_0100,  /* 100100..1001FF */
+  BidLev1_0100,  /* 100200..1002FF */
+  BidLev1_0100,  /* 100300..1003FF */
+  BidLev1_0100,  /* 100400..1004FF */
+  BidLev1_0100,  /* 100500..1005FF */
+  BidLev1_0100,  /* 100600..1006FF */
+  BidLev1_0100,  /* 100700..1007FF */
+  BidLev1_0100,  /* 100800..1008FF */
+  BidLev1_0100,  /* 100900..1009FF */
+  BidLev1_0100,  /* 100A00..100AFF */
+  BidLev1_0100,  /* 100B00..100BFF */
+  BidLev1_0100,  /* 100C00..100CFF */
+  BidLev1_0100,  /* 100D00..100DFF */
+  BidLev1_0100,  /* 100E00..100EFF */
+  BidLev1_0100,  /* 100F00..100FFF */
+  BidLev1_0100,  /* 101000..1010FF */
+  BidLev1_0100,  /* 101100..1011FF */
+  BidLev1_0100,  /* 101200..1012FF */
+  BidLev1_0100,  /* 101300..1013FF */
+  BidLev1_0100,  /* 101400..1014FF */
+  BidLev1_0100,  /* 101500..1015FF */
+  BidLev1_0100,  /* 101600..1016FF */
+  BidLev1_0100,  /* 101700..1017FF */
+  BidLev1_0100,  /* 101800..1018FF */
+  BidLev1_0100,  /* 101900..1019FF */
+  BidLev1_0100,  /* 101A00..101AFF */
+  BidLev1_0100,  /* 101B00..101BFF */
+  BidLev1_0100,  /* 101C00..101CFF */
+  BidLev1_0100,  /* 101D00..101DFF */
+  BidLev1_0100,  /* 101E00..101EFF */
+  BidLev1_0100,  /* 101F00..101FFF */
+  BidLev1_0100,  /* 102000..1020FF */
+  BidLev1_0100,  /* 102100..1021FF */
+  BidLev1_0100,  /* 102200..1022FF */
+  BidLev1_0100,  /* 102300..1023FF */
+  BidLev1_0100,  /* 102400..1024FF */
+  BidLev1_0100,  /* 102500..1025FF */
+  BidLev1_0100,  /* 102600..1026FF */
+  BidLev1_0100,  /* 102700..1027FF */
+  BidLev1_0100,  /* 102800..1028FF */
+  BidLev1_0100,  /* 102900..1029FF */
+  BidLev1_0100,  /* 102A00..102AFF */
+  BidLev1_0100,  /* 102B00..102BFF */
+  BidLev1_0100,  /* 102C00..102CFF */
+  BidLev1_0100,  /* 102D00..102DFF */
+  BidLev1_0100,  /* 102E00..102EFF */
+  BidLev1_0100,  /* 102F00..102FFF */
+  BidLev1_0100,  /* 103000..1030FF */
+  BidLev1_0100,  /* 103100..1031FF */
+  BidLev1_0100,  /* 103200..1032FF */
+  BidLev1_0100,  /* 103300..1033FF */
+  BidLev1_0100,  /* 103400..1034FF */
+  BidLev1_0100,  /* 103500..1035FF */
+  BidLev1_0100,  /* 103600..1036FF */
+  BidLev1_0100,  /* 103700..1037FF */
+  BidLev1_0100,  /* 103800..1038FF */
+  BidLev1_0100,  /* 103900..1039FF */
+  BidLev1_0100,  /* 103A00..103AFF */
+  BidLev1_0100,  /* 103B00..103BFF */
+  BidLev1_0100,  /* 103C00..103CFF */
+  BidLev1_0100,  /* 103D00..103DFF */
+  BidLev1_0100,  /* 103E00..103EFF */
+  BidLev1_0100,  /* 103F00..103FFF */
+  BidLev1_0100,  /* 104000..1040FF */
+  BidLev1_0100,  /* 104100..1041FF */
+  BidLev1_0100,  /* 104200..1042FF */
+  BidLev1_0100,  /* 104300..1043FF */
+  BidLev1_0100,  /* 104400..1044FF */
+  BidLev1_0100,  /* 104500..1045FF */
+  BidLev1_0100,  /* 104600..1046FF */
+  BidLev1_0100,  /* 104700..1047FF */
+  BidLev1_0100,  /* 104800..1048FF */
+  BidLev1_0100,  /* 104900..1049FF */
+  BidLev1_0100,  /* 104A00..104AFF */
+  BidLev1_0100,  /* 104B00..104BFF */
+  BidLev1_0100,  /* 104C00..104CFF */
+  BidLev1_0100,  /* 104D00..104DFF */
+  BidLev1_0100,  /* 104E00..104EFF */
+  BidLev1_0100,  /* 104F00..104FFF */
+  BidLev1_0100,  /* 105000..1050FF */
+  BidLev1_0100,  /* 105100..1051FF */
+  BidLev1_0100,  /* 105200..1052FF */
+  BidLev1_0100,  /* 105300..1053FF */
+  BidLev1_0100,  /* 105400..1054FF */
+  BidLev1_0100,  /* 105500..1055FF */
+  BidLev1_0100,  /* 105600..1056FF */
+  BidLev1_0100,  /* 105700..1057FF */
+  BidLev1_0100,  /* 105800..1058FF */
+  BidLev1_0100,  /* 105900..1059FF */
+  BidLev1_0100,  /* 105A00..105AFF */
+  BidLev1_0100,  /* 105B00..105BFF */
+  BidLev1_0100,  /* 105C00..105CFF */
+  BidLev1_0100,  /* 105D00..105DFF */
+  BidLev1_0100,  /* 105E00..105EFF */
+  BidLev1_0100,  /* 105F00..105FFF */
+  BidLev1_0100,  /* 106000..1060FF */
+  BidLev1_0100,  /* 106100..1061FF */
+  BidLev1_0100,  /* 106200..1062FF */
+  BidLev1_0100,  /* 106300..1063FF */
+  BidLev1_0100,  /* 106400..1064FF */
+  BidLev1_0100,  /* 106500..1065FF */
+  BidLev1_0100,  /* 106600..1066FF */
+  BidLev1_0100,  /* 106700..1067FF */
+  BidLev1_0100,  /* 106800..1068FF */
+  BidLev1_0100,  /* 106900..1069FF */
+  BidLev1_0100,  /* 106A00..106AFF */
+  BidLev1_0100,  /* 106B00..106BFF */
+  BidLev1_0100,  /* 106C00..106CFF */
+  BidLev1_0100,  /* 106D00..106DFF */
+  BidLev1_0100,  /* 106E00..106EFF */
+  BidLev1_0100,  /* 106F00..106FFF */
+  BidLev1_0100,  /* 107000..1070FF */
+  BidLev1_0100,  /* 107100..1071FF */
+  BidLev1_0100,  /* 107200..1072FF */
+  BidLev1_0100,  /* 107300..1073FF */
+  BidLev1_0100,  /* 107400..1074FF */
+  BidLev1_0100,  /* 107500..1075FF */
+  BidLev1_0100,  /* 107600..1076FF */
+  BidLev1_0100,  /* 107700..1077FF */
+  BidLev1_0100,  /* 107800..1078FF */
+  BidLev1_0100,  /* 107900..1079FF */
+  BidLev1_0100,  /* 107A00..107AFF */
+  BidLev1_0100,  /* 107B00..107BFF */
+  BidLev1_0100,  /* 107C00..107CFF */
+  BidLev1_0100,  /* 107D00..107DFF */
+  BidLev1_0100,  /* 107E00..107EFF */
+  BidLev1_0100,  /* 107F00..107FFF */
+  BidLev1_0100,  /* 108000..1080FF */
+  BidLev1_0100,  /* 108100..1081FF */
+  BidLev1_0100,  /* 108200..1082FF */
+  BidLev1_0100,  /* 108300..1083FF */
+  BidLev1_0100,  /* 108400..1084FF */
+  BidLev1_0100,  /* 108500..1085FF */
+  BidLev1_0100,  /* 108600..1086FF */
+  BidLev1_0100,  /* 108700..1087FF */
+  BidLev1_0100,  /* 108800..1088FF */
+  BidLev1_0100,  /* 108900..1089FF */
+  BidLev1_0100,  /* 108A00..108AFF */
+  BidLev1_0100,  /* 108B00..108BFF */
+  BidLev1_0100,  /* 108C00..108CFF */
+  BidLev1_0100,  /* 108D00..108DFF */
+  BidLev1_0100,  /* 108E00..108EFF */
+  BidLev1_0100,  /* 108F00..108FFF */
+  BidLev1_0100,  /* 109000..1090FF */
+  BidLev1_0100,  /* 109100..1091FF */
+  BidLev1_0100,  /* 109200..1092FF */
+  BidLev1_0100,  /* 109300..1093FF */
+  BidLev1_0100,  /* 109400..1094FF */
+  BidLev1_0100,  /* 109500..1095FF */
+  BidLev1_0100,  /* 109600..1096FF */
+  BidLev1_0100,  /* 109700..1097FF */
+  BidLev1_0100,  /* 109800..1098FF */
+  BidLev1_0100,  /* 109900..1099FF */
+  BidLev1_0100,  /* 109A00..109AFF */
+  BidLev1_0100,  /* 109B00..109BFF */
+  BidLev1_0100,  /* 109C00..109CFF */
+  BidLev1_0100,  /* 109D00..109DFF */
+  BidLev1_0100,  /* 109E00..109EFF */
+  BidLev1_0100,  /* 109F00..109FFF */
+  BidLev1_0100,  /* 10A000..10A0FF */
+  BidLev1_0100,  /* 10A100..10A1FF */
+  BidLev1_0100,  /* 10A200..10A2FF */
+  BidLev1_0100,  /* 10A300..10A3FF */
+  BidLev1_0100,  /* 10A400..10A4FF */
+  BidLev1_0100,  /* 10A500..10A5FF */
+  BidLev1_0100,  /* 10A600..10A6FF */
+  BidLev1_0100,  /* 10A700..10A7FF */
+  BidLev1_0100,  /* 10A800..10A8FF */
+  BidLev1_0100,  /* 10A900..10A9FF */
+  BidLev1_0100,  /* 10AA00..10AAFF */
+  BidLev1_0100,  /* 10AB00..10ABFF */
+  BidLev1_0100,  /* 10AC00..10ACFF */
+  BidLev1_0100,  /* 10AD00..10ADFF */
+  BidLev1_0100,  /* 10AE00..10AEFF */
+  BidLev1_0100,  /* 10AF00..10AFFF */
+  BidLev1_0100,  /* 10B000..10B0FF */
+  BidLev1_0100,  /* 10B100..10B1FF */
+  BidLev1_0100,  /* 10B200..10B2FF */
+  BidLev1_0100,  /* 10B300..10B3FF */
+  BidLev1_0100,  /* 10B400..10B4FF */
+  BidLev1_0100,  /* 10B500..10B5FF */
+  BidLev1_0100,  /* 10B600..10B6FF */
+  BidLev1_0100,  /* 10B700..10B7FF */
+  BidLev1_0100,  /* 10B800..10B8FF */
+  BidLev1_0100,  /* 10B900..10B9FF */
+  BidLev1_0100,  /* 10BA00..10BAFF */
+  BidLev1_0100,  /* 10BB00..10BBFF */
+  BidLev1_0100,  /* 10BC00..10BCFF */
+  BidLev1_0100,  /* 10BD00..10BDFF */
+  BidLev1_0100,  /* 10BE00..10BEFF */
+  BidLev1_0100,  /* 10BF00..10BFFF */
+  BidLev1_0100,  /* 10C000..10C0FF */
+  BidLev1_0100,  /* 10C100..10C1FF */
+  BidLev1_0100,  /* 10C200..10C2FF */
+  BidLev1_0100,  /* 10C300..10C3FF */
+  BidLev1_0100,  /* 10C400..10C4FF */
+  BidLev1_0100,  /* 10C500..10C5FF */
+  BidLev1_0100,  /* 10C600..10C6FF */
+  BidLev1_0100,  /* 10C700..10C7FF */
+  BidLev1_0100,  /* 10C800..10C8FF */
+  BidLev1_0100,  /* 10C900..10C9FF */
+  BidLev1_0100,  /* 10CA00..10CAFF */
+  BidLev1_0100,  /* 10CB00..10CBFF */
+  BidLev1_0100,  /* 10CC00..10CCFF */
+  BidLev1_0100,  /* 10CD00..10CDFF */
+  BidLev1_0100,  /* 10CE00..10CEFF */
+  BidLev1_0100,  /* 10CF00..10CFFF */
+  BidLev1_0100,  /* 10D000..10D0FF */
+  BidLev1_0100,  /* 10D100..10D1FF */
+  BidLev1_0100,  /* 10D200..10D2FF */
+  BidLev1_0100,  /* 10D300..10D3FF */
+  BidLev1_0100,  /* 10D400..10D4FF */
+  BidLev1_0100,  /* 10D500..10D5FF */
+  BidLev1_0100,  /* 10D600..10D6FF */
+  BidLev1_0100,  /* 10D700..10D7FF */
+  BidLev1_0100,  /* 10D800..10D8FF */
+  BidLev1_0100,  /* 10D900..10D9FF */
+  BidLev1_0100,  /* 10DA00..10DAFF */
+  BidLev1_0100,  /* 10DB00..10DBFF */
+  BidLev1_0100,  /* 10DC00..10DCFF */
+  BidLev1_0100,  /* 10DD00..10DDFF */
+  BidLev1_0100,  /* 10DE00..10DEFF */
+  BidLev1_0100,  /* 10DF00..10DFFF */
+  BidLev1_0100,  /* 10E000..10E0FF */
+  BidLev1_0100,  /* 10E100..10E1FF */
+  BidLev1_0100,  /* 10E200..10E2FF */
+  BidLev1_0100,  /* 10E300..10E3FF */
+  BidLev1_0100,  /* 10E400..10E4FF */
+  BidLev1_0100,  /* 10E500..10E5FF */
+  BidLev1_0100,  /* 10E600..10E6FF */
+  BidLev1_0100,  /* 10E700..10E7FF */
+  BidLev1_0100,  /* 10E800..10E8FF */
+  BidLev1_0100,  /* 10E900..10E9FF */
+  BidLev1_0100,  /* 10EA00..10EAFF */
+  BidLev1_0100,  /* 10EB00..10EBFF */
+  BidLev1_0100,  /* 10EC00..10ECFF */
+  BidLev1_0100,  /* 10ED00..10EDFF */
+  BidLev1_0100,  /* 10EE00..10EEFF */
+  BidLev1_0100,  /* 10EF00..10EFFF */
+  BidLev1_0100,  /* 10F000..10F0FF */
+  BidLev1_0100,  /* 10F100..10F1FF */
+  BidLev1_0100,  /* 10F200..10F2FF */
+  BidLev1_0100,  /* 10F300..10F3FF */
+  BidLev1_0100,  /* 10F400..10F4FF */
+  BidLev1_0100,  /* 10F500..10F5FF */
+  BidLev1_0100,  /* 10F600..10F6FF */
+  BidLev1_0100,  /* 10F700..10F7FF */
+  BidLev1_0100,  /* 10F800..10F8FF */
+  BidLev1_0100,  /* 10F900..10F9FF */
+  BidLev1_0100,  /* 10FA00..10FAFF */
+  BidLev1_0100,  /* 10FB00..10FBFF */
+  BidLev1_0100,  /* 10FC00..10FCFF */
+  BidLev1_0100,  /* 10FD00..10FDFF */
+  BidLev1_0100,  /* 10FE00..10FEFF */
+  BidLev1_1FF00,  /* 10FF00..10FFFF */
+};
+
+/* *INDENT-ON* */
+
+#define FRIBIDI_GET_BIDI_TYPE(x) \
+	((x) >= 0x110000 ? LTR :  \
+	BidLev1[((x) & 0xff) + \
+	BidLev0[((x) >> 8)]])
+
+#undef PACKTAB_UINT8
+#undef PACKTAB_UINT16
+#undef PACKTAB_UINT32
+
+/* End of generated bidi-type.tab.i */
diff -rupN orginal/scribus/fribidi/CMakeLists.txt patched/scribus/fribidi/CMakeLists.txt
--- orginal/scribus/fribidi/CMakeLists.txt	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/fribidi/CMakeLists.txt	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,32 @@
+INCLUDE_DIRECTORIES(
+${CMAKE_SOURCE_DIR}
+${CMAKE_SOURCE_DIR}/scribus
+${FREETYPE_INCLUDE_DIRS}
+)
+
+
+SET(SCRIBUS_FRIBIDI_LIB_SOURCES
+fribidi-arabic.c      
+fribidi-joining-types.c
+fribidi-bidi.c        
+fribidi-mem.c
+fribidi-bidi-types.c  
+fribidi-mirroring.c
+fribidi.c             
+fribidi-run.c
+fribidi-deprecated.c  
+fribidi-shape.c
+fribidi-joining.c
+)
+
+
+SET(SCRIBUS_FRIBIDI_LIB "scribus_fribidi_lib")
+ADD_LIBRARY(${SCRIBUS_FRIBIDI_LIB} STATIC ${SCRIBUS_FRIBIDI_LIB_SOURCES})
+# This is a convenience library that for linkage purposes is part of Scribus's
+# main API.
+# SET_TARGET_PROPERTIES(${SCRIBUS_FRIBIDI_LIB}
+# PROPERTIES
+# COMPILE_FLAGS -DCOMPILE_SCRIBUS_MAIN_APP
+# )
+
+
diff -rupN orginal/scribus/fribidi/common.h patched/scribus/fribidi/common.h
--- orginal/scribus/fribidi/common.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/fribidi/common.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,190 @@
+/* FriBidi
+ * common.h - common include for library sources
+ *
+ * $Id: common.h,v 1.20 2008-04-08 21:38:23 behdad Exp $
+ * $Author: behdad $
+ * $Date: 2008-04-08 21:38:23 $
+ * $Revision: 1.20 $
+ * $Source: /cvs/fribidi/fribidi2/lib/common.h,v $
+ *
+ * Author:
+ *   Behdad Esfahbod, 2004
+ *
+ * Copyright (C) 2004 Sharif FarsiWeb, Inc.
+ * 
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ * 
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library, in a file named COPYING; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA
+ *
+ * For licensing issues, contact <license@farsiweb.info>.
+ */
+#ifndef _COMMON_H
+#define _COMMON_H
+
+#if HAVE_CONFIG_H+0
+# include <config.h>
+#endif
+
+#include <fribidi-common.h>
+
+/* FRIBIDI_PRIVATESPACE is a macro used to name library internal symbols. */
+#ifndef FRIBIDI_PRIVATESPACE
+# define FRIBIDI_PRIVATESPACE1(A,B) A##B
+# define FRIBIDI_PRIVATESPACE0(A,B) FRIBIDI_PRIVATESPACE1(A,B)
+# define FRIBIDI_PRIVATESPACE(SYMBOL) FRIBIDI_PRIVATESPACE0(_,FRIBIDI_NAMESPACE(_##SYMBOL##__internal__))
+#endif /* !FRIBIDI_PRIVATESPACE */
+
+#if (defined(WIN32)) || (defined(_WIN32_WCE))
+# define FRIBIDI_ENTRY __declspec(dllexport)
+#endif /* WIN32 */
+
+#if FRIBIDI_USE_GLIB+0
+# ifndef SIZEOF_LONG
+#  define SIZEOF_LONG GLIB_SIZEOF_LONG
+# endif	/* !SIZEOF_LONG */
+# ifndef SIZEOF_VOID_P
+#  define SIZEOF_VOID_P GLIB_SIZEOF_VOID_P
+# endif	/* !SIZEOF_VOID_P */
+# ifndef __FRIBIDI_DOC
+#  include <glib/gmem.h>
+# endif	/* !__FRIBIDI_DOC */
+# ifndef fribidi_malloc
+#  define fribidi_malloc g_try_malloc
+#  define fribidi_free g_free
+# endif	/* !fribidi_malloc */
+# ifndef fribidi_assert
+#  ifndef __FRIBIDI_DOC
+#   include <glib/gmessages.h>
+#  endif /* !__FRIBIDI_DOC */
+#  define fribidi_assert g_assert
+# endif	/* !fribidi_assert */
+# ifndef __FRIBIDI_DOC
+#  include <glib/gmacros.h>
+# endif	/* !__FRIBIDI_DOC */
+# ifndef FRIBIDI_BEGIN_STMT
+#  define FRIBIDI_BEGIN_STMT G_STMT_START {
+#  define FRIBIDI_END_STMT } G_STMT_END
+# endif	/* !FRIBIDI_BEGIN_STMT */
+# ifndef LIKELY
+#  define LIKELY G_LIKELY
+#  define UNLIKELY G_UNLIKELY
+# endif	/* !LIKELY */
+# ifndef false
+#  define false FALSE
+# endif	/* !false */
+# ifndef true
+#  define true TRUE
+# endif	/* !true */
+#endif /* FRIBIDI_USE_GLIB */
+
+#ifndef false
+# define false (0)
+# endif	/* !false */
+# ifndef true
+#  define true (!false)
+# endif	/* !true */
+
+#ifndef NULL
+#  ifdef __cplusplus
+#    define NULL        (0L)
+#  else	/* !__cplusplus */
+#    define NULL        ((void*) 0)
+#  endif /* !__cplusplus */
+#endif /* !NULL */
+
+/* fribidi_malloc and fribidi_free should be used instead of malloc and free. 
+ * No need to include any headers. */
+#ifndef fribidi_malloc
+# if HAVE_STDLIB_H
+#  ifndef __FRIBIDI_DOC
+#   include <stdlib.h>
+#  endif /* __FRIBIDI_DOC */
+#  define fribidi_malloc malloc
+# else /* !HAVE_STDLIB_H */
+#  define fribidi_malloc (void *) malloc
+# endif	/* !HAVE_STDLIB_H */
+# define fribidi_free free
+#else /* fribidi_malloc */
+# ifndef fribidi_free
+#  error You should define fribidi_free too when you define fribidi_malloc.
+# endif	/* !fribidi_free */
+#endif /* fribidi_malloc */
+
+#if HAVE_STRING_H+0
+# if !STDC_HEADERS && HAVE_MEMORY_H
+#  include <memory.h>
+# endif
+# include <string.h>
+#endif
+#if HAVE_STRINGS_H+0
+# include <strings.h>
+#endif
+
+/* FRIBIDI_CHUNK_SIZE is the number of bytes in each chunk of memory being
+ * allocated for data structure pools. */
+#ifndef FRIBIDI_CHUNK_SIZE
+# if HAVE_ASM_PAGE_H
+#  ifndef __FRIBIDI_DOC
+#   include <asm/page.h>
+#  endif /* __FRIBIDI_DOC */
+#  define FRIBIDI_CHUNK_SIZE (PAGE_SIZE - 16)
+# else /* !HAVE_ASM_PAGE_H */
+#  define FRIBIDI_CHUNK_SIZE (4096 - 16)
+# endif	/* !HAVE_ASM_PAGE_H */
+#else /* FRIBIDI_CHUNK_SIZE */
+# if FRIBIDI_CHUNK_SIZE < 256
+#  error FRIBIDI_CHUNK_SIZE now should define the size of a chunk in bytes.
+# endif	/* FRIBIDI_CHUNK_SIZE < 256 */
+#endif /* FRIBIDI_CHUNK_SIZE */
+
+/* FRIBIDI_BEGIN_STMT should be used at the beginning of your macro
+ * definitions that are to behave like simple statements.  Use
+ * FRIBIDI_END_STMT at the end of the macro after the semicolon or brace. */
+#ifndef FRIBIDI_BEGIN_STMT
+# define FRIBIDI_BEGIN_STMT do {
+# define FRIBIDI_END_STMT } while (0)
+#endif /* !FRIBIDI_BEGIN_STMT */
+
+/* LIKEYLY and UNLIKELY are used to give a hint on branch prediction to the
+ * compiler. */
+#ifndef LIKELY
+# define LIKELY
+# define UNLIKELY
+#endif /* !LIKELY */
+
+#ifndef FRIBIDI_EMPTY_STMT
+# define FRIBIDI_EMPTY_STMT FRIBIDI_BEGIN_STMT (void) 0; FRIBIDI_END_STMT
+#endif /* !FRIBIDI_EMPTY_STMT */
+
+#if HAVE_STRINGIZE+0
+# define STRINGIZE(symbol) #symbol
+#else /* !HAVE_STRINGIZE */
+# define STRINGIZE(symbol) (no stringize operator available)
+#endif /* !HAVE_STRINGIZE */
+
+/* As per recommendation of GNU Coding Standards. */
+#ifndef _GNU_SOURCE
+# define _GNU_SOURCE
+#endif /* !_GNU_SOURCE */
+
+/* We respect our own rules. */
+#define FRIBIDI_NO_DEPRECATED
+
+
+#include "debug.h"
+
+#endif /* !_COMMON_H */
+/* Editor directions:
+ * vim:textwidth=78:tabstop=8:shiftwidth=2:autoindent:cindent
+ */
diff -rupN orginal/scribus/fribidi/config.h patched/scribus/fribidi/config.h
--- orginal/scribus/fribidi/config.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/fribidi/config.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,105 @@
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Define to 1 if you want to include debug code in the library */
+#define DEBUG 1
+
+/* Define to 1 if you have the <asm/page.h> header file. */
+/* #undef HAVE_ASM_PAGE_H */
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define HAVE_DLFCN_H 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the `memmove' function. */
+#define HAVE_MEMMOVE 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the `memset' function. */
+#define HAVE_MEMSET 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the `strdup' function. */
+#define HAVE_STRDUP 1
+
+/* Define to 1 if cpp supports the ANSI # stringizing operator. */
+#define HAVE_STRINGIZE 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/times.h> header file. */
+#define HAVE_SYS_TIMES_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to 1 if you have the <wchar.h> header file. */
+#define HAVE_WCHAR_H 1
+
+/* Define to the sub-directory in which libtool stores uninstalled libraries.
+   */
+#define LT_OBJDIR ".libs/"
+
+/* Name of package */
+#define PACKAGE "fribidi"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT "http://fribidi.org/bug"
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "GNU FriBidi"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "GNU FriBidi 0.19.2"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "fribidi"
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "0.19.2"
+
+/* Define as the return type of signal handlers (`int' or `void'). */
+#define RETSIGTYPE void
+
+/* The size of `int', as computed by sizeof. */
+#define SIZEOF_INT 4
+
+/* The size of `short', as computed by sizeof. */
+#define SIZEOF_SHORT 2
+
+/* The size of `void *', as computed by sizeof. */
+#define SIZEOF_VOID_P 4
+
+/* The size of `wchar_t', as computed by sizeof. */
+#define SIZEOF_WCHAR_T 4
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Define to 1 if you want to use simple mallocs instead of memory chunks */
+/* #undef USE_SIMPLE_MALLOC */
+
+/* Version number of package */
+#define VERSION "0.19.2"
+
+/* Define to empty if `const' does not conform to ANSI C. */
+/* #undef const */
diff -rupN orginal/scribus/fribidi/COPYING patched/scribus/fribidi/COPYING
--- orginal/scribus/fribidi/COPYING	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/fribidi/COPYING	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,504 @@
+		  GNU LESSER GENERAL PUBLIC LICENSE
+		       Version 2.1, February 1999
+
+ Copyright (C) 1991, 1999 Free Software Foundation, Inc.
+     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+[This is the first released version of the Lesser GPL.  It also counts
+ as the successor of the GNU Library Public License, version 2, hence
+ the version number 2.1.]
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+Licenses are intended to guarantee your freedom to share and change
+free software--to make sure the software is free for all its users.
+
+  This license, the Lesser General Public License, applies to some
+specially designated software packages--typically libraries--of the
+Free Software Foundation and other authors who decide to use it.  You
+can use it too, but we suggest you first think carefully about whether
+this license or the ordinary General Public License is the better
+strategy to use in any particular case, based on the explanations below.
+
+  When we speak of free software, we are referring to freedom of use,
+not price.  Our General Public Licenses are designed to make sure that
+you have the freedom to distribute copies of free software (and charge
+for this service if you wish); that you receive source code or can get
+it if you want it; that you can change the software and use pieces of
+it in new free programs; and that you are informed that you can do
+these things.
+
+  To protect your rights, we need to make restrictions that forbid
+distributors to deny you these rights or to ask you to surrender these
+rights.  These restrictions translate to certain responsibilities for
+you if you distribute copies of the library or if you modify it.
+
+  For example, if you distribute copies of the library, whether gratis
+or for a fee, you must give the recipients all the rights that we gave
+you.  You must make sure that they, too, receive or can get the source
+code.  If you link other code with the library, you must provide
+complete object files to the recipients, so that they can relink them
+with the library after making changes to the library and recompiling
+it.  And you must show them these terms so they know their rights.
+
+  We protect your rights with a two-step method: (1) we copyright the
+library, and (2) we offer you this license, which gives you legal
+permission to copy, distribute and/or modify the library.
+
+  To protect each distributor, we want to make it very clear that
+there is no warranty for the free library.  Also, if the library is
+modified by someone else and passed on, the recipients should know
+that what they have is not the original version, so that the original
+author's reputation will not be affected by problems that might be
+introduced by others.
+
+  Finally, software patents pose a constant threat to the existence of
+any free program.  We wish to make sure that a company cannot
+effectively restrict the users of a free program by obtaining a
+restrictive license from a patent holder.  Therefore, we insist that
+any patent license obtained for a version of the library must be
+consistent with the full freedom of use specified in this license.
+
+  Most GNU software, including some libraries, is covered by the
+ordinary GNU General Public License.  This license, the GNU Lesser
+General Public License, applies to certain designated libraries, and
+is quite different from the ordinary General Public License.  We use
+this license for certain libraries in order to permit linking those
+libraries into non-free programs.
+
+  When a program is linked with a library, whether statically or using
+a shared library, the combination of the two is legally speaking a
+combined work, a derivative of the original library.  The ordinary
+General Public License therefore permits such linking only if the
+entire combination fits its criteria of freedom.  The Lesser General
+Public License permits more lax criteria for linking other code with
+the library.
+
+  We call this license the "Lesser" General Public License because it
+does Less to protect the user's freedom than the ordinary General
+Public License.  It also provides other free software developers Less
+of an advantage over competing non-free programs.  These disadvantages
+are the reason we use the ordinary General Public License for many
+libraries.  However, the Lesser license provides advantages in certain
+special circumstances.
+
+  For example, on rare occasions, there may be a special need to
+encourage the widest possible use of a certain library, so that it becomes
+a de-facto standard.  To achieve this, non-free programs must be
+allowed to use the library.  A more frequent case is that a free
+library does the same job as widely used non-free libraries.  In this
+case, there is little to gain by limiting the free library to free
+software only, so we use the Lesser General Public License.
+
+  In other cases, permission to use a particular library in non-free
+programs enables a greater number of people to use a large body of
+free software.  For example, permission to use the GNU C Library in
+non-free programs enables many more people to use the whole GNU
+operating system, as well as its variant, the GNU/Linux operating
+system.
+
+  Although the Lesser General Public License is Less protective of the
+users' freedom, it does ensure that the user of a program that is
+linked with the Library has the freedom and the wherewithal to run
+that program using a modified version of the Library.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.  Pay close attention to the difference between a
+"work based on the library" and a "work that uses the library".  The
+former contains code derived from the library, whereas the latter must
+be combined with the library in order to run.
+
+		  GNU LESSER GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License Agreement applies to any software library or other
+program which contains a notice placed by the copyright holder or
+other authorized party saying it may be distributed under the terms of
+this Lesser General Public License (also called "this License").
+Each licensee is addressed as "you".
+
+  A "library" means a collection of software functions and/or data
+prepared so as to be conveniently linked with application programs
+(which use some of those functions and data) to form executables.
+
+  The "Library", below, refers to any such software library or work
+which has been distributed under these terms.  A "work based on the
+Library" means either the Library or any derivative work under
+copyright law: that is to say, a work containing the Library or a
+portion of it, either verbatim or with modifications and/or translated
+straightforwardly into another language.  (Hereinafter, translation is
+included without limitation in the term "modification".)
+
+  "Source code" for a work means the preferred form of the work for
+making modifications to it.  For a library, complete source code means
+all the source code for all modules it contains, plus any associated
+interface definition files, plus the scripts used to control compilation
+and installation of the library.
+
+  Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running a program using the Library is not restricted, and output from
+such a program is covered only if its contents constitute a work based
+on the Library (independent of the use of the Library in a tool for
+writing it).  Whether that is true depends on what the Library does
+and what the program that uses the Library does.
+  
+  1. You may copy and distribute verbatim copies of the Library's
+complete source code as you receive it, in any medium, provided that
+you conspicuously and appropriately publish on each copy an
+appropriate copyright notice and disclaimer of warranty; keep intact
+all the notices that refer to this License and to the absence of any
+warranty; and distribute a copy of this License along with the
+Library.
+
+  You may charge a fee for the physical act of transferring a copy,
+and you may at your option offer warranty protection in exchange for a
+fee.
+
+  2. You may modify your copy or copies of the Library or any portion
+of it, thus forming a work based on the Library, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) The modified work must itself be a software library.
+
+    b) You must cause the files modified to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    c) You must cause the whole of the work to be licensed at no
+    charge to all third parties under the terms of this License.
+
+    d) If a facility in the modified Library refers to a function or a
+    table of data to be supplied by an application program that uses
+    the facility, other than as an argument passed when the facility
+    is invoked, then you must make a good faith effort to ensure that,
+    in the event an application does not supply such function or
+    table, the facility still operates, and performs whatever part of
+    its purpose remains meaningful.
+
+    (For example, a function in a library to compute square roots has
+    a purpose that is entirely well-defined independent of the
+    application.  Therefore, Subsection 2d requires that any
+    application-supplied function or table used by this function must
+    be optional: if the application does not supply it, the square
+    root function must still compute square roots.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Library,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Library, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote
+it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Library.
+
+In addition, mere aggregation of another work not based on the Library
+with the Library (or with a work based on the Library) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may opt to apply the terms of the ordinary GNU General Public
+License instead of this License to a given copy of the Library.  To do
+this, you must alter all the notices that refer to this License, so
+that they refer to the ordinary GNU General Public License, version 2,
+instead of to this License.  (If a newer version than version 2 of the
+ordinary GNU General Public License has appeared, then you can specify
+that version instead if you wish.)  Do not make any other change in
+these notices.
+
+  Once this change is made in a given copy, it is irreversible for
+that copy, so the ordinary GNU General Public License applies to all
+subsequent copies and derivative works made from that copy.
+
+  This option is useful when you wish to copy part of the code of
+the Library into a program that is not a library.
+
+  4. You may copy and distribute the Library (or a portion or
+derivative of it, under Section 2) in object code or executable form
+under the terms of Sections 1 and 2 above provided that you accompany
+it with the complete corresponding machine-readable source code, which
+must be distributed under the terms of Sections 1 and 2 above on a
+medium customarily used for software interchange.
+
+  If distribution of object code is made by offering access to copy
+from a designated place, then offering equivalent access to copy the
+source code from the same place satisfies the requirement to
+distribute the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  5. A program that contains no derivative of any portion of the
+Library, but is designed to work with the Library by being compiled or
+linked with it, is called a "work that uses the Library".  Such a
+work, in isolation, is not a derivative work of the Library, and
+therefore falls outside the scope of this License.
+
+  However, linking a "work that uses the Library" with the Library
+creates an executable that is a derivative of the Library (because it
+contains portions of the Library), rather than a "work that uses the
+library".  The executable is therefore covered by this License.
+Section 6 states terms for distribution of such executables.
+
+  When a "work that uses the Library" uses material from a header file
+that is part of the Library, the object code for the work may be a
+derivative work of the Library even though the source code is not.
+Whether this is true is especially significant if the work can be
+linked without the Library, or if the work is itself a library.  The
+threshold for this to be true is not precisely defined by law.
+
+  If such an object file uses only numerical parameters, data
+structure layouts and accessors, and small macros and small inline
+functions (ten lines or less in length), then the use of the object
+file is unrestricted, regardless of whether it is legally a derivative
+work.  (Executables containing this object code plus portions of the
+Library will still fall under Section 6.)
+
+  Otherwise, if the work is a derivative of the Library, you may
+distribute the object code for the work under the terms of Section 6.
+Any executables containing that work also fall under Section 6,
+whether or not they are linked directly with the Library itself.
+
+  6. As an exception to the Sections above, you may also combine or
+link a "work that uses the Library" with the Library to produce a
+work containing portions of the Library, and distribute that work
+under terms of your choice, provided that the terms permit
+modification of the work for the customer's own use and reverse
+engineering for debugging such modifications.
+
+  You must give prominent notice with each copy of the work that the
+Library is used in it and that the Library and its use are covered by
+this License.  You must supply a copy of this License.  If the work
+during execution displays copyright notices, you must include the
+copyright notice for the Library among them, as well as a reference
+directing the user to the copy of this License.  Also, you must do one
+of these things:
+
+    a) Accompany the work with the complete corresponding
+    machine-readable source code for the Library including whatever
+    changes were used in the work (which must be distributed under
+    Sections 1 and 2 above); and, if the work is an executable linked
+    with the Library, with the complete machine-readable "work that
+    uses the Library", as object code and/or source code, so that the
+    user can modify the Library and then relink to produce a modified
+    executable containing the modified Library.  (It is understood
+    that the user who changes the contents of definitions files in the
+    Library will not necessarily be able to recompile the application
+    to use the modified definitions.)
+
+    b) Use a suitable shared library mechanism for linking with the
+    Library.  A suitable mechanism is one that (1) uses at run time a
+    copy of the library already present on the user's computer system,
+    rather than copying library functions into the executable, and (2)
+    will operate properly with a modified version of the library, if
+    the user installs one, as long as the modified version is
+    interface-compatible with the version that the work was made with.
+
+    c) Accompany the work with a written offer, valid for at
+    least three years, to give the same user the materials
+    specified in Subsection 6a, above, for a charge no more
+    than the cost of performing this distribution.
+
+    d) If distribution of the work is made by offering access to copy
+    from a designated place, offer equivalent access to copy the above
+    specified materials from the same place.
+
+    e) Verify that the user has already received a copy of these
+    materials or that you have already sent this user a copy.
+
+  For an executable, the required form of the "work that uses the
+Library" must include any data and utility programs needed for
+reproducing the executable from it.  However, as a special exception,
+the materials to be distributed need not include anything that is
+normally distributed (in either source or binary form) with the major
+components (compiler, kernel, and so on) of the operating system on
+which the executable runs, unless that component itself accompanies
+the executable.
+
+  It may happen that this requirement contradicts the license
+restrictions of other proprietary libraries that do not normally
+accompany the operating system.  Such a contradiction means you cannot
+use both them and the Library together in an executable that you
+distribute.
+
+  7. You may place library facilities that are a work based on the
+Library side-by-side in a single library together with other library
+facilities not covered by this License, and distribute such a combined
+library, provided that the separate distribution of the work based on
+the Library and of the other library facilities is otherwise
+permitted, and provided that you do these two things:
+
+    a) Accompany the combined library with a copy of the same work
+    based on the Library, uncombined with any other library
+    facilities.  This must be distributed under the terms of the
+    Sections above.
+
+    b) Give prominent notice with the combined library of the fact
+    that part of it is a work based on the Library, and explaining
+    where to find the accompanying uncombined form of the same work.
+
+  8. You may not copy, modify, sublicense, link with, or distribute
+the Library except as expressly provided under this License.  Any
+attempt otherwise to copy, modify, sublicense, link with, or
+distribute the Library is void, and will automatically terminate your
+rights under this License.  However, parties who have received copies,
+or rights, from you under this License will not have their licenses
+terminated so long as such parties remain in full compliance.
+
+  9. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Library or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Library (or any work based on the
+Library), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Library or works based on it.
+
+  10. Each time you redistribute the Library (or any work based on the
+Library), the recipient automatically receives a license from the
+original licensor to copy, distribute, link with or modify the Library
+subject to these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties with
+this License.
+
+  11. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Library at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Library by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Library.
+
+If any portion of this section is held invalid or unenforceable under any
+particular circumstance, the balance of the section is intended to apply,
+and the section as a whole is intended to apply in other circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  12. If the distribution and/or use of the Library is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Library under this License may add
+an explicit geographical distribution limitation excluding those countries,
+so that distribution is permitted only in or among countries not thus
+excluded.  In such case, this License incorporates the limitation as if
+written in the body of this License.
+
+  13. The Free Software Foundation may publish revised and/or new
+versions of the Lesser General Public License from time to time.
+Such new versions will be similar in spirit to the present version,
+but may differ in detail to address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Library
+specifies a version number of this License which applies to it and
+"any later version", you have the option of following the terms and
+conditions either of that version or of any later version published by
+the Free Software Foundation.  If the Library does not specify a
+license version number, you may choose any version ever published by
+the Free Software Foundation.
+
+  14. If you wish to incorporate parts of the Library into other free
+programs whose distribution conditions are incompatible with these,
+write to the author to ask for permission.  For software which is
+copyrighted by the Free Software Foundation, write to the Free
+Software Foundation; we sometimes make exceptions for this.  Our
+decision will be guided by the two goals of preserving the free status
+of all derivatives of our free software and of promoting the sharing
+and reuse of software generally.
+
+			    NO WARRANTY
+
+  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
+WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
+EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
+OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
+KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
+LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
+THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
+WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
+AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
+FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
+CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
+LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
+RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
+FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
+SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+           How to Apply These Terms to Your New Libraries
+
+  If you develop a new library, and you want it to be of the greatest
+possible use to the public, we recommend making it free software that
+everyone can redistribute and change.  You can do so by permitting
+redistribution under these terms (or, alternatively, under the terms of the
+ordinary General Public License).
+
+  To apply these terms, attach the following notices to the library.  It is
+safest to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least the
+"copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the library's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+Also add information on how to contact you by electronic and paper mail.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the library, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the
+  library `Frob' (a library for tweaking knobs) written by James Random Hacker.
+
+  <signature of Ty Coon>, 1 April 1990
+  Ty Coon, President of Vice
+
+That's all there is to it!
+
+
diff -rupN orginal/scribus/fribidi/debug.h patched/scribus/fribidi/debug.h
--- orginal/scribus/fribidi/debug.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/fribidi/debug.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,113 @@
+/* FriBidi
+ * debug.h - debug-only interfaces
+ *
+ * $Id: debug.h,v 1.10 2006/01/31 03:23:12 behdad Exp $
+ * $Author: behdad $
+ * $Date: 2006/01/31 03:23:12 $
+ * $Revision: 1.10 $
+ * $Source: /cvs/fribidi/fribidi2/lib/debug.h,v $
+ *
+ * Author:
+ *   Behdad Esfahbod, 2001, 2002, 2004
+ *
+ * Copyright (C) 2004 Sharif FarsiWeb, Inc.
+ * Copyright (C) 2001,2002 Behdad Esfahbod
+ * 
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ * 
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library, in a file named COPYING; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA
+ *
+ * For licensing issues, contact <license@farsiweb.info>.
+ */
+#ifndef _DEBUG_H
+#define _DEBUG_H
+
+#include "common.h"
+
+#include <fribidi-types.h>
+
+#include <fribidi-begindecls.h>
+
+#if DEBUG+0
+
+/* These definitions should only be used in DEBUG mode: */
+#ifndef __LINE__
+# define __LINE__ 0
+#endif /* !__LINE__ */
+#ifndef __FILE__
+# define __FILE__ "unknown"
+#endif /* !__FILE__ */
+
+#ifndef FRIBIDI_FPRINTF
+# ifndef __FRIBIDI_DOC
+#  include <stdio.h>
+# endif	/* !__FRIBIDI_DOC */
+# define FRIBIDI_FPRINTF fprintf
+# define FRIBIDI_STDERR_ stderr,
+#endif /* !FRIBIDI_FPRINTF */
+
+#ifndef MSG
+#define MSG(s) \
+	FRIBIDI_BEGIN_STMT \
+	FRIBIDI_FPRINTF(FRIBIDI_STDERR_ s); \
+	FRIBIDI_END_STMT
+#define MSG2(s, t) \
+	FRIBIDI_BEGIN_STMT \
+	FRIBIDI_FPRINTF(FRIBIDI_STDERR_ s, t); \
+	FRIBIDI_END_STMT
+#define MSG5(s, t, u, v, w) \
+	FRIBIDI_BEGIN_STMT \
+	FRIBIDI_FPRINTF(FRIBIDI_STDERR_ s, t, u, v, w); \
+	FRIBIDI_END_STMT
+#endif /* !MSG */
+
+#ifndef DBG
+# define DBG(s) \
+	FRIBIDI_BEGIN_STMT \
+	if (fribidi_debug_status()) { MSG(FRIBIDI ": " s "\n"); } \
+	FRIBIDI_END_STMT
+# define DBG2(s, t) \
+	FRIBIDI_BEGIN_STMT \
+	if (fribidi_debug_status()) { MSG2(FRIBIDI ": " s "\n", t); } \
+	FRIBIDI_END_STMT
+#endif /* !DBG */
+
+#ifndef fribidi_assert
+# define fribidi_assert(cond) \
+	FRIBIDI_BEGIN_STMT \
+	if (!(cond)) { \
+		DBG(__FILE__ ":" STRINGIZE(__LINE__) ": " \
+		    "assertion failed (" STRINGIZE(cond) ")"); \
+	} \
+	FRIBIDI_END_STMT
+#endif /* !fribidi_assert */
+
+#else /* !DEBUG */
+
+#ifndef DBG
+# define DBG(s)			FRIBIDI_EMPTY_STMT
+# define DBG2(s, t)		FRIBIDI_EMPTY_STMT
+#endif /* !DBG */
+#ifndef fribidi_assert
+# define fribidi_assert(cond)	FRIBIDI_EMPTY_STMT
+#endif /* !fribidi_assert */
+
+#endif /* !DEBUG */
+
+#include <fribidi-enddecls.h>
+
+#endif /* !_DEBUG_H */
+/* Editor directions:
+ * vim:textwidth=78:tabstop=8:shiftwidth=2:autoindent:cindent
+ */
diff -rupN orginal/scribus/fribidi/fribidi-arabic.c patched/scribus/fribidi/fribidi-arabic.c
--- orginal/scribus/fribidi/fribidi-arabic.c	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/fribidi/fribidi-arabic.c	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,193 @@
+/* fribidi-arabic.c - Arabic shaping
+ *
+ * Copyright (C) 2005  Behdad Esfahbod
+ *
+ * This file is part of GNU FriBidi.
+ * 
+ * GNU FriBidi is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * as published by the Free Software Foundation; either version 2.1
+ * of the License, or (at your option) any later version.
+ * 
+ * GNU FriBidi is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with GNU FriBidi; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * 
+ * For licensing issues, contact <license@farsiweb.info> or write to
+ * Sharif FarsiWeb, Inc., PO Box 13445-389, Tehran, Iran.
+ */
+/* $Id: fribidi-arabic.c,v 1.3 2007/04/05 16:14:39 behdad Exp $
+ * $Author: behdad $
+ * $Date: 2007/04/05 16:14:39 $
+ * $Revision: 1.3 $
+ * $Source: /cvs/fribidi/fribidi2/lib/fribidi-arabic.c,v $
+ *
+ * Author(s):
+ *   Behdad Esfahbod, 2005
+ */
+
+#include "common.h"
+
+#if HAVE_STDLIB_H+0
+# include <stdlib.h>
+#endif
+
+
+#include <fribidi-arabic.h>
+#include <fribidi-unicode.h>
+
+
+typedef struct _PairMap {
+  FriBidiChar pair[2], to;
+} PairMap;
+
+
+#define FRIBIDI_ACCESS_SHAPE_TABLE(table,min,max,x,shape) (table), (min), (max)
+# define FRIBIDI_ACCESS_SHAPE_TABLE_REAL(table,min,max,x,shape) \
+	(((x)<(min)||(x)>(max))?(x):(table)[(x)-(min)][(shape)])
+
+#include "arabic-shaping.tab.i"
+#include "arabic-misc.tab.i"
+
+
+static void
+fribidi_shape_arabic_joining (
+  /* input */
+  const FriBidiChar table[][4],
+  FriBidiChar min,
+  FriBidiChar max,
+  const FriBidiStrIndex len,
+  const FriBidiArabicProp *ar_props,
+  /* input and output */
+  FriBidiChar *str
+)
+{
+  register FriBidiStrIndex i;
+
+  for (i = 0; i < len; i++)
+    if (FRIBIDI_ARAB_SHAPES(ar_props[i]))
+      str[i] = FRIBIDI_ACCESS_SHAPE_TABLE_REAL (table, min, max, str[i], FRIBIDI_JOIN_SHAPE (ar_props[i]));
+}
+
+
+
+static int
+comp_PairMap (const void *pa, const void *pb)
+{
+  PairMap *a = (PairMap *)pa;
+  PairMap *b = (PairMap *)pb;
+
+  if (a->pair[0] != b->pair[0])
+    return a->pair[0] < b->pair[0] ? -1 : +1;
+  else
+    return a->pair[1] < b->pair[1] ? -1 :
+           a->pair[1] > b->pair[1] ? +1 :
+	   0;
+}
+
+
+static FriBidiChar
+find_pair_match (const PairMap *table, int size, FriBidiChar first, FriBidiChar second)
+{
+  PairMap *match;
+  PairMap x;
+  x.pair[0] = first;
+  x.pair[1] = second;
+  x.to = 0;
+  match = bsearch (&x, table, size, sizeof (table[0]), comp_PairMap);
+  return match ? match->to : 0;
+}
+
+#define PAIR_MATCH(table,len,first,second) \
+	((first)<(table[0].pair[0])||(first)>(table[len-1].pair[0])?0: \
+	 find_pair_match(table, len, first, second))
+
+static void
+fribidi_shape_arabic_ligature (
+  /* input */
+  const PairMap *table,
+  int size,
+  const FriBidiLevel *embedding_levels,
+  const FriBidiStrIndex len,
+  /* input and output */
+  FriBidiArabicProp *ar_props,
+  FriBidiChar *str
+)
+{
+  /* TODO: This doesn't form ligatures for even-level Arabic text.
+   * no big problem though. */
+  register FriBidiStrIndex i;
+
+  for (i = 0; i < len - 1; i++) {
+    register FriBidiChar c;
+    if (FRIBIDI_LEVEL_IS_RTL(embedding_levels[i]) &&
+	embedding_levels[i] == embedding_levels[i+1] &&
+	(c = PAIR_MATCH(table, size, str[i], str[i+1])))
+      {
+	str[i] = FRIBIDI_CHAR_FILL;
+	FRIBIDI_SET_BITS(ar_props[i], FRIBIDI_MASK_LIGATURED);
+	str[i+1] = c;
+      }
+  }
+}
+
+#define DO_LIGATURING(table, levels, len, ar_props, str) \
+	fribidi_shape_arabic_ligature ((table), sizeof(table)/sizeof((table)[0]), levels, len, ar_props, str)
+
+#define DO_SHAPING(tablemacro, len, ar_props, str) \
+	fribidi_shape_arabic_joining (tablemacro(,), len, ar_props, str);
+	
+
+
+
+FRIBIDI_ENTRY void
+fribidi_shape_arabic (
+  /* input */
+  FriBidiFlags flags,
+  const FriBidiLevel *embedding_levels,
+  const FriBidiStrIndex len,
+  /* input and output */
+  FriBidiArabicProp *ar_props,
+  FriBidiChar *str
+)
+{
+  DBG ("in fribidi_shape_arabic");
+
+  if UNLIKELY
+    (len == 0 || !str) return;
+
+  DBG ("in fribidi_shape");
+
+  fribidi_assert (ar_props);
+
+  if (FRIBIDI_TEST_BITS (flags, FRIBIDI_FLAG_SHAPE_ARAB_PRES))
+    {
+      DO_SHAPING (FRIBIDI_GET_ARABIC_SHAPE_PRES, len, ar_props, str);
+    }
+
+  if (FRIBIDI_TEST_BITS (flags, FRIBIDI_FLAG_SHAPE_ARAB_LIGA))
+    {
+      DO_LIGATURING (mandatory_liga_table, embedding_levels, len, ar_props, str);
+    }
+
+  if (FRIBIDI_TEST_BITS (flags, FRIBIDI_FLAG_SHAPE_ARAB_CONSOLE))
+    {
+      DO_LIGATURING (console_liga_table, embedding_levels, len, ar_props, str);
+      DO_SHAPING (FRIBIDI_GET_ARABIC_SHAPE_NSM, len, ar_props, str);
+    }
+}
+
+/* Editor directions:
+ * Local Variables:
+ *   mode: c
+ *   c-basic-offset: 2
+ *   indent-tabs-mode: t
+ *   tab-width: 8
+ * End:
+ * vim: textwidth=78: autoindent: cindent: shiftwidth=2: tabstop=8:
+ */
diff -rupN orginal/scribus/fribidi/fribidi-arabic.h patched/scribus/fribidi/fribidi-arabic.h
--- orginal/scribus/fribidi/fribidi-arabic.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/fribidi/fribidi-arabic.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,88 @@
+/* fribidi-arabic.h - do Arabic shaping to presentation forms
+ *
+ * Copyright (C) 2005  Behdad Esfahbod
+ * 
+ * This file is part of GNU FriBidi.
+ * 
+ * GNU FriBidi is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * as published by the Free Software Foundation; either version 2.1
+ * of the License, or (at your option) any later version.
+ * 
+ * GNU FriBidi is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with GNU FriBidi; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * 
+ * For licensing issues, contact <license@farsiweb.info> or write to
+ * Sharif FarsiWeb, Inc., PO Box 13445-389, Tehran, Iran.
+ */
+/* $Id: fribidi-arabic.h,v 1.1 2005/11/03 01:39:01 behdad Exp $
+ * $Author: behdad $
+ * $Date: 2005/11/03 01:39:01 $
+ * $Revision: 1.1 $
+ * $Source: /cvs/fribidi/fribidi2/lib/fribidi-arabic.h,v $
+ *
+ * Author(s):
+ *   Behdad Esfahbod, 2005
+ */
+#ifndef _FRIBIDI_ARABIC_H
+#define _FRIBIDI_ARABIC_H
+
+#include "fribidi-common.h"
+
+#include "fribidi-types.h"
+#include "fribidi-flags.h"
+#include "fribidi-bidi-types.h"
+#include "fribidi-joining.h"
+
+#include "fribidi-begindecls.h"
+
+
+#define fribidi_shape_arabic FRIBIDI_NAMESPACE(shape_arabic)
+/* fribidi_shape_arabic - do Arabic shaping
+ *
+ * The actual shaping that is done depends on the flags set.  Only flags
+ * starting with FRIBIDI_FLAG_SHAPE_ARAB_ affect this function.
+ * Currently these are:
+ *
+ *	* FRIBIDI_FLAG_SHAPE_MIRRORING: Do mirroring.
+ *	* FRIBIDI_FLAG_SHAPE_ARAB_PRES: Shape Arabic characters to their
+ *					presentation form glyphs.
+ *	* FRIBIDI_FLAG_SHAPE_ARAB_LIGA: Form mandatory Arabic ligatures.
+ *	* FRIBIDI_FLAG_SHAPE_ARAB_CONSOLE: Perform additional Arabic shaping
+ *					   suitable for text rendered on
+ *					   grid terminals with no mark
+ *					   rendering capabilities.
+ *
+ * Of the above, FRIBIDI_FLAG_SHAPE_ARAB_CONSOLE is only used in special
+ * cases, but the rest are recommended in any enviroment that doesn't have
+ * other means for doing Arabic shaping.  The set of extra flags that enable
+ * this level of Arabic support has a shortcut named FRIBIDI_FLAGS_ARABIC.
+ */
+FRIBIDI_ENTRY void
+fribidi_shape_arabic (
+  FriBidiFlags flags, /* shaping flags */
+  const FriBidiLevel *embedding_levels,
+  const FriBidiStrIndex len,	/* input string length */
+  FriBidiArabicProp *ar_props, /* input/output Arabic properties as
+				* computed by fribidi_join_arabic */
+  FriBidiChar *str		/* string to shape */
+);
+
+#include "fribidi-enddecls.h"
+
+#endif /* !_FRIBIDI_ARABIC_H */
+/* Editor directions:
+ * Local Variables:
+ *   mode: c
+ *   c-basic-offset: 2
+ *   indent-tabs-mode: t
+ *   tab-width: 8
+ * End:
+ * vim: textwidth=78: autoindent: cindent: shiftwidth=2: tabstop=8:
+ */
diff -rupN orginal/scribus/fribidi/fribidi-begindecls.h patched/scribus/fribidi/fribidi-begindecls.h
--- orginal/scribus/fribidi/fribidi-begindecls.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/fribidi/fribidi-begindecls.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,3 @@
+#ifdef FRIBIDI_BEGIN_DECLS
+FRIBIDI_BEGIN_DECLS
+#endif /* FRIBIDI_BEGIN_DECLS */
diff -rupN orginal/scribus/fribidi/fribidi-bidi-types-list.h patched/scribus/fribidi/fribidi-bidi-types-list.h
--- orginal/scribus/fribidi/fribidi-bidi-types-list.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/fribidi/fribidi-bidi-types-list.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,98 @@
+#ifndef __FRIBIDI_DOC
+/* FriBidi
+ * fribidi-bidi-types-list.h - list of bidi types
+ *
+ * $Id: fribidi-bidi-types-list.h,v 1.5 2004/06/13 20:11:42 behdad Exp $
+ * $Author: behdad $
+ * $Date: 2004/06/13 20:11:42 $
+ * $Revision: 1.5 $
+ * $Source: /cvs/fribidi/fribidi2/lib/fribidi-bidi-types-list.h,v $
+ *
+ * Author:
+ *   Behdad Esfahbod, 2001, 2002, 2004
+ *
+ * Copyright (C) 2004 Sharif FarsiWeb, Inc.
+ * Copyright (C) 2001,2002 Behdad Esfahbod
+ * 
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ * 
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library, in a file named COPYING; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA
+ *
+ * For licensing issues, contact <license@farsiweb.info>.
+ */
+/* *INDENT-OFF* */
+#endif /* !__FRIBIDI_DOC */
+#ifndef _FRIBIDI_ADD_TYPE
+# define _FRIBIDI_ADD_TYPE(x,y)
+#endif
+#ifndef _FRIBIDI_ADD_ALIAS
+# define _FRIBIDI_ADD_ALIAS(x1,x2)
+#endif
+
+#if !defined(_FRIBIDI_PAR_TYPES) || defined(_FRIBIDI_ALL_TYPES)
+
+_FRIBIDI_ADD_TYPE (LTR, 'L')	/* Left-To-Right letter */
+_FRIBIDI_ADD_TYPE (RTL, 'R')	/* Right-To-Left letter */
+_FRIBIDI_ADD_TYPE (AL, 'A')	/* Arabic Letter */
+_FRIBIDI_ADD_TYPE (EN, '1')	/* European Numeral */
+_FRIBIDI_ADD_TYPE (AN, '9')	/* Arabic Numeral */
+_FRIBIDI_ADD_TYPE (ES, 'w')	/* European number Separator */
+_FRIBIDI_ADD_TYPE (ET, 'w')	/* European number Terminator */
+_FRIBIDI_ADD_TYPE (CS, 'w')	/* Common Separator */
+_FRIBIDI_ADD_TYPE (NSM, '`')	/* Non Spacing Mark */
+_FRIBIDI_ADD_TYPE (BN, 'b')	/* Boundary Neutral */
+_FRIBIDI_ADD_TYPE (BS, 'B')	/* Block Separator */
+_FRIBIDI_ADD_TYPE (SS, 'S')	/* Segment Separator */
+_FRIBIDI_ADD_TYPE (WS, '_')	/* WhiteSpace */
+_FRIBIDI_ADD_TYPE (ON, 'n')	/* Other Neutral */
+_FRIBIDI_ADD_TYPE (LRE, '+')	/* Left-to-Right Embedding */
+_FRIBIDI_ADD_TYPE (RLE, '+')	/* Right-to-Left Embedding */
+_FRIBIDI_ADD_TYPE (LRO, '+')	/* Left-to-Right Override */
+_FRIBIDI_ADD_TYPE (RLO, '+')	/* Right-to-Left Override */
+_FRIBIDI_ADD_TYPE (PDF, '-')	/* Pop Directional Flag */
+
+#if defined(_FRIBIDI_ADD_ALIAS)
+_FRIBIDI_ADD_ALIAS (L, LTR)
+_FRIBIDI_ADD_ALIAS (R, RTL)
+_FRIBIDI_ADD_ALIAS (B, BS)
+_FRIBIDI_ADD_ALIAS (S, SS)
+#endif /* _FRIBIDI_ADD_ALIAS */
+
+#if defined(_FRIBIDI_SENTINEL_TYPE) || defined(_FRIBIDI_ALL_TYPES)
+_FRIBIDI_ADD_TYPE (SENTINEL, '$')	/* SENTINEL */
+#endif /* _FRIBIDI_SENTINEL_TYPES || _FRIBIDI_ALL_TYPES*/
+#endif /* !_FRIBIDI_PAR_TYPES || _FRIBIDI_ALL_TYPES */
+
+#if defined(_FRIBIDI_PAR_TYPES) || defined(_FRIBIDI_ALL_TYPES)
+# if !defined(_FRIBIDI_ALL_TYPES)
+_FRIBIDI_ADD_TYPE (LTR, 'L')	/* Left-To-Right paragraph */
+_FRIBIDI_ADD_TYPE (RTL, 'R')	/* Right-To-Left paragraph */
+_FRIBIDI_ADD_TYPE (ON, 'n')	/* directiOn-Neutral paragraph */
+# endif /* !_FRIBIDI_ALL_TYPES */
+_FRIBIDI_ADD_TYPE (WLTR, 'l')	/* Weak Left To Right paragraph */
+_FRIBIDI_ADD_TYPE (WRTL, 'r')	/* Weak Right To Left paragraph */
+#endif /* _FRIBIDI_PAR_TYPES || _FRIBIDI_ALL_TYPES*/
+
+#if defined(_FRIBIDI_ENUM_TYPES)
+typedef enum {
+# define _FRIBIDI_ADD_TYPE _FRIBIDI_ENUM_ADD_TYPE
+# include "fribidi-bidi-types-list.h"
+# undef _FRIBIDI_ADD_TYPE
+  _FRIBIDI_TYPES_MAX
+} _FRIBIDI_ENUM_TYPES
+#endif /* _FRIBIDI_ENUM_TYPES */
+
+#ifndef __FRIBIDI_DOC
+/* *INDENT-ON* */
+#endif /* !__FRIBIDI_DOC */
diff -rupN orginal/scribus/fribidi/fribidi-bidi-types.c patched/scribus/fribidi/fribidi-bidi-types.c
--- orginal/scribus/fribidi/fribidi-bidi-types.c	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/fribidi/fribidi-bidi-types.c	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,125 @@
+/* FriBidi
+ * fribidi-bidi-types.c - character bidi types
+ *
+ * $Id: fribidi-bidi-types.c,v 1.9 2006/01/31 03:23:13 behdad Exp $
+ * $Author: behdad $
+ * $Date: 2006/01/31 03:23:13 $
+ * $Revision: 1.9 $
+ * $Source: /cvs/fribidi/fribidi2/lib/fribidi-bidi-types.c,v $
+ *
+ * Authors:
+ *   Behdad Esfahbod, 2001, 2002, 2004
+ *
+ * Copyright (C) 2004 Sharif FarsiWeb, Inc.
+ * Copyright (C) 2001,2002 Behdad Esfahbod
+ * 
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ * 
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library, in a file named COPYING; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA
+ *
+ * For licensing issues, contact <license@farsiweb.info>.
+ */
+
+#include "common.h"
+
+#include <fribidi-bidi-types.h>
+
+#include "bidi-types.h"
+
+enum FriBidiCharTypeLinearEnum
+{
+# define _FRIBIDI_ADD_TYPE(TYPE,SYMBOL) TYPE,
+# include "fribidi-bidi-types-list.h"
+# undef _FRIBIDI_ADD_TYPE
+  _FRIBIDI_NUM_TYPES
+};
+
+#include "bidi-type.tab.i"
+
+/* Map FriBidiCharTypeLinearEnum to FriBidiCharType. */
+static const FriBidiCharType linear_enum_to_char_type[] = {
+# define _FRIBIDI_ADD_TYPE(TYPE,SYMBOL) FRIBIDI_TYPE_##TYPE,
+# include "fribidi-bidi-types-list.h"
+# undef _FRIBIDI_ADD_TYPE
+};
+
+FRIBIDI_ENTRY FriBidiCharType
+fribidi_get_bidi_type (
+  /* input */
+  FriBidiChar ch
+)
+{
+  return linear_enum_to_char_type[FRIBIDI_GET_BIDI_TYPE (ch)];
+}
+
+FRIBIDI_ENTRY void
+fribidi_get_bidi_types (
+  /* input */
+  const FriBidiChar *str,
+  const FriBidiStrIndex len,
+  /* output */
+  FriBidiCharType *btypes
+)
+{
+  register FriBidiStrIndex i = len;
+  for (; i; i--)
+    {
+      *btypes++ = linear_enum_to_char_type[FRIBIDI_GET_BIDI_TYPE (*str)];
+      str++;
+    }
+}
+
+FRIBIDI_ENTRY const char *
+fribidi_get_bidi_type_name (
+  /* input */
+  FriBidiCharType t
+)
+{
+  switch (t)
+    {
+#   define _FRIBIDI_ADD_TYPE(TYPE,SYMBOL) case FRIBIDI_TYPE_##TYPE: return STRINGIZE(TYPE);
+#   define _FRIBIDI_ALL_TYPES
+#   include "fribidi-bidi-types-list.h"
+#   undef _FRIBIDI_ALL_TYPES
+#   undef _FRIBIDI_ADD_TYPE
+    default:
+      return "?";
+    }
+}
+
+#if DEBUG+0
+
+char
+fribidi_char_from_bidi_type (
+  /* input */
+  FriBidiCharType t
+)
+{
+  switch (t)
+    {
+#   define _FRIBIDI_ADD_TYPE(TYPE,SYMBOL) case FRIBIDI_TYPE_##TYPE: return SYMBOL;
+#   define _FRIBIDI_ALL_TYPES
+#   include "fribidi-bidi-types-list.h"
+#   undef _FRIBIDI_ALL_TYPES
+#   undef _FRIBIDI_ADD_TYPE
+    default:
+      return '?';
+    }
+}
+
+#endif /* DEBUG */
+
+/* Editor directions:
+ * vim:textwidth=78:tabstop=8:shiftwidth=2:autoindent:cindent
+ */
diff -rupN orginal/scribus/fribidi/fribidi-bidi-types.h patched/scribus/fribidi/fribidi-bidi-types.h
--- orginal/scribus/fribidi/fribidi-bidi-types.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/fribidi/fribidi-bidi-types.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,389 @@
+/* FriBidi
+ * fribidi-bidi-types.h - character bidi types
+ *
+ * $Id: fribidi-bidi-types.h,v 1.15 2008-11-24 17:48:31 behdad Exp $
+ * $Author: behdad $
+ * $Date: 2008-11-24 17:48:31 $
+ * $Revision: 1.15 $
+ * $Source: /cvs/fribidi/fribidi2/lib/fribidi-bidi-types.h,v $
+ *
+ * Author:
+ *   Behdad Esfahbod, 2001, 2002, 2004
+ *
+ * Copyright (C) 2004 Sharif FarsiWeb, Inc.
+ * Copyright (C) 2001,2002 Behdad Esfahbod
+ * 
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ * 
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library, in a file named COPYING; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA
+ *
+ * For licensing issues, contact <license@farsiweb.info>.
+ */
+#ifndef _FRIBIDI_BIDI_TYPES_H
+#define _FRIBIDI_BIDI_TYPES_H
+
+#include "fribidi-common.h"
+
+#include "fribidi-types.h"
+
+#include "fribidi-begindecls.h"
+
+typedef signed char FriBidiLevel;
+
+/* 
+ * Define bit masks that bidi types are based on, each mask has
+ * only one bit set.
+ */
+
+/* RTL mask better be the least significant bit. */
+#define FRIBIDI_MASK_RTL	0x00000001L	/* Is right to left */
+#define FRIBIDI_MASK_ARABIC	0x00000002L	/* Is arabic */
+
+/* Each char can be only one of the three following. */
+#define FRIBIDI_MASK_STRONG	0x00000010L	/* Is strong */
+#define FRIBIDI_MASK_WEAK	0x00000020L	/* Is weak */
+#define FRIBIDI_MASK_NEUTRAL	0x00000040L	/* Is neutral */
+#define FRIBIDI_MASK_SENTINEL	0x00000080L	/* Is sentinel */
+/* Sentinels are not valid chars, just identify the start/end of strings. */
+
+/* Each char can be only one of the five following. */
+#define FRIBIDI_MASK_LETTER	0x00000100L	/* Is letter: L, R, AL */
+#define FRIBIDI_MASK_NUMBER	0x00000200L	/* Is number: EN, AN */
+#define FRIBIDI_MASK_NUMSEPTER	0x00000400L	/* Is separator or terminator: ES, ET, CS */
+#define FRIBIDI_MASK_SPACE	0x00000800L	/* Is space: BN, BS, SS, WS */
+#define FRIBIDI_MASK_EXPLICIT	0x00001000L	/* Is expilict mark: LRE, RLE, LRO, RLO, PDF */
+
+/* Can be set only if FRIBIDI_MASK_SPACE is also set. */
+#define FRIBIDI_MASK_SEPARATOR	0x00002000L	/* Is text separator: BS, SS */
+/* Can be set only if FRIBIDI_MASK_EXPLICIT is also set. */
+#define FRIBIDI_MASK_OVERRIDE	0x00004000L	/* Is explicit override: LRO, RLO */
+
+/* The following exist to make types pairwise different, some of them can
+ * be removed but are here because of efficiency (make queries faster). */
+
+#define FRIBIDI_MASK_ES		0x00010000L
+#define FRIBIDI_MASK_ET		0x00020000L
+#define FRIBIDI_MASK_CS		0x00040000L
+
+#define FRIBIDI_MASK_NSM	0x00080000L
+#define FRIBIDI_MASK_BN		0x00100000L
+
+#define FRIBIDI_MASK_BS		0x00200000L
+#define FRIBIDI_MASK_SS		0x00400000L
+#define FRIBIDI_MASK_WS		0x00800000L
+
+/* We reserve a single bit for user's private use: we will never use it. */
+#define FRIBIDI_MASK_PRIVATE	0x01000000L
+
+
+/*
+ * Define values for FriBidiCharType
+ */
+
+/* Strong types */
+
+/* Left-To-Right letter */
+#define FRIBIDI_TYPE_LTR_VAL	( FRIBIDI_MASK_STRONG | FRIBIDI_MASK_LETTER )
+/* Right-To-Left letter */
+#define FRIBIDI_TYPE_RTL_VAL	( FRIBIDI_MASK_STRONG | FRIBIDI_MASK_LETTER \
+				| FRIBIDI_MASK_RTL)
+/* Arabic Letter */
+#define FRIBIDI_TYPE_AL_VAL	( FRIBIDI_MASK_STRONG | FRIBIDI_MASK_LETTER \
+				| FRIBIDI_MASK_RTL | FRIBIDI_MASK_ARABIC )
+/* Left-to-Right Embedding */
+#define FRIBIDI_TYPE_LRE_VAL	( FRIBIDI_MASK_STRONG | FRIBIDI_MASK_EXPLICIT)
+/* Right-to-Left Embedding */
+#define FRIBIDI_TYPE_RLE_VAL	( FRIBIDI_MASK_STRONG | FRIBIDI_MASK_EXPLICIT \
+				| FRIBIDI_MASK_RTL )
+/* Left-to-Right Override */
+#define FRIBIDI_TYPE_LRO_VAL	( FRIBIDI_MASK_STRONG | FRIBIDI_MASK_EXPLICIT \
+				| FRIBIDI_MASK_OVERRIDE )
+/* Right-to-Left Override */
+#define FRIBIDI_TYPE_RLO_VAL	( FRIBIDI_MASK_STRONG | FRIBIDI_MASK_EXPLICIT \
+				| FRIBIDI_MASK_RTL | FRIBIDI_MASK_OVERRIDE )
+
+/* Weak types */
+
+/* Pop Directional Flag*/
+#define FRIBIDI_TYPE_PDF_VAL	( FRIBIDI_MASK_WEAK | FRIBIDI_MASK_EXPLICIT )
+/* European Numeral */
+#define FRIBIDI_TYPE_EN_VAL	( FRIBIDI_MASK_WEAK | FRIBIDI_MASK_NUMBER )
+/* Arabic Numeral */
+#define FRIBIDI_TYPE_AN_VAL	( FRIBIDI_MASK_WEAK | FRIBIDI_MASK_NUMBER \
+				| FRIBIDI_MASK_ARABIC )
+/* European number Separator */
+#define FRIBIDI_TYPE_ES_VAL	( FRIBIDI_MASK_WEAK | FRIBIDI_MASK_NUMSEPTER \
+				| FRIBIDI_MASK_ES )
+/* European number Terminator */
+#define FRIBIDI_TYPE_ET_VAL	( FRIBIDI_MASK_WEAK | FRIBIDI_MASK_NUMSEPTER \
+				| FRIBIDI_MASK_ET )
+/* Common Separator */
+#define FRIBIDI_TYPE_CS_VAL	( FRIBIDI_MASK_WEAK | FRIBIDI_MASK_NUMSEPTER \
+				| FRIBIDI_MASK_CS )
+/* Non Spacing Mark */
+#define FRIBIDI_TYPE_NSM_VAL	( FRIBIDI_MASK_WEAK | FRIBIDI_MASK_NSM )
+/* Boundary Neutral */
+#define FRIBIDI_TYPE_BN_VAL	( FRIBIDI_MASK_WEAK | FRIBIDI_MASK_SPACE \
+				| FRIBIDI_MASK_BN )
+
+/* Neutral types */
+
+/* Block Separator */
+#define FRIBIDI_TYPE_BS_VAL	( FRIBIDI_MASK_NEUTRAL | FRIBIDI_MASK_SPACE \
+				| FRIBIDI_MASK_SEPARATOR | FRIBIDI_MASK_BS )
+/* Segment Separator */
+#define FRIBIDI_TYPE_SS_VAL	( FRIBIDI_MASK_NEUTRAL | FRIBIDI_MASK_SPACE \
+				| FRIBIDI_MASK_SEPARATOR | FRIBIDI_MASK_SS )
+/* WhiteSpace */
+#define FRIBIDI_TYPE_WS_VAL	( FRIBIDI_MASK_NEUTRAL | FRIBIDI_MASK_SPACE \
+				| FRIBIDI_MASK_WS )
+/* Other Neutral */
+#define FRIBIDI_TYPE_ON_VAL	( FRIBIDI_MASK_NEUTRAL )
+
+
+/* The following are used in specifying paragraph direction only. */
+
+/* Weak Left-To-Right */
+#define FRIBIDI_TYPE_WLTR_VAL	( FRIBIDI_MASK_WEAK )
+/* Weak Right-To-Left */
+#define FRIBIDI_TYPE_WRTL_VAL	( FRIBIDI_MASK_WEAK | FRIBIDI_MASK_RTL )
+
+/* start or end of text (run list) SENTINEL.  Only used internally */
+#define FRIBIDI_TYPE_SENTINEL	( FRIBIDI_MASK_SENTINEL )
+
+/* Private types for applications.  More private types can be obtained by
+ * summing up from this one. */
+#define FRIBIDI_TYPE_PRIVATE	( FRIBIDI_MASK_PRIVATE )
+
+
+/* Define Enums only if sizeof(int) == 4 (UTF-32), and not compiling C++.
+ * The problem with C++ is that then casts between int32 and enum will fail!
+ */
+#if defined(__FRIBIDI_DOC) || (FRIBIDI_SIZEOF_INT+0 == 4 && !defined(__cplusplus))
+
+typedef enum
+{
+# define _FRIBIDI_ADD_TYPE(TYPE,SYMBOL) \
+	FRIBIDI_TYPE_##TYPE = FRIBIDI_TYPE_##TYPE##_VAL,
+# include "fribidi-bidi-types-list.h"
+# undef _FRIBIDI_ADD_TYPE
+  _FRIBIDI_TYPE_SENTINEL = FRIBIDI_TYPE_SENTINEL	/* Don't use this */
+} FriBidiCharType;
+
+typedef enum
+{
+# define _FRIBIDI_PAR_TYPES
+# define _FRIBIDI_ADD_TYPE(TYPE,SYMBOL) \
+	FRIBIDI_PAR_##TYPE = FRIBIDI_TYPE_##TYPE##_VAL,
+# include "fribidi-bidi-types-list.h"
+# undef _FRIBIDI_ADD_TYPE
+# undef _FRIBIDI_PAR_TYPES
+  _FRIBIDI_PAR_SENTINEL = FRIBIDI_TYPE_SENTINEL	/* Don't use this */
+} FriBidiParType;
+
+#else
+
+typedef fribidi_uint32 FriBidiCharType;
+# define FRIBIDI_TYPE_LTR	FRIBIDI_TYPE_LTR_VAL
+# define FRIBIDI_TYPE_RTL	FRIBIDI_TYPE_RTL_VAL
+# define FRIBIDI_TYPE_AL	FRIBIDI_TYPE_AL_VAL
+# define FRIBIDI_TYPE_EN	FRIBIDI_TYPE_EN_VAL
+# define FRIBIDI_TYPE_AN	FRIBIDI_TYPE_AN_VAL
+# define FRIBIDI_TYPE_ES	FRIBIDI_TYPE_ES_VAL
+# define FRIBIDI_TYPE_ET	FRIBIDI_TYPE_ET_VAL
+# define FRIBIDI_TYPE_CS	FRIBIDI_TYPE_CS_VAL
+# define FRIBIDI_TYPE_NSM	FRIBIDI_TYPE_NSM_VAL
+# define FRIBIDI_TYPE_BN	FRIBIDI_TYPE_BN_VAL
+# define FRIBIDI_TYPE_BS	FRIBIDI_TYPE_BS_VAL
+# define FRIBIDI_TYPE_SS	FRIBIDI_TYPE_SS_VAL
+# define FRIBIDI_TYPE_WS	FRIBIDI_TYPE_WS_VAL
+# define FRIBIDI_TYPE_ON	FRIBIDI_TYPE_ON_VAL
+# define FRIBIDI_TYPE_LRE	FRIBIDI_TYPE_LRE_VAL
+# define FRIBIDI_TYPE_RLE	FRIBIDI_TYPE_RLE_VAL
+# define FRIBIDI_TYPE_LRO	FRIBIDI_TYPE_LRO_VAL
+# define FRIBIDI_TYPE_RLO	FRIBIDI_TYPE_RLO_VAL
+# define FRIBIDI_TYPE_PDF	FRIBIDI_TYPE_PDF_VAL
+
+typedef fribidi_uint32 FriBidiParType;
+# define FRIBIDI_PAR_LTR	FRIBIDI_TYPE_LTR_VAL
+# define FRIBIDI_PAR_RTL	FRIBIDI_TYPE_RTL_VAL
+# define FRIBIDI_PAR_ON		FRIBIDI_TYPE_ON_VAL
+# define FRIBIDI_PAR_WLTR	FRIBIDI_TYPE_WLTR_VAL
+# define FRIBIDI_PAR_WRTL	FRIBIDI_TYPE_WRTL_VAL
+
+#endif
+
+/* Please don't use these two type names, use FRIBIDI_PAR_* form instead. */
+#define FRIBIDI_TYPE_WLTR	FRIBIDI_PAR_WLTR
+#define FRIBIDI_TYPE_WRTL	FRIBIDI_PAR_WRTL
+
+
+/*
+ * Defining macros for needed queries, It is fully dependent on the 
+ * implementation of FriBidiCharType.
+ */
+
+
+/* Is right-to-left level? */
+#define FRIBIDI_LEVEL_IS_RTL(lev) ((lev) & 1)
+
+/* Return the bidi type corresponding to the direction of the level number,
+   FRIBIDI_TYPE_LTR for evens and FRIBIDI_TYPE_RTL for odds. */
+#define FRIBIDI_LEVEL_TO_DIR(lev)	\
+	(FRIBIDI_LEVEL_IS_RTL (lev) ? FRIBIDI_TYPE_RTL : FRIBIDI_TYPE_LTR)
+
+/* Return the minimum level of the direction, 0 for FRIBIDI_TYPE_LTR and
+   1 for FRIBIDI_TYPE_RTL and FRIBIDI_TYPE_AL. */
+#define FRIBIDI_DIR_TO_LEVEL(dir)	\
+	((FriBidiLevel) (FRIBIDI_IS_RTL (dir) ? 1 : 0))
+
+/* Is right to left: RTL, AL, RLE, RLO? */
+#define FRIBIDI_IS_RTL(p)      ((p) & FRIBIDI_MASK_RTL)
+/* Is arabic: AL, AN? */
+#define FRIBIDI_IS_ARABIC(p)   ((p) & FRIBIDI_MASK_ARABIC)
+
+/* Is strong? */
+#define FRIBIDI_IS_STRONG(p)   ((p) & FRIBIDI_MASK_STRONG)
+/* Is weak? */
+#define FRIBIDI_IS_WEAK(p)     ((p) & FRIBIDI_MASK_WEAK)
+/* Is neutral? */
+#define FRIBIDI_IS_NEUTRAL(p)  ((p) & FRIBIDI_MASK_NEUTRAL)
+/* Is sentinel? */
+#define FRIBIDI_IS_SENTINEL(p) ((p) & FRIBIDI_MASK_SENTINEL)
+
+/* Is letter: L, R, AL? */
+#define FRIBIDI_IS_LETTER(p)   ((p) & FRIBIDI_MASK_LETTER)
+/* Is number: EN, AN? */
+#define FRIBIDI_IS_NUMBER(p)   ((p) & FRIBIDI_MASK_NUMBER)
+/* Is number separator or terminator: ES, ET, CS? */
+#define FRIBIDI_IS_NUMBER_SEPARATOR_OR_TERMINATOR(p) \
+	((p) & FRIBIDI_MASK_NUMSEPTER)
+/* Is space: BN, BS, SS, WS? */
+#define FRIBIDI_IS_SPACE(p)    ((p) & FRIBIDI_MASK_SPACE)
+/* Is explicit mark: LRE, RLE, LRO, RLO, PDF? */
+#define FRIBIDI_IS_EXPLICIT(p) ((p) & FRIBIDI_MASK_EXPLICIT)
+
+/* Is text separator: BS, SS? */
+#define FRIBIDI_IS_SEPARATOR(p) ((p) & FRIBIDI_MASK_SEPARATOR)
+
+/* Is explicit override: LRO, RLO? */
+#define FRIBIDI_IS_OVERRIDE(p) ((p) & FRIBIDI_MASK_OVERRIDE)
+
+/* Some more: */
+
+/* Is left to right letter: LTR? */
+#define FRIBIDI_IS_LTR_LETTER(p) \
+	((p) & (FRIBIDI_MASK_LETTER | FRIBIDI_MASK_RTL) == FRIBIDI_MASK_LETTER)
+
+/* Is right to left letter: RTL, AL? */
+#define FRIBIDI_IS_RTL_LETTER(p) \
+	((p) & (FRIBIDI_MASK_LETTER | FRIBIDI_MASK_RTL) \
+	== (FRIBIDI_MASK_LETTER | FRIBIDI_MASK_RTL))
+
+/* Is ES or CS: ES, CS? */
+#define FRIBIDI_IS_ES_OR_CS(p) \
+	((p) & (FRIBIDI_MASK_ES | FRIBIDI_MASK_CS))
+
+/* Is explicit or BN: LRE, RLE, LRO, RLO, PDF, BN? */
+#define FRIBIDI_IS_EXPLICIT_OR_BN(p) \
+	((p) & (FRIBIDI_MASK_EXPLICIT | FRIBIDI_MASK_BN))
+
+/* Is explicit or BN or NSM: LRE, RLE, LRO, RLO, PDF, BN, NSM? */
+#define FRIBIDI_IS_EXPLICIT_OR_BN_OR_NSM(p) \
+	((p) & (FRIBIDI_MASK_EXPLICIT | FRIBIDI_MASK_BN | FRIBIDI_MASK_NSM))
+
+/* Is explicit or BN or WS: LRE, RLE, LRO, RLO, PDF, BN, WS? */
+#define FRIBIDI_IS_EXPLICIT_OR_BN_OR_WS(p) \
+	((p) & (FRIBIDI_MASK_EXPLICIT | FRIBIDI_MASK_BN | FRIBIDI_MASK_WS))
+
+/* Is explicit or separator or BN or WS: LRE, RLE, LRO, RLO, PDF, BS, SS, BN, WS? */
+#define FRIBIDI_IS_EXPLICIT_OR_SEPARATOR_OR_BN_OR_WS(p) \
+	((p) & (FRIBIDI_MASK_EXPLICIT | FRIBIDI_MASK_SEPARATOR \
+		| FRIBIDI_MASK_BN | FRIBIDI_MASK_WS))
+
+/* Is private-use type for application? */
+#define FRIBIDI_IS_PRIVATE(p) ((p) & FRIBIDI_MASK_PRIVATE)
+
+/* Define some conversions. */
+
+/* Change numbers to RTL: EN,AN -> RTL. */
+#define FRIBIDI_CHANGE_NUMBER_TO_RTL(p) \
+	(FRIBIDI_IS_NUMBER(p) ? FRIBIDI_TYPE_RTL : (p))
+
+/* Override status of an explicit mark:
+ * LRO,LRE->LTR, RLO,RLE->RTL, otherwise->ON. */
+#define FRIBIDI_EXPLICIT_TO_OVERRIDE_DIR(p) \
+	(FRIBIDI_IS_OVERRIDE(p) ? FRIBIDI_LEVEL_TO_DIR(FRIBIDI_DIR_TO_LEVEL(p)) \
+				: FRIBIDI_TYPE_ON)
+
+/* Weaken type for paragraph fallback purposes:
+ * LTR->WLTR, RTL->WRTL. */
+#define FRIBIDI_WEAK_PARAGRAPH(p) (FRIBIDI_PAR_WLTR | ((p) & FRIBIDI_MASK_RTL))
+
+
+/* Functions finally */
+
+
+#define fribidi_get_bidi_type FRIBIDI_NAMESPACE(get_bidi_type)
+/* fribidi_get_bidi_type - get character bidi type
+ *
+ * This function returns the bidi type of a character as defined in Table 3.7
+ * Bidirectional Character Types of the Unicode Bidirectional Algorithm
+ * available at
+ * http://www.unicode.org/reports/tr9/#Bidirectional_Character_Types, using
+ * data provided in file UnicodeData.txt of the Unicode Character Database
+ * available at http://www.unicode.org/Public/UNIDATA/UnicodeData.txt.
+ *
+ * There are a few macros defined in fribidi-bidi-types.h for querying a bidi
+ * type.
+ */
+FRIBIDI_ENTRY FriBidiCharType
+fribidi_get_bidi_type (
+  FriBidiChar ch		/* input character */
+) FRIBIDI_GNUC_CONST;
+
+#define fribidi_get_bidi_types FRIBIDI_NAMESPACE(get_bidi_types)
+/* fribidi_get_bidi_types - get bidi types for an string of characters
+ *
+ * This function finds the bidi types of an string of characters.  See
+ * fribidi_get_bidi_type() for more information about the bidi types returned
+ * by this function.
+ */
+     FRIBIDI_ENTRY void fribidi_get_bidi_types (
+  const FriBidiChar *str,	/* input string */
+  const FriBidiStrIndex len,	/* input string length */
+  FriBidiCharType *btypes	/* output bidi types */
+);
+
+#define fribidi_get_bidi_type_name FRIBIDI_NAMESPACE(get_bidi_type_name)
+/* fribidi_get_bidi_type_name - get bidi type name
+ *
+ * This function returns the bidi type name of a character type.  The
+ * returned string is a static string and should not be freed.
+ *
+ * The type names are the same as ones defined in Table 3.7 Bidirectional
+ * Character Types of the Unicode Bidirectional Algorithm available at
+ * http://www.unicode.org/reports/tr9/#Bidirectional_Character_Types, with a
+ * few modifications: L->LTR, R->RTL, B->BS, S->SS.
+ */
+     FRIBIDI_ENTRY const char *fribidi_get_bidi_type_name (
+  FriBidiCharType t		/* input bidi type */
+) FRIBIDI_GNUC_CONST;
+
+#include "fribidi-enddecls.h"
+
+#endif /* !_FRIBIDI_BIDI_TYPES_H */
+/* Editor directions:
+ * vim:textwidth=78:tabstop=8:shiftwidth=2:autoindent:cindent
+ */
diff -rupN orginal/scribus/fribidi/fribidi-bidi.c patched/scribus/fribidi/fribidi-bidi.c
--- orginal/scribus/fribidi/fribidi-bidi.c	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/fribidi/fribidi-bidi.c	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,992 @@
+/* FriBidi
+ * fribidi-bidi.c - bidirectional algorithm
+ *
+ * $Id: fribidi-bidi.c,v 1.21 2007/03/15 18:09:25 behdad Exp $
+ * $Author: behdad $
+ * $Date: 2007/03/15 18:09:25 $
+ * $Revision: 1.21 $
+ * $Source: /cvs/fribidi/fribidi2/lib/fribidi-bidi.c,v $
+ *
+ * Authors:
+ *   Behdad Esfahbod, 2001, 2002, 2004
+ *   Dov Grobgeld, 1999, 2000
+ *
+ * Copyright (C) 2004 Sharif FarsiWeb, Inc
+ * Copyright (C) 2001,2002 Behdad Esfahbod
+ * Copyright (C) 1999,2000 Dov Grobgeld
+ * 
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ * 
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library, in a file named COPYING; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA
+ * 
+ * For licensing issues, contact <license@farsiweb.info>.
+ */
+
+#include "common.h"
+
+#include <fribidi-bidi.h>
+#include <fribidi-mirroring.h>
+#include <fribidi-unicode.h>
+
+#include "mem.h"
+#include "bidi-types.h"
+#include "run.h"
+
+/*
+ * This file implements most of Unicode Standard Annex #9, Tracking Number 13.
+ */
+
+#ifndef MAX
+# define MAX(a,b) ((a) > (b) ? (a) : (b))
+#endif /* !MAX */
+
+/* Some convenience macros */
+#define RL_TYPE(list) ((list)->type)
+#define RL_LEN(list) ((list)->len)
+#define RL_POS(list) ((list)->pos)
+#define RL_LEVEL(list) ((list)->level)
+
+static FriBidiRun *
+merge_with_prev (
+  FriBidiRun *second
+)
+{
+  FriBidiRun *first;
+
+  fribidi_assert (second);
+  fribidi_assert (second->next);
+  first = second->prev;
+  fribidi_assert (first);
+
+  first->next = second->next;
+  first->next->prev = first;
+  RL_LEN (first) += RL_LEN (second);
+  free_run (second);
+  return first;
+}
+
+static void
+compact_list (
+  FriBidiRun *list
+)
+{
+  fribidi_assert (list);
+
+  if (list->next)
+    for_run_list (list, list)
+      if (RL_TYPE (list->prev) == RL_TYPE (list)
+	  && RL_LEVEL (list->prev) == RL_LEVEL (list))
+      list = merge_with_prev (list);
+}
+
+static void
+compact_neutrals (
+  FriBidiRun *list
+)
+{
+  fribidi_assert (list);
+
+  if (list->next)
+    {
+      for_run_list (list, list)
+      {
+	if (RL_LEVEL (list->prev) == RL_LEVEL (list)
+	    &&
+	    ((RL_TYPE
+	      (list->prev) == RL_TYPE (list)
+	      || (FRIBIDI_IS_NEUTRAL (RL_TYPE (list->prev))
+		  && FRIBIDI_IS_NEUTRAL (RL_TYPE (list))))))
+	  list = merge_with_prev (list);
+      }
+    }
+}
+
+#if DEBUG+0
+/*======================================================================
+ *  For debugging, define some functions for printing the types and the
+ *  levels.
+ *----------------------------------------------------------------------*/
+
+static char char_from_level_array[] = {
+  '$',				/* -1 == FRIBIDI_SENTINEL, indicating
+				 * start or end of string. */
+  /* 0-61 == 0-9,a-z,A-Z are the the only valid levels before resolving
+   * implicits.  after that the level @ may be appear too. */
+  '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
+  'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',
+  'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
+  'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D',
+  'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',
+  'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
+  'Y', 'Z',
+
+  '@',				/* 62 == only must appear after resolving
+				 * implicits. */
+
+  '!',				/* 63 == FRIBIDI_LEVEL_INVALID, internal error,
+				 * this level shouldn't be seen.  */
+
+  '*', '*', '*', '*', '*'	/* >= 64 == overflows, this levels and higher
+				 * levels show a real bug!. */
+};
+
+#define fribidi_char_from_level(level) char_from_level_array[(level) + 1]
+
+static void
+print_types_re (
+  const FriBidiRun *pp
+)
+{
+  fribidi_assert (pp);
+
+  MSG ("  Run types  : ");
+  for_run_list (pp, pp)
+  {
+    MSG5 ("%d:%d(%s)[%d] ",
+	  pp->pos, pp->len, fribidi_get_bidi_type_name (pp->type), pp->level);
+  }
+  MSG ("\n");
+}
+
+static void
+print_resolved_levels (
+  const FriBidiRun *pp
+)
+{
+  fribidi_assert (pp);
+
+  MSG ("  Res. levels: ");
+  for_run_list (pp, pp)
+  {
+    register FriBidiStrIndex i;
+    for (i = RL_LEN (pp); i; i--)
+      MSG2 ("%c", fribidi_char_from_level (RL_LEVEL (pp)));
+  }
+  MSG ("\n");
+}
+
+static void
+print_resolved_types (
+  const FriBidiRun *pp
+)
+{
+  fribidi_assert (pp);
+
+  MSG ("  Res. types : ");
+  for_run_list (pp, pp)
+  {
+    FriBidiStrIndex i;
+    for (i = RL_LEN (pp); i; i--)
+      MSG2 ("%c", fribidi_char_from_bidi_type (pp->type));
+  }
+  MSG ("\n");
+}
+
+static void
+print_bidi_string (
+  /* input */
+  const FriBidiCharType *bidi_types,
+  const FriBidiStrIndex len
+)
+{
+  register FriBidiStrIndex i;
+
+  fribidi_assert (bidi_types);
+
+  MSG ("  Org. types : ");
+  for (i = 0; i < len; i++)
+    MSG2 ("%c", fribidi_char_from_bidi_type (bidi_types[i]));
+  MSG ("\n");
+}
+#endif /* DEBUG */
+
+
+/*=========================================================================
+ * define macros for push and pop the status in to / out of the stack
+ *-------------------------------------------------------------------------*/
+
+/* There are a few little points in pushing into and poping from the status
+   stack:
+   1. when the embedding level is not valid (more than
+   FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL=61), you must reject it, and not to push
+   into the stack, but when you see a PDF, you must find the matching code,
+   and if it was pushed in the stack, pop it, it means you must pop if and
+   only if you have pushed the matching code, the over_pushed var counts the
+   number of rejected codes so far.
+   2. there's a more confusing point too, when the embedding level is exactly
+   FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL-1=60, an LRO or LRE is rejected
+   because the new level would be FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL+1=62, that
+   is invalid; but an RLO or RLE is accepted because the new level is
+   FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL=61, that is valid, so the rejected codes
+   may be not continuous in the logical order, in fact there are at most two
+   continuous intervals of codes, with an RLO or RLE between them.  To support
+   this case, the first_interval var counts the number of rejected codes in
+   the first interval, when it is 0, means that there is only one interval.
+*/
+
+/* a. If this new level would be valid, then this embedding code is valid.
+   Remember (push) the current embedding level and override status.
+   Reset current level to this new level, and reset the override status to
+   new_override.
+   b. If the new level would not be valid, then this code is invalid. Don't
+   change the current level or override status.
+*/
+#define PUSH_STATUS \
+    FRIBIDI_BEGIN_STMT \
+      if LIKELY(new_level <= FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL) \
+        { \
+          if UNLIKELY(level == FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL - 1) \
+            first_interval = over_pushed; \
+          status_stack[stack_size].level = level; \
+          status_stack[stack_size].override = override; \
+          stack_size++; \
+          level = new_level; \
+          override = new_override; \
+        } else \
+	  over_pushed++; \
+    FRIBIDI_END_STMT
+
+/* If there was a valid matching code, restore (pop) the last remembered
+   (pushed) embedding level and directional override.
+*/
+#define POP_STATUS \
+    FRIBIDI_BEGIN_STMT \
+      if (stack_size) \
+      { \
+        if UNLIKELY(over_pushed > first_interval) \
+          over_pushed--; \
+        else \
+          { \
+            if LIKELY(over_pushed == first_interval) \
+              first_interval = 0; \
+            stack_size--; \
+            level = status_stack[stack_size].level; \
+            override = status_stack[stack_size].override; \
+          } \
+      } \
+    FRIBIDI_END_STMT
+
+
+/* Return the type of previous run or the SOR, if already at the start of
+   a level run. */
+#define PREV_TYPE_OR_SOR(pp) \
+    ( \
+      RL_LEVEL(pp->prev) == RL_LEVEL(pp) ? \
+        RL_TYPE(pp->prev) : \
+        FRIBIDI_LEVEL_TO_DIR(MAX(RL_LEVEL(pp->prev), RL_LEVEL(pp))) \
+    )
+
+/* Return the type of next run or the EOR, if already at the end of
+   a level run. */
+#define NEXT_TYPE_OR_EOR(pp) \
+    ( \
+      RL_LEVEL(pp->next) == RL_LEVEL(pp) ? \
+        RL_TYPE(pp->next) : \
+        FRIBIDI_LEVEL_TO_DIR(MAX(RL_LEVEL(pp->next), RL_LEVEL(pp))) \
+    )
+
+
+/* Return the embedding direction of a link. */
+#define FRIBIDI_EMBEDDING_DIRECTION(link) \
+    FRIBIDI_LEVEL_TO_DIR(RL_LEVEL(link))
+
+
+FRIBIDI_ENTRY FriBidiParType
+fribidi_get_par_direction (
+  /* input */
+  const FriBidiCharType *bidi_types,
+  const FriBidiStrIndex len
+)
+{
+  register FriBidiStrIndex i;
+
+  fribidi_assert (bidi_types);
+
+  for (i = 0; i < len; i++)
+    if (FRIBIDI_IS_LETTER (bidi_types[i]))
+      return FRIBIDI_IS_RTL (bidi_types[i]) ? FRIBIDI_PAR_RTL :
+	FRIBIDI_PAR_LTR;
+
+  return FRIBIDI_PAR_ON;
+}
+
+FRIBIDI_ENTRY FriBidiLevel
+fribidi_get_par_embedding_levels (
+  /* input */
+  const FriBidiCharType *bidi_types,
+  const FriBidiStrIndex len,
+  /* input and output */
+  FriBidiParType *pbase_dir,
+  /* output */
+  FriBidiLevel *embedding_levels
+)
+{
+  FriBidiLevel base_level, max_level = 0;
+  FriBidiParType base_dir;
+  FriBidiRun *main_run_list = NULL, *explicits_list = NULL, *pp;
+  fribidi_boolean status = false;
+
+  if UNLIKELY
+    (!len)
+    {
+      status = true;
+      goto out;
+    }
+
+  DBG ("in fribidi_get_par_embedding_levels");
+
+  fribidi_assert (bidi_types);
+  fribidi_assert (pbase_dir);
+  fribidi_assert (embedding_levels);
+
+  /* Determinate character types */
+  {
+    /* Get run-length encoded character types */
+    main_run_list = run_list_encode_bidi_types (bidi_types, len);
+    if UNLIKELY
+      (!main_run_list) goto out;
+  }
+
+  /* Find base level */
+  /* If no strong base_dir was found, resort to the weak direction
+     that was passed on input. */
+  base_level = FRIBIDI_DIR_TO_LEVEL (*pbase_dir);
+  if (!FRIBIDI_IS_STRONG (*pbase_dir))
+    /* P2. P3. Search for first strong character and use its direction as
+       base direction */
+    {
+      for_run_list (pp, main_run_list) if (FRIBIDI_IS_LETTER (RL_TYPE (pp)))
+	{
+	  base_level = FRIBIDI_DIR_TO_LEVEL (RL_TYPE (pp));
+	  *pbase_dir = FRIBIDI_LEVEL_TO_DIR (base_level);
+	  break;
+	}
+    }
+  base_dir = FRIBIDI_LEVEL_TO_DIR (base_level);
+  DBG2 ("  base level : %c", fribidi_char_from_level (base_level));
+  DBG2 ("  base dir   : %c", fribidi_char_from_bidi_type (base_dir));
+
+# if DEBUG
+  if UNLIKELY
+    (fribidi_debug_status ())
+    {
+      print_types_re (main_run_list);
+    }
+# endif	/* DEBUG */
+
+  /* Explicit Levels and Directions */
+  DBG ("explicit levels and directions");
+  {
+    FriBidiLevel level, new_level;
+    FriBidiCharType override, new_override;
+    FriBidiStrIndex i;
+    int stack_size, over_pushed, first_interval;
+    struct
+    {
+      FriBidiCharType override;	/* only LTR, RTL and ON are valid */
+      FriBidiLevel level;
+    } *status_stack;
+    FriBidiRun temp_link;
+
+/* explicits_list is a list like main_run_list, that holds the explicit
+   codes that are removed from main_run_list, to reinsert them later by
+   calling the shadow_run_list.
+*/
+    explicits_list = new_run_list ();
+    if UNLIKELY
+      (!explicits_list) goto out;
+
+    /* X1. Begin by setting the current embedding level to the paragraph
+       embedding level. Set the directional override status to neutral.
+       Process each character iteratively, applying rules X2 through X9.
+       Only embedding levels from 0 to 61 are valid in this phase. */
+
+    level = base_level;
+    override = FRIBIDI_TYPE_ON;
+    /* stack */
+    stack_size = 0;
+    over_pushed = 0;
+    first_interval = 0;
+    status_stack = fribidi_malloc (sizeof (status_stack[0]) *
+				   FRIBIDI_BIDI_MAX_RESOLVED_LEVELS);
+
+    for_run_list (pp, main_run_list)
+    {
+      FriBidiCharType this_type = RL_TYPE (pp);
+      if (FRIBIDI_IS_EXPLICIT_OR_BN (this_type))
+	{
+	  if (FRIBIDI_IS_STRONG (this_type))
+	    {			/* LRE, RLE, LRO, RLO */
+	      /* 1. Explicit Embeddings */
+	      /*   X2. With each RLE, compute the least greater odd
+	         embedding level. */
+	      /*   X3. With each LRE, compute the least greater even
+	         embedding level. */
+	      /* 2. Explicit Overrides */
+	      /*   X4. With each RLO, compute the least greater odd
+	         embedding level. */
+	      /*   X5. With each LRO, compute the least greater even
+	         embedding level. */
+	      new_override = FRIBIDI_EXPLICIT_TO_OVERRIDE_DIR (this_type);
+	      for (i = RL_LEN (pp); i; i--)
+		{
+		  new_level =
+		    ((level + FRIBIDI_DIR_TO_LEVEL (this_type) + 2) & ~1) -
+		    FRIBIDI_DIR_TO_LEVEL (this_type);
+		  PUSH_STATUS;
+		}
+	    }
+	  else if (this_type == FRIBIDI_TYPE_PDF)
+	    {
+	      /* 3. Terminating Embeddings and overrides */
+	      /*   X7. With each PDF, determine the matching embedding or
+	         override code. */
+	      for (i = RL_LEN (pp); i; i--)
+		POP_STATUS;
+	    }
+
+	  /* X9. Remove all RLE, LRE, RLO, LRO, PDF, and BN codes. */
+	  /* Remove element and add it to explicits_list */
+	  RL_LEVEL (pp) = FRIBIDI_SENTINEL;
+	  temp_link.next = pp->next;
+	  move_node_before (pp, explicits_list);
+	  pp = &temp_link;
+	}
+      else
+	{
+	  /* X6. For all types besides RLE, LRE, RLO, LRO, and PDF:
+	     a. Set the level of the current character to the current
+	     embedding level.
+	     b. Whenever the directional override status is not neutral,
+	     reset the current character type to the directional override
+	     status. */
+	  RL_LEVEL (pp) = level;
+	  if (!FRIBIDI_IS_NEUTRAL (override))
+	    RL_TYPE (pp) = override;
+	}
+      /* X8. All explicit directional embeddings and overrides are
+         completely terminated at the end of each paragraph. Paragraph
+         separators are not included in the embedding. */
+      /* This function is running on a single paragraph, so we can do
+         X8 after all the input is processed. */
+    }
+
+    /* Implementing X8. It has no effect on a single paragraph! */
+    level = base_level;
+    override = FRIBIDI_TYPE_ON;
+    stack_size = 0;
+    over_pushed = 0;
+
+    fribidi_free (status_stack);
+  }
+  /* X10. The remaining rules are applied to each run of characters at the
+     same level. For each run, determine the start-of-level-run (sor) and
+     end-of-level-run (eor) type, either L or R. This depends on the
+     higher of the two levels on either side of the boundary (at the start
+     or end of the paragraph, the level of the 'other' run is the base
+     embedding level). If the higher level is odd, the type is R, otherwise
+     it is L. */
+  /* Resolving Implicit Levels can be done out of X10 loop, so only change
+     of Resolving Weak Types and Resolving Neutral Types is needed. */
+
+  compact_list (main_run_list);
+
+# if DEBUG
+  if UNLIKELY
+    (fribidi_debug_status ())
+    {
+      print_types_re (main_run_list);
+      print_bidi_string (bidi_types, len);
+      print_resolved_levels (main_run_list);
+      print_resolved_types (main_run_list);
+    }
+# endif	/* DEBUG */
+
+  /* 4. Resolving weak types */
+  DBG ("resolving weak types");
+  {
+    FriBidiCharType last_strong, prev_type_orig;
+    fribidi_boolean w4;
+
+    last_strong = base_dir;
+
+    for_run_list (pp, main_run_list)
+    {
+      register FriBidiCharType prev_type, this_type, next_type;
+
+      prev_type = PREV_TYPE_OR_SOR (pp);
+      this_type = RL_TYPE (pp);
+      next_type = NEXT_TYPE_OR_EOR (pp);
+
+      if (FRIBIDI_IS_STRONG (prev_type))
+	last_strong = prev_type;
+
+      /* W1. NSM
+         Examine each non-spacing mark (NSM) in the level run, and change the
+         type of the NSM to the type of the previous character. If the NSM
+         is at the start of the level run, it will get the type of sor. */
+      /* Implementation note: it is important that if the previous character
+         is not sor, then we should merge this run with the previous,
+         because of rules like W5, that we assume all of a sequence of
+         adjacent ETs are in one FriBidiRun. */
+      if (this_type == FRIBIDI_TYPE_NSM)
+	{
+	  if (RL_LEVEL (pp->prev) == RL_LEVEL (pp))
+	    pp = merge_with_prev (pp);
+	  else
+	    RL_TYPE (pp) = prev_type;
+	  continue;		/* As we know the next condition cannot be true. */
+	}
+
+      /* W2: European numbers. */
+      if (this_type == FRIBIDI_TYPE_EN && last_strong == FRIBIDI_TYPE_AL)
+	{
+	  RL_TYPE (pp) = FRIBIDI_TYPE_AN;
+
+	  /* Resolving dependency of loops for rules W1 and W2, so we
+	     can merge them in one loop. */
+	  if (next_type == FRIBIDI_TYPE_NSM)
+	    RL_TYPE (pp->next) = FRIBIDI_TYPE_AN;
+	}
+    }
+
+
+    last_strong = base_dir;
+    /* Resolving dependency of loops for rules W4 and W5, W5 may
+       want to prevent W4 to take effect in the next turn, do this 
+       through "w4". */
+    w4 = true;
+    /* Resolving dependency of loops for rules W4 and W5 with W7,
+       W7 may change an EN to L but it sets the prev_type_orig if needed,
+       so W4 and W5 in next turn can still do their works. */
+    prev_type_orig = FRIBIDI_TYPE_ON;
+
+    for_run_list (pp, main_run_list)
+    {
+      register FriBidiCharType prev_type, this_type, next_type;
+
+      prev_type = PREV_TYPE_OR_SOR (pp);
+      this_type = RL_TYPE (pp);
+      next_type = NEXT_TYPE_OR_EOR (pp);
+
+      if (FRIBIDI_IS_STRONG (prev_type))
+	last_strong = prev_type;
+
+      /* W3: Change ALs to R. */
+      if (this_type == FRIBIDI_TYPE_AL)
+	{
+	  RL_TYPE (pp) = FRIBIDI_TYPE_RTL;
+	  w4 = true;
+	  prev_type_orig = FRIBIDI_TYPE_ON;
+	  continue;
+	}
+
+      /* W4. A single european separator changes to a european number.
+         A single common separator between two numbers of the same type
+         changes to that type. */
+      if (w4
+	  && RL_LEN (pp) == 1 && FRIBIDI_IS_ES_OR_CS (this_type)
+	  && FRIBIDI_IS_NUMBER (prev_type_orig)
+	  && prev_type_orig == next_type
+	  && (prev_type_orig == FRIBIDI_TYPE_EN
+	      || this_type == FRIBIDI_TYPE_CS))
+	{
+	  RL_TYPE (pp) = prev_type;
+	  this_type = RL_TYPE (pp);
+	}
+      w4 = true;
+
+      /* W5. A sequence of European terminators adjacent to European
+         numbers changes to All European numbers. */
+      if (this_type == FRIBIDI_TYPE_ET
+	  && (prev_type_orig == FRIBIDI_TYPE_EN
+	      || next_type == FRIBIDI_TYPE_EN))
+	{
+	  RL_TYPE (pp) = FRIBIDI_TYPE_EN;
+	  w4 = false;
+	  this_type = RL_TYPE (pp);
+	}
+
+      /* W6. Otherwise change separators and terminators to other neutral. */
+      if (FRIBIDI_IS_NUMBER_SEPARATOR_OR_TERMINATOR (this_type))
+	RL_TYPE (pp) = FRIBIDI_TYPE_ON;
+
+      /* W7. Change european numbers to L. */
+      if (this_type == FRIBIDI_TYPE_EN && last_strong == FRIBIDI_TYPE_LTR)
+	{
+	  RL_TYPE (pp) = FRIBIDI_TYPE_LTR;
+	  prev_type_orig = (RL_LEVEL (pp) == RL_LEVEL (pp->next) ?
+			    FRIBIDI_TYPE_EN : FRIBIDI_TYPE_ON);
+	}
+      else
+	prev_type_orig = PREV_TYPE_OR_SOR (pp->next);
+    }
+  }
+
+  compact_neutrals (main_run_list);
+
+# if DEBUG
+  if UNLIKELY
+    (fribidi_debug_status ())
+    {
+      print_resolved_levels (main_run_list);
+      print_resolved_types (main_run_list);
+    }
+# endif	/* DEBUG */
+
+  /* 5. Resolving Neutral Types */
+  DBG ("resolving neutral types");
+  {
+    /* N1. and N2.
+       For each neutral, resolve it. */
+    for_run_list (pp, main_run_list)
+    {
+      FriBidiCharType prev_type, this_type, next_type;
+
+      /* "European and Arabic numbers are treated as though they were R"
+         FRIBIDI_CHANGE_NUMBER_TO_RTL does this. */
+      this_type = FRIBIDI_CHANGE_NUMBER_TO_RTL (RL_TYPE (pp));
+      prev_type = FRIBIDI_CHANGE_NUMBER_TO_RTL (PREV_TYPE_OR_SOR (pp));
+      next_type = FRIBIDI_CHANGE_NUMBER_TO_RTL (NEXT_TYPE_OR_EOR (pp));
+
+      if (FRIBIDI_IS_NEUTRAL (this_type))
+	RL_TYPE (pp) = (prev_type == next_type) ?
+	  /* N1. */ prev_type :
+	  /* N2. */ FRIBIDI_EMBEDDING_DIRECTION (pp);
+    }
+  }
+
+  compact_list (main_run_list);
+
+# if DEBUG
+  if UNLIKELY
+    (fribidi_debug_status ())
+    {
+      print_resolved_levels (main_run_list);
+      print_resolved_types (main_run_list);
+    }
+# endif	/* DEBUG */
+
+  /* 6. Resolving implicit levels */
+  DBG ("resolving implicit levels");
+  {
+    max_level = base_level;
+
+    for_run_list (pp, main_run_list)
+    {
+      FriBidiCharType this_type;
+      int level;
+
+      this_type = RL_TYPE (pp);
+      level = RL_LEVEL (pp);
+
+      /* I1. Even */
+      /* I2. Odd */
+      if (FRIBIDI_IS_NUMBER (this_type))
+	RL_LEVEL (pp) = (level + 2) & ~1;
+      else
+	RL_LEVEL (pp) =
+	  level +
+	  (FRIBIDI_LEVEL_IS_RTL (level) ^ FRIBIDI_DIR_TO_LEVEL (this_type));
+
+      if (RL_LEVEL (pp) > max_level)
+	max_level = RL_LEVEL (pp);
+    }
+  }
+
+  compact_list (main_run_list);
+
+# if DEBUG
+  if UNLIKELY
+    (fribidi_debug_status ())
+    {
+      print_bidi_string (bidi_types, len);
+      print_resolved_levels (main_run_list);
+      print_resolved_types (main_run_list);
+    }
+# endif	/* DEBUG */
+
+/* Reinsert the explicit codes & BN's that are already removed, from the
+   explicits_list to main_run_list. */
+  DBG ("reinserting explicit codes");
+  if UNLIKELY
+    (explicits_list->next != explicits_list)
+    {
+      register FriBidiRun *p;
+      register fribidi_boolean stat =
+	shadow_run_list (main_run_list, explicits_list, true);
+      explicits_list = NULL;
+      if UNLIKELY
+	(!stat) goto out;
+
+      /* Set level of inserted explicit chars to that of their previous
+       * char, such that they do not affect reordering. */
+      p = main_run_list->next;
+      if (p != main_run_list && p->level == FRIBIDI_SENTINEL)
+	p->level = base_level;
+      for_run_list (p, main_run_list) if (p->level == FRIBIDI_SENTINEL)
+	p->level = p->prev->level;
+    }
+
+# if DEBUG
+  if UNLIKELY
+    (fribidi_debug_status ())
+    {
+      print_types_re (main_run_list);
+      print_resolved_levels (main_run_list);
+      print_resolved_types (main_run_list);
+    }
+# endif	/* DEBUG */
+
+  DBG ("reset the embedding levels, 1, 2, 3.");
+  {
+    register int j, state, pos;
+    register FriBidiCharType char_type;
+    register FriBidiRun *p, *q, *list;
+
+    /* L1. Reset the embedding levels of some chars:
+       1. segment separators,
+       2. paragraph separators,
+       3. any sequence of whitespace characters preceding a segment
+       separator or paragraph separator, and
+       ... (to be continued in fribidi_reorder_line()). */
+    list = new_run_list ();
+    if UNLIKELY
+      (!list) goto out;
+    q = list;
+    state = 1;
+    pos = len - 1;
+    for (j = len - 1; j >= -1; j--)
+      {
+	/* close up the open link at the end */
+	if (j >= 0)
+	  char_type = bidi_types[j];
+	else
+	  char_type = FRIBIDI_TYPE_ON;
+	if (!state && FRIBIDI_IS_SEPARATOR (char_type))
+	  {
+	    state = 1;
+	    pos = j;
+	  }
+	else if (state && !FRIBIDI_IS_EXPLICIT_OR_SEPARATOR_OR_BN_OR_WS
+		 (char_type))
+	  {
+	    state = 0;
+	    p = new_run ();
+	    if UNLIKELY
+	      (!p)
+	      {
+		free_run_list (list);
+		goto out;
+	      }
+	    p->pos = j + 1;
+	    p->len = pos - j;
+	    p->type = base_dir;
+	    p->level = base_level;
+	    move_node_before (p, q);
+	    q = p;
+	  }
+      }
+    if UNLIKELY
+      (!shadow_run_list (main_run_list, list, false)) goto out;
+  }
+
+# if DEBUG
+  if UNLIKELY
+    (fribidi_debug_status ())
+    {
+      print_types_re (main_run_list);
+      print_resolved_levels (main_run_list);
+      print_resolved_types (main_run_list);
+    }
+# endif	/* DEBUG */
+
+  {
+    FriBidiStrIndex pos = 0;
+    for_run_list (pp, main_run_list)
+    {
+      register FriBidiStrIndex l;
+      register FriBidiLevel level = pp->level;
+      for (l = pp->len; l; l--)
+	embedding_levels[pos++] = level;
+    }
+  }
+
+  status = true;
+
+out:
+  DBG ("leaving fribidi_get_par_embedding_levels");
+
+  if (main_run_list)
+    free_run_list (main_run_list);
+  if UNLIKELY
+    (explicits_list) free_run_list (explicits_list);
+
+  return status ? max_level + 1 : 0;
+}
+
+
+static void
+bidi_string_reverse (
+  FriBidiChar *str,
+  const FriBidiStrIndex len
+)
+{
+  FriBidiStrIndex i;
+
+  fribidi_assert (str);
+
+  for (i = 0; i < len / 2; i++)
+    {
+      FriBidiChar tmp = str[i];
+      str[i] = str[len - 1 - i];
+      str[len - 1 - i] = tmp;
+    }
+}
+
+static void
+index_array_reverse (
+  FriBidiStrIndex *arr,
+  const FriBidiStrIndex len
+)
+{
+  FriBidiStrIndex i;
+
+  fribidi_assert (arr);
+
+  for (i = 0; i < len / 2; i++)
+    {
+      FriBidiStrIndex tmp = arr[i];
+      arr[i] = arr[len - 1 - i];
+      arr[len - 1 - i] = tmp;
+    }
+}
+
+
+FRIBIDI_ENTRY FriBidiLevel
+fribidi_reorder_line (
+  /* input */
+  FriBidiFlags flags, /* reorder flags */
+  const FriBidiCharType *bidi_types,
+  const FriBidiStrIndex len,
+  const FriBidiStrIndex off,
+  const FriBidiParType base_dir,
+  /* input and output */
+  FriBidiLevel *embedding_levels,
+  FriBidiChar *visual_str,
+  /* output */
+  FriBidiStrIndex *map
+)
+{
+  fribidi_boolean status = false;
+  FriBidiLevel max_level = 0;
+
+  if UNLIKELY
+    (len == 0)
+    {
+      status = true;
+      goto out;
+    }
+
+  DBG ("in fribidi_reorder_line");
+
+  fribidi_assert (bidi_types);
+  fribidi_assert (embedding_levels);
+
+  DBG ("reset the embedding levels, 4. whitespace at the end of line");
+  {
+    register FriBidiStrIndex i;
+
+    /* L1. Reset the embedding levels of some chars:
+       4. any sequence of white space characters at the end of the line. */
+    for (i = off + len - 1; i >= off &&
+	 FRIBIDI_IS_EXPLICIT_OR_BN_OR_WS (bidi_types[i]); i--)
+      embedding_levels[i] = FRIBIDI_DIR_TO_LEVEL (base_dir);
+  }
+
+  /* 7. Reordering resolved levels */
+  {
+    register FriBidiLevel level;
+    register FriBidiStrIndex i;
+
+    /* Reorder both the outstring and the order array */
+    {
+      if (FRIBIDI_TEST_BITS (flags, FRIBIDI_FLAG_REORDER_NSM))
+	{
+	  /* L3. Reorder NSMs. */
+	  for (i = off + len - 1; i >= off; i--)
+	    if (FRIBIDI_LEVEL_IS_RTL (embedding_levels[i])
+		&& bidi_types[i] == FRIBIDI_TYPE_NSM)
+	      {
+		register FriBidiStrIndex seq_end = i;
+		level = embedding_levels[i];
+
+		for (i--; i >= off &&
+		     FRIBIDI_IS_EXPLICIT_OR_BN_OR_NSM (bidi_types[i])
+		     && embedding_levels[i] == level; i--)
+		  ;
+
+		if (i < off || embedding_levels[i] != level)
+		  {
+		    i++;
+		    DBG ("warning: NSM(s) at the beggining of level run");
+		  }
+
+		if (visual_str)
+		  {
+		    bidi_string_reverse (visual_str + i, seq_end - i + 1);
+		  }
+		if (map)
+		  {
+		    index_array_reverse (map + i, seq_end - i + 1);
+		  }
+	      }
+	}
+
+      /* Find max_level of the line.  We don't reuse the paragraph
+       * max_level, both for a cleaner API, and that the line max_level
+       * may be far less than paragraph max_level. */
+      for (i = off + len - 1; i >= off; i--)
+	if (embedding_levels[i] > max_level)
+	  max_level = embedding_levels[i];
+
+      /* L2. Reorder. */
+      for (level = max_level; level > 0; level--)
+	for (i = off + len - 1; i >= off; i--)
+	  if (embedding_levels[i] >= level)
+	    {
+	      /* Find all stretches that are >= level_idx */
+	      register FriBidiStrIndex seq_end = i;
+	      for (i--; i >= off && embedding_levels[i] >= level; i--)
+		;
+
+	      if (visual_str)
+		bidi_string_reverse (visual_str + i + 1, seq_end - i);
+	      if (map)
+		index_array_reverse (map + i + 1, seq_end - i);
+	    }
+    }
+
+  }
+
+  status = true;
+
+out:
+
+  return status ? max_level + 1 : 0;
+}
+
+/* Editor directions:
+ * vim:textwidth=78:tabstop=8:shiftwidth=2:autoindent:cindent
+ */
diff -rupN orginal/scribus/fribidi/fribidi-bidi.h patched/scribus/fribidi/fribidi-bidi.h
--- orginal/scribus/fribidi/fribidi-bidi.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/fribidi/fribidi-bidi.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,149 @@
+/* FriBidi
+ * fribidi-bidi.h - bidirectional algorithm
+ *
+ * $Id: fribidi-bidi.h,v 1.15 2005/11/03 01:39:01 behdad Exp $
+ * $Author: behdad $
+ * $Date: 2005/11/03 01:39:01 $
+ * $Revision: 1.15 $
+ * $Source: /cvs/fribidi/fribidi2/lib/fribidi-bidi.h,v $
+ *
+ * Authors:
+ *   Behdad Esfahbod, 2001, 2002, 2004
+ *   Dov Grobgeld, 1999, 2000
+ *
+ * Copyright (C) 2004 Sharif FarsiWeb, Inc
+ * Copyright (C) 2001,2002 Behdad Esfahbod
+ * Copyright (C) 1999,2000 Dov Grobgeld
+ * 
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ * 
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library, in a file named COPYING; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA
+ * 
+ * For licensing issues, contact <license@farsiweb.info>.
+ */
+#ifndef _FRIBIDI_BIDI_H
+#define _FRIBIDI_BIDI_H
+
+#include "fribidi-common.h"
+
+#include "fribidi-types.h"
+#include "fribidi-flags.h"
+#include "fribidi-bidi-types.h"
+
+#include "fribidi-begindecls.h"
+
+#define fribidi_get_par_embedding_levels FRIBIDI_NAMESPACE(get_par_embedding_levels)
+/* fribidi_get_par_direction - get base paragraph direction
+ *
+ * This function finds the base direction of a single paragraph,
+ * as defined by rule P2 of the Unicode Bidirectional Algorithm available at
+ * http://www.unicode.org/reports/tr9/#P2.
+ *
+ * You typically do not need this function as
+ * fribidi_get_par_embedding_levels() knows how to compute base direction
+ * itself, but you may need this to implement a more sophisticated paragraph
+ * direction handling.  Note that you can pass more than a paragraph to this
+ * function and the direction of the first non-neutral paragraph is returned,
+ * which is a very good heuristic to set direction of the neutral paragraphs
+ * at the beginning of text.  For other neutral paragraphs, you better use the
+ * direction of the previous paragraph.
+ *
+ * Returns: Base pargraph direction.  No weak paragraph direction is returned,
+ * only LTR, RTL, or ON.
+ */
+FRIBIDI_ENTRY FriBidiParType fribidi_get_par_direction (
+  const FriBidiCharType *bidi_types,	/* input list of bidi types as returned by
+					   fribidi_get_bidi_types() */
+  const FriBidiStrIndex len	/* input string length */
+);
+
+#define fribidi_get_par_embedding_levels FRIBIDI_NAMESPACE(get_par_embedding_levels)
+/* fribidi_get_par_embedding_levels - get bidi embedding levels of a paragraph
+ *
+ * This function finds the bidi embedding levels of a single paragraph,
+ * as defined by the Unicode Bidirectional Algorithm available at
+ * http://www.unicode.org/reports/tr9/.  This function implements rules P2 to
+ * I1 inclusive, and parts 1 to 3 of L1, except for rule X9 which is
+ *  implemented in fribidi_remove_bidi_marks().  Part 4 of L1 is implemented
+ *  in fribidi_reorder_line().
+ *
+ * There are a few macros defined in fribidi-bidi-types.h to work with this
+ * embedding levels.
+ *
+ * Returns: Maximum level found plus one, or zero if any error occured
+ * (memory allocation failure most probably).
+ */
+FRIBIDI_ENTRY FriBidiLevel
+fribidi_get_par_embedding_levels (
+  const FriBidiCharType *bidi_types,	/* input list of bidi types as returned by
+					   fribidi_get_bidi_types() */
+  const FriBidiStrIndex len,	/* input string length of the paragraph */
+  FriBidiParType *pbase_dir,	/* requested and resolved paragraph
+				 * base direction */
+  FriBidiLevel *embedding_levels	/* output list of embedding levels */
+) FRIBIDI_GNUC_WARN_UNUSED;
+
+#define fribidi_reorder_line FRIBIDI_NAMESPACE(reorder_line)
+/* fribidi_reorder_line - reorder a line of logical string to visual
+ *
+ * This function reorders the characters in a line of text from logical to
+ * final visual order.  This function implements part 4 of rule L1, and rules
+ * L2 and L3 of the Unicode Bidirectional Algorithm available at
+ * http://www.unicode.org/reports/tr9/#Reordering_Resolved_Levels.
+ *
+ * As a side effect it also sets position maps if not NULL.
+ *
+ * You should provide the resolved paragraph direction and embedding levels as
+ * set by fribidi_get_par_embedding_levels().  Also note that the embedding
+ * levels may change a bit.  To be exact, the embedding level of any sequence
+ * of white space at the end of line is reset to the paragraph embedding level
+ * (That is part 4 of rule L1).
+ *
+ * Note that the bidi types and embedding levels are not reordered.  You can
+ * reorder these (or any other) arrays using the map later.  The user is
+ * responsible to initialize map to something sensible, like an identity
+ * mapping, or pass NULL if no map is needed.
+ *
+ * There is an optional part to this function, which is whether non-spacing
+ * marks for right-to-left parts of the text should be reordered to come after
+ * their base characters in the visual string or not.  Most rendering engines
+ * expect this behavior, but console-based systems for example do not like it.
+ * This is controlled by the FRIBIDI_FLAG_REORDER_NSM flag.  The flag is on
+ * in FRIBIDI_FLAGS_DEFAULT.
+ *
+ * Returns: Maximum level found in this line plus one, or zero if any error
+ * occured (memory allocation failure most probably).
+ */
+     FRIBIDI_ENTRY FriBidiLevel fribidi_reorder_line (
+  FriBidiFlags flags, /* reorder flags */
+  const FriBidiCharType *bidi_types,	/* input list of bidi types as returned by
+					   fribidi_get_bidi_types() */
+  const FriBidiStrIndex len,	/* input length of the line */
+  const FriBidiStrIndex off,	/* input offset of the beginning of the line
+				   in the paragraph */
+  const FriBidiParType base_dir,	/* resolved paragraph base direction */
+  FriBidiLevel *embedding_levels,	/* input list of embedding levels,
+					   as returned by
+					   fribidi_get_par_embedding_levels */
+  FriBidiChar *visual_str,	/* visual string to reorder */
+  FriBidiStrIndex *map		/* a map of string indices which is reordered
+				 * to reflect where each glyph ends up. */
+) FRIBIDI_GNUC_WARN_UNUSED;
+
+#include "fribidi-enddecls.h"
+
+#endif /* !_FRIBIDI_BIDI_H */
+/* Editor directions:
+ * vim:textwidth=78:tabstop=8:shiftwidth=2:autoindent:cindent
+ */
diff -rupN orginal/scribus/fribidi/fribidi-common.h patched/scribus/fribidi/fribidi-common.h
--- orginal/scribus/fribidi/fribidi-common.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/fribidi/fribidi-common.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,130 @@
+/* FriBidi
+ * fribidi-common.h - common include for library headers
+ *
+ * $Id: fribidi-common.h,v 1.13 2007/04/05 16:13:24 behdad Exp $
+ * $Author: behdad $
+ * $Date: 2007/04/05 16:13:24 $
+ * $Revision: 1.13 $
+ * $Source: /cvs/fribidi/fribidi2/lib/fribidi-common.h,v $
+ *
+ * Author:
+ *   Behdad Esfahbod, 2004
+ *
+ * Copyright (C) 2004 Sharif FarsiWeb, Inc.
+ * 
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ * 
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library, in a file named COPYING; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA
+ * 
+ * For licensing issues, contact <license@farsiweb.info>.
+ */
+#ifndef _FRIBIDI_COMMON_H
+#define _FRIBIDI_COMMON_H
+
+#if DONT_HAVE_FRIBIDI_CONFIG_H+0
+# define FRIBIDI "fribidi"
+# define FRIBIDI_NAME "fribidi"
+# define FRIBIDI_VERSION "unknown"
+# define FRIBIDI_BUGREPORT "unknown"
+# define FRIBIDI_INTERFACE_VERSION_STRING "unknown"
+#else /* !DONT_HAVE_FRIBIDI_CONFIG_H */
+# include "fribidi-config.h"
+#endif /* !DONT_HAVE_FRIBIDI_CONFIG_H */
+
+#if HAVE_FRIBIDI_CUSTOM_H+0
+# include <fribidi-custom.h>
+#endif /* HAVE_FRIBIDI_CUSTOM_H */
+
+/* FRIBIDI_NAMESPACE is a macro used to name library symbols. */
+#ifndef FRIBIDI_NAMESPACE
+# define FRIBIDI_NAMESPACE(SYMBOL) fribidi##_##SYMBOL
+#endif /* !FRIBIDI_NAMESPACE */
+
+/* FRIBIDI_ENTRY is a macro used to declare library entry points. */
+#ifndef FRIBIDI_ENTRY
+# if (defined(WIN32)) || (defined(_WIN32_WCE))
+#  define FRIBIDI_ENTRY __declspec(dllimport)
+# else /* !WIN32 */
+#  define FRIBIDI_ENTRY		/* empty */
+# endif	/* !WIN32 */
+#endif /* !FRIBIDI_ENTRY */
+
+#if FRIBIDI_USE_GLIB+0
+# ifndef __FRIBIDI_DOC
+#  include <glib/gmacros.h>
+# endif	/* !__FRIBIDI_DOC */
+# define FRIBIDI_BEGIN_DECLS		G_BEGIN_DECLS
+# define FRIBIDI_END_DECLS		G_END_DECLS
+# define FRIBIDI_GNUC_CONST		G_GNUC_CONST
+# define FRIBIDI_GNUC_DEPRECATED	G_GNUC_DEPRECATED
+# if __GNUC__ > 2
+#  define FRIBIDI_GNUC_WARN_UNUSED	\
+	__attribute__((__warn_unused_result__))
+#  define FRIBIDI_GNUC_MALLOC		\
+	__attribute__((__malloc__))
+#  define FRIBIDI_GNUC_HIDDEN		\
+	__attribute__((__visibility__ ("hidden")))
+# else /* __GNUC__ <= 2 */
+#  define FRIBIDI_GNUC_WARN_UNUSED
+#  define FRIBIDI_GNUC_MALLOC
+#  define FRIBIDI_GNUC_HIDDEN
+# endif	/* __GNUC__ <= 2 */
+#else /* !FRIBIDI_USE_GLIB */
+# define FRIBIDI_GNUC_CONST
+# define FRIBIDI_GNUC_DEPRECATED
+# define FRIBIDI_GNUC_WARN_UNUSED
+# define FRIBIDI_GNUC_MALLOC
+# define FRIBIDI_GNUC_HIDDEN
+#endif /* !FRIBIDI_USE_GLIB */
+
+/* FRIBIDI_BEGIN_DECLS should be used at the beginning of your declarations,
+ * so that C++ compilers don't mangle their names.  Use FRIBIDI_END_DECLS at
+ * the end of C declarations. */
+#ifndef FRIBIDI_BEGIN_DECLS
+# ifdef __cplusplus
+#  define FRIBIDI_BEGIN_DECLS extern "C" {
+#  define FRIBIDI_END_DECLS }
+# else /* !__cplusplus */
+#  define FRIBIDI_BEGIN_DECLS	/* empty */
+#  define FRIBIDI_END_DECLS	/* empty */
+# endif	/* !__cplusplus */
+#endif /* !FRIBIDI_BEGIN_DECLS */
+
+
+
+
+#define fribidi_debug_status FRIBIDI_NAMESPACE(debug_status)
+FRIBIDI_ENTRY int fribidi_debug_status (
+  void
+);
+#define fribidi_set_debug FRIBIDI_NAMESPACE(set_debug)
+FRIBIDI_ENTRY int
+fribidi_set_debug (
+  int state		/* new state to set */
+);
+
+
+
+
+
+
+
+
+
+
+
+#endif /* !_FRIBIDI_COMMON_H */
+/* Editor directions:
+ * vim:textwidth=78:tabstop=8:shiftwidth=2:autoindent:cindent
+ */
diff -rupN orginal/scribus/fribidi/fribidi-config.h patched/scribus/fribidi/fribidi-config.h
--- orginal/scribus/fribidi/fribidi-config.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/fribidi/fribidi-config.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,26 @@
+/* lib/fribidi-config.h.  Generated from fribidi-config.h.in by configure. */
+/* Not copyrighted, in public domain. */
+#ifndef FRIBIDI_CONFIG_H
+#define FRIBIDI_CONFIG_H
+
+#define FRIBIDI "fribidi"
+#define FRIBIDI_NAME "GNU FriBidi"
+#define FRIBIDI_BUGREPORT "http://fribidi.org/bug"
+
+#define FRIBIDI_VERSION "0.19.2"
+#define FRIBIDI_MAJOR_VERSION 0
+#define FRIBIDI_MINOR_VERSION 19
+#define FRIBIDI_MICRO_VERSION 2
+#define FRIBIDI_INTERFACE_VERSION 3
+#define FRIBIDI_INTERFACE_VERSION_STRING "3"
+
+/* Define to 1 if you want charset conversion codes in the library */
+#define FRIBIDI_CHARSETS 1
+
+/* Define to 1 if you want to use glib */
+#define FRIBIDI_USE_GLIB 0
+
+/* The size of a `int', as computed by sizeof. */
+#define FRIBIDI_SIZEOF_INT 4
+
+#endif /* FRIBIDI_CONFIG_H */
diff -rupN orginal/scribus/fribidi/fribidi-deprecated.c patched/scribus/fribidi/fribidi-deprecated.c
--- orginal/scribus/fribidi/fribidi-deprecated.c	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/fribidi/fribidi-deprecated.c	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,314 @@
+/* FriBidi
+ * fribidi-deprecated.c - deprecated interfaces.
+ *
+ * $Id: fribidi-deprecated.c,v 1.6 2006/06/01 22:53:55 behdad Exp $
+ * $Author: behdad $
+ * $Date: 2006/06/01 22:53:55 $
+ * $Revision: 1.6 $
+ * $Source: /cvs/fribidi/fribidi2/lib/fribidi-deprecated.c,v $
+ *
+ * Authors:
+ *   Behdad Esfahbod, 2001, 2002, 2004
+ *   Dov Grobgeld, 1999, 2000
+ *
+ * Copyright (C) 2004 Sharif FarsiWeb, Inc
+ * Copyright (C) 2001,2002 Behdad Esfahbod
+ * Copyright (C) 1999,2000 Dov Grobgeld
+ * 
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ * 
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library, in a file named COPYING; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA
+ * 
+ * For licensing issues, contact <license@farsiweb.info>.
+ */
+
+#include "common.h"
+
+#undef FRIBIDI_NO_DEPRECATED
+
+#include <fribidi-deprecated.h>
+#include <fribidi.h>
+
+#if FRIBIDI_NO_DEPRECATED+0
+#else
+
+static FriBidiFlags flags = FRIBIDI_FLAGS_DEFAULT | FRIBIDI_FLAGS_ARABIC;
+
+FRIBIDI_ENTRY fribidi_boolean
+fribidi_set_mirroring (
+  /* input */
+  fribidi_boolean state
+)
+{
+  return FRIBIDI_ADJUST_AND_TEST_BITS (flags, FRIBIDI_FLAG_SHAPE_MIRRORING, state);
+}
+
+FRIBIDI_ENTRY fribidi_boolean
+fribidi_mirroring_status (
+  void
+)
+{
+  return FRIBIDI_TEST_BITS (flags, FRIBIDI_FLAG_SHAPE_MIRRORING);
+}
+
+FRIBIDI_ENTRY fribidi_boolean
+fribidi_set_reorder_nsm (
+  /* input */
+  fribidi_boolean state
+)
+{
+  return FRIBIDI_ADJUST_AND_TEST_BITS (flags, FRIBIDI_FLAG_REORDER_NSM, state);
+}
+
+fribidi_boolean
+fribidi_reorder_nsm_status (
+  void
+)
+{
+  return FRIBIDI_TEST_BITS (flags, FRIBIDI_FLAG_REORDER_NSM);
+}
+
+
+
+
+FRIBIDI_ENTRY FriBidiLevel
+fribidi_log2vis_get_embedding_levels (
+  const FriBidiCharType *bidi_types,	/* input list of bidi types as returned by
+					   fribidi_get_bidi_types() */
+  const FriBidiStrIndex len,	/* input string length of the paragraph */
+  FriBidiParType *pbase_dir,	/* requested and resolved paragraph
+				 * base direction */
+  FriBidiLevel *embedding_levels	/* output list of embedding levels */
+)
+{
+  return fribidi_get_par_embedding_levels (bidi_types, len, pbase_dir, embedding_levels);
+}
+
+FRIBIDI_ENTRY FriBidiCharType
+fribidi_get_type (
+  FriBidiChar ch		/* input character */
+)
+{
+  return fribidi_get_bidi_type (ch);
+}
+
+FRIBIDI_ENTRY FriBidiCharType
+fribidi_get_type_internal (
+  FriBidiChar ch		/* input character */
+)
+{
+  return fribidi_get_bidi_type (ch);
+}
+
+
+
+FRIBIDI_ENTRY FriBidiStrIndex
+fribidi_remove_bidi_marks (
+  FriBidiChar *str,
+  const FriBidiStrIndex len,
+  FriBidiStrIndex *positions_to_this,
+  FriBidiStrIndex *position_from_this_list,
+  FriBidiLevel *embedding_levels
+)
+{
+  register FriBidiStrIndex i, j = 0;
+  fribidi_boolean private_from_this = false;
+  fribidi_boolean status = false;
+
+  if UNLIKELY
+    (len == 0)
+    {
+      status = true;
+      goto out;
+    }
+
+  DBG ("in fribidi_remove_bidi_marks");
+
+  fribidi_assert (str);
+
+  /* If to_this is not NULL, we must have from_this as well. If it is
+     not given by the caller, we have to make a private instance of it. */
+  if (positions_to_this && !position_from_this_list)
+    {
+      position_from_this_list = fribidi_malloc (sizeof
+						(position_from_this_list[0]) *
+						len);
+      if UNLIKELY
+	(!position_from_this_list) goto out;
+      private_from_this = true;
+      for (i = 0; i < len; i++)
+	position_from_this_list[positions_to_this[i]] = i;
+    }
+
+  for (i = 0; i < len; i++)
+    if (!FRIBIDI_IS_EXPLICIT_OR_BN (fribidi_get_bidi_type (str[i]))
+	&& str[i] != FRIBIDI_CHAR_LRM && str[i] != FRIBIDI_CHAR_RLM)
+      {
+	str[j] = str[i];
+	if (embedding_levels)
+	  embedding_levels[j] = embedding_levels[i];
+	if (position_from_this_list)
+	  position_from_this_list[j] = position_from_this_list[i];
+	j++;
+      }
+
+  /* Convert the from_this list to to_this */
+  if (positions_to_this)
+    {
+      for (i = 0; i < len; i++)
+	positions_to_this[i] = -1;
+      for (i = 0; i < len; i++)
+	positions_to_this[position_from_this_list[i]] = i;
+    }
+
+  status = true;
+
+out:
+
+  if (private_from_this)
+    fribidi_free (position_from_this_list);
+
+  return status ? j : -1;
+}
+
+
+
+FRIBIDI_ENTRY FriBidiLevel
+fribidi_log2vis (
+  /* input */
+  const FriBidiChar *str,
+  FriBidiStrIndex len,
+  /* input and output */
+  FriBidiParType *pbase_dir,
+  /* output */
+  FriBidiChar *visual_str,
+  FriBidiStrIndex *positions_L_to_V,
+  FriBidiStrIndex *positions_V_to_L,
+  FriBidiLevel *embedding_levels
+)
+{
+  register FriBidiStrIndex i;
+  FriBidiLevel max_level = 0;
+  fribidi_boolean private_V_to_L = false;
+  fribidi_boolean private_embedding_levels = false;
+  fribidi_boolean status = false;
+  FriBidiArabicProp *ar_props = NULL;
+  FriBidiCharType *bidi_types = NULL;
+
+  if UNLIKELY
+    (len == 0)
+    {
+      status = true;
+      goto out;
+    }
+
+  DBG ("in fribidi_log2vis");
+
+  fribidi_assert (str);
+  fribidi_assert (pbase_dir);
+
+  bidi_types = fribidi_malloc (len * sizeof bidi_types[0]);
+  if (!bidi_types)
+    goto out;
+
+  fribidi_get_bidi_types (str, len, bidi_types);
+
+  if (!embedding_levels)
+    {
+      embedding_levels = fribidi_malloc (len * sizeof embedding_levels[0]);
+      if (!embedding_levels)
+	goto out;
+      private_embedding_levels = true;
+    }
+
+  max_level = fribidi_get_par_embedding_levels (bidi_types, len, pbase_dir,
+						embedding_levels) - 1;
+  if UNLIKELY
+    (max_level < 0) goto out;
+
+  /* If l2v is to be calculated we must have v2l as well. If it is not
+     given by the caller, we have to make a private instance of it. */
+  if (positions_L_to_V && !positions_V_to_L)
+    {
+      positions_V_to_L =
+	(FriBidiStrIndex *) fribidi_malloc (sizeof (FriBidiStrIndex) * len);
+      if (!positions_V_to_L)
+	goto out;
+      private_V_to_L = true;
+    }
+
+  /* Set up the ordering array to identity order */
+  if (positions_V_to_L)
+    {
+      for (i = 0; i < len; i++)
+	positions_V_to_L[i] = i;
+    }
+
+
+  if (visual_str)
+    {
+      /* Using memcpy instead
+      for (i = len - 1; i >= 0; i--)
+	visual_str[i] = str[i];
+      */
+      memcpy (visual_str, str, len * sizeof (*visual_str));
+
+      /* Arabic joining */
+      ar_props = fribidi_malloc (len * sizeof ar_props[0]);
+      fribidi_get_joining_types (str, len, ar_props);
+      fribidi_join_arabic (bidi_types, len, embedding_levels, ar_props);
+
+      fribidi_shape (flags, embedding_levels, len, ar_props, visual_str);
+    }
+
+  /* line breaking goes here, but we assume one line in this function */
+
+  /* and this should be called once per line, but again, we assume one
+   * line in this deprecated function */
+  status =
+    fribidi_reorder_line (flags, bidi_types, len, 0, *pbase_dir,
+			  embedding_levels, visual_str,
+			  positions_V_to_L);
+
+  /* Convert the v2l list to l2v */
+  if (positions_L_to_V)
+    {
+      for (i = 0; i < len; i++)
+	positions_L_to_V[i] = -1;
+      for (i = 0; i < len; i++)
+	positions_L_to_V[positions_V_to_L[i]] = i;
+    }
+
+out:
+
+  if (private_V_to_L)
+    fribidi_free (positions_V_to_L);
+
+  if (private_embedding_levels)
+    fribidi_free (embedding_levels);
+
+  if (ar_props)
+    fribidi_free (ar_props);
+
+  if (bidi_types)
+    fribidi_free (bidi_types);
+
+  return status ? max_level + 1 : 0;
+}
+
+#endif /* !FRIBIDI_NO_DEPRECATED */
+
+/* Editor directions:
+ * vim:textwidth=78:tabstop=8:shiftwidth=2:autoindent:cindent
+ */
diff -rupN orginal/scribus/fribidi/fribidi-deprecated.h patched/scribus/fribidi/fribidi-deprecated.h
--- orginal/scribus/fribidi/fribidi-deprecated.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/fribidi/fribidi-deprecated.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,243 @@
+/* FriBidi
+ * fribidi-deprecated.h - Deprecated interfaces
+ *
+ * $Id: fribidi-deprecated.h,v 1.3 2006/01/31 03:23:13 behdad Exp $
+ * $Author: behdad $
+ * $Date: 2006/01/31 03:23:13 $
+ * $Revision: 1.3 $
+ * $Source: /cvs/fribidi/fribidi2/lib/fribidi-deprecated.h,v $
+ *
+ * Author:
+ *   Behdad Esfahbod, 2004, 2005
+ *
+ * Copyright (C) 2004 Sharif FarsiWeb, Inc
+ * Copyright (C) 2004, 2005 Behdad Esfahbod
+ * 
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ * 
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library, in a file named COPYING; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA
+ * 
+ * For licensing issues, contact <license@farsiweb.info>.
+ */
+#ifndef _FRIBIDI_DEPRECATED_H
+#define _FRIBIDI_DEPRECATED_H
+
+#include "fribidi-common.h"
+
+#include "fribidi-types.h"
+
+#include "fribidi-bidi-types.h"
+
+#include "fribidi-begindecls.h"
+
+
+
+#define fribidi_mirroring_status FRIBIDI_NAMESPACE(mirroring_status)
+/* fribidi_mirroring_status - get current mirroring status
+ *
+ * This function is deprecated and only used with other deprecated functions.
+ */
+     FRIBIDI_ENTRY fribidi_boolean fribidi_mirroring_status (
+  void
+) FRIBIDI_GNUC_DEPRECATED;
+
+#define fribidi_set_mirroring FRIBIDI_NAMESPACE(set_mirroring)
+/* fribidi_set_mirroring - set mirroring on or off
+ *
+ * This function is used to turn character mirroring on or off.
+ * Character mirroring is the act of replacing a mirrorable glyph
+ * (character), eg. left paranthesis, with the matching glyph, 
+ * eg. right paranthesis, in a right-to-left resolved context.
+ * If your rendering engine does mirroring itself, you may want to 
+ * turn it off here.
+ *
+ * This flag is on by default.
+ * This function is deprecated and only used with other deprecated functions.
+ *
+ * Returns: the new mirroring status.
+ */
+     FRIBIDI_ENTRY fribidi_boolean fribidi_set_mirroring (
+  fribidi_boolean state		/* new state to set */
+) FRIBIDI_GNUC_DEPRECATED;
+
+
+#define fribidi_reorder_nsm_status FRIBIDI_NAMESPACE(reorder_nsm_status)
+/* fribidi_reorder_nsm_status - get current marks reordering status
+ *
+ * This function is deprecated and only used with other deprecated functions.
+ */
+     FRIBIDI_ENTRY fribidi_boolean fribidi_reorder_nsm_status (
+  void
+) FRIBIDI_GNUC_DEPRECATED;
+
+#define fribidi_set_reorder_nsm FRIBIDI_NAMESPACE(set_reorder_nsm)
+/* fribidi_set_reorder_nsm - set marks reordering on or off
+ *
+ * This function is used to turn non-spacing marks reordering on or
+ * off.  Reordering non-spacing marks is the act of placing non-spacing
+ * marks (bidi class NSM) after their base character in a right-to-left
+ * resolved context.  If your rendering engine expects non-spacing marks
+ * always after the base character in the memory representation of the
+ * visual string, you need this option on.  An example of where people
+ * may need it off is when rendering in the console when non-spacing
+ * marks cannot be applied on top of the base character.
+ *
+ * This flag is on by default.
+ * This function is deprecated and only used with other deprecated functions.
+ *
+ * Returns: the new marks reordering status.
+ */
+     FRIBIDI_ENTRY fribidi_boolean fribidi_set_reorder_nsm (
+  fribidi_boolean state		/* new state to set */
+) FRIBIDI_GNUC_DEPRECATED;
+
+
+
+
+/* fribidi_log2vis_get_embedding_levels - get embedding levels
+ *
+ * Deprecated. Replaced by fribidi_get_par_embedding_levels.
+ */
+#define fribidi_log2vis_get_embedding_levels FRIBIDI_NAMESPACE(log2vis_get_embedding_levels)
+FRIBIDI_ENTRY FriBidiLevel
+fribidi_log2vis_get_embedding_levels (
+  const FriBidiCharType *bidi_types,	/* input list of bidi types as returned by
+					   fribidi_get_bidi_types() */
+  const FriBidiStrIndex len,	/* input string length of the paragraph */
+  FriBidiParType *pbase_dir,	/* requested and resolved paragraph
+				 * base direction */
+  FriBidiLevel *embedding_levels	/* output list of embedding levels */
+) FRIBIDI_GNUC_DEPRECATED;
+
+/* fribidi_get_type - get character bidi type
+ *
+ * Deprecated. Replaced by fribidi_get_bidi_type.
+ */
+#define fribidi_get_type FRIBIDI_NAMESPACE(get_type)
+FRIBIDI_ENTRY FriBidiCharType
+fribidi_get_type (
+  FriBidiChar ch		/* input character */
+) FRIBIDI_GNUC_DEPRECATED;
+
+/* fribidi_get_type_internal - get character bidi type
+ *
+ * Deprecated. Replaced by fribidi_get_bidi_type.
+ */
+#define fribidi_get_type_internal FRIBIDI_NAMESPACE(get_type_internal)
+FRIBIDI_ENTRY FriBidiCharType
+fribidi_get_type_internal (
+  FriBidiChar ch		/* input character */
+) FRIBIDI_GNUC_DEPRECATED;
+
+#define fribidi_remove_bidi_marks FRIBIDI_NAMESPACE(remove_bidi_marks)
+/* fribidi_remove_bidi_marks - remove bidi marks out of an string
+ *
+ * This function removes the bidi and boundary-neutral marks out of an string
+ * and the accompanying lists.  It implements rule X9 of the Unicode
+ * Bidirectional Algorithm available at
+ * http://www.unicode.org/reports/tr9/#X9, with the exception that it removes
+ * U+200E LEFT-TO-RIGHT MARK and U+200F RIGHT-TO-LEFT MARK too.
+ *
+ * If any of the input lists are NULL, the list is skipped.  If str is the
+ * visual string, then positions_to_this is  positions_L_to_V and
+ * position_from_this_list is positions_V_to_L;  if str is the logical
+ * string, the other way. Moreover, the position maps should be filled with
+ * valid entries.
+ * 
+ * A position map pointing to a removed character is filled with -1. By the
+ * way, you should not use embedding_levels if str is visual string.
+ * 
+ * For best results this function should be run on a whole paragraph, not
+ * lines; but feel free to do otherwise if you know what you are doing.
+ * Deprecated.  Use fribidi_remove_special_chars instead.
+ *
+ * Returns: New length of the string, or -1 if an error occured (memory
+ * allocation failure most probably).
+ */
+FRIBIDI_ENTRY FriBidiStrIndex
+fribidi_remove_bidi_marks (
+  FriBidiChar *str,		/* input string to clean */
+  const FriBidiStrIndex len,	/* input string length */
+  FriBidiStrIndex *positions_to_this,	/* list mapping positions to the
+					   order used in str */
+  FriBidiStrIndex *position_from_this_list,	/* list mapping positions from the
+						   order used in str */
+  FriBidiLevel *embedding_levels	/* list of embedding levels */
+)
+     FRIBIDI_GNUC_WARN_UNUSED FRIBIDI_GNUC_DEPRECATED;
+
+
+#define fribidi_log2vis FRIBIDI_NAMESPACE(log2vis)
+/* fribidi_log2vis - get visual string
+ *
+ * This function converts the logical input string to the visual output
+ * strings as specified by the Unicode Bidirectional Algorithm.  As a side
+ * effect it also generates mapping lists between the two strings, and the
+ * list of embedding levels as defined by the algorithm.
+ *
+ * If NULL is passed as any of the the lists, the list is ignored and not
+ * filled.
+ *
+ * This function is obsolete because it only handles one-line paragraphs. 
+ * Please consider using other functions instead.  Deprecated.
+ *
+ * Returns: Maximum level found plus one, or zero if any error occured
+ * (memory allocation failure most probably).
+ */
+     FRIBIDI_ENTRY FriBidiLevel fribidi_log2vis (
+  const FriBidiChar *str,	/* input logical string */
+  const FriBidiStrIndex len,	/* input string length */
+  FriBidiParType *pbase_dir,	/* requested and resolved paragraph
+				 * base direction */
+  FriBidiChar *visual_str,	/* output visual string */
+  FriBidiStrIndex *positions_L_to_V,	/* output mapping from logical to 
+					 * visual string positions */
+  FriBidiStrIndex *positions_V_to_L,	/* output mapping from visual string
+					 * back to the logical string
+					 * positions */
+  FriBidiLevel *embedding_levels	/* output list of embedding levels */
+)
+     FRIBIDI_GNUC_WARN_UNUSED FRIBIDI_GNUC_DEPRECATED;
+
+
+#define UNI_MAX_BIDI_LEVEL	FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL
+#define UNI_LRM			FRIBIDI_CHAR_LRM
+#define UNI_RLM			FRIBIDI_CHAR_RLM
+#define UNI_LRE			FRIBIDI_CHAR_LRE
+#define UNI_RLE			FRIBIDI_CHAR_RLE
+#define UNI_LRO			FRIBIDI_CHAR_LRO
+#define UNI_RLO			FRIBIDI_CHAR_RLO
+#define UNI_LS			FRIBIDI_CHAR_LS
+#define UNI_PS			FRIBIDI_CHAR_PS
+#define UNI_ZWNJ		FRIBIDI_CHAR_ZWNJ
+#define UNI_ZWJ			FRIBIDI_CHAR_ZWJ
+#define UNI_HEBREW_ALEF		FRIBIDI_CHAR_HEBREW_ALEF
+#define UNI_ARABIC_ALEF		FRIBIDI_CHAR_ARABIC_ALEF
+#define UNI_ARABIC_ZERO		FRIBIDI_CHAR_ARABIC_ZERO
+#define UNI_FARSI_ZERO		FRIBIDI_CHAR_PERSIAN_ZERO
+
+#define FRIBIDI_TYPE_WL		FRIBIDI_PAR_WLTR
+#define FRIBIDI_TYPE_WR		FRIBIDI_PAR_WRTL
+#define FRIBIDI_TYPE_L		FRIBIDI_PAR_LTR
+#define FRIBIDI_TYPE_R		FRIBIDI_PAR_RTL
+#define FRIBIDI_TYPE_N		FRIBIDI_PAR_ON
+#define FRIBIDI_TYPE_B		FRIBIDI_TYPE_BS
+#define FRIBIDI_TYPE_S		FRIBIDI_TYPE_SS
+
+#include "fribidi-enddecls.h"
+
+#endif /* !_FRIBIDI_DEPRECATED_H */
+/* Editor directions:
+ * vim:textwidth=78:tabstop=8:shiftwidth=2:autoindent:cindent
+ */
diff -rupN orginal/scribus/fribidi/fribidi-enddecls.h patched/scribus/fribidi/fribidi-enddecls.h
--- orginal/scribus/fribidi/fribidi-enddecls.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/fribidi/fribidi-enddecls.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,3 @@
+#ifdef FRIBIDI_END_DECLS
+FRIBIDI_END_DECLS
+#endif /* FRIBIDI_END_DECLS */
diff -rupN orginal/scribus/fribidi/fribidi-flags.h patched/scribus/fribidi/fribidi-flags.h
--- orginal/scribus/fribidi/fribidi-flags.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/fribidi/fribidi-flags.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,78 @@
+/* FriBidi
+ * fribidi-flags.h - option flags
+ *
+ * $Id: fribidi-flags.h,v 1.1 2005/11/03 01:39:01 behdad Exp $
+ * $Author: behdad $
+ * $Date: 2005/11/03 01:39:01 $
+ * $Revision: 1.1 $
+ * $Source: /cvs/fribidi/fribidi2/lib/fribidi-flags.h,v $
+ *
+ * Author:
+ *   Behdad Esfahbod, 2005
+ *
+ * Copyright (C) 2005 Behdad Esfahbod
+ * 
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ * 
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library, in a file named COPYING; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA
+ *
+ * For licensing issues, contact <license@farsiweb.info>.
+ */
+#ifndef _FRIBIDI_FLAGS_H
+#define _FRIBIDI_FLAGS_H
+
+#include "fribidi-common.h"
+
+#include "fribidi-types.h"
+
+#include "fribidi-begindecls.h"
+
+typedef fribidi_uint32 FriBidiFlags;
+
+/* 
+ * Define option flags that various functions use. Each mask has
+ * only one bit set.
+ */
+
+#define FRIBIDI_FLAG_SHAPE_MIRRORING	0x00000001
+#define FRIBIDI_FLAG_REORDER_NSM	0x00000002
+
+#define FRIBIDI_FLAG_SHAPE_ARAB_PRES	0x00000100
+#define FRIBIDI_FLAG_SHAPE_ARAB_LIGA	0x00000200
+#define FRIBIDI_FLAG_SHAPE_ARAB_CONSOLE	0x00000400
+
+#define FRIBIDI_FLAG_REMOVE_BIDI	0x00010000
+#define FRIBIDI_FLAG_REMOVE_JOINING	0x00020000
+#define FRIBIDI_FLAG_REMOVE_SPECIALS	0x00040000
+
+
+/*
+ * And their combinations.
+ */
+
+#define FRIBIDI_FLAGS_DEFAULT		( \
+	FRIBIDI_FLAG_SHAPE_MIRRORING	| \
+	FRIBIDI_FLAG_REORDER_NSM	| \
+	FRIBIDI_FLAG_REMOVE_SPECIALS	)
+
+#define FRIBIDI_FLAGS_ARABIC		( \
+	FRIBIDI_FLAG_SHAPE_ARAB_PRES	| \
+	FRIBIDI_FLAG_SHAPE_ARAB_LIGA	)
+
+#include "fribidi-enddecls.h"
+
+#endif /* !_FRIBIDI_FLAGS_H */
+/* Editor directions:
+ * vim:textwidth=78:tabstop=8:shiftwidth=2:autoindent:cindent
+ */
diff -rupN orginal/scribus/fribidi/fribidi-joining-types-list.h patched/scribus/fribidi/fribidi-joining-types-list.h
--- orginal/scribus/fribidi/fribidi-joining-types-list.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/fribidi/fribidi-joining-types-list.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,50 @@
+#ifndef __FRIBIDI_DOC
+/* FriBidi
+ * fribidi-joining-types-list.h - list of joining types
+ *
+ * $Id: fribidi-joining-types-list.h,v 1.2 2004/06/15 11:52:02 behdad Exp $
+ * $Author: behdad $
+ * $Date: 2004/06/15 11:52:02 $
+ * $Revision: 1.2 $
+ * $Source: /cvs/fribidi/fribidi2/lib/fribidi-joining-types-list.h,v $
+ *
+ * Author:
+ *   Behdad Esfahbod, 2004
+ *
+ * Copyright (C) 2004 Sharif FarsiWeb, Inc.
+ * Copyright (C) 2004 Behdad Esfahbod
+ * 
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ * 
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library, in a file named COPYING; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA
+ *
+ * For licensing issues, contact <license@farsiweb.info>.
+ */
+/* *INDENT-OFF* */
+#endif /* !__FRIBIDI_DOC */
+#ifndef _FRIBIDI_ADD_TYPE
+# define _FRIBIDI_ADD_TYPE(x,y)
+#endif
+
+_FRIBIDI_ADD_TYPE (U, '|')	/* nUn-joining, e.g. Full Stop */
+_FRIBIDI_ADD_TYPE (R, '<')	/* Right-joining, e.g. Arabic Letter Dal */
+_FRIBIDI_ADD_TYPE (D, '+')	/* Dual-joining, e.g. Arabic Letter Ain */
+_FRIBIDI_ADD_TYPE (C, '-')	/* join-Causing, e.g. Tatweel, ZWJ */
+_FRIBIDI_ADD_TYPE (T, '^')	/* Transparent, e.g. Arabic Fatha */
+_FRIBIDI_ADD_TYPE (L, '>')	/* Left-joining, i.e. fictional */
+_FRIBIDI_ADD_TYPE (G, '~')	/* iGnored, e.g. LRE, RLE, ZWNBSP */
+
+#ifndef __FRIBIDI_DOC
+/* *INDENT-ON* */
+#endif /* !__FRIBIDI_DOC */
diff -rupN orginal/scribus/fribidi/fribidi-joining-types.c patched/scribus/fribidi/fribidi-joining-types.c
--- orginal/scribus/fribidi/fribidi-joining-types.c	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/fribidi/fribidi-joining-types.c	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,118 @@
+/* FriBidi
+ * fribidi-joining-types.c - character joining types
+ *
+ * $Id: fribidi-joining-types.c,v 1.5 2006/01/31 03:23:13 behdad Exp $
+ * $Author: behdad $
+ * $Date: 2006/01/31 03:23:13 $
+ * $Revision: 1.5 $
+ * $Source: /cvs/fribidi/fribidi2/lib/fribidi-joining-types.c,v $
+ *
+ * Authors:
+ *   Behdad Esfahbod, 2001, 2002, 2004
+ *
+ * Copyright (C) 2004 Sharif FarsiWeb, Inc.
+ * Copyright (C) 2001,2002 Behdad Esfahbod
+ * 
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ * 
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library, in a file named COPYING; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA
+ *
+ * For licensing issues, contact <license@farsiweb.info>.
+ */
+
+#include "common.h"
+
+#include <fribidi-joining-types.h>
+
+#include "joining-types.h"
+
+enum FriBidiJoiningTypeShortEnum
+{
+# define _FRIBIDI_ADD_TYPE(TYPE,SYMBOL) TYPE = FRIBIDI_JOINING_TYPE_##TYPE,
+# include "fribidi-joining-types-list.h"
+# undef _FRIBIDI_ADD_TYPE
+  _FRIBIDI_NUM_TYPES
+};
+
+#include "joining-type.tab.i"
+
+FRIBIDI_ENTRY FriBidiJoiningType
+fribidi_get_joining_type (
+  /* input */
+  FriBidiChar ch
+)
+{
+  return FRIBIDI_GET_JOINING_TYPE (ch);
+}
+
+FRIBIDI_ENTRY void
+fribidi_get_joining_types (
+  /* input */
+  const FriBidiChar *str,
+  const FriBidiStrIndex len,
+  /* output */
+  FriBidiJoiningType *jtypes
+)
+{
+  register FriBidiStrIndex i = len;
+  for (; i; i--)
+    {
+      *jtypes++ = FRIBIDI_GET_JOINING_TYPE (*str);
+      str++;
+    }
+}
+
+FRIBIDI_ENTRY const char *
+fribidi_get_joining_type_name (
+  /* input */
+  FriBidiJoiningType j
+)
+{
+  switch (j)
+    {
+#   define _FRIBIDI_ADD_TYPE(TYPE,SYMBOL) case FRIBIDI_JOINING_TYPE_##TYPE: return STRINGIZE(TYPE);
+#   include "fribidi-joining-types-list.h"
+#   undef _FRIBIDI_ADD_TYPE
+    default:
+      return "?";
+    }
+}
+
+#if DEBUG+0
+
+char
+fribidi_char_from_joining_type (
+  /* input */
+  FriBidiJoiningType j,
+  fribidi_boolean visual
+)
+{
+  /* switch left and right if on visual run */
+  if (visual & ((FRIBIDI_JOINS_RIGHT (j) && !FRIBIDI_JOINS_LEFT (j)) |
+		(!FRIBIDI_JOINS_RIGHT (j) && FRIBIDI_JOINS_LEFT (j))))
+    j ^= FRIBIDI_MASK_JOINS_RIGHT | FRIBIDI_MASK_JOINS_LEFT;
+
+#   define _FRIBIDI_ADD_TYPE(TYPE,SYMBOL)	\
+	if (FRIBIDI_IS_JOINING_TYPE_##TYPE(j)) return SYMBOL;
+#   include "fribidi-joining-types-list.h"
+#   undef _FRIBIDI_ADD_TYPE
+
+  return '?';
+}
+
+#endif /* DEBUG */
+
+/* Editor directions:
+ * vim:textwidth=78:tabstop=8:shiftwidth=2:autoindent:cindent
+ */
diff -rupN orginal/scribus/fribidi/fribidi-joining-types.h patched/scribus/fribidi/fribidi-joining-types.h
--- orginal/scribus/fribidi/fribidi-joining-types.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/fribidi/fribidi-joining-types.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,258 @@
+/* FriBidi
+ * fribidi-joining-types.h - character joining types
+ *
+ * $Id: fribidi-joining-types.h,v 1.5 2005/11/03 01:39:01 behdad Exp $
+ * $Author: behdad $
+ * $Date: 2005/11/03 01:39:01 $
+ * $Revision: 1.5 $
+ * $Source: /cvs/fribidi/fribidi2/lib/fribidi-joining-types.h,v $
+ *
+ * Author:
+ *   Behdad Esfahbod, 2001, 2002, 2004
+ *
+ * Copyright (C) 2004 Sharif FarsiWeb, Inc.
+ * Copyright (C) 2001,2002 Behdad Esfahbod
+ * 
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ * 
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library, in a file named COPYING; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA
+ *
+ * For licensing issues, contact <license@farsiweb.info>.
+ */
+#ifndef _FRIBIDI_JOINING_TYPES_H
+#define _FRIBIDI_JOINING_TYPES_H
+
+#include "fribidi-common.h"
+
+#include "fribidi-types.h"
+
+#include "fribidi-begindecls.h"
+
+/* 
+ * Define bit masks that joining types are based on, each mask has
+ * only one bit set.
+ */
+
+#define FRIBIDI_MASK_JOINS_RIGHT	0x01	/* May join to right */
+#define FRIBIDI_MASK_JOINS_LEFT		0x02	/* May join to right */
+#define FRIBIDI_MASK_ARAB_SHAPES	0x04	/* May Arabic shape */
+#define FRIBIDI_MASK_TRANSPARENT	0x08	/* Is transparent */
+#define FRIBIDI_MASK_IGNORED		0x10	/* Is ignored */
+#define FRIBIDI_MASK_LIGATURED		0x20	/* Is ligatured */
+
+/*
+ * Define values for FriBidiJoiningType
+ */
+
+/* nUn-joining */
+#define FRIBIDI_JOINING_TYPE_U_VAL	( 0 )
+
+/* Right-joining */
+#define FRIBIDI_JOINING_TYPE_R_VAL	\
+	( FRIBIDI_MASK_JOINS_RIGHT | FRIBIDI_MASK_ARAB_SHAPES )
+
+/* Dual-joining */
+#define FRIBIDI_JOINING_TYPE_D_VAL	\
+	( FRIBIDI_MASK_JOINS_RIGHT | FRIBIDI_MASK_JOINS_LEFT \
+	| FRIBIDI_MASK_ARAB_SHAPES )
+
+/* join-Causing */
+#define FRIBIDI_JOINING_TYPE_C_VAL	\
+	( FRIBIDI_MASK_JOINS_RIGHT | FRIBIDI_MASK_JOINS_LEFT )
+
+/* Left-joining */
+#define FRIBIDI_JOINING_TYPE_L_VAL	\
+	( FRIBIDI_MASK_JOINS_LEFT | FRIBIDI_MASK_ARAB_SHAPES )
+
+/* Transparent */
+#define FRIBIDI_JOINING_TYPE_T_VAL	\
+	( FRIBIDI_MASK_TRANSPARENT | FRIBIDI_MASK_ARAB_SHAPES )
+
+/* iGnored */
+#define FRIBIDI_JOINING_TYPE_G_VAL	( FRIBIDI_MASK_IGNORED )
+
+
+enum _FriBidiJoiningTypeEnum
+{
+# define _FRIBIDI_ADD_TYPE(TYPE,SYMBOL) \
+	FRIBIDI_JOINING_TYPE_##TYPE = FRIBIDI_JOINING_TYPE_##TYPE##_VAL,
+# include "fribidi-joining-types-list.h"
+# undef _FRIBIDI_ADD_TYPE
+  _FRIBIDI_JOINING_TYPE_JUNK	/* Don't use this */
+};
+
+#ifdef __FRIBIDI_DOC
+typedef enum _FriBidiJoiningTypeEnum FriBidiJoiningType;
+#else /* !__FRIBIDI_DOC */
+typedef fribidi_uint8 FriBidiJoiningType;
+#endif /* !__FRIBIDI_DOC */
+
+/* FriBidiArabicProp is essentially the same type as FriBidiJoiningType, but
+ * not limited to the few values returned by fribidi_get_joining_type. */
+typedef fribidi_uint8 FriBidiArabicProp;
+
+/*
+ * The equivalent of JoiningType values for ArabicProp
+ */
+
+/* Primary Arabic Joining Classes (Table 8-2) */
+
+/* nUn-joining */
+#define FRIBIDI_IS_JOINING_TYPE_U(p)	\
+	( 0 == ( (p) &	\
+		( FRIBIDI_MASK_TRANSPARENT | FRIBIDI_MASK_IGNORED	\
+		| FRIBIDI_MASK_JOINS_RIGHT | FRIBIDI_MASK_JOINS_LEFT ) ) )
+
+/* Right-joining */
+#define FRIBIDI_IS_JOINING_TYPE_R(p)	\
+	( FRIBIDI_MASK_JOINS_RIGHT == ( (p) &	\
+		( FRIBIDI_MASK_TRANSPARENT | FRIBIDI_MASK_IGNORED	\
+		| FRIBIDI_MASK_JOINS_RIGHT | FRIBIDI_MASK_JOINS_LEFT ) ) )
+
+/* Dual-joining */
+#define FRIBIDI_IS_JOINING_TYPE_D(p)	\
+	( ( FRIBIDI_MASK_JOINS_RIGHT | FRIBIDI_MASK_JOINS_LEFT	\
+	  | FRIBIDI_MASK_ARAB_SHAPES ) == ( (p) &	\
+		( FRIBIDI_MASK_TRANSPARENT | FRIBIDI_MASK_IGNORED	\
+		| FRIBIDI_MASK_JOINS_RIGHT | FRIBIDI_MASK_JOINS_LEFT	\
+		| FRIBIDI_MASK_ARAB_SHAPES ) ) )
+
+/* join-Causing */
+#define FRIBIDI_IS_JOINING_TYPE_C(p)	\
+	( ( FRIBIDI_MASK_JOINS_RIGHT | FRIBIDI_MASK_JOINS_LEFT ) == ( (p) & \
+		( FRIBIDI_MASK_TRANSPARENT | FRIBIDI_MASK_IGNORED	\
+		| FRIBIDI_MASK_JOINS_RIGHT | FRIBIDI_MASK_JOINS_LEFT	\
+		| FRIBIDI_MASK_ARAB_SHAPES ) ) )
+
+/* Left-joining */
+#define FRIBIDI_IS_JOINING_TYPE_L(p)	\
+	( FRIBIDI_MASK_JOINS_LEFT == ( (p) &	\
+		( FRIBIDI_MASK_TRANSPARENT | FRIBIDI_MASK_IGNORED	\
+		| FRIBIDI_MASK_JOINS_RIGHT | FRIBIDI_MASK_JOINS_LEFT ) ) )
+
+/* Transparent */
+#define FRIBIDI_IS_JOINING_TYPE_T(p)	\
+	( FRIBIDI_MASK_TRANSPARENT == ( (p) &	\
+		( FRIBIDI_MASK_TRANSPARENT | FRIBIDI_MASK_IGNORED ) ) )
+
+/* iGnored */
+#define FRIBIDI_IS_JOINING_TYPE_G(p)	\
+	( FRIBIDI_MASK_IGNORED == ( (p) &	\
+		( FRIBIDI_MASK_TRANSPARENT | FRIBIDI_MASK_IGNORED ) ) )
+
+/* and for Derived Arabic Joining Classes (Table 8-3) */
+
+/* Right join-Causing */
+#define FRIBIDI_IS_JOINING_TYPE_RC(p)	\
+	( FRIBIDI_MASK_JOINS_RIGHT == ( (p) &	\
+		( FRIBIDI_MASK_TRANSPARENT | FRIBIDI_MASK_IGNORED	\
+		| FRIBIDI_MASK_JOINS_RIGHT ) ) )
+
+/* Left join-Causing */
+#define FRIBIDI_IS_JOINING_TYPE_LC(p)	\
+	( FRIBIDI_MASK_JOINS_LEFT == ( (p) &	\
+		( FRIBIDI_MASK_TRANSPARENT | FRIBIDI_MASK_IGNORED	\
+		| FRIBIDI_MASK_JOINS_LEFT ) ) )
+
+
+/*
+ * Defining macros for needed queries, It is fully dependent on the 
+ * implementation of FriBidiJoiningType.
+ */
+
+/* Joins to right: R, D, C? */
+#define FRIBIDI_JOINS_RIGHT(p)	((p) & FRIBIDI_MASK_JOINS_RIGHT)
+
+/* Joins to left: L, D, C? */
+#define FRIBIDI_JOINS_LEFT(p)	((p) & FRIBIDI_MASK_JOINS_LEFT)
+
+/* May shape: R, D, L, T? */
+#define FRIBIDI_ARAB_SHAPES(p)	((p) & FRIBIDI_MASK_ARAB_SHAPES)
+
+/* Is skipped in joining: T, G? */
+#define FRIBIDI_IS_JOIN_SKIPPED(p)	\
+	((p) & (FRIBIDI_MASK_TRANSPARENT | FRIBIDI_MASK_IGNORED))
+
+/* Is base that will be shaped: R, D, L? */
+#define FRIBIDI_IS_JOIN_BASE_SHAPES(p)	\
+	( FRIBIDI_MASK_ARAB_SHAPES == ( (p) &	\
+		( FRIBIDI_MASK_TRANSPARENT | FRIBIDI_MASK_IGNORED	\
+		| FRIBIDI_MASK_ARAB_SHAPES ) ) )
+
+#define FRIBIDI_JOINS_PRECEDING_MASK(level)	\
+	(FRIBIDI_LEVEL_IS_RTL (level) ? FRIBIDI_MASK_JOINS_RIGHT	\
+				      : FRIBIDI_MASK_JOINS_LEFT)
+
+#define FRIBIDI_JOINS_FOLLOWING_MASK(level)	\
+	(FRIBIDI_LEVEL_IS_RTL (level) ? FRIBIDI_MASK_JOINS_LEFT	\
+				      : FRIBIDI_MASK_JOINS_RIGHT)
+
+#define FRIBIDI_JOIN_SHAPE(p)	\
+	((p) & ( FRIBIDI_MASK_JOINS_RIGHT | FRIBIDI_MASK_JOINS_LEFT ))
+
+/* Functions finally */
+
+
+#define fribidi_get_joining_type FRIBIDI_NAMESPACE(get_joining_type)
+/* fribidi_get_joining_type - get character joining type
+ *
+ * This function returns the joining type of a character as defined in Table
+ * 8-2 Primary Arabic Joining Classes of the Unicode standard available at
+ * http://www.unicode.org/versions/Unicode4.0.0/ch08.pdf#G7462, using data
+ * provided in file ArabicShaping.txt and UnicodeData.txt of the Unicode
+ * Character Database available at
+ * http://www.unicode.org/Public/UNIDATA/ArabicShaping.txt and
+ * http://www.unicode.org/Public/UNIDATA/UnicodeData.txt. 
+ *
+ * There are a few macros defined in fribidi-joining-types.h for querying a
+ * joining type.
+ */
+FRIBIDI_ENTRY FriBidiJoiningType
+fribidi_get_joining_type (
+  FriBidiChar ch		/* input character */
+) FRIBIDI_GNUC_CONST;
+
+#define fribidi_get_joining_types FRIBIDI_NAMESPACE(get_joining_types)
+/* fribidi_get_joining_types - get joining types for an string of characters
+ *
+ * This function finds the joining types of an string of characters.  See
+ * fribidi_get_joining_type for more information about the joining types
+ * returned by this function.
+ */
+     FRIBIDI_ENTRY void fribidi_get_joining_types (
+  const FriBidiChar *str,	/* input string */
+  const FriBidiStrIndex len,	/* input string length */
+  FriBidiJoiningType *jtypes	/* output joining types */
+);
+
+#define fribidi_get_joining_type_name FRIBIDI_NAMESPACE(get_joining_type_name)
+/* fribidi_get_joining_type_name - get joining type name
+ *
+ * This function returns the joining type name of a joining type.  The
+ * returned string is a static string and should not be freed.
+ *
+ * The type names are the same as ones defined in Table 8-2  Primary Arabic
+ * Joining Classes of the Unicode standard available at
+ * http://www.unicode.org/versions/Unicode4.0.0/ch08.pdf#G7462.
+ */
+     FRIBIDI_ENTRY const char *fribidi_get_joining_type_name (
+  FriBidiJoiningType j		/* input joining type */
+) FRIBIDI_GNUC_CONST;
+
+#include "fribidi-enddecls.h"
+
+#endif /* !_FRIBIDI_JOINING_TYPES_H */
+/* Editor directions:
+ * vim:textwidth=78:tabstop=8:shiftwidth=2:autoindent:cindent
+ */
diff -rupN orginal/scribus/fribidi/fribidi-joining.c patched/scribus/fribidi/fribidi-joining.c
--- orginal/scribus/fribidi/fribidi-joining.c	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/fribidi/fribidi-joining.c	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,193 @@
+/* FriBidi
+ * fribidi-joining.h - Arabic joining algorithm
+ *
+ * $Id: fribidi-joining.c,v 1.6 2006/01/31 03:23:13 behdad Exp $
+ * $Author: behdad $
+ * $Date: 2006/01/31 03:23:13 $
+ * $Revision: 1.6 $
+ * $Source: /cvs/fribidi/fribidi2/lib/fribidi-joining.c,v $
+ *
+ * Authors:
+ *   Behdad Esfahbod, 2004
+ *
+ * Copyright (C) 2004 Sharif FarsiWeb, Inc
+ * Copyright (C) 2004 Behdad Esfahbod
+ * 
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ * 
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library, in a file named COPYING; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA
+ * 
+ * For licensing issues, contact <license@farsiweb.info>.
+ */
+
+#include "common.h"
+
+#include <fribidi-joining.h>
+
+#include "mem.h"
+#include "bidi-types.h"
+#include "joining-types.h"
+
+#if DEBUG+0
+/*======================================================================
+ *  For debugging, define some functions for printing joining types and
+ *  properties.
+ *----------------------------------------------------------------------*/
+
+static void
+print_joining_types (
+  /* input */
+  const FriBidiLevel *embedding_levels,
+  const FriBidiStrIndex len,
+  const FriBidiJoiningType *jtypes
+)
+{
+  register FriBidiStrIndex i;
+
+  fribidi_assert (jtypes);
+
+  MSG ("  Join. types: ");
+  for (i = 0; i < len; i++)
+    MSG2 ("%c", fribidi_char_from_joining_type (jtypes[i],
+						!FRIBIDI_LEVEL_IS_RTL
+						(embedding_levels[i])));
+  MSG ("\n");
+}
+#endif /* DEBUG */
+
+#define FRIBIDI_CONSISTENT_LEVEL(i)	\
+	(FRIBIDI_IS_EXPLICIT_OR_BN (bidi_types[(i)])	\
+	 ? FRIBIDI_SENTINEL	\
+	 : embedding_levels[(i)])
+
+#define FRIBIDI_LEVELS_MATCH(i, j)	\
+	((i) == (j) || (i) == FRIBIDI_SENTINEL || (j) == FRIBIDI_SENTINEL)
+
+FRIBIDI_ENTRY void
+fribidi_join_arabic (
+  /* input */
+  const FriBidiCharType *bidi_types,
+  const FriBidiStrIndex len,
+  const FriBidiLevel *embedding_levels,
+  /* input and output */
+  FriBidiArabicProp *ar_props
+)
+{
+  if UNLIKELY
+    (len == 0) return;
+
+  DBG ("in fribidi_join_arabic");
+
+  fribidi_assert (bidi_types);
+  fribidi_assert (embedding_levels);
+  fribidi_assert (ar_props);
+
+# if DEBUG
+  if UNLIKELY
+    (fribidi_debug_status ())
+    {
+      print_joining_types (embedding_levels, len, ar_props);
+    }
+# endif	/* DEBUG */
+
+  /* The joining algorithm turned out very very dirty :(.  That's what happens
+   * when you follow the standard which has never been implemented closely
+   * before.
+   */
+
+  /* 8.2 Arabic - Cursive Joining */
+  DBG ("Arabic cursive joining");
+  {
+    /* The following do not need to be initialized as long as joins is
+     * initialized to false.  We just do to turn off compiler warnings. */
+    register FriBidiStrIndex saved = 0;
+    register FriBidiLevel saved_level = FRIBIDI_SENTINEL;
+    register fribidi_boolean saved_shapes = false;
+    register FriBidiArabicProp saved_joins_following_mask = 0;
+
+    register fribidi_boolean joins = false;
+    register FriBidiStrIndex i;
+
+    for (i = 0; i < len; i++)
+      if (!FRIBIDI_IS_JOINING_TYPE_G (ar_props[i]))
+	{
+	  register fribidi_boolean disjoin = false;
+	  register fribidi_boolean shapes = FRIBIDI_ARAB_SHAPES (ar_props[i]);
+	  register FriBidiLevel level = FRIBIDI_CONSISTENT_LEVEL (i);
+
+	  if (joins && !FRIBIDI_LEVELS_MATCH (saved_level, level))
+	    {
+	      disjoin = true;
+	      joins = false;
+	    }
+
+	  if (!FRIBIDI_IS_JOIN_SKIPPED (ar_props[i]))
+	    {
+	      register const FriBidiArabicProp joins_preceding_mask =
+		FRIBIDI_JOINS_PRECEDING_MASK (level);
+
+	      if (!joins)
+		{
+		  if (shapes)
+		    FRIBIDI_UNSET_BITS (ar_props[i], joins_preceding_mask);
+		}
+	      else if (!FRIBIDI_TEST_BITS (ar_props[i], joins_preceding_mask))
+	        {
+		  disjoin = true;
+		}
+	      else
+	        {
+		  register FriBidiStrIndex j;
+		  /* This is a FriBidi extension:  we set joining properties
+		   * for skipped characters in between, so we can put NSMs on tatweel
+		   * later if we want.  Useful on console for example.
+		   */
+		  for (j = saved + 1; j < i; j++)
+		    FRIBIDI_SET_BITS (ar_props[j], joins_preceding_mask | saved_joins_following_mask);
+		}
+	    }
+
+	  if (disjoin && saved_shapes)
+	    FRIBIDI_UNSET_BITS (ar_props[saved], saved_joins_following_mask);
+
+	  if (!FRIBIDI_IS_JOIN_SKIPPED (ar_props[i]))
+	    {
+	      saved = i;
+	      saved_level = level;
+	      saved_shapes = shapes;
+	      saved_joins_following_mask =
+		FRIBIDI_JOINS_FOLLOWING_MASK (level);
+	      joins =
+		FRIBIDI_TEST_BITS (ar_props[i], saved_joins_following_mask);
+	    }
+	}
+    if ((joins) && saved_shapes)
+      FRIBIDI_UNSET_BITS (ar_props[saved], saved_joins_following_mask);
+
+  }
+
+# if DEBUG
+  if UNLIKELY
+    (fribidi_debug_status ())
+    {
+      print_joining_types (embedding_levels, len, ar_props);
+    }
+# endif	/* DEBUG */
+
+  DBG ("leaving fribidi_join_arabic");
+}
+
+/* Editor directions:
+ * vim:textwidth=78:tabstop=8:shiftwidth=2:autoindent:cindent
+ */
diff -rupN orginal/scribus/fribidi/fribidi-joining.h patched/scribus/fribidi/fribidi-joining.h
--- orginal/scribus/fribidi/fribidi-joining.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/fribidi/fribidi-joining.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,81 @@
+/* FriBidi
+ * fribidi-joining.h - Arabic joining algorithm
+ *
+ * $Id: fribidi-joining.h,v 1.3 2004/06/21 21:15:31 behdad Exp $
+ * $Author: behdad $
+ * $Date: 2004/06/21 21:15:31 $
+ * $Revision: 1.3 $
+ * $Source: /cvs/fribidi/fribidi2/lib/fribidi-joining.h,v $
+ *
+ * Authors:
+ *   Behdad Esfahbod, 2004
+ *
+ * Copyright (C) 2004 Sharif FarsiWeb, Inc
+ * Copyright (C) 2004 Behdad Esfahbod
+ * 
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ * 
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library, in a file named COPYING; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA
+ * 
+ * For licensing issues, contact <license@farsiweb.info>.
+ */
+#ifndef _FRIBIDI_JOINING_H
+#define _FRIBIDI_JOINING_H
+
+#include "fribidi-common.h"
+
+#include "fribidi-types.h"
+#include "fribidi-bidi-types.h"
+#include "fribidi-joining-types.h"
+
+#include "fribidi-begindecls.h"
+
+#define fribidi_join_arabic FRIBIDI_NAMESPACE(join_arabic)
+/* fribidi_join_arabic - do Arabic joining
+ *
+ * This function does the Arabic joining algorithm.  Means, given Arabic
+ * joining types of the characters in ar_props (don't worry,
+ * FriBidiJoiningType can be casted to FriBidiArabicProp automagically), this
+ * function modifies this properties to grasp the effect of neighboring
+ * characters.  You probably need this information later to do Arabic shaping.
+ *
+ * This function implements rules R1 to R7 inclusive (all rules) of the Arabic
+ * Cursive Joining algorithm of the Unicode standard as available at 
+ * http://www.unicode.org/versions/Unicode4.0.0/ch08.pdf#G7462.  It also
+ * interacts correctly with the bidirection algorithm as defined in Section
+ * 3.5 Shaping of the Unicode Bidirectional Algorithm available at
+ * http://www.unicode.org/reports/tr9/#Shaping.
+ *
+ * There are a few macros defined in fribidi-joining-types.h for querying the
+ * Arabic properties computed by this function.
+ */
+FRIBIDI_ENTRY void fribidi_join_arabic (
+  const FriBidiCharType *bidi_types,	/* input list of bidi types as
+					   returned by
+					   fribidi_get_bidi_types() */
+  const FriBidiStrIndex len,	/* input string length */
+  const FriBidiLevel *embedding_levels,	/* input list of embedding
+					   levels, as returned by
+					   fribidi_get_par_embedding_levels */
+  FriBidiArabicProp *ar_props	/* Arabic properties to analyze, initilized by
+				   joining types, as returned by
+				   fribidi_get_joining_types */
+);
+
+#include "fribidi-enddecls.h"
+
+#endif /* !_FRIBIDI_JOINING_H */
+/* Editor directions:
+ * vim:textwidth=78:tabstop=8:shiftwidth=2:autoindent:cindent
+ */
diff -rupN orginal/scribus/fribidi/fribidi-mem.c patched/scribus/fribidi/fribidi-mem.c
--- orginal/scribus/fribidi/fribidi-mem.c	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/fribidi/fribidi-mem.c	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,140 @@
+/* FriBidi
+ * fribidi-mem.c - memory manipulation routines
+ *
+ * $Id: fribidi-mem.c,v 1.8 2006/01/31 03:23:13 behdad Exp $
+ * $Author: behdad $
+ * $Date: 2006/01/31 03:23:13 $
+ * $Revision: 1.8 $
+ * $Source: /cvs/fribidi/fribidi2/lib/fribidi-mem.c,v $
+ *
+ * Authors:
+ *   Behdad Esfahbod, 2001, 2002, 2004
+ *
+ * Copyright (C) 2004 Sharif FarsiWeb, Inc
+ * Copyright (C) 2001,2002 Behdad Esfahbod
+ * 
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ * 
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library, in a file named COPYING; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA
+ * 
+ * For licensing issues, contact <license@farsiweb.info>.
+ */
+
+#include "common.h"
+
+#include "mem.h"
+
+#if FRIBIDI_USE_GLIB+0
+#else
+#if USE_SIMPLE_MALLOC+0
+#else
+
+struct _FriBidiMemChunk
+{
+  int atom_size;
+  int area_size;
+  int empty_size;
+  void *chunk;
+};
+
+FriBidiMemChunk *
+fribidi_mem_chunk_new (
+  /* input */
+  const char *name,
+  int atom_size,
+  unsigned long area_size,
+  int alloc_type
+)
+{
+  register FriBidiMemChunk *m;
+
+  fribidi_assert (area_size >= atom_size * 8);
+
+  m = (FriBidiMemChunk *) fribidi_malloc (sizeof (FriBidiMemChunk));
+  if LIKELY
+    (m)
+    {
+      m->atom_size = atom_size;
+      m->area_size = area_size;
+      m->empty_size = 0;
+      m->chunk = NULL;
+    }
+
+  return m;
+}
+
+void *
+fribidi_mem_chunk_alloc (
+  /* input */
+  FriBidiMemChunk *mem_chunk
+)
+{
+  fribidi_assert (mem_chunk);
+
+  if UNLIKELY
+    (mem_chunk->empty_size < mem_chunk->atom_size)
+    {
+      register void *chunk = fribidi_malloc (mem_chunk->area_size);
+      if LIKELY
+	(chunk)
+	{
+	  if (mem_chunk->chunk)
+	    *(void **) chunk =
+	      (char *) mem_chunk->chunk + mem_chunk->empty_size -
+	      mem_chunk->area_size;
+	  chunk = (char *) chunk + mem_chunk->atom_size;
+	  mem_chunk->chunk = chunk;
+	  mem_chunk->empty_size = mem_chunk->area_size - mem_chunk->atom_size;
+	}
+      else
+	return NULL;
+    }
+
+  {
+    register void *m = mem_chunk->chunk;
+    mem_chunk->chunk = (char *) mem_chunk->chunk + mem_chunk->atom_size;
+    mem_chunk->empty_size -= mem_chunk->atom_size;
+
+    return m;
+  }
+}
+
+void
+fribidi_mem_chunk_destroy (
+  /* input */
+  FriBidiMemChunk *mem_chunk
+)
+{
+  register void *chunk;
+
+  fribidi_assert (mem_chunk);
+
+  chunk =
+    (char *) mem_chunk->chunk + mem_chunk->empty_size - mem_chunk->area_size;
+  while LIKELY
+    (chunk)
+    {
+      register void *tofree = chunk;
+      chunk = *(void **) chunk;
+      fribidi_free (tofree);
+    }
+  fribidi_free (mem_chunk);
+}
+
+#endif /* !USE_SIMPLE_MALLOC */
+#endif /* !FRIBIDI_USE_GLIB */
+
+/* Editor directions:
+ * vim:textwidth=78:tabstop=8:shiftwidth=2:autoindent:cindent
+ */
diff -rupN orginal/scribus/fribidi/fribidi-mirroring.c patched/scribus/fribidi/fribidi-mirroring.c
--- orginal/scribus/fribidi/fribidi-mirroring.c	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/fribidi/fribidi-mirroring.c	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,96 @@
+/* fribidi-mirroring.c - get mirrored character
+ *
+ * Copyright (C) 2004  Sharif FarsiWeb, Inc
+ * Copyright (C) 2001, 2002, 2004  Behdad Esfahbod
+ * Copyright (C) 1999, 2000  Dov Grobgeld
+ *
+ * This file is part of GNU FriBidi.
+ * 
+ * GNU FriBidi is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * as published by the Free Software Foundation; either version 2.1
+ * of the License, or (at your option) any later version.
+ * 
+ * GNU FriBidi is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with GNU FriBidi; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * 
+ * For licensing issues, contact <license@farsiweb.info> or write to
+ * Sharif FarsiWeb, Inc., PO Box 13445-389, Tehran, Iran.
+ */
+/* $Id: fribidi-mirroring.c,v 1.15 2005/11/03 01:39:01 behdad Exp $
+ * $Author: behdad $
+ * $Date: 2005/11/03 01:39:01 $
+ * $Revision: 1.15 $
+ * $Source: /cvs/fribidi/fribidi2/lib/fribidi-mirroring.c,v $
+ *
+ * Author(s):
+ *   Behdad Esfahbod, 2001, 2002, 2004
+ *   Dov Grobgeld, 1999, 2000
+ */
+
+#include "common.h"
+
+#include <fribidi-mirroring.h>
+
+#include "mirroring.tab.i"
+
+FRIBIDI_ENTRY fribidi_boolean
+fribidi_get_mirror_char (
+  /* input */
+  FriBidiChar ch,
+  /* output */
+  FriBidiChar *mirrored_ch
+)
+{
+  register FriBidiChar result;
+  result = FRIBIDI_GET_MIRRORING (ch);
+  if (mirrored_ch)
+    *mirrored_ch = result;
+  return ch != result ? true : false;
+}
+
+
+FRIBIDI_ENTRY void
+fribidi_shape_mirroring (
+  /* input */
+  const FriBidiLevel *embedding_levels,
+  const FriBidiStrIndex len,
+  /* input and output */
+  FriBidiChar *str
+)
+{
+  register FriBidiStrIndex i;
+
+  DBG ("in fribidi_shape_mirroring");
+
+  if UNLIKELY
+    (len == 0 || !str) return;
+
+  fribidi_assert (embedding_levels);
+
+  /* L4. Mirror all characters that are in odd levels and have mirrors. */
+  for (i = len - 1; i >= 0; i--)
+    if (FRIBIDI_LEVEL_IS_RTL (embedding_levels[i]))
+      {
+	FriBidiChar mirrored_ch;
+
+	if (fribidi_get_mirror_char (str[i], &mirrored_ch))
+	  str[i] = mirrored_ch;
+      }
+}
+
+/* Editor directions:
+ * Local Variables:
+ *   mode: c
+ *   c-basic-offset: 2
+ *   indent-tabs-mode: t
+ *   tab-width: 8
+ * End:
+ * vim: textwidth=78: autoindent: cindent: shiftwidth=2: tabstop=8:
+ */
diff -rupN orginal/scribus/fribidi/fribidi-mirroring.h patched/scribus/fribidi/fribidi-mirroring.h
--- orginal/scribus/fribidi/fribidi-mirroring.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/fribidi/fribidi-mirroring.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,94 @@
+/* fribidi-mirroring.h - get mirrored character
+ *
+ * Copyright (C) 2004  Sharif FarsiWeb, Inc
+ * Copyright (C) 2001, 2002, 2004  Behdad Esfahbod
+ * Copyright (C) 1999, 2000  Dov Grobgeld
+ * 
+ * This file is part of GNU FriBidi.
+ * 
+ * GNU FriBidi is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * as published by the Free Software Foundation; either version 2.1
+ * of the License, or (at your option) any later version.
+ * 
+ * GNU FriBidi is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with GNU FriBidi; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * 
+ * For licensing issues, contact <license@farsiweb.info> or write to
+ * Sharif FarsiWeb, Inc., PO Box 13445-389, Tehran, Iran.
+ */
+/* $Id: fribidi-mirroring.h,v 1.10 2004/09/28 07:58:57 behdad Exp $
+ * $Author: behdad $
+ * $Date: 2004/09/28 07:58:57 $
+ * $Revision: 1.10 $
+ * $Source: /cvs/fribidi/fribidi2/lib/fribidi-mirroring.h,v $
+ *
+ * Author(s):
+ *   Behdad Esfahbod, 2001, 2002, 2004
+ *   Dov Grobgeld, 1999, 2000
+ */
+#ifndef _FRIBIDI_MIRRORING_H
+#define _FRIBIDI_MIRRORING_H
+
+#include "fribidi-common.h"
+
+#include "fribidi-types.h"
+#include "fribidi-bidi-types.h"
+
+#include "fribidi-begindecls.h"
+
+#define fribidi_get_mirror_char FRIBIDI_NAMESPACE(get_mirror_char)
+/* fribidi_get_mirror_char - get mirrored character
+ *
+ * This function finds the mirrored equivalent of a character as defined in
+ * the file BidiMirroring.txt of the Unicode Character Database available at
+ * http://www.unicode.org/Public/UNIDATA/BidiMirroring.txt.
+ *
+ * If  the input character is a declared as a mirroring character in the
+ * Unicode standard and has a mirrored equivalent.  The matching mirrored
+ * character is put in the output, otherwise the input character itself is
+ * put.
+ *
+ * Returns: if the character has a mirroring equivalent or not.
+ */
+FRIBIDI_ENTRY fribidi_boolean fribidi_get_mirror_char (
+  FriBidiChar ch,		/* input character */
+  FriBidiChar *mirrored_ch	/* output mirrored character */
+);
+
+#define fribidi_shape_mirroring FRIBIDI_NAMESPACE(shape_mirroring)
+/* fribidi_shape_mirroring - do mirroring shaping
+ *
+ * This functions replaces mirroring characters on right-to-left embeddings in
+ * string with their mirrored equivalent as returned by
+ * fribidi_get_mirror_char().
+ *
+ * This function implements rule L4 of the Unicode Bidirectional Algorithm
+ * available at http://www.unicode.org/reports/tr9/#L4.
+ */
+FRIBIDI_ENTRY void fribidi_shape_mirroring (
+  const FriBidiLevel *embedding_levels,	/* input list of embedding
+					   levels, as returned by
+					   fribidi_get_par_embedding_levels */
+  const FriBidiStrIndex len,	/* input string length */
+  FriBidiChar *str		/* string to shape */
+);
+
+#include "fribidi-enddecls.h"
+
+#endif /* !_FRIBIDI_MIRRORING_H */
+/* Editor directions:
+ * Local Variables:
+ *   mode: c
+ *   c-basic-offset: 2
+ *   indent-tabs-mode: t
+ *   tab-width: 8
+ * End:
+ * vim: textwidth=78: autoindent: cindent: shiftwidth=2: tabstop=8:
+ */
diff -rupN orginal/scribus/fribidi/fribidi-run.c patched/scribus/fribidi/fribidi-run.c
--- orginal/scribus/fribidi/fribidi-run.c	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/fribidi/fribidi-run.c	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,376 @@
+/* FriBidi
+ * fribidi-run.c - text run data type
+ *
+ * $Id: fribidi-run.c,v 1.8 2006/01/31 03:23:13 behdad Exp $
+ * $Author: behdad $
+ * $Date: 2006/01/31 03:23:13 $
+ * $Revision: 1.8 $
+ * $Source: /cvs/fribidi/fribidi2/lib/fribidi-run.c,v $
+ *
+ * Authors:
+ *   Behdad Esfahbod, 2001, 2002, 2004
+ *   Dov Grobgeld, 1999, 2000
+ *
+ * Copyright (C) 2004 Sharif FarsiWeb, Inc
+ * Copyright (C) 2001,2002 Behdad Esfahbod
+ * Copyright (C) 1999,2000 Dov Grobgeld
+ * 
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ * 
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library, in a file named COPYING; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA
+ * 
+ * For licensing issues, contact <license@farsiweb.info>.
+ */
+
+#include "common.h"
+
+#include <fribidi-bidi-types.h>
+
+#include "run.h"
+#include "mem.h"
+#include "bidi-types.h"
+
+#if USE_SIMPLE_MALLOC+0
+#else
+static FriBidiRun *free_runs = NULL;
+#endif
+
+FriBidiRun *
+new_run (
+  void
+)
+{
+  register FriBidiRun *run;
+
+#if USE_SIMPLE_MALLOC+0
+  run = fribidi_malloc (sizeof (FriBidiRun));
+#else /* !USE_SIMPLE_MALLOC */
+  if (free_runs)
+    {
+      run = free_runs;
+      free_runs = run->next;
+    }
+  else
+    {
+      static FriBidiMemChunk *run_mem_chunk = NULL;
+
+      if UNLIKELY
+	(!run_mem_chunk)
+	 run_mem_chunk = fribidi_chunk_new_for_type (FriBidiRun);
+
+      if LIKELY
+	(run_mem_chunk)
+	run = fribidi_chunk_new (FriBidiRun, run_mem_chunk);
+      else
+	run = NULL;
+    }
+#endif /* !USE_SIMPLE_MALLOC */
+
+  if LIKELY
+    (run)
+    {
+      run->len = run->pos = run->level = 0;
+      run->next = run->prev = NULL;
+    }
+  return run;
+}
+
+void
+free_run (
+  /* input */
+  FriBidiRun *run
+)
+{
+  fribidi_assert (run);
+#if USE_SIMPLE_MALLOC+0
+  fribidi_free (run);
+#else /* !USE_SIMPLE_MALLOC */
+  run->next = free_runs;
+  free_runs = run;
+#endif /* !USE_SIMPLE_MALLOC */
+}
+
+FriBidiRun *
+new_run_list (
+  void
+)
+{
+  register FriBidiRun *run;
+
+  run = new_run ();
+
+  if LIKELY
+    (run)
+    {
+      run->type = FRIBIDI_TYPE_SENTINEL;
+      run->level = FRIBIDI_SENTINEL;
+      run->pos = FRIBIDI_SENTINEL;
+      run->len = FRIBIDI_SENTINEL;
+      run->next = run->prev = run;
+    }
+
+  return run;
+}
+
+void
+free_run_list (
+  FriBidiRun *run_list
+)
+{
+  if (!run_list)
+    return;
+
+  fribidi_validate_run_list (run_list);
+
+#if USE_SIMPLE_MALLOC+0
+  {
+    register FriBidiRun *pp;
+
+    pp = run_list;
+    pp->prev->next = NULL;
+    while LIKELY
+      (pp)
+      {
+	register FriBidiRun *p;
+
+	p = pp;
+	pp = pp->next;
+	free_run (p);
+      };
+  }
+#else /* !USE_SIMPLE_MALLOC */
+  run_list->prev->next = free_runs;
+  free_runs = run_list;
+#endif /* !USE_SIMPLE_MALLOC */
+}
+
+
+FriBidiRun *
+run_list_encode_bidi_types (
+  /* input */
+  const FriBidiCharType *bidi_types,
+  const FriBidiStrIndex len
+)
+{
+  FriBidiRun *list, *last;
+  register FriBidiRun *run = NULL;
+  FriBidiStrIndex i;
+
+  fribidi_assert (bidi_types);
+
+  /* Create the list sentinel */
+  list = new_run_list ();
+  if UNLIKELY
+    (!list) return NULL;
+  last = list;
+
+  /* Scan over the character types */
+  for (i = 0; i < len; i++)
+    {
+      register FriBidiCharType char_type = bidi_types[i];
+      if (char_type != last->type)
+	{
+	  run = new_run ();
+	  if UNLIKELY
+	    (!run) break;
+	  run->type = char_type;
+	  run->pos = i;
+	  last->len = run->pos - last->pos;
+	  last->next = run;
+	  run->prev = last;
+	  last = run;
+	}
+    }
+
+  /* Close the circle */
+  last->len = len - last->pos;
+  last->next = list;
+  list->prev = last;
+
+  if UNLIKELY
+    (!run)
+    {
+      /* Memory allocation failed */
+      free_run_list (list);
+      return NULL;
+    }
+
+  fribidi_validate_run_list (list);
+
+  return list;
+}
+
+/* override the run list 'base', with the runs in the list 'over', to
+   reinsert the previously-removed explicit codes (at X9) from
+   'explicits_list' back into 'type_rl_list' for example. This is used at the
+   end of I2 to restore the explicit marks, and also to reset the character
+   types of characters at L1.
+
+   it is assumed that the 'pos' of the first element in 'base' list is not
+   more than the 'pos' of the first element of the 'over' list, and the
+   'pos' of the last element of the 'base' list is not less than the 'pos'
+   of the last element of the 'over' list. these two conditions are always
+   satisfied for the two usages mentioned above.
+
+   Note:
+     frees the over list.
+
+   Todo:
+     use some explanatory names instead of p, q, ...
+     rewrite comment above to remove references to special usage.
+*/
+fribidi_boolean
+shadow_run_list (
+  /* input */
+  FriBidiRun *base,
+  FriBidiRun *over,
+  fribidi_boolean preserve_length
+)
+{
+  register FriBidiRun *p = base, *q, *r, *s, *t;
+  register FriBidiStrIndex pos = 0, pos2;
+  fribidi_boolean status = false;
+
+  fribidi_validate_run_list (base);
+  fribidi_validate_run_list (over);
+
+  for_run_list (q, over)
+  {
+    if UNLIKELY
+      (!q->len || q->pos < pos) continue;
+    pos = q->pos;
+    while (p->next->type != FRIBIDI_TYPE_SENTINEL && p->next->pos <= pos)
+      p = p->next;
+    /* now p is the element that q must be inserted 'in'. */
+    pos2 = pos + q->len;
+    r = p;
+    while (r->next->type != FRIBIDI_TYPE_SENTINEL && r->next->pos < pos2)
+      r = r->next;
+    if (preserve_length)
+      r->len += q->len;
+    /* now r is the last element that q affects. */
+    if LIKELY
+      (p == r)
+      {
+	/* split p into at most 3 intervals, and insert q in the place of
+	   the second interval, set r to be the third part. */
+	/* third part needed? */
+	if (p->pos + p->len > pos2)
+	  {
+	    r = new_run ();
+	    if UNLIKELY
+	      (!r) goto out;
+	    p->next->prev = r;
+	    r->next = p->next;
+	    r->level = p->level;
+	    r->type = p->type;
+	    r->len = p->pos + p->len - pos2;
+	    r->pos = pos2;
+	  }
+	else
+	  r = r->next;
+
+	if LIKELY
+	  (p->pos + p->len >= pos)
+	  {
+	    /* first part needed? */
+	    if (p->pos < pos)
+	      /* cut the end of p. */
+	      p->len = pos - p->pos;
+	    else
+	      {
+		t = p;
+		p = p->prev;
+		free_run (t);
+	      }
+	  }
+      }
+    else
+      {
+	if LIKELY
+	  (p->pos + p->len >= pos)
+	  {
+	    /* p needed? */
+	    if (p->pos < pos)
+	      /* cut the end of p. */
+	      p->len = pos - p->pos;
+	    else
+	      p = p->prev;
+	  }
+
+	/* r needed? */
+	if (r->pos + r->len > pos2)
+	  {
+	    /* cut the begining of r. */
+	    r->len = r->pos + r->len - pos2;
+	    r->pos = pos2;
+	  }
+	else
+	  r = r->next;
+
+	/* remove the elements between p and r. */
+	for (s = p->next; s != r;)
+	  {
+	    t = s;
+	    s = s->next;
+	    free_run (t);
+	  }
+      }
+    /* before updating the next and prev runs to point to the inserted q,
+       we must remember the next element of q in the 'over' list.
+     */
+    t = q;
+    q = q->prev;
+    delete_node (t);
+    p->next = t;
+    t->prev = p;
+    t->next = r;
+    r->prev = t;
+  }
+  status = true;
+
+  fribidi_validate_run_list (base);
+
+out:
+  free_run_list (over);
+
+  return status;
+}
+
+#if DEBUG+0
+
+void
+fribidi_validate_run_list (
+  FriBidiRun *run_list		/* input run list */
+)
+{
+  register FriBidiRun *q;
+
+  fribidi_assert (run_list);
+  fribidi_assert (run_list->next);
+  fribidi_assert (run_list->next->prev == run_list);
+  fribidi_assert (run_list->type == FRIBIDI_TYPE_SENTINEL);
+  for_run_list (q, run_list)
+  {
+    fribidi_assert (q->next);
+    fribidi_assert (q->next->prev == q);
+  }
+  fribidi_assert (q == run_list);
+}
+
+#endif /* !DEBUG */
+
+/* Editor directions:
+ * vim:textwidth=78:tabstop=8:shiftwidth=2:autoindent:cindent
+ */
diff -rupN orginal/scribus/fribidi/fribidi-shape.c patched/scribus/fribidi/fribidi-shape.c
--- orginal/scribus/fribidi/fribidi-shape.c	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/fribidi/fribidi-shape.c	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,69 @@
+/* FriBidi
+ * fribidi-shape.c - shaping
+ *
+ * $Id: fribidi-shape.c,v 1.1 2005/11/03 01:39:01 behdad Exp $
+ * $Author: behdad $
+ * $Date: 2005/11/03 01:39:01 $
+ * $Revision: 1.1 $
+ * $Source: /cvs/fribidi/fribidi2/lib/fribidi-shape.c,v $
+ *
+ * Authors:
+ *   Behdad Esfahbod, 2001, 2002, 2004
+ *   Dov Grobgeld, 1999, 2000
+ *
+ * Copyright (C) 2005 Behdad Esfahbod
+ * 
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ * 
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library, in a file named COPYING; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA
+ * 
+ * For licensing issues, contact <license@farsiweb.info>.
+ */
+
+#include "common.h"
+
+#include <fribidi-shape.h>
+#include <fribidi-mirroring.h>
+#include <fribidi-arabic.h>
+
+
+FRIBIDI_ENTRY void
+fribidi_shape (
+  /* input */
+  FriBidiFlags flags,
+  const FriBidiLevel *embedding_levels,
+  const FriBidiStrIndex len,
+  /* input and output */
+  FriBidiArabicProp *ar_props,
+  FriBidiChar *str
+)
+{
+  if UNLIKELY
+    (len == 0 || !str) return;
+
+  DBG ("in fribidi_shape");
+
+  fribidi_assert (embedding_levels);
+
+  if (ar_props)
+    fribidi_shape_arabic (flags, embedding_levels, len, ar_props, str);
+
+  if (FRIBIDI_TEST_BITS (flags, FRIBIDI_FLAG_SHAPE_MIRRORING))
+    fribidi_shape_mirroring (embedding_levels, len, str);
+}
+
+
+/* Editor directions:
+ * vim:textwidth=78:tabstop=8:shiftwidth=2:autoindent:cindent
+ */
diff -rupN orginal/scribus/fribidi/fribidi-shape.h patched/scribus/fribidi/fribidi-shape.h
--- orginal/scribus/fribidi/fribidi-shape.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/fribidi/fribidi-shape.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,78 @@
+/* FriBidi
+ * fribidi-shape.h - shaping
+ *
+ * $Id: fribidi-shape.h,v 1.2 2006/01/14 12:09:29 behdad Exp $
+ * $Author: behdad $
+ * $Date: 2006/01/14 12:09:29 $
+ * $Revision: 1.2 $
+ * $Source: /cvs/fribidi/fribidi2/lib/fribidi-shape.h,v $
+ *
+ * Author:
+ *   Behdad Esfahbod, 2004, 2005
+ *
+ * Copyright (C) 2004 Sharif FarsiWeb, Inc
+ * Copyright (C) 2004, 2005 Behdad Esfahbod
+ * 
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ * 
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library, in a file named COPYING; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA
+ * 
+ * For licensing issues, contact <license@farsiweb.info>.
+ */
+#ifndef _FRIBIDI_SHAPE_H
+#define _FRIBIDI_SHAPE_H
+
+#include "fribidi-types.h"
+#include "fribidi-flags.h"
+#include "fribidi-bidi-types.h"
+#include "fribidi-joining-types.h"
+
+#include "fribidi-begindecls.h"
+
+
+#define fribidi_shape FRIBIDI_NAMESPACE(shape)
+/* fribidi_shape - do bidi-aware shaping
+ *
+ * This function does all shaping work that depends on the resolved embedding
+ * levels of the characters.  Currently it does mirroring and Arabic shaping,
+ * but the list may grow in the future.  This function is a wrapper around
+ * fribidi_shape_mirroring and fribidi_shape_arabic.
+ *
+ * The flags parameter specifies which shapings are applied.  The only flags
+ * affecting the functionality of this function are those beginning with
+ * FRIBIDI_FLAG_SHAPE_.  Of these, only FRIBIDI_FLAG_SHAPE_MIRRORING is on
+ * in FRIBIDI_FLAGS_DEFAULT.  For details of the Arabic-specific flags see
+ * fribidi_shape_arabic.  If ar_props is NULL, no Arabic shaping is performed.
+ *
+ * Feel free to do your own shaping before or after calling this function,
+ * but you should take care of embedding levels yourself then.
+ */
+FRIBIDI_ENTRY void fribidi_shape (
+  FriBidiFlags flags, /* shaping flags */
+  const FriBidiLevel *embedding_levels,	/* input list of embedding
+					   levels, as returned by
+					   fribidi_get_par_embedding_levels */
+  const FriBidiStrIndex len,	/* input string length */
+  FriBidiArabicProp *ar_props, /* input/output Arabic properties as
+				       * computed by fribidi_join_arabic */
+  FriBidiChar *str		/* string to shape */
+);
+
+
+#include "fribidi-enddecls.h"
+
+#endif /* !_FRIBIDI_SHAPE_H */
+/* Editor directions:
+ * vim:textwidth=78:tabstop=8:shiftwidth=2:autoindent:cindent
+ */
diff -rupN orginal/scribus/fribidi/fribidi-types.h patched/scribus/fribidi/fribidi-types.h
--- orginal/scribus/fribidi/fribidi-types.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/fribidi/fribidi-types.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,163 @@
+/* FriBidi
+ * fribidi-types.h - define data types for the rest of the library
+ *
+ * $Id: fribidi-types.h,v 1.12 2006/01/31 03:23:13 behdad Exp $
+ * $Author: behdad $
+ * $Date: 2006/01/31 03:23:13 $
+ * $Revision: 1.12 $
+ * $Source: /cvs/fribidi/fribidi2/lib/fribidi-types.h,v $
+ *
+ * Author:
+ *   Behdad Esfahbod, 2001, 2002, 2004
+ *
+ * Copyright (C) 2004 Sharif FarsiWeb, Inc.
+ * Copyright (C) 2001,2002 Behdad Esfahbod
+ * 
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ * 
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library, in a file named COPYING; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA
+ *
+ * For licensing issues, contact <license@farsiweb.info>.
+ */
+#ifndef _FRIBIDI_TYPES_H
+#define _FRIBIDI_TYPES_H
+
+#include "fribidi-common.h"
+
+#include "fribidi-begindecls.h"
+
+
+#if FRIBIDI_USE_GLIB+0
+# ifndef __FRIBIDI_DOC
+#  include <glib/gtypes.h>
+#  include <glib/gunicode.h>
+# endif	/* !__FRIBIDI_DOC */
+# define FRIBIDI_INT8_LOCAL		gint8
+# define FRIBIDI_INT16_LOCAL		gint16
+# define FRIBIDI_INT32_LOCAL		gint32
+# define FRIBIDI_UINT8_LOCAL		guint8
+# define FRIBIDI_UINT16_LOCAL		guint16
+# define FRIBIDI_UINT32_LOCAL		guint32
+# define FRIBIDI_BOOLEAN_LOCAL		gboolean
+# define FRIBIDI_UNICHAR_LOCAL		gunichar
+#else /* !FRIBIDI_USE_GLIB */
+# if defined(HAVE_INTTYPES_H) || defined(HAVE_STDINT_H)
+#  ifndef __FRIBIDI_DOC
+#   if HAVE_INTTYPES_H
+#    include <inttypes.h>
+#   elif HAVE_STDINT_H
+#    include <stdint.h>
+#   endif /* !HAVE_STDINT_H */
+#  endif /* !__FRIBIDI_DOC */
+#  define FRIBIDI_INT8_LOCAL		int8_t
+#  define FRIBIDI_INT16_LOCAL		int16_t
+#  define FRIBIDI_INT32_LOCAL		int32_t
+#  define FRIBIDI_UINT8_LOCAL		uint8_t
+#  define FRIBIDI_UINT16_LOCAL		uint16_t
+#  define FRIBIDI_UINT32_LOCAL		uint32_t
+# else /* no int types */
+#  define FRIBIDI_INT8_LOCAL		signed char
+#  define FRIBIDI_UINT8_LOCAL		unsigned char
+#  if !defined(FRIBIDI_SIZEOF_INT) || FRIBIDI_SIZEOF_INT >= 4
+#   define FRIBIDI_INT16_LOCAL		signed short
+#   define FRIBIDI_UINT16_LOCAL		unsigned short
+#   define FRIBIDI_INT32_LOCAL		signed int
+#   define FRIBIDI_UINT32_LOCAL		unsigned int
+#  else	/* SIZEOF_INT < 4 */
+#   define FRIBIDI_INT16_LOCAL		signed int
+#   define FRIBIDI_UINT16_LOCAL		unsigned int
+#   define FRIBIDI_INT32_LOCAL		signed long
+#   define FRIBIDI_UINT32_LOCAL		unsigned long
+#  endif /* SIZEOF_INT < 4 */
+# endif	/* no int types */
+# define FRIBIDI_BOOLEAN_LOCAL		int
+# if SIZEOF_WCHAR_T >= 4
+#  ifndef __FRIBIDI_DOC
+#   if STDC_HEADERS
+#    include <stdlib.h>
+#    include <stddef.h>
+#   else /* !STDC_HEADERS */
+#    if HAVE_STDLIB_H
+#     include <stdlib.h>
+#    endif /* !HAVE_STDLIB_H */
+#   endif /* !STDC_HEADERS */
+#  endif /* !__FRIBIDI_DOC */
+#  define FRIBIDI_UNICHAR_LOCAL		wchar_t
+# else /* SIZEOF_WCHAR_T < 4 */
+#  define FRIBIDI_UNICHAR_LOCAL		fribidi_uint32
+# endif	/* SIZEOF_WCHAR_T < 4 */
+#endif /* !FRIBIDI_USE_GLIB */
+
+#if FRIBIDI_INT_TYPES+0
+#else
+# define FRIBIDI_INT8	FRIBIDI_INT8_LOCAL
+# define FRIBIDI_INT16	FRIBIDI_INT16_LOCAL
+# define FRIBIDI_INT32	FRIBIDI_INT32_LOCAL
+# define FRIBIDI_UINT8	FRIBIDI_UINT8_LOCAL
+# define FRIBIDI_UINT16	FRIBIDI_UINT16_LOCAL
+# define FRIBIDI_UINT32	FRIBIDI_UINT32_LOCAL
+#endif /* !FRIBIDI_INT_TYPES */
+#ifndef FRIBIDI_BOOLEAN
+# define FRIBIDI_BOOLEAN	FRIBIDI_BOOLEAN_LOCAL
+#endif /* !FRIBIDI_BOOLEAN */
+#ifndef FRIBIDI_UNICHAR
+# define FRIBIDI_UNICHAR FRIBIDI_UNICHAR_LOCAL
+#endif /* !FRIBIDI_UNICHAR */
+#ifndef FRIBIDI_STR_INDEX
+# define FRIBIDI_STR_INDEX int
+#endif /* FRIBIDI_STR_INDEX */
+
+
+typedef FRIBIDI_UINT8 fribidi_int8;
+typedef FRIBIDI_INT16 fribidi_int16;
+typedef FRIBIDI_INT32 fribidi_int32;
+typedef FRIBIDI_UINT8 fribidi_uint8;
+typedef FRIBIDI_UINT16 fribidi_uint16;
+typedef FRIBIDI_UINT32 fribidi_uint32;
+typedef FRIBIDI_BOOLEAN fribidi_boolean;
+
+typedef FRIBIDI_UNICHAR FriBidiChar;
+typedef FRIBIDI_STR_INDEX FriBidiStrIndex;
+
+
+#ifndef FRIBIDI_MAX_STRING_LENGTH
+# define FRIBIDI_MAX_STRING_LENGTH (sizeof (FriBidiStrIndex) == 2 ?	\
+		0x7FFF : (sizeof (FriBidiStrIndex) == 1 ? \
+		0x7F : 0x7FFFFFFFL))
+#endif
+
+/* A few macros for working with bits */
+
+#define FRIBIDI_TEST_BITS(x, mask) (((x) & (mask)) ? 1 : 0)
+
+#define FRIBIDI_INCLUDE_BITS(x, mask) ((x) | (mask))
+
+#define FRIBIDI_EXCLUDE_BITS(x, mask) ((x) & ~(mask))
+
+#define FRIBIDI_SET_BITS(x, mask)	((x) |= (mask))
+
+#define FRIBIDI_UNSET_BITS(x, mask)	((x) &= ~(mask))
+
+#define FRIBIDI_ADJUST_BITS(x, mask, cond)	\
+	((x) = ((x) & ~(mask)) | ((cond) ? (mask) : 0))
+
+#define FRIBIDI_ADJUST_AND_TEST_BITS(x, mask, cond)	\
+	FRIBIDI_TEST_BITS(FRIBIDI_ADJUST_BITS((x), (mask), (cond)), (mask))
+
+#include "fribidi-enddecls.h"
+
+#endif /* !_FRIBIDI_TYPES_H */
+/* Editor directions:
+ * vim:textwidth=78:tabstop=8:shiftwidth=2:autoindent:cindent
+ */
diff -rupN orginal/scribus/fribidi/fribidi-unicode-version.h patched/scribus/fribidi/fribidi-unicode-version.h
--- orginal/scribus/fribidi/fribidi-unicode-version.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/fribidi/fribidi-unicode-version.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,14 @@
+/* fribidi-unicode-version.h
+ * generated by gen-unicode-version (GNU FriBidi 0.19.1)
+ * from the file BidiMirroring.txt */
+
+#define FRIBIDI_UNICODE_VERSION "5.1.0"
+#define FRIBIDI_UNICODE_MAJOR_VERSION 5
+#define FRIBIDI_UNICODE_MINOR_VERSION 1
+#define FRIBIDI_UNICODE_MICRO_VERSION 0
+#define FRIBIDI_UNICODE_NAMESPACE(SYMBOL) \
+	FRIBIDI_NAMESPACE(SYMBOL##_unicode_5_1_0)
+#define FRIBIDI_UNICODE_PRIVATESPACE(SYMBOL) \
+	FRIBIDI_PRIVATESPACE(SYMBOL##_unicode_5_1_0)
+
+/* End of generated fribidi-unicode-version.h */
diff -rupN orginal/scribus/fribidi/fribidi-unicode.h patched/scribus/fribidi/fribidi-unicode.h
--- orginal/scribus/fribidi/fribidi-unicode.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/fribidi/fribidi-unicode.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,105 @@
+/* FriBidi
+ * fribidi-unicode.h - general Unicode definitions
+ *
+ * $Id: fribidi-unicode.h,v 1.7 2006/01/31 03:23:13 behdad Exp $
+ * $Author: behdad $
+ * $Date: 2006/01/31 03:23:13 $
+ * $Revision: 1.7 $
+ * $Source: /cvs/fribidi/fribidi2/lib/fribidi-unicode.h,v $
+ *
+ * Author:
+ *   Behdad Esfahbod, 2001, 2002, 2004
+ *
+ * Copyright (C) 2004 Sharif FarsiWeb, Inc
+ * Copyright (C) 2001,2002 Behdad Esfahbod
+ * 
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ * 
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library, in a file named COPYING; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA
+ * 
+ * For licensing issues, contact <license@farsiweb.info>.
+ */
+#ifndef _FRIBIDI_UNICODE_H
+#define _FRIBIDI_UNICODE_H
+
+#include "fribidi-common.h"
+
+#include "fribidi-types.h"
+
+#include "fribidi-begindecls.h"
+
+/* We do not support surrogates yet */
+#define FRIBIDI_UNICODE_CHARS	(sizeof(FriBidiChar) >= 4 ? 0x110000 : 0xFFFE)
+
+/* Unicode version - FRIBIDI_UNICODE_VERSION */
+#if DONT_HAVE_FRIBIDI_UNICODE_VERSION_H+0
+# define FRIBIDI_UNICODE_VERSION "unknown"
+#else /* !DONT_HAVE_FRIBIDI_UNICODE_VERSION_H */
+# include "fribidi-unicode-version.h"
+#endif /* !DONT_HAVE_FRIBIDI_UNICODE_VERSION_H */
+
+#define fribidi_unicode_version FRIBIDI_NAMESPACE(unicode_version)
+/* An string containing the version the Unicode standard implemented,
+ * in the form of "x.y.z", or "unknown". */
+extern const char *fribidi_unicode_version;
+
+
+/* Unicode Bidirectional Algorithm definitions: */
+
+/* Number of types defined in the bidi algorithm */
+#define FRIBIDI_BIDI_NUM_TYPES			19
+
+/* The maximum embedding level value assigned by explicit marks */
+#define FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL		61
+/* The maximum *number* of different resolved embedding levels: 0-62 */
+#define FRIBIDI_BIDI_MAX_RESOLVED_LEVELS	63
+
+
+/* A few Unicode characters: */
+
+/* Bidirectional marks */
+#define FRIBIDI_CHAR_LRM		0x200E
+#define FRIBIDI_CHAR_RLM		0x200F
+#define FRIBIDI_CHAR_LRE		0x202A
+#define FRIBIDI_CHAR_RLE		0x202B
+#define FRIBIDI_CHAR_PDF		0x202C
+#define FRIBIDI_CHAR_LRO		0x202D
+#define FRIBIDI_CHAR_RLO		0x202E
+
+/* Line and Paragraph Separators */
+#define FRIBIDI_CHAR_LS			0x2028
+#define FRIBIDI_CHAR_PS			0x2029
+
+/* Arabic Joining marks */
+#define FRIBIDI_CHAR_ZWNJ		0x200C
+#define FRIBIDI_CHAR_ZWJ		0x200D
+
+/* Hebrew and Arabic */
+#define FRIBIDI_CHAR_HEBREW_ALEF	0x05D0
+#define FRIBIDI_CHAR_ARABIC_ALEF	0x0627
+#define FRIBIDI_CHAR_ARABIC_ZERO	0x0660
+#define FRIBIDI_CHAR_PERSIAN_ZERO	0x06F0
+
+/* Misc */
+#define FRIBIDI_CHAR_ZWNBSP		0xFEFF
+
+/* Char we place for a deleted slot, to delete later */
+#define FRIBIDI_CHAR_FILL		FRIBIDI_CHAR_ZWNBSP
+
+#include "fribidi-enddecls.h"
+
+#endif /* !_FRIBIDI_UNICODE_H */
+/* Editor directions:
+ * vim:textwidth=78:tabstop=8:shiftwidth=2:autoindent:cindent
+ */
diff -rupN orginal/scribus/fribidi/fribidi.c patched/scribus/fribidi/fribidi.c
--- orginal/scribus/fribidi/fribidi.c	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/fribidi/fribidi.c	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,105 @@
+/* FriBidi
+ * fribidi.c - Unicode bidirectional and Arabic joining/shaping algorithms
+ *
+ * $Id: fribidi.c,v 1.18 2006/01/31 03:23:13 behdad Exp $
+ * $Author: behdad $
+ * $Date: 2006/01/31 03:23:13 $
+ * $Revision: 1.18 $
+ * $Source: /cvs/fribidi/fribidi2/lib/fribidi.c,v $
+ *
+ * Authors:
+ *   Behdad Esfahbod, 2001, 2002, 2004
+ *   Dov Grobgeld, 1999, 2000
+ *
+ * Copyright (C) 2004 Sharif FarsiWeb, Inc
+ * Copyright (C) 2001,2002 Behdad Esfahbod
+ * Copyright (C) 1999,2000 Dov Grobgeld
+ * 
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ * 
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library, in a file named COPYING; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA
+ * 
+ * For licensing issues, contact <license@farsiweb.info>.
+ */
+
+#include "common.h"
+
+#include <fribidi.h>
+
+#if DEBUG+0
+static int flag_debug = false;
+#endif
+
+FRIBIDI_ENTRY fribidi_boolean
+fribidi_debug_status (
+  void
+)
+{
+#if DEBUG+0
+  return flag_debug;
+#else
+  return false;
+#endif
+}
+
+FRIBIDI_ENTRY fribidi_boolean
+fribidi_set_debug (
+  /* input */
+  fribidi_boolean state
+)
+{
+#if DEBUG+0
+  return flag_debug = state;
+#else
+  return false;
+#endif
+}
+
+
+
+const char *fribidi_unicode_version = FRIBIDI_UNICODE_VERSION;
+
+const char *fribidi_version_info =
+  "(" FRIBIDI_NAME ") " FRIBIDI_VERSION "\n"
+  "interface version " FRIBIDI_INTERFACE_VERSION_STRING ",\n"
+  "Unicode Character Database version " FRIBIDI_UNICODE_VERSION ",\n"
+  "Configure options"
+#if DEBUG+0
+  " --enable-debug"
+#endif /* DEBUG */
+#if USE_SIMPLE_MALLOC+0
+  " --enable-malloc"
+#endif /* USE_SIMPLE_MALLOC */
+#if FRIBIDI_CHARSETS+0
+#else
+  " --disable-charsets"
+#endif /* !FRIBIDI_CHARSETS */
+#if FRIBIDI_USE_GLIB+0
+  " --with-glib"
+#else /* !FRIBIDI_USE_GLIB */
+  " --without-glib"
+#endif /* !FRIBIDI_USE_GLIB */
+  ".\n\n"
+  "Copyright (C) 2004  Sharif FarsiWeb, Inc.\n"
+  "Copyright (C) 2001, 2002, 2004, 2005  Behdad Esfahbod\n"
+  "Copyright (C) 1999, 2000  Dov Grobgeld\n"
+  FRIBIDI_NAME " comes with NO WARRANTY, to the extent permitted by law.\n"
+  "You may redistribute copies of " FRIBIDI_NAME " under\n"
+  "the terms of the GNU Lesser General Public License.\n"
+  "For more information about these matters, see the file named COPYING.\n\n"
+  "Written by Behdad Esfahbod and Dov Grobgeld.\n";
+
+/* Editor directions:
+ * vim:textwidth=78:tabstop=8:shiftwidth=2:autoindent:cindent
+ */
diff -rupN orginal/scribus/fribidi/fribidi.h patched/scribus/fribidi/fribidi.h
--- orginal/scribus/fribidi/fribidi.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/fribidi/fribidi.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,68 @@
+/* FriBidi
+ * fribidi.h - Unicode bidirectional and Arabic joining/shaping algorithms
+ *
+ * $Id: fribidi.h,v 1.10 2006/01/31 03:23:13 behdad Exp $
+ * $Author: behdad $
+ * $Date: 2006/01/31 03:23:13 $
+ * $Revision: 1.10 $
+ * $Source: /cvs/fribidi/fribidi2/lib/fribidi.h,v $
+ *
+ * Author:
+ *   Behdad Esfahbod, 2004
+ *
+ * Copyright (C) 2004 Sharif FarsiWeb, Inc
+ * 
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ * 
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library, in a file named COPYING; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA
+ * 
+ * For licensing issues, contact <license@farsiweb.info>.
+ */
+#ifndef _FRIBIDI_H
+#define _FRIBIDI_H
+
+#include "fribidi-common.h"
+
+#include "fribidi-unicode.h"
+#include "fribidi-types.h"
+#include "fribidi-flags.h"
+#include "fribidi-bidi-types.h"
+#include "fribidi-bidi.h"
+#include "fribidi-joining-types.h"
+#include "fribidi-joining.h"
+#include "fribidi-mirroring.h"
+#include "fribidi-arabic.h"
+#include "fribidi-shape.h"
+
+
+#if FRIBIDI_NO_DEPRECATED+0
+#else
+# include "fribidi-deprecated.h"
+#endif				/* !FRIBIDI_NO_DEPRECATED */
+
+
+#include "fribidi-begindecls.h"
+
+
+
+#define fribidi_version_info FRIBIDI_NAMESPACE(version_info)
+/* An string containing the version information of the library. */
+     extern const char *fribidi_version_info;
+
+#include "fribidi-enddecls.h"
+
+#endif /* !_FRIBIDI_H */
+/* Editor directions:
+ * vim:textwidth=78:tabstop=8:shiftwidth=2:autoindent:cindent
+ */
diff -rupN orginal/scribus/fribidi/INSTALL patched/scribus/fribidi/INSTALL
--- orginal/scribus/fribidi/INSTALL	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/fribidi/INSTALL	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,291 @@
+Installation Instructions
+*************************
+
+Copyright (C) 1994, 1995, 1996, 1999, 2000, 2001, 2002, 2004, 2005,
+2006, 2007, 2008 Free Software Foundation, Inc.
+
+   This file is free documentation; the Free Software Foundation gives
+unlimited permission to copy, distribute and modify it.
+
+Basic Installation
+==================
+
+   Briefly, the shell commands `./configure; make; make install' should
+configure, build, and install this package.  The following
+more-detailed instructions are generic; see the `README' file for
+instructions specific to this package.
+
+   The `configure' shell script attempts to guess correct values for
+various system-dependent variables used during compilation.  It uses
+those values to create a `Makefile' in each directory of the package.
+It may also create one or more `.h' files containing system-dependent
+definitions.  Finally, it creates a shell script `config.status' that
+you can run in the future to recreate the current configuration, and a
+file `config.log' containing compiler output (useful mainly for
+debugging `configure').
+
+   It can also use an optional file (typically called `config.cache'
+and enabled with `--cache-file=config.cache' or simply `-C') that saves
+the results of its tests to speed up reconfiguring.  Caching is
+disabled by default to prevent problems with accidental use of stale
+cache files.
+
+   If you need to do unusual things to compile the package, please try
+to figure out how `configure' could check whether to do them, and mail
+diffs or instructions to the address given in the `README' so they can
+be considered for the next release.  If you are using the cache, and at
+some point `config.cache' contains results you don't want to keep, you
+may remove or edit it.
+
+   The file `configure.ac' (or `configure.in') is used to create
+`configure' by a program called `autoconf'.  You need `configure.ac' if
+you want to change it or regenerate `configure' using a newer version
+of `autoconf'.
+
+The simplest way to compile this package is:
+
+  1. `cd' to the directory containing the package's source code and type
+     `./configure' to configure the package for your system.
+
+     Running `configure' might take a while.  While running, it prints
+     some messages telling which features it is checking for.
+
+  2. Type `make' to compile the package.
+
+  3. Optionally, type `make check' to run any self-tests that come with
+     the package.
+
+  4. Type `make install' to install the programs and any data files and
+     documentation.
+
+  5. You can remove the program binaries and object files from the
+     source code directory by typing `make clean'.  To also remove the
+     files that `configure' created (so you can compile the package for
+     a different kind of computer), type `make distclean'.  There is
+     also a `make maintainer-clean' target, but that is intended mainly
+     for the package's developers.  If you use it, you may have to get
+     all sorts of other programs in order to regenerate files that came
+     with the distribution.
+
+  6. Often, you can also type `make uninstall' to remove the installed
+     files again.
+
+Compilers and Options
+=====================
+
+   Some systems require unusual options for compilation or linking that
+the `configure' script does not know about.  Run `./configure --help'
+for details on some of the pertinent environment variables.
+
+   You can give `configure' initial values for configuration parameters
+by setting variables in the command line or in the environment.  Here
+is an example:
+
+     ./configure CC=c99 CFLAGS=-g LIBS=-lposix
+
+   *Note Defining Variables::, for more details.
+
+Compiling For Multiple Architectures
+====================================
+
+   You can compile the package for more than one kind of computer at the
+same time, by placing the object files for each architecture in their
+own directory.  To do this, you can use GNU `make'.  `cd' to the
+directory where you want the object files and executables to go and run
+the `configure' script.  `configure' automatically checks for the
+source code in the directory that `configure' is in and in `..'.
+
+   With a non-GNU `make', it is safer to compile the package for one
+architecture at a time in the source code directory.  After you have
+installed the package for one architecture, use `make distclean' before
+reconfiguring for another architecture.
+
+   On MacOS X 10.5 and later systems, you can create libraries and
+executables that work on multiple system types--known as "fat" or
+"universal" binaries--by specifying multiple `-arch' options to the
+compiler but only a single `-arch' option to the preprocessor.  Like
+this:
+
+     ./configure CC="gcc -arch i386 -arch x86_64 -arch ppc -arch ppc64" \
+                 CXX="g++ -arch i386 -arch x86_64 -arch ppc -arch ppc64" \
+                 CPP="gcc -E" CXXCPP="g++ -E"
+
+   This is not guaranteed to produce working output in all cases, you
+may have to build one architecture at a time and combine the results
+using the `lipo' tool if you have problems.
+
+Installation Names
+==================
+
+   By default, `make install' installs the package's commands under
+`/usr/local/bin', include files under `/usr/local/include', etc.  You
+can specify an installation prefix other than `/usr/local' by giving
+`configure' the option `--prefix=PREFIX'.
+
+   You can specify separate installation prefixes for
+architecture-specific files and architecture-independent files.  If you
+pass the option `--exec-prefix=PREFIX' to `configure', the package uses
+PREFIX as the prefix for installing programs and libraries.
+Documentation and other data files still use the regular prefix.
+
+   In addition, if you use an unusual directory layout you can give
+options like `--bindir=DIR' to specify different values for particular
+kinds of files.  Run `configure --help' for a list of the directories
+you can set and what kinds of files go in them.
+
+   If the package supports it, you can cause programs to be installed
+with an extra prefix or suffix on their names by giving `configure' the
+option `--program-prefix=PREFIX' or `--program-suffix=SUFFIX'.
+
+Optional Features
+=================
+
+   Some packages pay attention to `--enable-FEATURE' options to
+`configure', where FEATURE indicates an optional part of the package.
+They may also pay attention to `--with-PACKAGE' options, where PACKAGE
+is something like `gnu-as' or `x' (for the X Window System).  The
+`README' should mention any `--enable-' and `--with-' options that the
+package recognizes.
+
+   For packages that use the X Window System, `configure' can usually
+find the X include and library files automatically, but if it doesn't,
+you can use the `configure' options `--x-includes=DIR' and
+`--x-libraries=DIR' to specify their locations.
+
+Particular systems
+==================
+
+   On HP-UX, the default C compiler is not ANSI C compatible.  If GNU
+CC is not installed, it is recommended to use the following options in
+order to use an ANSI C compiler:
+
+     ./configure CC="cc -Ae"
+
+and if that doesn't work, install pre-built binaries of GCC for HP-UX.
+
+   On OSF/1 a.k.a. Tru64, some versions of the default C compiler cannot
+parse its `<wchar.h>' header file.  The option `-nodtk' can be used as
+a workaround.  If GNU CC is not installed, it is therefore recommended
+to try
+
+     ./configure CC="cc"
+
+and if that doesn't work, try
+
+     ./configure CC="cc -nodtk"
+
+Specifying the System Type
+==========================
+
+   There may be some features `configure' cannot figure out
+automatically, but needs to determine by the type of machine the package
+will run on.  Usually, assuming the package is built to be run on the
+_same_ architectures, `configure' can figure that out, but if it prints
+a message saying it cannot guess the machine type, give it the
+`--build=TYPE' option.  TYPE can either be a short name for the system
+type, such as `sun4', or a canonical name which has the form:
+
+     CPU-COMPANY-SYSTEM
+
+where SYSTEM can have one of these forms:
+
+     OS KERNEL-OS
+
+   See the file `config.sub' for the possible values of each field.  If
+`config.sub' isn't included in this package, then this package doesn't
+need to know the machine type.
+
+   If you are _building_ compiler tools for cross-compiling, you should
+use the option `--target=TYPE' to select the type of system they will
+produce code for.
+
+   If you want to _use_ a cross compiler, that generates code for a
+platform different from the build platform, you should specify the
+"host" platform (i.e., that on which the generated programs will
+eventually be run) with `--host=TYPE'.
+
+Sharing Defaults
+================
+
+   If you want to set default values for `configure' scripts to share,
+you can create a site shell script called `config.site' that gives
+default values for variables like `CC', `cache_file', and `prefix'.
+`configure' looks for `PREFIX/share/config.site' if it exists, then
+`PREFIX/etc/config.site' if it exists.  Or, you can set the
+`CONFIG_SITE' environment variable to the location of the site script.
+A warning: not all `configure' scripts look for a site script.
+
+Defining Variables
+==================
+
+   Variables not defined in a site shell script can be set in the
+environment passed to `configure'.  However, some packages may run
+configure again during the build, and the customized values of these
+variables may be lost.  In order to avoid this problem, you should set
+them in the `configure' command line, using `VAR=value'.  For example:
+
+     ./configure CC=/usr/local2/bin/gcc
+
+causes the specified `gcc' to be used as the C compiler (unless it is
+overridden in the site shell script).
+
+Unfortunately, this technique does not work for `CONFIG_SHELL' due to
+an Autoconf bug.  Until the bug is fixed you can use this workaround:
+
+     CONFIG_SHELL=/bin/bash /bin/bash ./configure CONFIG_SHELL=/bin/bash
+
+`configure' Invocation
+======================
+
+   `configure' recognizes the following options to control how it
+operates.
+
+`--help'
+`-h'
+     Print a summary of all of the options to `configure', and exit.
+
+`--help=short'
+`--help=recursive'
+     Print a summary of the options unique to this package's
+     `configure', and exit.  The `short' variant lists options used
+     only in the top level, while the `recursive' variant lists options
+     also present in any nested packages.
+
+`--version'
+`-V'
+     Print the version of Autoconf used to generate the `configure'
+     script, and exit.
+
+`--cache-file=FILE'
+     Enable the cache: use and save the results of the tests in FILE,
+     traditionally `config.cache'.  FILE defaults to `/dev/null' to
+     disable caching.
+
+`--config-cache'
+`-C'
+     Alias for `--cache-file=config.cache'.
+
+`--quiet'
+`--silent'
+`-q'
+     Do not print messages saying which checks are being made.  To
+     suppress all normal output, redirect it to `/dev/null' (any error
+     messages will still be shown).
+
+`--srcdir=DIR'
+     Look for the package's source code in directory DIR.  Usually
+     `configure' can determine that directory automatically.
+
+`--prefix=DIR'
+     Use DIR as the installation prefix.  *Note Installation Names::
+     for more details, including other options available for fine-tuning
+     the installation locations.
+
+`--no-create'
+`-n'
+     Run the configure checks, but stop before creating any output
+     files.
+
+`configure' also accepts some other, not widely useful, options.  Run
+`configure --help' for more details.
+
diff -rupN orginal/scribus/fribidi/joining-types.h patched/scribus/fribidi/joining-types.h
--- orginal/scribus/fribidi/joining-types.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/fribidi/joining-types.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,59 @@
+/* FriBidi
+ * joining-types.h - define internal joining types
+ *
+ * $Id: joining-types.h,v 1.4 2006/01/31 03:23:13 behdad Exp $
+ * $Author: behdad $
+ * $Date: 2006/01/31 03:23:13 $
+ * $Revision: 1.4 $
+ * $Source: /cvs/fribidi/fribidi2/lib/joining-types.h,v $
+ *
+ * Author:
+ *   Behdad Esfahbod, 2004
+ *
+ * Copyright (C) 2004 Sharif FarsiWeb, Inc.
+ * Copyright (C) 2004 Behdad Esfahbod
+ * 
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ * 
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library, in a file named COPYING; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA
+ *
+ * For licensing issues, contact <license@farsiweb.info>.
+ */
+#ifndef _JOINING_TYPES_H
+#define _JOINING_TYPES_H
+
+#include "common.h"
+
+#include <fribidi-types.h>
+#include <fribidi-joining-types.h>
+
+#include <fribidi-begindecls.h>
+
+#if DEBUG+0
+
+#define fribidi_char_from_joining_type FRIBIDI_PRIVATESPACE(char_from_joining_type)
+char
+fribidi_char_from_joining_type (
+  FriBidiJoiningType j,		/* input joining type */
+  fribidi_boolean visual	/* in visual context or logical? */
+) FRIBIDI_GNUC_HIDDEN;
+
+#endif /* DEBUG */
+
+#include <fribidi-enddecls.h>
+
+#endif /* !_JOINING_TYPES_H */
+/* Editor directions:
+ * vim:textwidth=78:tabstop=8:shiftwidth=2:autoindent:cindent
+ */
diff -rupN orginal/scribus/fribidi/joining-type.tab.i patched/scribus/fribidi/joining-type.tab.i
--- orginal/scribus/fribidi/joining-type.tab.i	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/fribidi/joining-type.tab.i	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,4488 @@
+/* joining-type.tab.i
+ * generated by gen-joining-type-tab (GNU FriBidi 0.19.1)
+ * from the files UnicodeData.txt, ArabicShaping.txt of Unicode version 5.1.0. */
+
+#define PACKTAB_UINT8 fribidi_uint8
+#define PACKTAB_UINT16 fribidi_uint16
+#define PACKTAB_UINT32 fribidi_uint32
+
+/*
+  generated by packtab.c version 3
+
+  use FRIBIDI_GET_JOINING_TYPE(key) to access your table
+
+  assumed sizeof(unsigned char): 1
+  required memory: 18176
+  lookups: 2
+  partition shape: Joi[4096][256]
+  different table entries: 1 39
+*/
+
+/* *INDENT-OFF* */
+
+static const unsigned char JoiLev1[256*39] = {
+#define JoiLev1_00000 0x0
+  G,G,G,G,G,G,G,G,G,U,U,U,U,U,G,G,G,G,G,G,G,G,G,G,G,G,G,G,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,G,
+  G,G,G,G,G,U,G,G,G,G,G,G,G,G,G,G,G,G,G,G,G,G,G,G,G,G,G,G,G,G,G,G,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+#define JoiLev1_00100 0x100
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+#define JoiLev1_00300 0x200
+  T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,
+  T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,
+  T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,
+  T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+#define JoiLev1_00400 0x300
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,T,T,T,T,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+#define JoiLev1_00500 0x400
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,
+  T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,U,T,
+  U,T,T,U,T,T,U,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+#define JoiLev1_00600 0x500
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,T,T,T,T,T,T,T,T,T,T,T,U,U,U,U,U,
+  U,U,R,R,R,R,D,R,D,R,D,D,D,D,D,R,R,R,R,D,D,D,D,D,D,D,D,D,D,D,D,D,
+  C,D,D,D,D,D,D,D,R,D,D,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,D,D,T,R,R,R,U,R,R,R,D,D,D,D,D,D,D,D,
+  D,D,D,D,D,D,D,D,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,D,D,D,D,D,D,
+  D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,
+  R,D,D,R,R,R,R,R,R,R,R,R,D,R,D,R,D,D,R,R,U,R,T,T,T,T,T,T,T,U,U,T,
+  T,T,T,T,T,U,U,T,T,U,T,T,T,T,R,R,U,U,U,U,U,U,U,U,U,U,D,D,D,U,U,D,
+#define JoiLev1_00700 0x600
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,T,R,T,D,D,D,R,R,R,R,R,D,D,D,D,R,D,
+  D,D,D,D,D,D,D,D,R,D,R,D,R,D,D,R,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,
+  T,T,T,T,T,T,T,T,T,T,T,U,U,R,D,D,D,D,D,D,D,D,D,D,D,R,R,R,D,D,D,D,
+  D,D,D,D,D,D,D,D,D,D,D,R,R,D,D,D,D,R,D,R,R,D,D,D,R,R,D,D,D,D,D,D,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,T,T,T,T,T,T,T,T,T,T,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,
+  D,D,D,D,D,D,D,D,D,D,D,T,T,T,T,T,T,T,T,T,U,U,U,U,U,U,C,U,U,U,U,U,
+#define JoiLev1_00900 0x700
+  U,T,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,T,U,U,U,
+  U,T,T,T,T,T,T,T,T,U,U,U,U,T,U,U,U,T,T,T,T,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,T,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,T,U,U,U,
+  U,T,T,T,T,U,U,U,U,U,U,U,U,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,T,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+#define JoiLev1_00A00 0x800
+  U,T,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,T,U,U,U,
+  U,T,T,U,U,U,U,T,T,U,U,T,T,T,U,U,U,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,T,T,U,U,U,T,U,U,U,U,U,U,U,U,U,U,
+  U,T,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,T,U,U,U,
+  U,T,T,T,T,T,U,T,T,U,U,U,U,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,T,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+#define JoiLev1_00B00 0x900
+  U,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,T,U,U,T,
+  U,T,T,T,T,U,U,U,U,U,U,U,U,T,U,U,U,U,U,U,U,U,T,U,U,U,U,U,U,U,U,U,
+  U,U,T,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  T,U,U,U,U,U,U,U,U,U,U,U,U,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+#define JoiLev1_00C00 0xA00
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,T,T,
+  T,U,U,U,U,U,T,T,T,U,T,T,T,T,U,U,U,U,U,U,U,T,T,U,U,U,U,U,U,U,U,U,
+  U,U,T,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,T,U,U,T,
+  U,U,U,U,U,U,T,U,U,U,U,U,T,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,T,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+#define JoiLev1_00D00 0xB00
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,T,T,T,T,U,U,U,U,U,U,U,U,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,T,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,T,U,U,U,U,U,U,U,T,T,T,U,T,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+#define JoiLev1_00E00 0xC00
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,T,U,U,T,T,T,T,T,T,T,U,U,U,U,U,
+  U,U,U,U,U,U,U,T,T,T,T,T,T,T,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,T,U,U,T,T,T,T,T,T,U,T,T,U,U,U,
+  U,U,U,U,U,U,U,U,T,T,T,T,T,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+#define JoiLev1_00F00 0xD00
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,T,T,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,T,U,T,U,T,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,T,T,T,T,T,T,T,T,T,T,T,T,T,T,U,
+  T,T,T,T,T,U,T,T,U,U,U,U,U,U,U,U,T,T,T,T,T,T,T,T,U,T,T,T,T,T,T,T,
+  T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,U,U,U,
+  U,U,U,U,U,U,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+#define JoiLev1_01000 0xE00
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,T,T,T,T,U,T,T,T,T,T,T,U,T,T,U,U,T,T,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,T,T,U,U,U,U,T,T,
+  T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,T,T,T,T,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,T,U,U,T,T,U,U,U,U,U,U,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+#define JoiLev1_01300 0xF00
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,T,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+#define JoiLev1_01700 0x1000
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,T,T,T,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,T,T,T,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,T,T,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,T,T,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,T,T,U,T,T,T,T,T,T,T,U,U,
+  U,U,U,U,U,U,T,U,U,T,T,T,T,T,T,T,T,T,T,T,U,U,U,U,U,U,U,U,U,T,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+#define JoiLev1_01800 0x1100
+  U,U,U,U,U,U,U,U,U,U,U,T,T,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+#define JoiLev1_01900 0x1200
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  T,T,T,U,U,U,U,T,T,U,U,U,U,U,U,U,U,U,T,U,U,U,U,U,U,T,T,T,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+#define JoiLev1_01A00 0x1300
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,T,T,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+#define JoiLev1_01B00 0x1400
+  T,T,T,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,T,U,T,T,T,T,T,U,T,U,U,U,
+  U,U,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,T,T,T,T,T,T,T,T,T,U,U,U,U,U,U,U,U,U,U,U,U,
+  T,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,T,T,T,T,U,U,T,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+#define JoiLev1_01C00 0x1500
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,T,T,T,T,T,T,T,T,U,U,T,T,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+#define JoiLev1_01D00 0x1600
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,
+  T,T,T,T,T,T,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,T,T,
+#define JoiLev1_02000 0x1700
+  U,U,U,U,U,U,U,U,U,U,U,T,U,C,T,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,T,T,T,T,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  T,T,T,T,T,U,U,U,U,U,T,T,T,T,T,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,T,T,T,T,T,T,T,T,T,T,T,T,T,U,U,U,
+  U,T,U,U,U,T,T,T,T,T,T,T,T,T,T,T,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+#define JoiLev1_02D00 0x1800
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,
+#define JoiLev1_03000 0x1900
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,T,T,T,T,T,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,T,T,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+#define JoiLev1_0A600 0x1A00
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,T,U,U,U,U,U,U,U,U,U,U,U,U,T,T,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+#define JoiLev1_0A800 0x1B00
+  U,U,T,U,U,U,T,U,U,U,U,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,T,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+#define JoiLev1_0A900 0x1C00
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,T,T,T,T,T,T,T,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,T,T,T,T,T,T,T,T,T,T,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+#define JoiLev1_0AA00 0x1D00
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,T,T,T,T,T,T,U,U,T,T,U,U,T,T,U,U,U,U,U,U,U,U,U,
+  U,U,U,T,U,U,U,U,U,U,U,U,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+#define JoiLev1_0FB00 0x1E00
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,T,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+#define JoiLev1_0FE00 0x1F00
+  T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  T,T,T,T,T,T,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,T,
+#define JoiLev1_0FF00 0x2000
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,T,T,T,U,U,U,U,
+#define JoiLev1_10100 0x2100
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,T,U,U,
+#define JoiLev1_10A00 0x2200
+  U,T,T,T,U,T,T,U,U,U,U,U,T,T,T,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,T,T,T,U,U,U,U,T,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+#define JoiLev1_1D100 0x2300
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,T,T,T,U,U,U,U,U,U,U,U,U,T,T,T,T,T,T,T,T,T,T,T,T,T,
+  T,T,T,U,U,T,T,T,T,T,T,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,T,T,T,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+#define JoiLev1_1D200 0x2400
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,T,T,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+#define JoiLev1_E0000 0x2500
+  U,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,
+  T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,
+  T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+  U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+#define JoiLev1_E0100 0x2600
+  T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,
+  T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,
+  T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,
+  T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,
+  T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,
+  T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,
+  T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,
+  T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,
+};
+
+static const PACKTAB_UINT16 JoiLev0[4096*1] = {
+#define JoiLev0_00000 0x0
+  JoiLev1_00000,  /* 00000..000FF */
+  JoiLev1_00100,  /* 00100..001FF */
+  JoiLev1_00100,  /* 00200..002FF */
+  JoiLev1_00300,  /* 00300..003FF */
+  JoiLev1_00400,  /* 00400..004FF */
+  JoiLev1_00500,  /* 00500..005FF */
+  JoiLev1_00600,  /* 00600..006FF */
+  JoiLev1_00700,  /* 00700..007FF */
+  JoiLev1_00100,  /* 00800..008FF */
+  JoiLev1_00900,  /* 00900..009FF */
+  JoiLev1_00A00,  /* 00A00..00AFF */
+  JoiLev1_00B00,  /* 00B00..00BFF */
+  JoiLev1_00C00,  /* 00C00..00CFF */
+  JoiLev1_00D00,  /* 00D00..00DFF */
+  JoiLev1_00E00,  /* 00E00..00EFF */
+  JoiLev1_00F00,  /* 00F00..00FFF */
+  JoiLev1_01000,  /* 01000..010FF */
+  JoiLev1_00100,  /* 01100..011FF */
+  JoiLev1_00100,  /* 01200..012FF */
+  JoiLev1_01300,  /* 01300..013FF */
+  JoiLev1_00100,  /* 01400..014FF */
+  JoiLev1_00100,  /* 01500..015FF */
+  JoiLev1_00100,  /* 01600..016FF */
+  JoiLev1_01700,  /* 01700..017FF */
+  JoiLev1_01800,  /* 01800..018FF */
+  JoiLev1_01900,  /* 01900..019FF */
+  JoiLev1_01A00,  /* 01A00..01AFF */
+  JoiLev1_01B00,  /* 01B00..01BFF */
+  JoiLev1_01C00,  /* 01C00..01CFF */
+  JoiLev1_01D00,  /* 01D00..01DFF */
+  JoiLev1_00100,  /* 01E00..01EFF */
+  JoiLev1_00100,  /* 01F00..01FFF */
+  JoiLev1_02000,  /* 02000..020FF */
+  JoiLev1_00100,  /* 02100..021FF */
+  JoiLev1_00100,  /* 02200..022FF */
+  JoiLev1_00100,  /* 02300..023FF */
+  JoiLev1_00100,  /* 02400..024FF */
+  JoiLev1_00100,  /* 02500..025FF */
+  JoiLev1_00100,  /* 02600..026FF */
+  JoiLev1_00100,  /* 02700..027FF */
+  JoiLev1_00100,  /* 02800..028FF */
+  JoiLev1_00100,  /* 02900..029FF */
+  JoiLev1_00100,  /* 02A00..02AFF */
+  JoiLev1_00100,  /* 02B00..02BFF */
+  JoiLev1_00100,  /* 02C00..02CFF */
+  JoiLev1_02D00,  /* 02D00..02DFF */
+  JoiLev1_00100,  /* 02E00..02EFF */
+  JoiLev1_00100,  /* 02F00..02FFF */
+  JoiLev1_03000,  /* 03000..030FF */
+  JoiLev1_00100,  /* 03100..031FF */
+  JoiLev1_00100,  /* 03200..032FF */
+  JoiLev1_00100,  /* 03300..033FF */
+  JoiLev1_00100,  /* 03400..034FF */
+  JoiLev1_00100,  /* 03500..035FF */
+  JoiLev1_00100,  /* 03600..036FF */
+  JoiLev1_00100,  /* 03700..037FF */
+  JoiLev1_00100,  /* 03800..038FF */
+  JoiLev1_00100,  /* 03900..039FF */
+  JoiLev1_00100,  /* 03A00..03AFF */
+  JoiLev1_00100,  /* 03B00..03BFF */
+  JoiLev1_00100,  /* 03C00..03CFF */
+  JoiLev1_00100,  /* 03D00..03DFF */
+  JoiLev1_00100,  /* 03E00..03EFF */
+  JoiLev1_00100,  /* 03F00..03FFF */
+  JoiLev1_00100,  /* 04000..040FF */
+  JoiLev1_00100,  /* 04100..041FF */
+  JoiLev1_00100,  /* 04200..042FF */
+  JoiLev1_00100,  /* 04300..043FF */
+  JoiLev1_00100,  /* 04400..044FF */
+  JoiLev1_00100,  /* 04500..045FF */
+  JoiLev1_00100,  /* 04600..046FF */
+  JoiLev1_00100,  /* 04700..047FF */
+  JoiLev1_00100,  /* 04800..048FF */
+  JoiLev1_00100,  /* 04900..049FF */
+  JoiLev1_00100,  /* 04A00..04AFF */
+  JoiLev1_00100,  /* 04B00..04BFF */
+  JoiLev1_00100,  /* 04C00..04CFF */
+  JoiLev1_00100,  /* 04D00..04DFF */
+  JoiLev1_00100,  /* 04E00..04EFF */
+  JoiLev1_00100,  /* 04F00..04FFF */
+  JoiLev1_00100,  /* 05000..050FF */
+  JoiLev1_00100,  /* 05100..051FF */
+  JoiLev1_00100,  /* 05200..052FF */
+  JoiLev1_00100,  /* 05300..053FF */
+  JoiLev1_00100,  /* 05400..054FF */
+  JoiLev1_00100,  /* 05500..055FF */
+  JoiLev1_00100,  /* 05600..056FF */
+  JoiLev1_00100,  /* 05700..057FF */
+  JoiLev1_00100,  /* 05800..058FF */
+  JoiLev1_00100,  /* 05900..059FF */
+  JoiLev1_00100,  /* 05A00..05AFF */
+  JoiLev1_00100,  /* 05B00..05BFF */
+  JoiLev1_00100,  /* 05C00..05CFF */
+  JoiLev1_00100,  /* 05D00..05DFF */
+  JoiLev1_00100,  /* 05E00..05EFF */
+  JoiLev1_00100,  /* 05F00..05FFF */
+  JoiLev1_00100,  /* 06000..060FF */
+  JoiLev1_00100,  /* 06100..061FF */
+  JoiLev1_00100,  /* 06200..062FF */
+  JoiLev1_00100,  /* 06300..063FF */
+  JoiLev1_00100,  /* 06400..064FF */
+  JoiLev1_00100,  /* 06500..065FF */
+  JoiLev1_00100,  /* 06600..066FF */
+  JoiLev1_00100,  /* 06700..067FF */
+  JoiLev1_00100,  /* 06800..068FF */
+  JoiLev1_00100,  /* 06900..069FF */
+  JoiLev1_00100,  /* 06A00..06AFF */
+  JoiLev1_00100,  /* 06B00..06BFF */
+  JoiLev1_00100,  /* 06C00..06CFF */
+  JoiLev1_00100,  /* 06D00..06DFF */
+  JoiLev1_00100,  /* 06E00..06EFF */
+  JoiLev1_00100,  /* 06F00..06FFF */
+  JoiLev1_00100,  /* 07000..070FF */
+  JoiLev1_00100,  /* 07100..071FF */
+  JoiLev1_00100,  /* 07200..072FF */
+  JoiLev1_00100,  /* 07300..073FF */
+  JoiLev1_00100,  /* 07400..074FF */
+  JoiLev1_00100,  /* 07500..075FF */
+  JoiLev1_00100,  /* 07600..076FF */
+  JoiLev1_00100,  /* 07700..077FF */
+  JoiLev1_00100,  /* 07800..078FF */
+  JoiLev1_00100,  /* 07900..079FF */
+  JoiLev1_00100,  /* 07A00..07AFF */
+  JoiLev1_00100,  /* 07B00..07BFF */
+  JoiLev1_00100,  /* 07C00..07CFF */
+  JoiLev1_00100,  /* 07D00..07DFF */
+  JoiLev1_00100,  /* 07E00..07EFF */
+  JoiLev1_00100,  /* 07F00..07FFF */
+  JoiLev1_00100,  /* 08000..080FF */
+  JoiLev1_00100,  /* 08100..081FF */
+  JoiLev1_00100,  /* 08200..082FF */
+  JoiLev1_00100,  /* 08300..083FF */
+  JoiLev1_00100,  /* 08400..084FF */
+  JoiLev1_00100,  /* 08500..085FF */
+  JoiLev1_00100,  /* 08600..086FF */
+  JoiLev1_00100,  /* 08700..087FF */
+  JoiLev1_00100,  /* 08800..088FF */
+  JoiLev1_00100,  /* 08900..089FF */
+  JoiLev1_00100,  /* 08A00..08AFF */
+  JoiLev1_00100,  /* 08B00..08BFF */
+  JoiLev1_00100,  /* 08C00..08CFF */
+  JoiLev1_00100,  /* 08D00..08DFF */
+  JoiLev1_00100,  /* 08E00..08EFF */
+  JoiLev1_00100,  /* 08F00..08FFF */
+  JoiLev1_00100,  /* 09000..090FF */
+  JoiLev1_00100,  /* 09100..091FF */
+  JoiLev1_00100,  /* 09200..092FF */
+  JoiLev1_00100,  /* 09300..093FF */
+  JoiLev1_00100,  /* 09400..094FF */
+  JoiLev1_00100,  /* 09500..095FF */
+  JoiLev1_00100,  /* 09600..096FF */
+  JoiLev1_00100,  /* 09700..097FF */
+  JoiLev1_00100,  /* 09800..098FF */
+  JoiLev1_00100,  /* 09900..099FF */
+  JoiLev1_00100,  /* 09A00..09AFF */
+  JoiLev1_00100,  /* 09B00..09BFF */
+  JoiLev1_00100,  /* 09C00..09CFF */
+  JoiLev1_00100,  /* 09D00..09DFF */
+  JoiLev1_00100,  /* 09E00..09EFF */
+  JoiLev1_00100,  /* 09F00..09FFF */
+  JoiLev1_00100,  /* 0A000..0A0FF */
+  JoiLev1_00100,  /* 0A100..0A1FF */
+  JoiLev1_00100,  /* 0A200..0A2FF */
+  JoiLev1_00100,  /* 0A300..0A3FF */
+  JoiLev1_00100,  /* 0A400..0A4FF */
+  JoiLev1_00100,  /* 0A500..0A5FF */
+  JoiLev1_0A600,  /* 0A600..0A6FF */
+  JoiLev1_00100,  /* 0A700..0A7FF */
+  JoiLev1_0A800,  /* 0A800..0A8FF */
+  JoiLev1_0A900,  /* 0A900..0A9FF */
+  JoiLev1_0AA00,  /* 0AA00..0AAFF */
+  JoiLev1_00100,  /* 0AB00..0ABFF */
+  JoiLev1_00100,  /* 0AC00..0ACFF */
+  JoiLev1_00100,  /* 0AD00..0ADFF */
+  JoiLev1_00100,  /* 0AE00..0AEFF */
+  JoiLev1_00100,  /* 0AF00..0AFFF */
+  JoiLev1_00100,  /* 0B000..0B0FF */
+  JoiLev1_00100,  /* 0B100..0B1FF */
+  JoiLev1_00100,  /* 0B200..0B2FF */
+  JoiLev1_00100,  /* 0B300..0B3FF */
+  JoiLev1_00100,  /* 0B400..0B4FF */
+  JoiLev1_00100,  /* 0B500..0B5FF */
+  JoiLev1_00100,  /* 0B600..0B6FF */
+  JoiLev1_00100,  /* 0B700..0B7FF */
+  JoiLev1_00100,  /* 0B800..0B8FF */
+  JoiLev1_00100,  /* 0B900..0B9FF */
+  JoiLev1_00100,  /* 0BA00..0BAFF */
+  JoiLev1_00100,  /* 0BB00..0BBFF */
+  JoiLev1_00100,  /* 0BC00..0BCFF */
+  JoiLev1_00100,  /* 0BD00..0BDFF */
+  JoiLev1_00100,  /* 0BE00..0BEFF */
+  JoiLev1_00100,  /* 0BF00..0BFFF */
+  JoiLev1_00100,  /* 0C000..0C0FF */
+  JoiLev1_00100,  /* 0C100..0C1FF */
+  JoiLev1_00100,  /* 0C200..0C2FF */
+  JoiLev1_00100,  /* 0C300..0C3FF */
+  JoiLev1_00100,  /* 0C400..0C4FF */
+  JoiLev1_00100,  /* 0C500..0C5FF */
+  JoiLev1_00100,  /* 0C600..0C6FF */
+  JoiLev1_00100,  /* 0C700..0C7FF */
+  JoiLev1_00100,  /* 0C800..0C8FF */
+  JoiLev1_00100,  /* 0C900..0C9FF */
+  JoiLev1_00100,  /* 0CA00..0CAFF */
+  JoiLev1_00100,  /* 0CB00..0CBFF */
+  JoiLev1_00100,  /* 0CC00..0CCFF */
+  JoiLev1_00100,  /* 0CD00..0CDFF */
+  JoiLev1_00100,  /* 0CE00..0CEFF */
+  JoiLev1_00100,  /* 0CF00..0CFFF */
+  JoiLev1_00100,  /* 0D000..0D0FF */
+  JoiLev1_00100,  /* 0D100..0D1FF */
+  JoiLev1_00100,  /* 0D200..0D2FF */
+  JoiLev1_00100,  /* 0D300..0D3FF */
+  JoiLev1_00100,  /* 0D400..0D4FF */
+  JoiLev1_00100,  /* 0D500..0D5FF */
+  JoiLev1_00100,  /* 0D600..0D6FF */
+  JoiLev1_00100,  /* 0D700..0D7FF */
+  JoiLev1_00100,  /* 0D800..0D8FF */
+  JoiLev1_00100,  /* 0D900..0D9FF */
+  JoiLev1_00100,  /* 0DA00..0DAFF */
+  JoiLev1_00100,  /* 0DB00..0DBFF */
+  JoiLev1_00100,  /* 0DC00..0DCFF */
+  JoiLev1_00100,  /* 0DD00..0DDFF */
+  JoiLev1_00100,  /* 0DE00..0DEFF */
+  JoiLev1_00100,  /* 0DF00..0DFFF */
+  JoiLev1_00100,  /* 0E000..0E0FF */
+  JoiLev1_00100,  /* 0E100..0E1FF */
+  JoiLev1_00100,  /* 0E200..0E2FF */
+  JoiLev1_00100,  /* 0E300..0E3FF */
+  JoiLev1_00100,  /* 0E400..0E4FF */
+  JoiLev1_00100,  /* 0E500..0E5FF */
+  JoiLev1_00100,  /* 0E600..0E6FF */
+  JoiLev1_00100,  /* 0E700..0E7FF */
+  JoiLev1_00100,  /* 0E800..0E8FF */
+  JoiLev1_00100,  /* 0E900..0E9FF */
+  JoiLev1_00100,  /* 0EA00..0EAFF */
+  JoiLev1_00100,  /* 0EB00..0EBFF */
+  JoiLev1_00100,  /* 0EC00..0ECFF */
+  JoiLev1_00100,  /* 0ED00..0EDFF */
+  JoiLev1_00100,  /* 0EE00..0EEFF */
+  JoiLev1_00100,  /* 0EF00..0EFFF */
+  JoiLev1_00100,  /* 0F000..0F0FF */
+  JoiLev1_00100,  /* 0F100..0F1FF */
+  JoiLev1_00100,  /* 0F200..0F2FF */
+  JoiLev1_00100,  /* 0F300..0F3FF */
+  JoiLev1_00100,  /* 0F400..0F4FF */
+  JoiLev1_00100,  /* 0F500..0F5FF */
+  JoiLev1_00100,  /* 0F600..0F6FF */
+  JoiLev1_00100,  /* 0F700..0F7FF */
+  JoiLev1_00100,  /* 0F800..0F8FF */
+  JoiLev1_00100,  /* 0F900..0F9FF */
+  JoiLev1_00100,  /* 0FA00..0FAFF */
+  JoiLev1_0FB00,  /* 0FB00..0FBFF */
+  JoiLev1_00100,  /* 0FC00..0FCFF */
+  JoiLev1_00100,  /* 0FD00..0FDFF */
+  JoiLev1_0FE00,  /* 0FE00..0FEFF */
+  JoiLev1_0FF00,  /* 0FF00..0FFFF */
+  JoiLev1_00100,  /* 10000..100FF */
+  JoiLev1_10100,  /* 10100..101FF */
+  JoiLev1_00100,  /* 10200..102FF */
+  JoiLev1_00100,  /* 10300..103FF */
+  JoiLev1_00100,  /* 10400..104FF */
+  JoiLev1_00100,  /* 10500..105FF */
+  JoiLev1_00100,  /* 10600..106FF */
+  JoiLev1_00100,  /* 10700..107FF */
+  JoiLev1_00100,  /* 10800..108FF */
+  JoiLev1_00100,  /* 10900..109FF */
+  JoiLev1_10A00,  /* 10A00..10AFF */
+  JoiLev1_00100,  /* 10B00..10BFF */
+  JoiLev1_00100,  /* 10C00..10CFF */
+  JoiLev1_00100,  /* 10D00..10DFF */
+  JoiLev1_00100,  /* 10E00..10EFF */
+  JoiLev1_00100,  /* 10F00..10FFF */
+  JoiLev1_00100,  /* 11000..110FF */
+  JoiLev1_00100,  /* 11100..111FF */
+  JoiLev1_00100,  /* 11200..112FF */
+  JoiLev1_00100,  /* 11300..113FF */
+  JoiLev1_00100,  /* 11400..114FF */
+  JoiLev1_00100,  /* 11500..115FF */
+  JoiLev1_00100,  /* 11600..116FF */
+  JoiLev1_00100,  /* 11700..117FF */
+  JoiLev1_00100,  /* 11800..118FF */
+  JoiLev1_00100,  /* 11900..119FF */
+  JoiLev1_00100,  /* 11A00..11AFF */
+  JoiLev1_00100,  /* 11B00..11BFF */
+  JoiLev1_00100,  /* 11C00..11CFF */
+  JoiLev1_00100,  /* 11D00..11DFF */
+  JoiLev1_00100,  /* 11E00..11EFF */
+  JoiLev1_00100,  /* 11F00..11FFF */
+  JoiLev1_00100,  /* 12000..120FF */
+  JoiLev1_00100,  /* 12100..121FF */
+  JoiLev1_00100,  /* 12200..122FF */
+  JoiLev1_00100,  /* 12300..123FF */
+  JoiLev1_00100,  /* 12400..124FF */
+  JoiLev1_00100,  /* 12500..125FF */
+  JoiLev1_00100,  /* 12600..126FF */
+  JoiLev1_00100,  /* 12700..127FF */
+  JoiLev1_00100,  /* 12800..128FF */
+  JoiLev1_00100,  /* 12900..129FF */
+  JoiLev1_00100,  /* 12A00..12AFF */
+  JoiLev1_00100,  /* 12B00..12BFF */
+  JoiLev1_00100,  /* 12C00..12CFF */
+  JoiLev1_00100,  /* 12D00..12DFF */
+  JoiLev1_00100,  /* 12E00..12EFF */
+  JoiLev1_00100,  /* 12F00..12FFF */
+  JoiLev1_00100,  /* 13000..130FF */
+  JoiLev1_00100,  /* 13100..131FF */
+  JoiLev1_00100,  /* 13200..132FF */
+  JoiLev1_00100,  /* 13300..133FF */
+  JoiLev1_00100,  /* 13400..134FF */
+  JoiLev1_00100,  /* 13500..135FF */
+  JoiLev1_00100,  /* 13600..136FF */
+  JoiLev1_00100,  /* 13700..137FF */
+  JoiLev1_00100,  /* 13800..138FF */
+  JoiLev1_00100,  /* 13900..139FF */
+  JoiLev1_00100,  /* 13A00..13AFF */
+  JoiLev1_00100,  /* 13B00..13BFF */
+  JoiLev1_00100,  /* 13C00..13CFF */
+  JoiLev1_00100,  /* 13D00..13DFF */
+  JoiLev1_00100,  /* 13E00..13EFF */
+  JoiLev1_00100,  /* 13F00..13FFF */
+  JoiLev1_00100,  /* 14000..140FF */
+  JoiLev1_00100,  /* 14100..141FF */
+  JoiLev1_00100,  /* 14200..142FF */
+  JoiLev1_00100,  /* 14300..143FF */
+  JoiLev1_00100,  /* 14400..144FF */
+  JoiLev1_00100,  /* 14500..145FF */
+  JoiLev1_00100,  /* 14600..146FF */
+  JoiLev1_00100,  /* 14700..147FF */
+  JoiLev1_00100,  /* 14800..148FF */
+  JoiLev1_00100,  /* 14900..149FF */
+  JoiLev1_00100,  /* 14A00..14AFF */
+  JoiLev1_00100,  /* 14B00..14BFF */
+  JoiLev1_00100,  /* 14C00..14CFF */
+  JoiLev1_00100,  /* 14D00..14DFF */
+  JoiLev1_00100,  /* 14E00..14EFF */
+  JoiLev1_00100,  /* 14F00..14FFF */
+  JoiLev1_00100,  /* 15000..150FF */
+  JoiLev1_00100,  /* 15100..151FF */
+  JoiLev1_00100,  /* 15200..152FF */
+  JoiLev1_00100,  /* 15300..153FF */
+  JoiLev1_00100,  /* 15400..154FF */
+  JoiLev1_00100,  /* 15500..155FF */
+  JoiLev1_00100,  /* 15600..156FF */
+  JoiLev1_00100,  /* 15700..157FF */
+  JoiLev1_00100,  /* 15800..158FF */
+  JoiLev1_00100,  /* 15900..159FF */
+  JoiLev1_00100,  /* 15A00..15AFF */
+  JoiLev1_00100,  /* 15B00..15BFF */
+  JoiLev1_00100,  /* 15C00..15CFF */
+  JoiLev1_00100,  /* 15D00..15DFF */
+  JoiLev1_00100,  /* 15E00..15EFF */
+  JoiLev1_00100,  /* 15F00..15FFF */
+  JoiLev1_00100,  /* 16000..160FF */
+  JoiLev1_00100,  /* 16100..161FF */
+  JoiLev1_00100,  /* 16200..162FF */
+  JoiLev1_00100,  /* 16300..163FF */
+  JoiLev1_00100,  /* 16400..164FF */
+  JoiLev1_00100,  /* 16500..165FF */
+  JoiLev1_00100,  /* 16600..166FF */
+  JoiLev1_00100,  /* 16700..167FF */
+  JoiLev1_00100,  /* 16800..168FF */
+  JoiLev1_00100,  /* 16900..169FF */
+  JoiLev1_00100,  /* 16A00..16AFF */
+  JoiLev1_00100,  /* 16B00..16BFF */
+  JoiLev1_00100,  /* 16C00..16CFF */
+  JoiLev1_00100,  /* 16D00..16DFF */
+  JoiLev1_00100,  /* 16E00..16EFF */
+  JoiLev1_00100,  /* 16F00..16FFF */
+  JoiLev1_00100,  /* 17000..170FF */
+  JoiLev1_00100,  /* 17100..171FF */
+  JoiLev1_00100,  /* 17200..172FF */
+  JoiLev1_00100,  /* 17300..173FF */
+  JoiLev1_00100,  /* 17400..174FF */
+  JoiLev1_00100,  /* 17500..175FF */
+  JoiLev1_00100,  /* 17600..176FF */
+  JoiLev1_00100,  /* 17700..177FF */
+  JoiLev1_00100,  /* 17800..178FF */
+  JoiLev1_00100,  /* 17900..179FF */
+  JoiLev1_00100,  /* 17A00..17AFF */
+  JoiLev1_00100,  /* 17B00..17BFF */
+  JoiLev1_00100,  /* 17C00..17CFF */
+  JoiLev1_00100,  /* 17D00..17DFF */
+  JoiLev1_00100,  /* 17E00..17EFF */
+  JoiLev1_00100,  /* 17F00..17FFF */
+  JoiLev1_00100,  /* 18000..180FF */
+  JoiLev1_00100,  /* 18100..181FF */
+  JoiLev1_00100,  /* 18200..182FF */
+  JoiLev1_00100,  /* 18300..183FF */
+  JoiLev1_00100,  /* 18400..184FF */
+  JoiLev1_00100,  /* 18500..185FF */
+  JoiLev1_00100,  /* 18600..186FF */
+  JoiLev1_00100,  /* 18700..187FF */
+  JoiLev1_00100,  /* 18800..188FF */
+  JoiLev1_00100,  /* 18900..189FF */
+  JoiLev1_00100,  /* 18A00..18AFF */
+  JoiLev1_00100,  /* 18B00..18BFF */
+  JoiLev1_00100,  /* 18C00..18CFF */
+  JoiLev1_00100,  /* 18D00..18DFF */
+  JoiLev1_00100,  /* 18E00..18EFF */
+  JoiLev1_00100,  /* 18F00..18FFF */
+  JoiLev1_00100,  /* 19000..190FF */
+  JoiLev1_00100,  /* 19100..191FF */
+  JoiLev1_00100,  /* 19200..192FF */
+  JoiLev1_00100,  /* 19300..193FF */
+  JoiLev1_00100,  /* 19400..194FF */
+  JoiLev1_00100,  /* 19500..195FF */
+  JoiLev1_00100,  /* 19600..196FF */
+  JoiLev1_00100,  /* 19700..197FF */
+  JoiLev1_00100,  /* 19800..198FF */
+  JoiLev1_00100,  /* 19900..199FF */
+  JoiLev1_00100,  /* 19A00..19AFF */
+  JoiLev1_00100,  /* 19B00..19BFF */
+  JoiLev1_00100,  /* 19C00..19CFF */
+  JoiLev1_00100,  /* 19D00..19DFF */
+  JoiLev1_00100,  /* 19E00..19EFF */
+  JoiLev1_00100,  /* 19F00..19FFF */
+  JoiLev1_00100,  /* 1A000..1A0FF */
+  JoiLev1_00100,  /* 1A100..1A1FF */
+  JoiLev1_00100,  /* 1A200..1A2FF */
+  JoiLev1_00100,  /* 1A300..1A3FF */
+  JoiLev1_00100,  /* 1A400..1A4FF */
+  JoiLev1_00100,  /* 1A500..1A5FF */
+  JoiLev1_00100,  /* 1A600..1A6FF */
+  JoiLev1_00100,  /* 1A700..1A7FF */
+  JoiLev1_00100,  /* 1A800..1A8FF */
+  JoiLev1_00100,  /* 1A900..1A9FF */
+  JoiLev1_00100,  /* 1AA00..1AAFF */
+  JoiLev1_00100,  /* 1AB00..1ABFF */
+  JoiLev1_00100,  /* 1AC00..1ACFF */
+  JoiLev1_00100,  /* 1AD00..1ADFF */
+  JoiLev1_00100,  /* 1AE00..1AEFF */
+  JoiLev1_00100,  /* 1AF00..1AFFF */
+  JoiLev1_00100,  /* 1B000..1B0FF */
+  JoiLev1_00100,  /* 1B100..1B1FF */
+  JoiLev1_00100,  /* 1B200..1B2FF */
+  JoiLev1_00100,  /* 1B300..1B3FF */
+  JoiLev1_00100,  /* 1B400..1B4FF */
+  JoiLev1_00100,  /* 1B500..1B5FF */
+  JoiLev1_00100,  /* 1B600..1B6FF */
+  JoiLev1_00100,  /* 1B700..1B7FF */
+  JoiLev1_00100,  /* 1B800..1B8FF */
+  JoiLev1_00100,  /* 1B900..1B9FF */
+  JoiLev1_00100,  /* 1BA00..1BAFF */
+  JoiLev1_00100,  /* 1BB00..1BBFF */
+  JoiLev1_00100,  /* 1BC00..1BCFF */
+  JoiLev1_00100,  /* 1BD00..1BDFF */
+  JoiLev1_00100,  /* 1BE00..1BEFF */
+  JoiLev1_00100,  /* 1BF00..1BFFF */
+  JoiLev1_00100,  /* 1C000..1C0FF */
+  JoiLev1_00100,  /* 1C100..1C1FF */
+  JoiLev1_00100,  /* 1C200..1C2FF */
+  JoiLev1_00100,  /* 1C300..1C3FF */
+  JoiLev1_00100,  /* 1C400..1C4FF */
+  JoiLev1_00100,  /* 1C500..1C5FF */
+  JoiLev1_00100,  /* 1C600..1C6FF */
+  JoiLev1_00100,  /* 1C700..1C7FF */
+  JoiLev1_00100,  /* 1C800..1C8FF */
+  JoiLev1_00100,  /* 1C900..1C9FF */
+  JoiLev1_00100,  /* 1CA00..1CAFF */
+  JoiLev1_00100,  /* 1CB00..1CBFF */
+  JoiLev1_00100,  /* 1CC00..1CCFF */
+  JoiLev1_00100,  /* 1CD00..1CDFF */
+  JoiLev1_00100,  /* 1CE00..1CEFF */
+  JoiLev1_00100,  /* 1CF00..1CFFF */
+  JoiLev1_00100,  /* 1D000..1D0FF */
+  JoiLev1_1D100,  /* 1D100..1D1FF */
+  JoiLev1_1D200,  /* 1D200..1D2FF */
+  JoiLev1_00100,  /* 1D300..1D3FF */
+  JoiLev1_00100,  /* 1D400..1D4FF */
+  JoiLev1_00100,  /* 1D500..1D5FF */
+  JoiLev1_00100,  /* 1D600..1D6FF */
+  JoiLev1_00100,  /* 1D700..1D7FF */
+  JoiLev1_00100,  /* 1D800..1D8FF */
+  JoiLev1_00100,  /* 1D900..1D9FF */
+  JoiLev1_00100,  /* 1DA00..1DAFF */
+  JoiLev1_00100,  /* 1DB00..1DBFF */
+  JoiLev1_00100,  /* 1DC00..1DCFF */
+  JoiLev1_00100,  /* 1DD00..1DDFF */
+  JoiLev1_00100,  /* 1DE00..1DEFF */
+  JoiLev1_00100,  /* 1DF00..1DFFF */
+  JoiLev1_00100,  /* 1E000..1E0FF */
+  JoiLev1_00100,  /* 1E100..1E1FF */
+  JoiLev1_00100,  /* 1E200..1E2FF */
+  JoiLev1_00100,  /* 1E300..1E3FF */
+  JoiLev1_00100,  /* 1E400..1E4FF */
+  JoiLev1_00100,  /* 1E500..1E5FF */
+  JoiLev1_00100,  /* 1E600..1E6FF */
+  JoiLev1_00100,  /* 1E700..1E7FF */
+  JoiLev1_00100,  /* 1E800..1E8FF */
+  JoiLev1_00100,  /* 1E900..1E9FF */
+  JoiLev1_00100,  /* 1EA00..1EAFF */
+  JoiLev1_00100,  /* 1EB00..1EBFF */
+  JoiLev1_00100,  /* 1EC00..1ECFF */
+  JoiLev1_00100,  /* 1ED00..1EDFF */
+  JoiLev1_00100,  /* 1EE00..1EEFF */
+  JoiLev1_00100,  /* 1EF00..1EFFF */
+  JoiLev1_00100,  /* 1F000..1F0FF */
+  JoiLev1_00100,  /* 1F100..1F1FF */
+  JoiLev1_00100,  /* 1F200..1F2FF */
+  JoiLev1_00100,  /* 1F300..1F3FF */
+  JoiLev1_00100,  /* 1F400..1F4FF */
+  JoiLev1_00100,  /* 1F500..1F5FF */
+  JoiLev1_00100,  /* 1F600..1F6FF */
+  JoiLev1_00100,  /* 1F700..1F7FF */
+  JoiLev1_00100,  /* 1F800..1F8FF */
+  JoiLev1_00100,  /* 1F900..1F9FF */
+  JoiLev1_00100,  /* 1FA00..1FAFF */
+  JoiLev1_00100,  /* 1FB00..1FBFF */
+  JoiLev1_00100,  /* 1FC00..1FCFF */
+  JoiLev1_00100,  /* 1FD00..1FDFF */
+  JoiLev1_00100,  /* 1FE00..1FEFF */
+  JoiLev1_00100,  /* 1FF00..1FFFF */
+  JoiLev1_00100,  /* 20000..200FF */
+  JoiLev1_00100,  /* 20100..201FF */
+  JoiLev1_00100,  /* 20200..202FF */
+  JoiLev1_00100,  /* 20300..203FF */
+  JoiLev1_00100,  /* 20400..204FF */
+  JoiLev1_00100,  /* 20500..205FF */
+  JoiLev1_00100,  /* 20600..206FF */
+  JoiLev1_00100,  /* 20700..207FF */
+  JoiLev1_00100,  /* 20800..208FF */
+  JoiLev1_00100,  /* 20900..209FF */
+  JoiLev1_00100,  /* 20A00..20AFF */
+  JoiLev1_00100,  /* 20B00..20BFF */
+  JoiLev1_00100,  /* 20C00..20CFF */
+  JoiLev1_00100,  /* 20D00..20DFF */
+  JoiLev1_00100,  /* 20E00..20EFF */
+  JoiLev1_00100,  /* 20F00..20FFF */
+  JoiLev1_00100,  /* 21000..210FF */
+  JoiLev1_00100,  /* 21100..211FF */
+  JoiLev1_00100,  /* 21200..212FF */
+  JoiLev1_00100,  /* 21300..213FF */
+  JoiLev1_00100,  /* 21400..214FF */
+  JoiLev1_00100,  /* 21500..215FF */
+  JoiLev1_00100,  /* 21600..216FF */
+  JoiLev1_00100,  /* 21700..217FF */
+  JoiLev1_00100,  /* 21800..218FF */
+  JoiLev1_00100,  /* 21900..219FF */
+  JoiLev1_00100,  /* 21A00..21AFF */
+  JoiLev1_00100,  /* 21B00..21BFF */
+  JoiLev1_00100,  /* 21C00..21CFF */
+  JoiLev1_00100,  /* 21D00..21DFF */
+  JoiLev1_00100,  /* 21E00..21EFF */
+  JoiLev1_00100,  /* 21F00..21FFF */
+  JoiLev1_00100,  /* 22000..220FF */
+  JoiLev1_00100,  /* 22100..221FF */
+  JoiLev1_00100,  /* 22200..222FF */
+  JoiLev1_00100,  /* 22300..223FF */
+  JoiLev1_00100,  /* 22400..224FF */
+  JoiLev1_00100,  /* 22500..225FF */
+  JoiLev1_00100,  /* 22600..226FF */
+  JoiLev1_00100,  /* 22700..227FF */
+  JoiLev1_00100,  /* 22800..228FF */
+  JoiLev1_00100,  /* 22900..229FF */
+  JoiLev1_00100,  /* 22A00..22AFF */
+  JoiLev1_00100,  /* 22B00..22BFF */
+  JoiLev1_00100,  /* 22C00..22CFF */
+  JoiLev1_00100,  /* 22D00..22DFF */
+  JoiLev1_00100,  /* 22E00..22EFF */
+  JoiLev1_00100,  /* 22F00..22FFF */
+  JoiLev1_00100,  /* 23000..230FF */
+  JoiLev1_00100,  /* 23100..231FF */
+  JoiLev1_00100,  /* 23200..232FF */
+  JoiLev1_00100,  /* 23300..233FF */
+  JoiLev1_00100,  /* 23400..234FF */
+  JoiLev1_00100,  /* 23500..235FF */
+  JoiLev1_00100,  /* 23600..236FF */
+  JoiLev1_00100,  /* 23700..237FF */
+  JoiLev1_00100,  /* 23800..238FF */
+  JoiLev1_00100,  /* 23900..239FF */
+  JoiLev1_00100,  /* 23A00..23AFF */
+  JoiLev1_00100,  /* 23B00..23BFF */
+  JoiLev1_00100,  /* 23C00..23CFF */
+  JoiLev1_00100,  /* 23D00..23DFF */
+  JoiLev1_00100,  /* 23E00..23EFF */
+  JoiLev1_00100,  /* 23F00..23FFF */
+  JoiLev1_00100,  /* 24000..240FF */
+  JoiLev1_00100,  /* 24100..241FF */
+  JoiLev1_00100,  /* 24200..242FF */
+  JoiLev1_00100,  /* 24300..243FF */
+  JoiLev1_00100,  /* 24400..244FF */
+  JoiLev1_00100,  /* 24500..245FF */
+  JoiLev1_00100,  /* 24600..246FF */
+  JoiLev1_00100,  /* 24700..247FF */
+  JoiLev1_00100,  /* 24800..248FF */
+  JoiLev1_00100,  /* 24900..249FF */
+  JoiLev1_00100,  /* 24A00..24AFF */
+  JoiLev1_00100,  /* 24B00..24BFF */
+  JoiLev1_00100,  /* 24C00..24CFF */
+  JoiLev1_00100,  /* 24D00..24DFF */
+  JoiLev1_00100,  /* 24E00..24EFF */
+  JoiLev1_00100,  /* 24F00..24FFF */
+  JoiLev1_00100,  /* 25000..250FF */
+  JoiLev1_00100,  /* 25100..251FF */
+  JoiLev1_00100,  /* 25200..252FF */
+  JoiLev1_00100,  /* 25300..253FF */
+  JoiLev1_00100,  /* 25400..254FF */
+  JoiLev1_00100,  /* 25500..255FF */
+  JoiLev1_00100,  /* 25600..256FF */
+  JoiLev1_00100,  /* 25700..257FF */
+  JoiLev1_00100,  /* 25800..258FF */
+  JoiLev1_00100,  /* 25900..259FF */
+  JoiLev1_00100,  /* 25A00..25AFF */
+  JoiLev1_00100,  /* 25B00..25BFF */
+  JoiLev1_00100,  /* 25C00..25CFF */
+  JoiLev1_00100,  /* 25D00..25DFF */
+  JoiLev1_00100,  /* 25E00..25EFF */
+  JoiLev1_00100,  /* 25F00..25FFF */
+  JoiLev1_00100,  /* 26000..260FF */
+  JoiLev1_00100,  /* 26100..261FF */
+  JoiLev1_00100,  /* 26200..262FF */
+  JoiLev1_00100,  /* 26300..263FF */
+  JoiLev1_00100,  /* 26400..264FF */
+  JoiLev1_00100,  /* 26500..265FF */
+  JoiLev1_00100,  /* 26600..266FF */
+  JoiLev1_00100,  /* 26700..267FF */
+  JoiLev1_00100,  /* 26800..268FF */
+  JoiLev1_00100,  /* 26900..269FF */
+  JoiLev1_00100,  /* 26A00..26AFF */
+  JoiLev1_00100,  /* 26B00..26BFF */
+  JoiLev1_00100,  /* 26C00..26CFF */
+  JoiLev1_00100,  /* 26D00..26DFF */
+  JoiLev1_00100,  /* 26E00..26EFF */
+  JoiLev1_00100,  /* 26F00..26FFF */
+  JoiLev1_00100,  /* 27000..270FF */
+  JoiLev1_00100,  /* 27100..271FF */
+  JoiLev1_00100,  /* 27200..272FF */
+  JoiLev1_00100,  /* 27300..273FF */
+  JoiLev1_00100,  /* 27400..274FF */
+  JoiLev1_00100,  /* 27500..275FF */
+  JoiLev1_00100,  /* 27600..276FF */
+  JoiLev1_00100,  /* 27700..277FF */
+  JoiLev1_00100,  /* 27800..278FF */
+  JoiLev1_00100,  /* 27900..279FF */
+  JoiLev1_00100,  /* 27A00..27AFF */
+  JoiLev1_00100,  /* 27B00..27BFF */
+  JoiLev1_00100,  /* 27C00..27CFF */
+  JoiLev1_00100,  /* 27D00..27DFF */
+  JoiLev1_00100,  /* 27E00..27EFF */
+  JoiLev1_00100,  /* 27F00..27FFF */
+  JoiLev1_00100,  /* 28000..280FF */
+  JoiLev1_00100,  /* 28100..281FF */
+  JoiLev1_00100,  /* 28200..282FF */
+  JoiLev1_00100,  /* 28300..283FF */
+  JoiLev1_00100,  /* 28400..284FF */
+  JoiLev1_00100,  /* 28500..285FF */
+  JoiLev1_00100,  /* 28600..286FF */
+  JoiLev1_00100,  /* 28700..287FF */
+  JoiLev1_00100,  /* 28800..288FF */
+  JoiLev1_00100,  /* 28900..289FF */
+  JoiLev1_00100,  /* 28A00..28AFF */
+  JoiLev1_00100,  /* 28B00..28BFF */
+  JoiLev1_00100,  /* 28C00..28CFF */
+  JoiLev1_00100,  /* 28D00..28DFF */
+  JoiLev1_00100,  /* 28E00..28EFF */
+  JoiLev1_00100,  /* 28F00..28FFF */
+  JoiLev1_00100,  /* 29000..290FF */
+  JoiLev1_00100,  /* 29100..291FF */
+  JoiLev1_00100,  /* 29200..292FF */
+  JoiLev1_00100,  /* 29300..293FF */
+  JoiLev1_00100,  /* 29400..294FF */
+  JoiLev1_00100,  /* 29500..295FF */
+  JoiLev1_00100,  /* 29600..296FF */
+  JoiLev1_00100,  /* 29700..297FF */
+  JoiLev1_00100,  /* 29800..298FF */
+  JoiLev1_00100,  /* 29900..299FF */
+  JoiLev1_00100,  /* 29A00..29AFF */
+  JoiLev1_00100,  /* 29B00..29BFF */
+  JoiLev1_00100,  /* 29C00..29CFF */
+  JoiLev1_00100,  /* 29D00..29DFF */
+  JoiLev1_00100,  /* 29E00..29EFF */
+  JoiLev1_00100,  /* 29F00..29FFF */
+  JoiLev1_00100,  /* 2A000..2A0FF */
+  JoiLev1_00100,  /* 2A100..2A1FF */
+  JoiLev1_00100,  /* 2A200..2A2FF */
+  JoiLev1_00100,  /* 2A300..2A3FF */
+  JoiLev1_00100,  /* 2A400..2A4FF */
+  JoiLev1_00100,  /* 2A500..2A5FF */
+  JoiLev1_00100,  /* 2A600..2A6FF */
+  JoiLev1_00100,  /* 2A700..2A7FF */
+  JoiLev1_00100,  /* 2A800..2A8FF */
+  JoiLev1_00100,  /* 2A900..2A9FF */
+  JoiLev1_00100,  /* 2AA00..2AAFF */
+  JoiLev1_00100,  /* 2AB00..2ABFF */
+  JoiLev1_00100,  /* 2AC00..2ACFF */
+  JoiLev1_00100,  /* 2AD00..2ADFF */
+  JoiLev1_00100,  /* 2AE00..2AEFF */
+  JoiLev1_00100,  /* 2AF00..2AFFF */
+  JoiLev1_00100,  /* 2B000..2B0FF */
+  JoiLev1_00100,  /* 2B100..2B1FF */
+  JoiLev1_00100,  /* 2B200..2B2FF */
+  JoiLev1_00100,  /* 2B300..2B3FF */
+  JoiLev1_00100,  /* 2B400..2B4FF */
+  JoiLev1_00100,  /* 2B500..2B5FF */
+  JoiLev1_00100,  /* 2B600..2B6FF */
+  JoiLev1_00100,  /* 2B700..2B7FF */
+  JoiLev1_00100,  /* 2B800..2B8FF */
+  JoiLev1_00100,  /* 2B900..2B9FF */
+  JoiLev1_00100,  /* 2BA00..2BAFF */
+  JoiLev1_00100,  /* 2BB00..2BBFF */
+  JoiLev1_00100,  /* 2BC00..2BCFF */
+  JoiLev1_00100,  /* 2BD00..2BDFF */
+  JoiLev1_00100,  /* 2BE00..2BEFF */
+  JoiLev1_00100,  /* 2BF00..2BFFF */
+  JoiLev1_00100,  /* 2C000..2C0FF */
+  JoiLev1_00100,  /* 2C100..2C1FF */
+  JoiLev1_00100,  /* 2C200..2C2FF */
+  JoiLev1_00100,  /* 2C300..2C3FF */
+  JoiLev1_00100,  /* 2C400..2C4FF */
+  JoiLev1_00100,  /* 2C500..2C5FF */
+  JoiLev1_00100,  /* 2C600..2C6FF */
+  JoiLev1_00100,  /* 2C700..2C7FF */
+  JoiLev1_00100,  /* 2C800..2C8FF */
+  JoiLev1_00100,  /* 2C900..2C9FF */
+  JoiLev1_00100,  /* 2CA00..2CAFF */
+  JoiLev1_00100,  /* 2CB00..2CBFF */
+  JoiLev1_00100,  /* 2CC00..2CCFF */
+  JoiLev1_00100,  /* 2CD00..2CDFF */
+  JoiLev1_00100,  /* 2CE00..2CEFF */
+  JoiLev1_00100,  /* 2CF00..2CFFF */
+  JoiLev1_00100,  /* 2D000..2D0FF */
+  JoiLev1_00100,  /* 2D100..2D1FF */
+  JoiLev1_00100,  /* 2D200..2D2FF */
+  JoiLev1_00100,  /* 2D300..2D3FF */
+  JoiLev1_00100,  /* 2D400..2D4FF */
+  JoiLev1_00100,  /* 2D500..2D5FF */
+  JoiLev1_00100,  /* 2D600..2D6FF */
+  JoiLev1_00100,  /* 2D700..2D7FF */
+  JoiLev1_00100,  /* 2D800..2D8FF */
+  JoiLev1_00100,  /* 2D900..2D9FF */
+  JoiLev1_00100,  /* 2DA00..2DAFF */
+  JoiLev1_00100,  /* 2DB00..2DBFF */
+  JoiLev1_00100,  /* 2DC00..2DCFF */
+  JoiLev1_00100,  /* 2DD00..2DDFF */
+  JoiLev1_00100,  /* 2DE00..2DEFF */
+  JoiLev1_00100,  /* 2DF00..2DFFF */
+  JoiLev1_00100,  /* 2E000..2E0FF */
+  JoiLev1_00100,  /* 2E100..2E1FF */
+  JoiLev1_00100,  /* 2E200..2E2FF */
+  JoiLev1_00100,  /* 2E300..2E3FF */
+  JoiLev1_00100,  /* 2E400..2E4FF */
+  JoiLev1_00100,  /* 2E500..2E5FF */
+  JoiLev1_00100,  /* 2E600..2E6FF */
+  JoiLev1_00100,  /* 2E700..2E7FF */
+  JoiLev1_00100,  /* 2E800..2E8FF */
+  JoiLev1_00100,  /* 2E900..2E9FF */
+  JoiLev1_00100,  /* 2EA00..2EAFF */
+  JoiLev1_00100,  /* 2EB00..2EBFF */
+  JoiLev1_00100,  /* 2EC00..2ECFF */
+  JoiLev1_00100,  /* 2ED00..2EDFF */
+  JoiLev1_00100,  /* 2EE00..2EEFF */
+  JoiLev1_00100,  /* 2EF00..2EFFF */
+  JoiLev1_00100,  /* 2F000..2F0FF */
+  JoiLev1_00100,  /* 2F100..2F1FF */
+  JoiLev1_00100,  /* 2F200..2F2FF */
+  JoiLev1_00100,  /* 2F300..2F3FF */
+  JoiLev1_00100,  /* 2F400..2F4FF */
+  JoiLev1_00100,  /* 2F500..2F5FF */
+  JoiLev1_00100,  /* 2F600..2F6FF */
+  JoiLev1_00100,  /* 2F700..2F7FF */
+  JoiLev1_00100,  /* 2F800..2F8FF */
+  JoiLev1_00100,  /* 2F900..2F9FF */
+  JoiLev1_00100,  /* 2FA00..2FAFF */
+  JoiLev1_00100,  /* 2FB00..2FBFF */
+  JoiLev1_00100,  /* 2FC00..2FCFF */
+  JoiLev1_00100,  /* 2FD00..2FDFF */
+  JoiLev1_00100,  /* 2FE00..2FEFF */
+  JoiLev1_00100,  /* 2FF00..2FFFF */
+  JoiLev1_00100,  /* 30000..300FF */
+  JoiLev1_00100,  /* 30100..301FF */
+  JoiLev1_00100,  /* 30200..302FF */
+  JoiLev1_00100,  /* 30300..303FF */
+  JoiLev1_00100,  /* 30400..304FF */
+  JoiLev1_00100,  /* 30500..305FF */
+  JoiLev1_00100,  /* 30600..306FF */
+  JoiLev1_00100,  /* 30700..307FF */
+  JoiLev1_00100,  /* 30800..308FF */
+  JoiLev1_00100,  /* 30900..309FF */
+  JoiLev1_00100,  /* 30A00..30AFF */
+  JoiLev1_00100,  /* 30B00..30BFF */
+  JoiLev1_00100,  /* 30C00..30CFF */
+  JoiLev1_00100,  /* 30D00..30DFF */
+  JoiLev1_00100,  /* 30E00..30EFF */
+  JoiLev1_00100,  /* 30F00..30FFF */
+  JoiLev1_00100,  /* 31000..310FF */
+  JoiLev1_00100,  /* 31100..311FF */
+  JoiLev1_00100,  /* 31200..312FF */
+  JoiLev1_00100,  /* 31300..313FF */
+  JoiLev1_00100,  /* 31400..314FF */
+  JoiLev1_00100,  /* 31500..315FF */
+  JoiLev1_00100,  /* 31600..316FF */
+  JoiLev1_00100,  /* 31700..317FF */
+  JoiLev1_00100,  /* 31800..318FF */
+  JoiLev1_00100,  /* 31900..319FF */
+  JoiLev1_00100,  /* 31A00..31AFF */
+  JoiLev1_00100,  /* 31B00..31BFF */
+  JoiLev1_00100,  /* 31C00..31CFF */
+  JoiLev1_00100,  /* 31D00..31DFF */
+  JoiLev1_00100,  /* 31E00..31EFF */
+  JoiLev1_00100,  /* 31F00..31FFF */
+  JoiLev1_00100,  /* 32000..320FF */
+  JoiLev1_00100,  /* 32100..321FF */
+  JoiLev1_00100,  /* 32200..322FF */
+  JoiLev1_00100,  /* 32300..323FF */
+  JoiLev1_00100,  /* 32400..324FF */
+  JoiLev1_00100,  /* 32500..325FF */
+  JoiLev1_00100,  /* 32600..326FF */
+  JoiLev1_00100,  /* 32700..327FF */
+  JoiLev1_00100,  /* 32800..328FF */
+  JoiLev1_00100,  /* 32900..329FF */
+  JoiLev1_00100,  /* 32A00..32AFF */
+  JoiLev1_00100,  /* 32B00..32BFF */
+  JoiLev1_00100,  /* 32C00..32CFF */
+  JoiLev1_00100,  /* 32D00..32DFF */
+  JoiLev1_00100,  /* 32E00..32EFF */
+  JoiLev1_00100,  /* 32F00..32FFF */
+  JoiLev1_00100,  /* 33000..330FF */
+  JoiLev1_00100,  /* 33100..331FF */
+  JoiLev1_00100,  /* 33200..332FF */
+  JoiLev1_00100,  /* 33300..333FF */
+  JoiLev1_00100,  /* 33400..334FF */
+  JoiLev1_00100,  /* 33500..335FF */
+  JoiLev1_00100,  /* 33600..336FF */
+  JoiLev1_00100,  /* 33700..337FF */
+  JoiLev1_00100,  /* 33800..338FF */
+  JoiLev1_00100,  /* 33900..339FF */
+  JoiLev1_00100,  /* 33A00..33AFF */
+  JoiLev1_00100,  /* 33B00..33BFF */
+  JoiLev1_00100,  /* 33C00..33CFF */
+  JoiLev1_00100,  /* 33D00..33DFF */
+  JoiLev1_00100,  /* 33E00..33EFF */
+  JoiLev1_00100,  /* 33F00..33FFF */
+  JoiLev1_00100,  /* 34000..340FF */
+  JoiLev1_00100,  /* 34100..341FF */
+  JoiLev1_00100,  /* 34200..342FF */
+  JoiLev1_00100,  /* 34300..343FF */
+  JoiLev1_00100,  /* 34400..344FF */
+  JoiLev1_00100,  /* 34500..345FF */
+  JoiLev1_00100,  /* 34600..346FF */
+  JoiLev1_00100,  /* 34700..347FF */
+  JoiLev1_00100,  /* 34800..348FF */
+  JoiLev1_00100,  /* 34900..349FF */
+  JoiLev1_00100,  /* 34A00..34AFF */
+  JoiLev1_00100,  /* 34B00..34BFF */
+  JoiLev1_00100,  /* 34C00..34CFF */
+  JoiLev1_00100,  /* 34D00..34DFF */
+  JoiLev1_00100,  /* 34E00..34EFF */
+  JoiLev1_00100,  /* 34F00..34FFF */
+  JoiLev1_00100,  /* 35000..350FF */
+  JoiLev1_00100,  /* 35100..351FF */
+  JoiLev1_00100,  /* 35200..352FF */
+  JoiLev1_00100,  /* 35300..353FF */
+  JoiLev1_00100,  /* 35400..354FF */
+  JoiLev1_00100,  /* 35500..355FF */
+  JoiLev1_00100,  /* 35600..356FF */
+  JoiLev1_00100,  /* 35700..357FF */
+  JoiLev1_00100,  /* 35800..358FF */
+  JoiLev1_00100,  /* 35900..359FF */
+  JoiLev1_00100,  /* 35A00..35AFF */
+  JoiLev1_00100,  /* 35B00..35BFF */
+  JoiLev1_00100,  /* 35C00..35CFF */
+  JoiLev1_00100,  /* 35D00..35DFF */
+  JoiLev1_00100,  /* 35E00..35EFF */
+  JoiLev1_00100,  /* 35F00..35FFF */
+  JoiLev1_00100,  /* 36000..360FF */
+  JoiLev1_00100,  /* 36100..361FF */
+  JoiLev1_00100,  /* 36200..362FF */
+  JoiLev1_00100,  /* 36300..363FF */
+  JoiLev1_00100,  /* 36400..364FF */
+  JoiLev1_00100,  /* 36500..365FF */
+  JoiLev1_00100,  /* 36600..366FF */
+  JoiLev1_00100,  /* 36700..367FF */
+  JoiLev1_00100,  /* 36800..368FF */
+  JoiLev1_00100,  /* 36900..369FF */
+  JoiLev1_00100,  /* 36A00..36AFF */
+  JoiLev1_00100,  /* 36B00..36BFF */
+  JoiLev1_00100,  /* 36C00..36CFF */
+  JoiLev1_00100,  /* 36D00..36DFF */
+  JoiLev1_00100,  /* 36E00..36EFF */
+  JoiLev1_00100,  /* 36F00..36FFF */
+  JoiLev1_00100,  /* 37000..370FF */
+  JoiLev1_00100,  /* 37100..371FF */
+  JoiLev1_00100,  /* 37200..372FF */
+  JoiLev1_00100,  /* 37300..373FF */
+  JoiLev1_00100,  /* 37400..374FF */
+  JoiLev1_00100,  /* 37500..375FF */
+  JoiLev1_00100,  /* 37600..376FF */
+  JoiLev1_00100,  /* 37700..377FF */
+  JoiLev1_00100,  /* 37800..378FF */
+  JoiLev1_00100,  /* 37900..379FF */
+  JoiLev1_00100,  /* 37A00..37AFF */
+  JoiLev1_00100,  /* 37B00..37BFF */
+  JoiLev1_00100,  /* 37C00..37CFF */
+  JoiLev1_00100,  /* 37D00..37DFF */
+  JoiLev1_00100,  /* 37E00..37EFF */
+  JoiLev1_00100,  /* 37F00..37FFF */
+  JoiLev1_00100,  /* 38000..380FF */
+  JoiLev1_00100,  /* 38100..381FF */
+  JoiLev1_00100,  /* 38200..382FF */
+  JoiLev1_00100,  /* 38300..383FF */
+  JoiLev1_00100,  /* 38400..384FF */
+  JoiLev1_00100,  /* 38500..385FF */
+  JoiLev1_00100,  /* 38600..386FF */
+  JoiLev1_00100,  /* 38700..387FF */
+  JoiLev1_00100,  /* 38800..388FF */
+  JoiLev1_00100,  /* 38900..389FF */
+  JoiLev1_00100,  /* 38A00..38AFF */
+  JoiLev1_00100,  /* 38B00..38BFF */
+  JoiLev1_00100,  /* 38C00..38CFF */
+  JoiLev1_00100,  /* 38D00..38DFF */
+  JoiLev1_00100,  /* 38E00..38EFF */
+  JoiLev1_00100,  /* 38F00..38FFF */
+  JoiLev1_00100,  /* 39000..390FF */
+  JoiLev1_00100,  /* 39100..391FF */
+  JoiLev1_00100,  /* 39200..392FF */
+  JoiLev1_00100,  /* 39300..393FF */
+  JoiLev1_00100,  /* 39400..394FF */
+  JoiLev1_00100,  /* 39500..395FF */
+  JoiLev1_00100,  /* 39600..396FF */
+  JoiLev1_00100,  /* 39700..397FF */
+  JoiLev1_00100,  /* 39800..398FF */
+  JoiLev1_00100,  /* 39900..399FF */
+  JoiLev1_00100,  /* 39A00..39AFF */
+  JoiLev1_00100,  /* 39B00..39BFF */
+  JoiLev1_00100,  /* 39C00..39CFF */
+  JoiLev1_00100,  /* 39D00..39DFF */
+  JoiLev1_00100,  /* 39E00..39EFF */
+  JoiLev1_00100,  /* 39F00..39FFF */
+  JoiLev1_00100,  /* 3A000..3A0FF */
+  JoiLev1_00100,  /* 3A100..3A1FF */
+  JoiLev1_00100,  /* 3A200..3A2FF */
+  JoiLev1_00100,  /* 3A300..3A3FF */
+  JoiLev1_00100,  /* 3A400..3A4FF */
+  JoiLev1_00100,  /* 3A500..3A5FF */
+  JoiLev1_00100,  /* 3A600..3A6FF */
+  JoiLev1_00100,  /* 3A700..3A7FF */
+  JoiLev1_00100,  /* 3A800..3A8FF */
+  JoiLev1_00100,  /* 3A900..3A9FF */
+  JoiLev1_00100,  /* 3AA00..3AAFF */
+  JoiLev1_00100,  /* 3AB00..3ABFF */
+  JoiLev1_00100,  /* 3AC00..3ACFF */
+  JoiLev1_00100,  /* 3AD00..3ADFF */
+  JoiLev1_00100,  /* 3AE00..3AEFF */
+  JoiLev1_00100,  /* 3AF00..3AFFF */
+  JoiLev1_00100,  /* 3B000..3B0FF */
+  JoiLev1_00100,  /* 3B100..3B1FF */
+  JoiLev1_00100,  /* 3B200..3B2FF */
+  JoiLev1_00100,  /* 3B300..3B3FF */
+  JoiLev1_00100,  /* 3B400..3B4FF */
+  JoiLev1_00100,  /* 3B500..3B5FF */
+  JoiLev1_00100,  /* 3B600..3B6FF */
+  JoiLev1_00100,  /* 3B700..3B7FF */
+  JoiLev1_00100,  /* 3B800..3B8FF */
+  JoiLev1_00100,  /* 3B900..3B9FF */
+  JoiLev1_00100,  /* 3BA00..3BAFF */
+  JoiLev1_00100,  /* 3BB00..3BBFF */
+  JoiLev1_00100,  /* 3BC00..3BCFF */
+  JoiLev1_00100,  /* 3BD00..3BDFF */
+  JoiLev1_00100,  /* 3BE00..3BEFF */
+  JoiLev1_00100,  /* 3BF00..3BFFF */
+  JoiLev1_00100,  /* 3C000..3C0FF */
+  JoiLev1_00100,  /* 3C100..3C1FF */
+  JoiLev1_00100,  /* 3C200..3C2FF */
+  JoiLev1_00100,  /* 3C300..3C3FF */
+  JoiLev1_00100,  /* 3C400..3C4FF */
+  JoiLev1_00100,  /* 3C500..3C5FF */
+  JoiLev1_00100,  /* 3C600..3C6FF */
+  JoiLev1_00100,  /* 3C700..3C7FF */
+  JoiLev1_00100,  /* 3C800..3C8FF */
+  JoiLev1_00100,  /* 3C900..3C9FF */
+  JoiLev1_00100,  /* 3CA00..3CAFF */
+  JoiLev1_00100,  /* 3CB00..3CBFF */
+  JoiLev1_00100,  /* 3CC00..3CCFF */
+  JoiLev1_00100,  /* 3CD00..3CDFF */
+  JoiLev1_00100,  /* 3CE00..3CEFF */
+  JoiLev1_00100,  /* 3CF00..3CFFF */
+  JoiLev1_00100,  /* 3D000..3D0FF */
+  JoiLev1_00100,  /* 3D100..3D1FF */
+  JoiLev1_00100,  /* 3D200..3D2FF */
+  JoiLev1_00100,  /* 3D300..3D3FF */
+  JoiLev1_00100,  /* 3D400..3D4FF */
+  JoiLev1_00100,  /* 3D500..3D5FF */
+  JoiLev1_00100,  /* 3D600..3D6FF */
+  JoiLev1_00100,  /* 3D700..3D7FF */
+  JoiLev1_00100,  /* 3D800..3D8FF */
+  JoiLev1_00100,  /* 3D900..3D9FF */
+  JoiLev1_00100,  /* 3DA00..3DAFF */
+  JoiLev1_00100,  /* 3DB00..3DBFF */
+  JoiLev1_00100,  /* 3DC00..3DCFF */
+  JoiLev1_00100,  /* 3DD00..3DDFF */
+  JoiLev1_00100,  /* 3DE00..3DEFF */
+  JoiLev1_00100,  /* 3DF00..3DFFF */
+  JoiLev1_00100,  /* 3E000..3E0FF */
+  JoiLev1_00100,  /* 3E100..3E1FF */
+  JoiLev1_00100,  /* 3E200..3E2FF */
+  JoiLev1_00100,  /* 3E300..3E3FF */
+  JoiLev1_00100,  /* 3E400..3E4FF */
+  JoiLev1_00100,  /* 3E500..3E5FF */
+  JoiLev1_00100,  /* 3E600..3E6FF */
+  JoiLev1_00100,  /* 3E700..3E7FF */
+  JoiLev1_00100,  /* 3E800..3E8FF */
+  JoiLev1_00100,  /* 3E900..3E9FF */
+  JoiLev1_00100,  /* 3EA00..3EAFF */
+  JoiLev1_00100,  /* 3EB00..3EBFF */
+  JoiLev1_00100,  /* 3EC00..3ECFF */
+  JoiLev1_00100,  /* 3ED00..3EDFF */
+  JoiLev1_00100,  /* 3EE00..3EEFF */
+  JoiLev1_00100,  /* 3EF00..3EFFF */
+  JoiLev1_00100,  /* 3F000..3F0FF */
+  JoiLev1_00100,  /* 3F100..3F1FF */
+  JoiLev1_00100,  /* 3F200..3F2FF */
+  JoiLev1_00100,  /* 3F300..3F3FF */
+  JoiLev1_00100,  /* 3F400..3F4FF */
+  JoiLev1_00100,  /* 3F500..3F5FF */
+  JoiLev1_00100,  /* 3F600..3F6FF */
+  JoiLev1_00100,  /* 3F700..3F7FF */
+  JoiLev1_00100,  /* 3F800..3F8FF */
+  JoiLev1_00100,  /* 3F900..3F9FF */
+  JoiLev1_00100,  /* 3FA00..3FAFF */
+  JoiLev1_00100,  /* 3FB00..3FBFF */
+  JoiLev1_00100,  /* 3FC00..3FCFF */
+  JoiLev1_00100,  /* 3FD00..3FDFF */
+  JoiLev1_00100,  /* 3FE00..3FEFF */
+  JoiLev1_00100,  /* 3FF00..3FFFF */
+  JoiLev1_00100,  /* 40000..400FF */
+  JoiLev1_00100,  /* 40100..401FF */
+  JoiLev1_00100,  /* 40200..402FF */
+  JoiLev1_00100,  /* 40300..403FF */
+  JoiLev1_00100,  /* 40400..404FF */
+  JoiLev1_00100,  /* 40500..405FF */
+  JoiLev1_00100,  /* 40600..406FF */
+  JoiLev1_00100,  /* 40700..407FF */
+  JoiLev1_00100,  /* 40800..408FF */
+  JoiLev1_00100,  /* 40900..409FF */
+  JoiLev1_00100,  /* 40A00..40AFF */
+  JoiLev1_00100,  /* 40B00..40BFF */
+  JoiLev1_00100,  /* 40C00..40CFF */
+  JoiLev1_00100,  /* 40D00..40DFF */
+  JoiLev1_00100,  /* 40E00..40EFF */
+  JoiLev1_00100,  /* 40F00..40FFF */
+  JoiLev1_00100,  /* 41000..410FF */
+  JoiLev1_00100,  /* 41100..411FF */
+  JoiLev1_00100,  /* 41200..412FF */
+  JoiLev1_00100,  /* 41300..413FF */
+  JoiLev1_00100,  /* 41400..414FF */
+  JoiLev1_00100,  /* 41500..415FF */
+  JoiLev1_00100,  /* 41600..416FF */
+  JoiLev1_00100,  /* 41700..417FF */
+  JoiLev1_00100,  /* 41800..418FF */
+  JoiLev1_00100,  /* 41900..419FF */
+  JoiLev1_00100,  /* 41A00..41AFF */
+  JoiLev1_00100,  /* 41B00..41BFF */
+  JoiLev1_00100,  /* 41C00..41CFF */
+  JoiLev1_00100,  /* 41D00..41DFF */
+  JoiLev1_00100,  /* 41E00..41EFF */
+  JoiLev1_00100,  /* 41F00..41FFF */
+  JoiLev1_00100,  /* 42000..420FF */
+  JoiLev1_00100,  /* 42100..421FF */
+  JoiLev1_00100,  /* 42200..422FF */
+  JoiLev1_00100,  /* 42300..423FF */
+  JoiLev1_00100,  /* 42400..424FF */
+  JoiLev1_00100,  /* 42500..425FF */
+  JoiLev1_00100,  /* 42600..426FF */
+  JoiLev1_00100,  /* 42700..427FF */
+  JoiLev1_00100,  /* 42800..428FF */
+  JoiLev1_00100,  /* 42900..429FF */
+  JoiLev1_00100,  /* 42A00..42AFF */
+  JoiLev1_00100,  /* 42B00..42BFF */
+  JoiLev1_00100,  /* 42C00..42CFF */
+  JoiLev1_00100,  /* 42D00..42DFF */
+  JoiLev1_00100,  /* 42E00..42EFF */
+  JoiLev1_00100,  /* 42F00..42FFF */
+  JoiLev1_00100,  /* 43000..430FF */
+  JoiLev1_00100,  /* 43100..431FF */
+  JoiLev1_00100,  /* 43200..432FF */
+  JoiLev1_00100,  /* 43300..433FF */
+  JoiLev1_00100,  /* 43400..434FF */
+  JoiLev1_00100,  /* 43500..435FF */
+  JoiLev1_00100,  /* 43600..436FF */
+  JoiLev1_00100,  /* 43700..437FF */
+  JoiLev1_00100,  /* 43800..438FF */
+  JoiLev1_00100,  /* 43900..439FF */
+  JoiLev1_00100,  /* 43A00..43AFF */
+  JoiLev1_00100,  /* 43B00..43BFF */
+  JoiLev1_00100,  /* 43C00..43CFF */
+  JoiLev1_00100,  /* 43D00..43DFF */
+  JoiLev1_00100,  /* 43E00..43EFF */
+  JoiLev1_00100,  /* 43F00..43FFF */
+  JoiLev1_00100,  /* 44000..440FF */
+  JoiLev1_00100,  /* 44100..441FF */
+  JoiLev1_00100,  /* 44200..442FF */
+  JoiLev1_00100,  /* 44300..443FF */
+  JoiLev1_00100,  /* 44400..444FF */
+  JoiLev1_00100,  /* 44500..445FF */
+  JoiLev1_00100,  /* 44600..446FF */
+  JoiLev1_00100,  /* 44700..447FF */
+  JoiLev1_00100,  /* 44800..448FF */
+  JoiLev1_00100,  /* 44900..449FF */
+  JoiLev1_00100,  /* 44A00..44AFF */
+  JoiLev1_00100,  /* 44B00..44BFF */
+  JoiLev1_00100,  /* 44C00..44CFF */
+  JoiLev1_00100,  /* 44D00..44DFF */
+  JoiLev1_00100,  /* 44E00..44EFF */
+  JoiLev1_00100,  /* 44F00..44FFF */
+  JoiLev1_00100,  /* 45000..450FF */
+  JoiLev1_00100,  /* 45100..451FF */
+  JoiLev1_00100,  /* 45200..452FF */
+  JoiLev1_00100,  /* 45300..453FF */
+  JoiLev1_00100,  /* 45400..454FF */
+  JoiLev1_00100,  /* 45500..455FF */
+  JoiLev1_00100,  /* 45600..456FF */
+  JoiLev1_00100,  /* 45700..457FF */
+  JoiLev1_00100,  /* 45800..458FF */
+  JoiLev1_00100,  /* 45900..459FF */
+  JoiLev1_00100,  /* 45A00..45AFF */
+  JoiLev1_00100,  /* 45B00..45BFF */
+  JoiLev1_00100,  /* 45C00..45CFF */
+  JoiLev1_00100,  /* 45D00..45DFF */
+  JoiLev1_00100,  /* 45E00..45EFF */
+  JoiLev1_00100,  /* 45F00..45FFF */
+  JoiLev1_00100,  /* 46000..460FF */
+  JoiLev1_00100,  /* 46100..461FF */
+  JoiLev1_00100,  /* 46200..462FF */
+  JoiLev1_00100,  /* 46300..463FF */
+  JoiLev1_00100,  /* 46400..464FF */
+  JoiLev1_00100,  /* 46500..465FF */
+  JoiLev1_00100,  /* 46600..466FF */
+  JoiLev1_00100,  /* 46700..467FF */
+  JoiLev1_00100,  /* 46800..468FF */
+  JoiLev1_00100,  /* 46900..469FF */
+  JoiLev1_00100,  /* 46A00..46AFF */
+  JoiLev1_00100,  /* 46B00..46BFF */
+  JoiLev1_00100,  /* 46C00..46CFF */
+  JoiLev1_00100,  /* 46D00..46DFF */
+  JoiLev1_00100,  /* 46E00..46EFF */
+  JoiLev1_00100,  /* 46F00..46FFF */
+  JoiLev1_00100,  /* 47000..470FF */
+  JoiLev1_00100,  /* 47100..471FF */
+  JoiLev1_00100,  /* 47200..472FF */
+  JoiLev1_00100,  /* 47300..473FF */
+  JoiLev1_00100,  /* 47400..474FF */
+  JoiLev1_00100,  /* 47500..475FF */
+  JoiLev1_00100,  /* 47600..476FF */
+  JoiLev1_00100,  /* 47700..477FF */
+  JoiLev1_00100,  /* 47800..478FF */
+  JoiLev1_00100,  /* 47900..479FF */
+  JoiLev1_00100,  /* 47A00..47AFF */
+  JoiLev1_00100,  /* 47B00..47BFF */
+  JoiLev1_00100,  /* 47C00..47CFF */
+  JoiLev1_00100,  /* 47D00..47DFF */
+  JoiLev1_00100,  /* 47E00..47EFF */
+  JoiLev1_00100,  /* 47F00..47FFF */
+  JoiLev1_00100,  /* 48000..480FF */
+  JoiLev1_00100,  /* 48100..481FF */
+  JoiLev1_00100,  /* 48200..482FF */
+  JoiLev1_00100,  /* 48300..483FF */
+  JoiLev1_00100,  /* 48400..484FF */
+  JoiLev1_00100,  /* 48500..485FF */
+  JoiLev1_00100,  /* 48600..486FF */
+  JoiLev1_00100,  /* 48700..487FF */
+  JoiLev1_00100,  /* 48800..488FF */
+  JoiLev1_00100,  /* 48900..489FF */
+  JoiLev1_00100,  /* 48A00..48AFF */
+  JoiLev1_00100,  /* 48B00..48BFF */
+  JoiLev1_00100,  /* 48C00..48CFF */
+  JoiLev1_00100,  /* 48D00..48DFF */
+  JoiLev1_00100,  /* 48E00..48EFF */
+  JoiLev1_00100,  /* 48F00..48FFF */
+  JoiLev1_00100,  /* 49000..490FF */
+  JoiLev1_00100,  /* 49100..491FF */
+  JoiLev1_00100,  /* 49200..492FF */
+  JoiLev1_00100,  /* 49300..493FF */
+  JoiLev1_00100,  /* 49400..494FF */
+  JoiLev1_00100,  /* 49500..495FF */
+  JoiLev1_00100,  /* 49600..496FF */
+  JoiLev1_00100,  /* 49700..497FF */
+  JoiLev1_00100,  /* 49800..498FF */
+  JoiLev1_00100,  /* 49900..499FF */
+  JoiLev1_00100,  /* 49A00..49AFF */
+  JoiLev1_00100,  /* 49B00..49BFF */
+  JoiLev1_00100,  /* 49C00..49CFF */
+  JoiLev1_00100,  /* 49D00..49DFF */
+  JoiLev1_00100,  /* 49E00..49EFF */
+  JoiLev1_00100,  /* 49F00..49FFF */
+  JoiLev1_00100,  /* 4A000..4A0FF */
+  JoiLev1_00100,  /* 4A100..4A1FF */
+  JoiLev1_00100,  /* 4A200..4A2FF */
+  JoiLev1_00100,  /* 4A300..4A3FF */
+  JoiLev1_00100,  /* 4A400..4A4FF */
+  JoiLev1_00100,  /* 4A500..4A5FF */
+  JoiLev1_00100,  /* 4A600..4A6FF */
+  JoiLev1_00100,  /* 4A700..4A7FF */
+  JoiLev1_00100,  /* 4A800..4A8FF */
+  JoiLev1_00100,  /* 4A900..4A9FF */
+  JoiLev1_00100,  /* 4AA00..4AAFF */
+  JoiLev1_00100,  /* 4AB00..4ABFF */
+  JoiLev1_00100,  /* 4AC00..4ACFF */
+  JoiLev1_00100,  /* 4AD00..4ADFF */
+  JoiLev1_00100,  /* 4AE00..4AEFF */
+  JoiLev1_00100,  /* 4AF00..4AFFF */
+  JoiLev1_00100,  /* 4B000..4B0FF */
+  JoiLev1_00100,  /* 4B100..4B1FF */
+  JoiLev1_00100,  /* 4B200..4B2FF */
+  JoiLev1_00100,  /* 4B300..4B3FF */
+  JoiLev1_00100,  /* 4B400..4B4FF */
+  JoiLev1_00100,  /* 4B500..4B5FF */
+  JoiLev1_00100,  /* 4B600..4B6FF */
+  JoiLev1_00100,  /* 4B700..4B7FF */
+  JoiLev1_00100,  /* 4B800..4B8FF */
+  JoiLev1_00100,  /* 4B900..4B9FF */
+  JoiLev1_00100,  /* 4BA00..4BAFF */
+  JoiLev1_00100,  /* 4BB00..4BBFF */
+  JoiLev1_00100,  /* 4BC00..4BCFF */
+  JoiLev1_00100,  /* 4BD00..4BDFF */
+  JoiLev1_00100,  /* 4BE00..4BEFF */
+  JoiLev1_00100,  /* 4BF00..4BFFF */
+  JoiLev1_00100,  /* 4C000..4C0FF */
+  JoiLev1_00100,  /* 4C100..4C1FF */
+  JoiLev1_00100,  /* 4C200..4C2FF */
+  JoiLev1_00100,  /* 4C300..4C3FF */
+  JoiLev1_00100,  /* 4C400..4C4FF */
+  JoiLev1_00100,  /* 4C500..4C5FF */
+  JoiLev1_00100,  /* 4C600..4C6FF */
+  JoiLev1_00100,  /* 4C700..4C7FF */
+  JoiLev1_00100,  /* 4C800..4C8FF */
+  JoiLev1_00100,  /* 4C900..4C9FF */
+  JoiLev1_00100,  /* 4CA00..4CAFF */
+  JoiLev1_00100,  /* 4CB00..4CBFF */
+  JoiLev1_00100,  /* 4CC00..4CCFF */
+  JoiLev1_00100,  /* 4CD00..4CDFF */
+  JoiLev1_00100,  /* 4CE00..4CEFF */
+  JoiLev1_00100,  /* 4CF00..4CFFF */
+  JoiLev1_00100,  /* 4D000..4D0FF */
+  JoiLev1_00100,  /* 4D100..4D1FF */
+  JoiLev1_00100,  /* 4D200..4D2FF */
+  JoiLev1_00100,  /* 4D300..4D3FF */
+  JoiLev1_00100,  /* 4D400..4D4FF */
+  JoiLev1_00100,  /* 4D500..4D5FF */
+  JoiLev1_00100,  /* 4D600..4D6FF */
+  JoiLev1_00100,  /* 4D700..4D7FF */
+  JoiLev1_00100,  /* 4D800..4D8FF */
+  JoiLev1_00100,  /* 4D900..4D9FF */
+  JoiLev1_00100,  /* 4DA00..4DAFF */
+  JoiLev1_00100,  /* 4DB00..4DBFF */
+  JoiLev1_00100,  /* 4DC00..4DCFF */
+  JoiLev1_00100,  /* 4DD00..4DDFF */
+  JoiLev1_00100,  /* 4DE00..4DEFF */
+  JoiLev1_00100,  /* 4DF00..4DFFF */
+  JoiLev1_00100,  /* 4E000..4E0FF */
+  JoiLev1_00100,  /* 4E100..4E1FF */
+  JoiLev1_00100,  /* 4E200..4E2FF */
+  JoiLev1_00100,  /* 4E300..4E3FF */
+  JoiLev1_00100,  /* 4E400..4E4FF */
+  JoiLev1_00100,  /* 4E500..4E5FF */
+  JoiLev1_00100,  /* 4E600..4E6FF */
+  JoiLev1_00100,  /* 4E700..4E7FF */
+  JoiLev1_00100,  /* 4E800..4E8FF */
+  JoiLev1_00100,  /* 4E900..4E9FF */
+  JoiLev1_00100,  /* 4EA00..4EAFF */
+  JoiLev1_00100,  /* 4EB00..4EBFF */
+  JoiLev1_00100,  /* 4EC00..4ECFF */
+  JoiLev1_00100,  /* 4ED00..4EDFF */
+  JoiLev1_00100,  /* 4EE00..4EEFF */
+  JoiLev1_00100,  /* 4EF00..4EFFF */
+  JoiLev1_00100,  /* 4F000..4F0FF */
+  JoiLev1_00100,  /* 4F100..4F1FF */
+  JoiLev1_00100,  /* 4F200..4F2FF */
+  JoiLev1_00100,  /* 4F300..4F3FF */
+  JoiLev1_00100,  /* 4F400..4F4FF */
+  JoiLev1_00100,  /* 4F500..4F5FF */
+  JoiLev1_00100,  /* 4F600..4F6FF */
+  JoiLev1_00100,  /* 4F700..4F7FF */
+  JoiLev1_00100,  /* 4F800..4F8FF */
+  JoiLev1_00100,  /* 4F900..4F9FF */
+  JoiLev1_00100,  /* 4FA00..4FAFF */
+  JoiLev1_00100,  /* 4FB00..4FBFF */
+  JoiLev1_00100,  /* 4FC00..4FCFF */
+  JoiLev1_00100,  /* 4FD00..4FDFF */
+  JoiLev1_00100,  /* 4FE00..4FEFF */
+  JoiLev1_00100,  /* 4FF00..4FFFF */
+  JoiLev1_00100,  /* 50000..500FF */
+  JoiLev1_00100,  /* 50100..501FF */
+  JoiLev1_00100,  /* 50200..502FF */
+  JoiLev1_00100,  /* 50300..503FF */
+  JoiLev1_00100,  /* 50400..504FF */
+  JoiLev1_00100,  /* 50500..505FF */
+  JoiLev1_00100,  /* 50600..506FF */
+  JoiLev1_00100,  /* 50700..507FF */
+  JoiLev1_00100,  /* 50800..508FF */
+  JoiLev1_00100,  /* 50900..509FF */
+  JoiLev1_00100,  /* 50A00..50AFF */
+  JoiLev1_00100,  /* 50B00..50BFF */
+  JoiLev1_00100,  /* 50C00..50CFF */
+  JoiLev1_00100,  /* 50D00..50DFF */
+  JoiLev1_00100,  /* 50E00..50EFF */
+  JoiLev1_00100,  /* 50F00..50FFF */
+  JoiLev1_00100,  /* 51000..510FF */
+  JoiLev1_00100,  /* 51100..511FF */
+  JoiLev1_00100,  /* 51200..512FF */
+  JoiLev1_00100,  /* 51300..513FF */
+  JoiLev1_00100,  /* 51400..514FF */
+  JoiLev1_00100,  /* 51500..515FF */
+  JoiLev1_00100,  /* 51600..516FF */
+  JoiLev1_00100,  /* 51700..517FF */
+  JoiLev1_00100,  /* 51800..518FF */
+  JoiLev1_00100,  /* 51900..519FF */
+  JoiLev1_00100,  /* 51A00..51AFF */
+  JoiLev1_00100,  /* 51B00..51BFF */
+  JoiLev1_00100,  /* 51C00..51CFF */
+  JoiLev1_00100,  /* 51D00..51DFF */
+  JoiLev1_00100,  /* 51E00..51EFF */
+  JoiLev1_00100,  /* 51F00..51FFF */
+  JoiLev1_00100,  /* 52000..520FF */
+  JoiLev1_00100,  /* 52100..521FF */
+  JoiLev1_00100,  /* 52200..522FF */
+  JoiLev1_00100,  /* 52300..523FF */
+  JoiLev1_00100,  /* 52400..524FF */
+  JoiLev1_00100,  /* 52500..525FF */
+  JoiLev1_00100,  /* 52600..526FF */
+  JoiLev1_00100,  /* 52700..527FF */
+  JoiLev1_00100,  /* 52800..528FF */
+  JoiLev1_00100,  /* 52900..529FF */
+  JoiLev1_00100,  /* 52A00..52AFF */
+  JoiLev1_00100,  /* 52B00..52BFF */
+  JoiLev1_00100,  /* 52C00..52CFF */
+  JoiLev1_00100,  /* 52D00..52DFF */
+  JoiLev1_00100,  /* 52E00..52EFF */
+  JoiLev1_00100,  /* 52F00..52FFF */
+  JoiLev1_00100,  /* 53000..530FF */
+  JoiLev1_00100,  /* 53100..531FF */
+  JoiLev1_00100,  /* 53200..532FF */
+  JoiLev1_00100,  /* 53300..533FF */
+  JoiLev1_00100,  /* 53400..534FF */
+  JoiLev1_00100,  /* 53500..535FF */
+  JoiLev1_00100,  /* 53600..536FF */
+  JoiLev1_00100,  /* 53700..537FF */
+  JoiLev1_00100,  /* 53800..538FF */
+  JoiLev1_00100,  /* 53900..539FF */
+  JoiLev1_00100,  /* 53A00..53AFF */
+  JoiLev1_00100,  /* 53B00..53BFF */
+  JoiLev1_00100,  /* 53C00..53CFF */
+  JoiLev1_00100,  /* 53D00..53DFF */
+  JoiLev1_00100,  /* 53E00..53EFF */
+  JoiLev1_00100,  /* 53F00..53FFF */
+  JoiLev1_00100,  /* 54000..540FF */
+  JoiLev1_00100,  /* 54100..541FF */
+  JoiLev1_00100,  /* 54200..542FF */
+  JoiLev1_00100,  /* 54300..543FF */
+  JoiLev1_00100,  /* 54400..544FF */
+  JoiLev1_00100,  /* 54500..545FF */
+  JoiLev1_00100,  /* 54600..546FF */
+  JoiLev1_00100,  /* 54700..547FF */
+  JoiLev1_00100,  /* 54800..548FF */
+  JoiLev1_00100,  /* 54900..549FF */
+  JoiLev1_00100,  /* 54A00..54AFF */
+  JoiLev1_00100,  /* 54B00..54BFF */
+  JoiLev1_00100,  /* 54C00..54CFF */
+  JoiLev1_00100,  /* 54D00..54DFF */
+  JoiLev1_00100,  /* 54E00..54EFF */
+  JoiLev1_00100,  /* 54F00..54FFF */
+  JoiLev1_00100,  /* 55000..550FF */
+  JoiLev1_00100,  /* 55100..551FF */
+  JoiLev1_00100,  /* 55200..552FF */
+  JoiLev1_00100,  /* 55300..553FF */
+  JoiLev1_00100,  /* 55400..554FF */
+  JoiLev1_00100,  /* 55500..555FF */
+  JoiLev1_00100,  /* 55600..556FF */
+  JoiLev1_00100,  /* 55700..557FF */
+  JoiLev1_00100,  /* 55800..558FF */
+  JoiLev1_00100,  /* 55900..559FF */
+  JoiLev1_00100,  /* 55A00..55AFF */
+  JoiLev1_00100,  /* 55B00..55BFF */
+  JoiLev1_00100,  /* 55C00..55CFF */
+  JoiLev1_00100,  /* 55D00..55DFF */
+  JoiLev1_00100,  /* 55E00..55EFF */
+  JoiLev1_00100,  /* 55F00..55FFF */
+  JoiLev1_00100,  /* 56000..560FF */
+  JoiLev1_00100,  /* 56100..561FF */
+  JoiLev1_00100,  /* 56200..562FF */
+  JoiLev1_00100,  /* 56300..563FF */
+  JoiLev1_00100,  /* 56400..564FF */
+  JoiLev1_00100,  /* 56500..565FF */
+  JoiLev1_00100,  /* 56600..566FF */
+  JoiLev1_00100,  /* 56700..567FF */
+  JoiLev1_00100,  /* 56800..568FF */
+  JoiLev1_00100,  /* 56900..569FF */
+  JoiLev1_00100,  /* 56A00..56AFF */
+  JoiLev1_00100,  /* 56B00..56BFF */
+  JoiLev1_00100,  /* 56C00..56CFF */
+  JoiLev1_00100,  /* 56D00..56DFF */
+  JoiLev1_00100,  /* 56E00..56EFF */
+  JoiLev1_00100,  /* 56F00..56FFF */
+  JoiLev1_00100,  /* 57000..570FF */
+  JoiLev1_00100,  /* 57100..571FF */
+  JoiLev1_00100,  /* 57200..572FF */
+  JoiLev1_00100,  /* 57300..573FF */
+  JoiLev1_00100,  /* 57400..574FF */
+  JoiLev1_00100,  /* 57500..575FF */
+  JoiLev1_00100,  /* 57600..576FF */
+  JoiLev1_00100,  /* 57700..577FF */
+  JoiLev1_00100,  /* 57800..578FF */
+  JoiLev1_00100,  /* 57900..579FF */
+  JoiLev1_00100,  /* 57A00..57AFF */
+  JoiLev1_00100,  /* 57B00..57BFF */
+  JoiLev1_00100,  /* 57C00..57CFF */
+  JoiLev1_00100,  /* 57D00..57DFF */
+  JoiLev1_00100,  /* 57E00..57EFF */
+  JoiLev1_00100,  /* 57F00..57FFF */
+  JoiLev1_00100,  /* 58000..580FF */
+  JoiLev1_00100,  /* 58100..581FF */
+  JoiLev1_00100,  /* 58200..582FF */
+  JoiLev1_00100,  /* 58300..583FF */
+  JoiLev1_00100,  /* 58400..584FF */
+  JoiLev1_00100,  /* 58500..585FF */
+  JoiLev1_00100,  /* 58600..586FF */
+  JoiLev1_00100,  /* 58700..587FF */
+  JoiLev1_00100,  /* 58800..588FF */
+  JoiLev1_00100,  /* 58900..589FF */
+  JoiLev1_00100,  /* 58A00..58AFF */
+  JoiLev1_00100,  /* 58B00..58BFF */
+  JoiLev1_00100,  /* 58C00..58CFF */
+  JoiLev1_00100,  /* 58D00..58DFF */
+  JoiLev1_00100,  /* 58E00..58EFF */
+  JoiLev1_00100,  /* 58F00..58FFF */
+  JoiLev1_00100,  /* 59000..590FF */
+  JoiLev1_00100,  /* 59100..591FF */
+  JoiLev1_00100,  /* 59200..592FF */
+  JoiLev1_00100,  /* 59300..593FF */
+  JoiLev1_00100,  /* 59400..594FF */
+  JoiLev1_00100,  /* 59500..595FF */
+  JoiLev1_00100,  /* 59600..596FF */
+  JoiLev1_00100,  /* 59700..597FF */
+  JoiLev1_00100,  /* 59800..598FF */
+  JoiLev1_00100,  /* 59900..599FF */
+  JoiLev1_00100,  /* 59A00..59AFF */
+  JoiLev1_00100,  /* 59B00..59BFF */
+  JoiLev1_00100,  /* 59C00..59CFF */
+  JoiLev1_00100,  /* 59D00..59DFF */
+  JoiLev1_00100,  /* 59E00..59EFF */
+  JoiLev1_00100,  /* 59F00..59FFF */
+  JoiLev1_00100,  /* 5A000..5A0FF */
+  JoiLev1_00100,  /* 5A100..5A1FF */
+  JoiLev1_00100,  /* 5A200..5A2FF */
+  JoiLev1_00100,  /* 5A300..5A3FF */
+  JoiLev1_00100,  /* 5A400..5A4FF */
+  JoiLev1_00100,  /* 5A500..5A5FF */
+  JoiLev1_00100,  /* 5A600..5A6FF */
+  JoiLev1_00100,  /* 5A700..5A7FF */
+  JoiLev1_00100,  /* 5A800..5A8FF */
+  JoiLev1_00100,  /* 5A900..5A9FF */
+  JoiLev1_00100,  /* 5AA00..5AAFF */
+  JoiLev1_00100,  /* 5AB00..5ABFF */
+  JoiLev1_00100,  /* 5AC00..5ACFF */
+  JoiLev1_00100,  /* 5AD00..5ADFF */
+  JoiLev1_00100,  /* 5AE00..5AEFF */
+  JoiLev1_00100,  /* 5AF00..5AFFF */
+  JoiLev1_00100,  /* 5B000..5B0FF */
+  JoiLev1_00100,  /* 5B100..5B1FF */
+  JoiLev1_00100,  /* 5B200..5B2FF */
+  JoiLev1_00100,  /* 5B300..5B3FF */
+  JoiLev1_00100,  /* 5B400..5B4FF */
+  JoiLev1_00100,  /* 5B500..5B5FF */
+  JoiLev1_00100,  /* 5B600..5B6FF */
+  JoiLev1_00100,  /* 5B700..5B7FF */
+  JoiLev1_00100,  /* 5B800..5B8FF */
+  JoiLev1_00100,  /* 5B900..5B9FF */
+  JoiLev1_00100,  /* 5BA00..5BAFF */
+  JoiLev1_00100,  /* 5BB00..5BBFF */
+  JoiLev1_00100,  /* 5BC00..5BCFF */
+  JoiLev1_00100,  /* 5BD00..5BDFF */
+  JoiLev1_00100,  /* 5BE00..5BEFF */
+  JoiLev1_00100,  /* 5BF00..5BFFF */
+  JoiLev1_00100,  /* 5C000..5C0FF */
+  JoiLev1_00100,  /* 5C100..5C1FF */
+  JoiLev1_00100,  /* 5C200..5C2FF */
+  JoiLev1_00100,  /* 5C300..5C3FF */
+  JoiLev1_00100,  /* 5C400..5C4FF */
+  JoiLev1_00100,  /* 5C500..5C5FF */
+  JoiLev1_00100,  /* 5C600..5C6FF */
+  JoiLev1_00100,  /* 5C700..5C7FF */
+  JoiLev1_00100,  /* 5C800..5C8FF */
+  JoiLev1_00100,  /* 5C900..5C9FF */
+  JoiLev1_00100,  /* 5CA00..5CAFF */
+  JoiLev1_00100,  /* 5CB00..5CBFF */
+  JoiLev1_00100,  /* 5CC00..5CCFF */
+  JoiLev1_00100,  /* 5CD00..5CDFF */
+  JoiLev1_00100,  /* 5CE00..5CEFF */
+  JoiLev1_00100,  /* 5CF00..5CFFF */
+  JoiLev1_00100,  /* 5D000..5D0FF */
+  JoiLev1_00100,  /* 5D100..5D1FF */
+  JoiLev1_00100,  /* 5D200..5D2FF */
+  JoiLev1_00100,  /* 5D300..5D3FF */
+  JoiLev1_00100,  /* 5D400..5D4FF */
+  JoiLev1_00100,  /* 5D500..5D5FF */
+  JoiLev1_00100,  /* 5D600..5D6FF */
+  JoiLev1_00100,  /* 5D700..5D7FF */
+  JoiLev1_00100,  /* 5D800..5D8FF */
+  JoiLev1_00100,  /* 5D900..5D9FF */
+  JoiLev1_00100,  /* 5DA00..5DAFF */
+  JoiLev1_00100,  /* 5DB00..5DBFF */
+  JoiLev1_00100,  /* 5DC00..5DCFF */
+  JoiLev1_00100,  /* 5DD00..5DDFF */
+  JoiLev1_00100,  /* 5DE00..5DEFF */
+  JoiLev1_00100,  /* 5DF00..5DFFF */
+  JoiLev1_00100,  /* 5E000..5E0FF */
+  JoiLev1_00100,  /* 5E100..5E1FF */
+  JoiLev1_00100,  /* 5E200..5E2FF */
+  JoiLev1_00100,  /* 5E300..5E3FF */
+  JoiLev1_00100,  /* 5E400..5E4FF */
+  JoiLev1_00100,  /* 5E500..5E5FF */
+  JoiLev1_00100,  /* 5E600..5E6FF */
+  JoiLev1_00100,  /* 5E700..5E7FF */
+  JoiLev1_00100,  /* 5E800..5E8FF */
+  JoiLev1_00100,  /* 5E900..5E9FF */
+  JoiLev1_00100,  /* 5EA00..5EAFF */
+  JoiLev1_00100,  /* 5EB00..5EBFF */
+  JoiLev1_00100,  /* 5EC00..5ECFF */
+  JoiLev1_00100,  /* 5ED00..5EDFF */
+  JoiLev1_00100,  /* 5EE00..5EEFF */
+  JoiLev1_00100,  /* 5EF00..5EFFF */
+  JoiLev1_00100,  /* 5F000..5F0FF */
+  JoiLev1_00100,  /* 5F100..5F1FF */
+  JoiLev1_00100,  /* 5F200..5F2FF */
+  JoiLev1_00100,  /* 5F300..5F3FF */
+  JoiLev1_00100,  /* 5F400..5F4FF */
+  JoiLev1_00100,  /* 5F500..5F5FF */
+  JoiLev1_00100,  /* 5F600..5F6FF */
+  JoiLev1_00100,  /* 5F700..5F7FF */
+  JoiLev1_00100,  /* 5F800..5F8FF */
+  JoiLev1_00100,  /* 5F900..5F9FF */
+  JoiLev1_00100,  /* 5FA00..5FAFF */
+  JoiLev1_00100,  /* 5FB00..5FBFF */
+  JoiLev1_00100,  /* 5FC00..5FCFF */
+  JoiLev1_00100,  /* 5FD00..5FDFF */
+  JoiLev1_00100,  /* 5FE00..5FEFF */
+  JoiLev1_00100,  /* 5FF00..5FFFF */
+  JoiLev1_00100,  /* 60000..600FF */
+  JoiLev1_00100,  /* 60100..601FF */
+  JoiLev1_00100,  /* 60200..602FF */
+  JoiLev1_00100,  /* 60300..603FF */
+  JoiLev1_00100,  /* 60400..604FF */
+  JoiLev1_00100,  /* 60500..605FF */
+  JoiLev1_00100,  /* 60600..606FF */
+  JoiLev1_00100,  /* 60700..607FF */
+  JoiLev1_00100,  /* 60800..608FF */
+  JoiLev1_00100,  /* 60900..609FF */
+  JoiLev1_00100,  /* 60A00..60AFF */
+  JoiLev1_00100,  /* 60B00..60BFF */
+  JoiLev1_00100,  /* 60C00..60CFF */
+  JoiLev1_00100,  /* 60D00..60DFF */
+  JoiLev1_00100,  /* 60E00..60EFF */
+  JoiLev1_00100,  /* 60F00..60FFF */
+  JoiLev1_00100,  /* 61000..610FF */
+  JoiLev1_00100,  /* 61100..611FF */
+  JoiLev1_00100,  /* 61200..612FF */
+  JoiLev1_00100,  /* 61300..613FF */
+  JoiLev1_00100,  /* 61400..614FF */
+  JoiLev1_00100,  /* 61500..615FF */
+  JoiLev1_00100,  /* 61600..616FF */
+  JoiLev1_00100,  /* 61700..617FF */
+  JoiLev1_00100,  /* 61800..618FF */
+  JoiLev1_00100,  /* 61900..619FF */
+  JoiLev1_00100,  /* 61A00..61AFF */
+  JoiLev1_00100,  /* 61B00..61BFF */
+  JoiLev1_00100,  /* 61C00..61CFF */
+  JoiLev1_00100,  /* 61D00..61DFF */
+  JoiLev1_00100,  /* 61E00..61EFF */
+  JoiLev1_00100,  /* 61F00..61FFF */
+  JoiLev1_00100,  /* 62000..620FF */
+  JoiLev1_00100,  /* 62100..621FF */
+  JoiLev1_00100,  /* 62200..622FF */
+  JoiLev1_00100,  /* 62300..623FF */
+  JoiLev1_00100,  /* 62400..624FF */
+  JoiLev1_00100,  /* 62500..625FF */
+  JoiLev1_00100,  /* 62600..626FF */
+  JoiLev1_00100,  /* 62700..627FF */
+  JoiLev1_00100,  /* 62800..628FF */
+  JoiLev1_00100,  /* 62900..629FF */
+  JoiLev1_00100,  /* 62A00..62AFF */
+  JoiLev1_00100,  /* 62B00..62BFF */
+  JoiLev1_00100,  /* 62C00..62CFF */
+  JoiLev1_00100,  /* 62D00..62DFF */
+  JoiLev1_00100,  /* 62E00..62EFF */
+  JoiLev1_00100,  /* 62F00..62FFF */
+  JoiLev1_00100,  /* 63000..630FF */
+  JoiLev1_00100,  /* 63100..631FF */
+  JoiLev1_00100,  /* 63200..632FF */
+  JoiLev1_00100,  /* 63300..633FF */
+  JoiLev1_00100,  /* 63400..634FF */
+  JoiLev1_00100,  /* 63500..635FF */
+  JoiLev1_00100,  /* 63600..636FF */
+  JoiLev1_00100,  /* 63700..637FF */
+  JoiLev1_00100,  /* 63800..638FF */
+  JoiLev1_00100,  /* 63900..639FF */
+  JoiLev1_00100,  /* 63A00..63AFF */
+  JoiLev1_00100,  /* 63B00..63BFF */
+  JoiLev1_00100,  /* 63C00..63CFF */
+  JoiLev1_00100,  /* 63D00..63DFF */
+  JoiLev1_00100,  /* 63E00..63EFF */
+  JoiLev1_00100,  /* 63F00..63FFF */
+  JoiLev1_00100,  /* 64000..640FF */
+  JoiLev1_00100,  /* 64100..641FF */
+  JoiLev1_00100,  /* 64200..642FF */
+  JoiLev1_00100,  /* 64300..643FF */
+  JoiLev1_00100,  /* 64400..644FF */
+  JoiLev1_00100,  /* 64500..645FF */
+  JoiLev1_00100,  /* 64600..646FF */
+  JoiLev1_00100,  /* 64700..647FF */
+  JoiLev1_00100,  /* 64800..648FF */
+  JoiLev1_00100,  /* 64900..649FF */
+  JoiLev1_00100,  /* 64A00..64AFF */
+  JoiLev1_00100,  /* 64B00..64BFF */
+  JoiLev1_00100,  /* 64C00..64CFF */
+  JoiLev1_00100,  /* 64D00..64DFF */
+  JoiLev1_00100,  /* 64E00..64EFF */
+  JoiLev1_00100,  /* 64F00..64FFF */
+  JoiLev1_00100,  /* 65000..650FF */
+  JoiLev1_00100,  /* 65100..651FF */
+  JoiLev1_00100,  /* 65200..652FF */
+  JoiLev1_00100,  /* 65300..653FF */
+  JoiLev1_00100,  /* 65400..654FF */
+  JoiLev1_00100,  /* 65500..655FF */
+  JoiLev1_00100,  /* 65600..656FF */
+  JoiLev1_00100,  /* 65700..657FF */
+  JoiLev1_00100,  /* 65800..658FF */
+  JoiLev1_00100,  /* 65900..659FF */
+  JoiLev1_00100,  /* 65A00..65AFF */
+  JoiLev1_00100,  /* 65B00..65BFF */
+  JoiLev1_00100,  /* 65C00..65CFF */
+  JoiLev1_00100,  /* 65D00..65DFF */
+  JoiLev1_00100,  /* 65E00..65EFF */
+  JoiLev1_00100,  /* 65F00..65FFF */
+  JoiLev1_00100,  /* 66000..660FF */
+  JoiLev1_00100,  /* 66100..661FF */
+  JoiLev1_00100,  /* 66200..662FF */
+  JoiLev1_00100,  /* 66300..663FF */
+  JoiLev1_00100,  /* 66400..664FF */
+  JoiLev1_00100,  /* 66500..665FF */
+  JoiLev1_00100,  /* 66600..666FF */
+  JoiLev1_00100,  /* 66700..667FF */
+  JoiLev1_00100,  /* 66800..668FF */
+  JoiLev1_00100,  /* 66900..669FF */
+  JoiLev1_00100,  /* 66A00..66AFF */
+  JoiLev1_00100,  /* 66B00..66BFF */
+  JoiLev1_00100,  /* 66C00..66CFF */
+  JoiLev1_00100,  /* 66D00..66DFF */
+  JoiLev1_00100,  /* 66E00..66EFF */
+  JoiLev1_00100,  /* 66F00..66FFF */
+  JoiLev1_00100,  /* 67000..670FF */
+  JoiLev1_00100,  /* 67100..671FF */
+  JoiLev1_00100,  /* 67200..672FF */
+  JoiLev1_00100,  /* 67300..673FF */
+  JoiLev1_00100,  /* 67400..674FF */
+  JoiLev1_00100,  /* 67500..675FF */
+  JoiLev1_00100,  /* 67600..676FF */
+  JoiLev1_00100,  /* 67700..677FF */
+  JoiLev1_00100,  /* 67800..678FF */
+  JoiLev1_00100,  /* 67900..679FF */
+  JoiLev1_00100,  /* 67A00..67AFF */
+  JoiLev1_00100,  /* 67B00..67BFF */
+  JoiLev1_00100,  /* 67C00..67CFF */
+  JoiLev1_00100,  /* 67D00..67DFF */
+  JoiLev1_00100,  /* 67E00..67EFF */
+  JoiLev1_00100,  /* 67F00..67FFF */
+  JoiLev1_00100,  /* 68000..680FF */
+  JoiLev1_00100,  /* 68100..681FF */
+  JoiLev1_00100,  /* 68200..682FF */
+  JoiLev1_00100,  /* 68300..683FF */
+  JoiLev1_00100,  /* 68400..684FF */
+  JoiLev1_00100,  /* 68500..685FF */
+  JoiLev1_00100,  /* 68600..686FF */
+  JoiLev1_00100,  /* 68700..687FF */
+  JoiLev1_00100,  /* 68800..688FF */
+  JoiLev1_00100,  /* 68900..689FF */
+  JoiLev1_00100,  /* 68A00..68AFF */
+  JoiLev1_00100,  /* 68B00..68BFF */
+  JoiLev1_00100,  /* 68C00..68CFF */
+  JoiLev1_00100,  /* 68D00..68DFF */
+  JoiLev1_00100,  /* 68E00..68EFF */
+  JoiLev1_00100,  /* 68F00..68FFF */
+  JoiLev1_00100,  /* 69000..690FF */
+  JoiLev1_00100,  /* 69100..691FF */
+  JoiLev1_00100,  /* 69200..692FF */
+  JoiLev1_00100,  /* 69300..693FF */
+  JoiLev1_00100,  /* 69400..694FF */
+  JoiLev1_00100,  /* 69500..695FF */
+  JoiLev1_00100,  /* 69600..696FF */
+  JoiLev1_00100,  /* 69700..697FF */
+  JoiLev1_00100,  /* 69800..698FF */
+  JoiLev1_00100,  /* 69900..699FF */
+  JoiLev1_00100,  /* 69A00..69AFF */
+  JoiLev1_00100,  /* 69B00..69BFF */
+  JoiLev1_00100,  /* 69C00..69CFF */
+  JoiLev1_00100,  /* 69D00..69DFF */
+  JoiLev1_00100,  /* 69E00..69EFF */
+  JoiLev1_00100,  /* 69F00..69FFF */
+  JoiLev1_00100,  /* 6A000..6A0FF */
+  JoiLev1_00100,  /* 6A100..6A1FF */
+  JoiLev1_00100,  /* 6A200..6A2FF */
+  JoiLev1_00100,  /* 6A300..6A3FF */
+  JoiLev1_00100,  /* 6A400..6A4FF */
+  JoiLev1_00100,  /* 6A500..6A5FF */
+  JoiLev1_00100,  /* 6A600..6A6FF */
+  JoiLev1_00100,  /* 6A700..6A7FF */
+  JoiLev1_00100,  /* 6A800..6A8FF */
+  JoiLev1_00100,  /* 6A900..6A9FF */
+  JoiLev1_00100,  /* 6AA00..6AAFF */
+  JoiLev1_00100,  /* 6AB00..6ABFF */
+  JoiLev1_00100,  /* 6AC00..6ACFF */
+  JoiLev1_00100,  /* 6AD00..6ADFF */
+  JoiLev1_00100,  /* 6AE00..6AEFF */
+  JoiLev1_00100,  /* 6AF00..6AFFF */
+  JoiLev1_00100,  /* 6B000..6B0FF */
+  JoiLev1_00100,  /* 6B100..6B1FF */
+  JoiLev1_00100,  /* 6B200..6B2FF */
+  JoiLev1_00100,  /* 6B300..6B3FF */
+  JoiLev1_00100,  /* 6B400..6B4FF */
+  JoiLev1_00100,  /* 6B500..6B5FF */
+  JoiLev1_00100,  /* 6B600..6B6FF */
+  JoiLev1_00100,  /* 6B700..6B7FF */
+  JoiLev1_00100,  /* 6B800..6B8FF */
+  JoiLev1_00100,  /* 6B900..6B9FF */
+  JoiLev1_00100,  /* 6BA00..6BAFF */
+  JoiLev1_00100,  /* 6BB00..6BBFF */
+  JoiLev1_00100,  /* 6BC00..6BCFF */
+  JoiLev1_00100,  /* 6BD00..6BDFF */
+  JoiLev1_00100,  /* 6BE00..6BEFF */
+  JoiLev1_00100,  /* 6BF00..6BFFF */
+  JoiLev1_00100,  /* 6C000..6C0FF */
+  JoiLev1_00100,  /* 6C100..6C1FF */
+  JoiLev1_00100,  /* 6C200..6C2FF */
+  JoiLev1_00100,  /* 6C300..6C3FF */
+  JoiLev1_00100,  /* 6C400..6C4FF */
+  JoiLev1_00100,  /* 6C500..6C5FF */
+  JoiLev1_00100,  /* 6C600..6C6FF */
+  JoiLev1_00100,  /* 6C700..6C7FF */
+  JoiLev1_00100,  /* 6C800..6C8FF */
+  JoiLev1_00100,  /* 6C900..6C9FF */
+  JoiLev1_00100,  /* 6CA00..6CAFF */
+  JoiLev1_00100,  /* 6CB00..6CBFF */
+  JoiLev1_00100,  /* 6CC00..6CCFF */
+  JoiLev1_00100,  /* 6CD00..6CDFF */
+  JoiLev1_00100,  /* 6CE00..6CEFF */
+  JoiLev1_00100,  /* 6CF00..6CFFF */
+  JoiLev1_00100,  /* 6D000..6D0FF */
+  JoiLev1_00100,  /* 6D100..6D1FF */
+  JoiLev1_00100,  /* 6D200..6D2FF */
+  JoiLev1_00100,  /* 6D300..6D3FF */
+  JoiLev1_00100,  /* 6D400..6D4FF */
+  JoiLev1_00100,  /* 6D500..6D5FF */
+  JoiLev1_00100,  /* 6D600..6D6FF */
+  JoiLev1_00100,  /* 6D700..6D7FF */
+  JoiLev1_00100,  /* 6D800..6D8FF */
+  JoiLev1_00100,  /* 6D900..6D9FF */
+  JoiLev1_00100,  /* 6DA00..6DAFF */
+  JoiLev1_00100,  /* 6DB00..6DBFF */
+  JoiLev1_00100,  /* 6DC00..6DCFF */
+  JoiLev1_00100,  /* 6DD00..6DDFF */
+  JoiLev1_00100,  /* 6DE00..6DEFF */
+  JoiLev1_00100,  /* 6DF00..6DFFF */
+  JoiLev1_00100,  /* 6E000..6E0FF */
+  JoiLev1_00100,  /* 6E100..6E1FF */
+  JoiLev1_00100,  /* 6E200..6E2FF */
+  JoiLev1_00100,  /* 6E300..6E3FF */
+  JoiLev1_00100,  /* 6E400..6E4FF */
+  JoiLev1_00100,  /* 6E500..6E5FF */
+  JoiLev1_00100,  /* 6E600..6E6FF */
+  JoiLev1_00100,  /* 6E700..6E7FF */
+  JoiLev1_00100,  /* 6E800..6E8FF */
+  JoiLev1_00100,  /* 6E900..6E9FF */
+  JoiLev1_00100,  /* 6EA00..6EAFF */
+  JoiLev1_00100,  /* 6EB00..6EBFF */
+  JoiLev1_00100,  /* 6EC00..6ECFF */
+  JoiLev1_00100,  /* 6ED00..6EDFF */
+  JoiLev1_00100,  /* 6EE00..6EEFF */
+  JoiLev1_00100,  /* 6EF00..6EFFF */
+  JoiLev1_00100,  /* 6F000..6F0FF */
+  JoiLev1_00100,  /* 6F100..6F1FF */
+  JoiLev1_00100,  /* 6F200..6F2FF */
+  JoiLev1_00100,  /* 6F300..6F3FF */
+  JoiLev1_00100,  /* 6F400..6F4FF */
+  JoiLev1_00100,  /* 6F500..6F5FF */
+  JoiLev1_00100,  /* 6F600..6F6FF */
+  JoiLev1_00100,  /* 6F700..6F7FF */
+  JoiLev1_00100,  /* 6F800..6F8FF */
+  JoiLev1_00100,  /* 6F900..6F9FF */
+  JoiLev1_00100,  /* 6FA00..6FAFF */
+  JoiLev1_00100,  /* 6FB00..6FBFF */
+  JoiLev1_00100,  /* 6FC00..6FCFF */
+  JoiLev1_00100,  /* 6FD00..6FDFF */
+  JoiLev1_00100,  /* 6FE00..6FEFF */
+  JoiLev1_00100,  /* 6FF00..6FFFF */
+  JoiLev1_00100,  /* 70000..700FF */
+  JoiLev1_00100,  /* 70100..701FF */
+  JoiLev1_00100,  /* 70200..702FF */
+  JoiLev1_00100,  /* 70300..703FF */
+  JoiLev1_00100,  /* 70400..704FF */
+  JoiLev1_00100,  /* 70500..705FF */
+  JoiLev1_00100,  /* 70600..706FF */
+  JoiLev1_00100,  /* 70700..707FF */
+  JoiLev1_00100,  /* 70800..708FF */
+  JoiLev1_00100,  /* 70900..709FF */
+  JoiLev1_00100,  /* 70A00..70AFF */
+  JoiLev1_00100,  /* 70B00..70BFF */
+  JoiLev1_00100,  /* 70C00..70CFF */
+  JoiLev1_00100,  /* 70D00..70DFF */
+  JoiLev1_00100,  /* 70E00..70EFF */
+  JoiLev1_00100,  /* 70F00..70FFF */
+  JoiLev1_00100,  /* 71000..710FF */
+  JoiLev1_00100,  /* 71100..711FF */
+  JoiLev1_00100,  /* 71200..712FF */
+  JoiLev1_00100,  /* 71300..713FF */
+  JoiLev1_00100,  /* 71400..714FF */
+  JoiLev1_00100,  /* 71500..715FF */
+  JoiLev1_00100,  /* 71600..716FF */
+  JoiLev1_00100,  /* 71700..717FF */
+  JoiLev1_00100,  /* 71800..718FF */
+  JoiLev1_00100,  /* 71900..719FF */
+  JoiLev1_00100,  /* 71A00..71AFF */
+  JoiLev1_00100,  /* 71B00..71BFF */
+  JoiLev1_00100,  /* 71C00..71CFF */
+  JoiLev1_00100,  /* 71D00..71DFF */
+  JoiLev1_00100,  /* 71E00..71EFF */
+  JoiLev1_00100,  /* 71F00..71FFF */
+  JoiLev1_00100,  /* 72000..720FF */
+  JoiLev1_00100,  /* 72100..721FF */
+  JoiLev1_00100,  /* 72200..722FF */
+  JoiLev1_00100,  /* 72300..723FF */
+  JoiLev1_00100,  /* 72400..724FF */
+  JoiLev1_00100,  /* 72500..725FF */
+  JoiLev1_00100,  /* 72600..726FF */
+  JoiLev1_00100,  /* 72700..727FF */
+  JoiLev1_00100,  /* 72800..728FF */
+  JoiLev1_00100,  /* 72900..729FF */
+  JoiLev1_00100,  /* 72A00..72AFF */
+  JoiLev1_00100,  /* 72B00..72BFF */
+  JoiLev1_00100,  /* 72C00..72CFF */
+  JoiLev1_00100,  /* 72D00..72DFF */
+  JoiLev1_00100,  /* 72E00..72EFF */
+  JoiLev1_00100,  /* 72F00..72FFF */
+  JoiLev1_00100,  /* 73000..730FF */
+  JoiLev1_00100,  /* 73100..731FF */
+  JoiLev1_00100,  /* 73200..732FF */
+  JoiLev1_00100,  /* 73300..733FF */
+  JoiLev1_00100,  /* 73400..734FF */
+  JoiLev1_00100,  /* 73500..735FF */
+  JoiLev1_00100,  /* 73600..736FF */
+  JoiLev1_00100,  /* 73700..737FF */
+  JoiLev1_00100,  /* 73800..738FF */
+  JoiLev1_00100,  /* 73900..739FF */
+  JoiLev1_00100,  /* 73A00..73AFF */
+  JoiLev1_00100,  /* 73B00..73BFF */
+  JoiLev1_00100,  /* 73C00..73CFF */
+  JoiLev1_00100,  /* 73D00..73DFF */
+  JoiLev1_00100,  /* 73E00..73EFF */
+  JoiLev1_00100,  /* 73F00..73FFF */
+  JoiLev1_00100,  /* 74000..740FF */
+  JoiLev1_00100,  /* 74100..741FF */
+  JoiLev1_00100,  /* 74200..742FF */
+  JoiLev1_00100,  /* 74300..743FF */
+  JoiLev1_00100,  /* 74400..744FF */
+  JoiLev1_00100,  /* 74500..745FF */
+  JoiLev1_00100,  /* 74600..746FF */
+  JoiLev1_00100,  /* 74700..747FF */
+  JoiLev1_00100,  /* 74800..748FF */
+  JoiLev1_00100,  /* 74900..749FF */
+  JoiLev1_00100,  /* 74A00..74AFF */
+  JoiLev1_00100,  /* 74B00..74BFF */
+  JoiLev1_00100,  /* 74C00..74CFF */
+  JoiLev1_00100,  /* 74D00..74DFF */
+  JoiLev1_00100,  /* 74E00..74EFF */
+  JoiLev1_00100,  /* 74F00..74FFF */
+  JoiLev1_00100,  /* 75000..750FF */
+  JoiLev1_00100,  /* 75100..751FF */
+  JoiLev1_00100,  /* 75200..752FF */
+  JoiLev1_00100,  /* 75300..753FF */
+  JoiLev1_00100,  /* 75400..754FF */
+  JoiLev1_00100,  /* 75500..755FF */
+  JoiLev1_00100,  /* 75600..756FF */
+  JoiLev1_00100,  /* 75700..757FF */
+  JoiLev1_00100,  /* 75800..758FF */
+  JoiLev1_00100,  /* 75900..759FF */
+  JoiLev1_00100,  /* 75A00..75AFF */
+  JoiLev1_00100,  /* 75B00..75BFF */
+  JoiLev1_00100,  /* 75C00..75CFF */
+  JoiLev1_00100,  /* 75D00..75DFF */
+  JoiLev1_00100,  /* 75E00..75EFF */
+  JoiLev1_00100,  /* 75F00..75FFF */
+  JoiLev1_00100,  /* 76000..760FF */
+  JoiLev1_00100,  /* 76100..761FF */
+  JoiLev1_00100,  /* 76200..762FF */
+  JoiLev1_00100,  /* 76300..763FF */
+  JoiLev1_00100,  /* 76400..764FF */
+  JoiLev1_00100,  /* 76500..765FF */
+  JoiLev1_00100,  /* 76600..766FF */
+  JoiLev1_00100,  /* 76700..767FF */
+  JoiLev1_00100,  /* 76800..768FF */
+  JoiLev1_00100,  /* 76900..769FF */
+  JoiLev1_00100,  /* 76A00..76AFF */
+  JoiLev1_00100,  /* 76B00..76BFF */
+  JoiLev1_00100,  /* 76C00..76CFF */
+  JoiLev1_00100,  /* 76D00..76DFF */
+  JoiLev1_00100,  /* 76E00..76EFF */
+  JoiLev1_00100,  /* 76F00..76FFF */
+  JoiLev1_00100,  /* 77000..770FF */
+  JoiLev1_00100,  /* 77100..771FF */
+  JoiLev1_00100,  /* 77200..772FF */
+  JoiLev1_00100,  /* 77300..773FF */
+  JoiLev1_00100,  /* 77400..774FF */
+  JoiLev1_00100,  /* 77500..775FF */
+  JoiLev1_00100,  /* 77600..776FF */
+  JoiLev1_00100,  /* 77700..777FF */
+  JoiLev1_00100,  /* 77800..778FF */
+  JoiLev1_00100,  /* 77900..779FF */
+  JoiLev1_00100,  /* 77A00..77AFF */
+  JoiLev1_00100,  /* 77B00..77BFF */
+  JoiLev1_00100,  /* 77C00..77CFF */
+  JoiLev1_00100,  /* 77D00..77DFF */
+  JoiLev1_00100,  /* 77E00..77EFF */
+  JoiLev1_00100,  /* 77F00..77FFF */
+  JoiLev1_00100,  /* 78000..780FF */
+  JoiLev1_00100,  /* 78100..781FF */
+  JoiLev1_00100,  /* 78200..782FF */
+  JoiLev1_00100,  /* 78300..783FF */
+  JoiLev1_00100,  /* 78400..784FF */
+  JoiLev1_00100,  /* 78500..785FF */
+  JoiLev1_00100,  /* 78600..786FF */
+  JoiLev1_00100,  /* 78700..787FF */
+  JoiLev1_00100,  /* 78800..788FF */
+  JoiLev1_00100,  /* 78900..789FF */
+  JoiLev1_00100,  /* 78A00..78AFF */
+  JoiLev1_00100,  /* 78B00..78BFF */
+  JoiLev1_00100,  /* 78C00..78CFF */
+  JoiLev1_00100,  /* 78D00..78DFF */
+  JoiLev1_00100,  /* 78E00..78EFF */
+  JoiLev1_00100,  /* 78F00..78FFF */
+  JoiLev1_00100,  /* 79000..790FF */
+  JoiLev1_00100,  /* 79100..791FF */
+  JoiLev1_00100,  /* 79200..792FF */
+  JoiLev1_00100,  /* 79300..793FF */
+  JoiLev1_00100,  /* 79400..794FF */
+  JoiLev1_00100,  /* 79500..795FF */
+  JoiLev1_00100,  /* 79600..796FF */
+  JoiLev1_00100,  /* 79700..797FF */
+  JoiLev1_00100,  /* 79800..798FF */
+  JoiLev1_00100,  /* 79900..799FF */
+  JoiLev1_00100,  /* 79A00..79AFF */
+  JoiLev1_00100,  /* 79B00..79BFF */
+  JoiLev1_00100,  /* 79C00..79CFF */
+  JoiLev1_00100,  /* 79D00..79DFF */
+  JoiLev1_00100,  /* 79E00..79EFF */
+  JoiLev1_00100,  /* 79F00..79FFF */
+  JoiLev1_00100,  /* 7A000..7A0FF */
+  JoiLev1_00100,  /* 7A100..7A1FF */
+  JoiLev1_00100,  /* 7A200..7A2FF */
+  JoiLev1_00100,  /* 7A300..7A3FF */
+  JoiLev1_00100,  /* 7A400..7A4FF */
+  JoiLev1_00100,  /* 7A500..7A5FF */
+  JoiLev1_00100,  /* 7A600..7A6FF */
+  JoiLev1_00100,  /* 7A700..7A7FF */
+  JoiLev1_00100,  /* 7A800..7A8FF */
+  JoiLev1_00100,  /* 7A900..7A9FF */
+  JoiLev1_00100,  /* 7AA00..7AAFF */
+  JoiLev1_00100,  /* 7AB00..7ABFF */
+  JoiLev1_00100,  /* 7AC00..7ACFF */
+  JoiLev1_00100,  /* 7AD00..7ADFF */
+  JoiLev1_00100,  /* 7AE00..7AEFF */
+  JoiLev1_00100,  /* 7AF00..7AFFF */
+  JoiLev1_00100,  /* 7B000..7B0FF */
+  JoiLev1_00100,  /* 7B100..7B1FF */
+  JoiLev1_00100,  /* 7B200..7B2FF */
+  JoiLev1_00100,  /* 7B300..7B3FF */
+  JoiLev1_00100,  /* 7B400..7B4FF */
+  JoiLev1_00100,  /* 7B500..7B5FF */
+  JoiLev1_00100,  /* 7B600..7B6FF */
+  JoiLev1_00100,  /* 7B700..7B7FF */
+  JoiLev1_00100,  /* 7B800..7B8FF */
+  JoiLev1_00100,  /* 7B900..7B9FF */
+  JoiLev1_00100,  /* 7BA00..7BAFF */
+  JoiLev1_00100,  /* 7BB00..7BBFF */
+  JoiLev1_00100,  /* 7BC00..7BCFF */
+  JoiLev1_00100,  /* 7BD00..7BDFF */
+  JoiLev1_00100,  /* 7BE00..7BEFF */
+  JoiLev1_00100,  /* 7BF00..7BFFF */
+  JoiLev1_00100,  /* 7C000..7C0FF */
+  JoiLev1_00100,  /* 7C100..7C1FF */
+  JoiLev1_00100,  /* 7C200..7C2FF */
+  JoiLev1_00100,  /* 7C300..7C3FF */
+  JoiLev1_00100,  /* 7C400..7C4FF */
+  JoiLev1_00100,  /* 7C500..7C5FF */
+  JoiLev1_00100,  /* 7C600..7C6FF */
+  JoiLev1_00100,  /* 7C700..7C7FF */
+  JoiLev1_00100,  /* 7C800..7C8FF */
+  JoiLev1_00100,  /* 7C900..7C9FF */
+  JoiLev1_00100,  /* 7CA00..7CAFF */
+  JoiLev1_00100,  /* 7CB00..7CBFF */
+  JoiLev1_00100,  /* 7CC00..7CCFF */
+  JoiLev1_00100,  /* 7CD00..7CDFF */
+  JoiLev1_00100,  /* 7CE00..7CEFF */
+  JoiLev1_00100,  /* 7CF00..7CFFF */
+  JoiLev1_00100,  /* 7D000..7D0FF */
+  JoiLev1_00100,  /* 7D100..7D1FF */
+  JoiLev1_00100,  /* 7D200..7D2FF */
+  JoiLev1_00100,  /* 7D300..7D3FF */
+  JoiLev1_00100,  /* 7D400..7D4FF */
+  JoiLev1_00100,  /* 7D500..7D5FF */
+  JoiLev1_00100,  /* 7D600..7D6FF */
+  JoiLev1_00100,  /* 7D700..7D7FF */
+  JoiLev1_00100,  /* 7D800..7D8FF */
+  JoiLev1_00100,  /* 7D900..7D9FF */
+  JoiLev1_00100,  /* 7DA00..7DAFF */
+  JoiLev1_00100,  /* 7DB00..7DBFF */
+  JoiLev1_00100,  /* 7DC00..7DCFF */
+  JoiLev1_00100,  /* 7DD00..7DDFF */
+  JoiLev1_00100,  /* 7DE00..7DEFF */
+  JoiLev1_00100,  /* 7DF00..7DFFF */
+  JoiLev1_00100,  /* 7E000..7E0FF */
+  JoiLev1_00100,  /* 7E100..7E1FF */
+  JoiLev1_00100,  /* 7E200..7E2FF */
+  JoiLev1_00100,  /* 7E300..7E3FF */
+  JoiLev1_00100,  /* 7E400..7E4FF */
+  JoiLev1_00100,  /* 7E500..7E5FF */
+  JoiLev1_00100,  /* 7E600..7E6FF */
+  JoiLev1_00100,  /* 7E700..7E7FF */
+  JoiLev1_00100,  /* 7E800..7E8FF */
+  JoiLev1_00100,  /* 7E900..7E9FF */
+  JoiLev1_00100,  /* 7EA00..7EAFF */
+  JoiLev1_00100,  /* 7EB00..7EBFF */
+  JoiLev1_00100,  /* 7EC00..7ECFF */
+  JoiLev1_00100,  /* 7ED00..7EDFF */
+  JoiLev1_00100,  /* 7EE00..7EEFF */
+  JoiLev1_00100,  /* 7EF00..7EFFF */
+  JoiLev1_00100,  /* 7F000..7F0FF */
+  JoiLev1_00100,  /* 7F100..7F1FF */
+  JoiLev1_00100,  /* 7F200..7F2FF */
+  JoiLev1_00100,  /* 7F300..7F3FF */
+  JoiLev1_00100,  /* 7F400..7F4FF */
+  JoiLev1_00100,  /* 7F500..7F5FF */
+  JoiLev1_00100,  /* 7F600..7F6FF */
+  JoiLev1_00100,  /* 7F700..7F7FF */
+  JoiLev1_00100,  /* 7F800..7F8FF */
+  JoiLev1_00100,  /* 7F900..7F9FF */
+  JoiLev1_00100,  /* 7FA00..7FAFF */
+  JoiLev1_00100,  /* 7FB00..7FBFF */
+  JoiLev1_00100,  /* 7FC00..7FCFF */
+  JoiLev1_00100,  /* 7FD00..7FDFF */
+  JoiLev1_00100,  /* 7FE00..7FEFF */
+  JoiLev1_00100,  /* 7FF00..7FFFF */
+  JoiLev1_00100,  /* 80000..800FF */
+  JoiLev1_00100,  /* 80100..801FF */
+  JoiLev1_00100,  /* 80200..802FF */
+  JoiLev1_00100,  /* 80300..803FF */
+  JoiLev1_00100,  /* 80400..804FF */
+  JoiLev1_00100,  /* 80500..805FF */
+  JoiLev1_00100,  /* 80600..806FF */
+  JoiLev1_00100,  /* 80700..807FF */
+  JoiLev1_00100,  /* 80800..808FF */
+  JoiLev1_00100,  /* 80900..809FF */
+  JoiLev1_00100,  /* 80A00..80AFF */
+  JoiLev1_00100,  /* 80B00..80BFF */
+  JoiLev1_00100,  /* 80C00..80CFF */
+  JoiLev1_00100,  /* 80D00..80DFF */
+  JoiLev1_00100,  /* 80E00..80EFF */
+  JoiLev1_00100,  /* 80F00..80FFF */
+  JoiLev1_00100,  /* 81000..810FF */
+  JoiLev1_00100,  /* 81100..811FF */
+  JoiLev1_00100,  /* 81200..812FF */
+  JoiLev1_00100,  /* 81300..813FF */
+  JoiLev1_00100,  /* 81400..814FF */
+  JoiLev1_00100,  /* 81500..815FF */
+  JoiLev1_00100,  /* 81600..816FF */
+  JoiLev1_00100,  /* 81700..817FF */
+  JoiLev1_00100,  /* 81800..818FF */
+  JoiLev1_00100,  /* 81900..819FF */
+  JoiLev1_00100,  /* 81A00..81AFF */
+  JoiLev1_00100,  /* 81B00..81BFF */
+  JoiLev1_00100,  /* 81C00..81CFF */
+  JoiLev1_00100,  /* 81D00..81DFF */
+  JoiLev1_00100,  /* 81E00..81EFF */
+  JoiLev1_00100,  /* 81F00..81FFF */
+  JoiLev1_00100,  /* 82000..820FF */
+  JoiLev1_00100,  /* 82100..821FF */
+  JoiLev1_00100,  /* 82200..822FF */
+  JoiLev1_00100,  /* 82300..823FF */
+  JoiLev1_00100,  /* 82400..824FF */
+  JoiLev1_00100,  /* 82500..825FF */
+  JoiLev1_00100,  /* 82600..826FF */
+  JoiLev1_00100,  /* 82700..827FF */
+  JoiLev1_00100,  /* 82800..828FF */
+  JoiLev1_00100,  /* 82900..829FF */
+  JoiLev1_00100,  /* 82A00..82AFF */
+  JoiLev1_00100,  /* 82B00..82BFF */
+  JoiLev1_00100,  /* 82C00..82CFF */
+  JoiLev1_00100,  /* 82D00..82DFF */
+  JoiLev1_00100,  /* 82E00..82EFF */
+  JoiLev1_00100,  /* 82F00..82FFF */
+  JoiLev1_00100,  /* 83000..830FF */
+  JoiLev1_00100,  /* 83100..831FF */
+  JoiLev1_00100,  /* 83200..832FF */
+  JoiLev1_00100,  /* 83300..833FF */
+  JoiLev1_00100,  /* 83400..834FF */
+  JoiLev1_00100,  /* 83500..835FF */
+  JoiLev1_00100,  /* 83600..836FF */
+  JoiLev1_00100,  /* 83700..837FF */
+  JoiLev1_00100,  /* 83800..838FF */
+  JoiLev1_00100,  /* 83900..839FF */
+  JoiLev1_00100,  /* 83A00..83AFF */
+  JoiLev1_00100,  /* 83B00..83BFF */
+  JoiLev1_00100,  /* 83C00..83CFF */
+  JoiLev1_00100,  /* 83D00..83DFF */
+  JoiLev1_00100,  /* 83E00..83EFF */
+  JoiLev1_00100,  /* 83F00..83FFF */
+  JoiLev1_00100,  /* 84000..840FF */
+  JoiLev1_00100,  /* 84100..841FF */
+  JoiLev1_00100,  /* 84200..842FF */
+  JoiLev1_00100,  /* 84300..843FF */
+  JoiLev1_00100,  /* 84400..844FF */
+  JoiLev1_00100,  /* 84500..845FF */
+  JoiLev1_00100,  /* 84600..846FF */
+  JoiLev1_00100,  /* 84700..847FF */
+  JoiLev1_00100,  /* 84800..848FF */
+  JoiLev1_00100,  /* 84900..849FF */
+  JoiLev1_00100,  /* 84A00..84AFF */
+  JoiLev1_00100,  /* 84B00..84BFF */
+  JoiLev1_00100,  /* 84C00..84CFF */
+  JoiLev1_00100,  /* 84D00..84DFF */
+  JoiLev1_00100,  /* 84E00..84EFF */
+  JoiLev1_00100,  /* 84F00..84FFF */
+  JoiLev1_00100,  /* 85000..850FF */
+  JoiLev1_00100,  /* 85100..851FF */
+  JoiLev1_00100,  /* 85200..852FF */
+  JoiLev1_00100,  /* 85300..853FF */
+  JoiLev1_00100,  /* 85400..854FF */
+  JoiLev1_00100,  /* 85500..855FF */
+  JoiLev1_00100,  /* 85600..856FF */
+  JoiLev1_00100,  /* 85700..857FF */
+  JoiLev1_00100,  /* 85800..858FF */
+  JoiLev1_00100,  /* 85900..859FF */
+  JoiLev1_00100,  /* 85A00..85AFF */
+  JoiLev1_00100,  /* 85B00..85BFF */
+  JoiLev1_00100,  /* 85C00..85CFF */
+  JoiLev1_00100,  /* 85D00..85DFF */
+  JoiLev1_00100,  /* 85E00..85EFF */
+  JoiLev1_00100,  /* 85F00..85FFF */
+  JoiLev1_00100,  /* 86000..860FF */
+  JoiLev1_00100,  /* 86100..861FF */
+  JoiLev1_00100,  /* 86200..862FF */
+  JoiLev1_00100,  /* 86300..863FF */
+  JoiLev1_00100,  /* 86400..864FF */
+  JoiLev1_00100,  /* 86500..865FF */
+  JoiLev1_00100,  /* 86600..866FF */
+  JoiLev1_00100,  /* 86700..867FF */
+  JoiLev1_00100,  /* 86800..868FF */
+  JoiLev1_00100,  /* 86900..869FF */
+  JoiLev1_00100,  /* 86A00..86AFF */
+  JoiLev1_00100,  /* 86B00..86BFF */
+  JoiLev1_00100,  /* 86C00..86CFF */
+  JoiLev1_00100,  /* 86D00..86DFF */
+  JoiLev1_00100,  /* 86E00..86EFF */
+  JoiLev1_00100,  /* 86F00..86FFF */
+  JoiLev1_00100,  /* 87000..870FF */
+  JoiLev1_00100,  /* 87100..871FF */
+  JoiLev1_00100,  /* 87200..872FF */
+  JoiLev1_00100,  /* 87300..873FF */
+  JoiLev1_00100,  /* 87400..874FF */
+  JoiLev1_00100,  /* 87500..875FF */
+  JoiLev1_00100,  /* 87600..876FF */
+  JoiLev1_00100,  /* 87700..877FF */
+  JoiLev1_00100,  /* 87800..878FF */
+  JoiLev1_00100,  /* 87900..879FF */
+  JoiLev1_00100,  /* 87A00..87AFF */
+  JoiLev1_00100,  /* 87B00..87BFF */
+  JoiLev1_00100,  /* 87C00..87CFF */
+  JoiLev1_00100,  /* 87D00..87DFF */
+  JoiLev1_00100,  /* 87E00..87EFF */
+  JoiLev1_00100,  /* 87F00..87FFF */
+  JoiLev1_00100,  /* 88000..880FF */
+  JoiLev1_00100,  /* 88100..881FF */
+  JoiLev1_00100,  /* 88200..882FF */
+  JoiLev1_00100,  /* 88300..883FF */
+  JoiLev1_00100,  /* 88400..884FF */
+  JoiLev1_00100,  /* 88500..885FF */
+  JoiLev1_00100,  /* 88600..886FF */
+  JoiLev1_00100,  /* 88700..887FF */
+  JoiLev1_00100,  /* 88800..888FF */
+  JoiLev1_00100,  /* 88900..889FF */
+  JoiLev1_00100,  /* 88A00..88AFF */
+  JoiLev1_00100,  /* 88B00..88BFF */
+  JoiLev1_00100,  /* 88C00..88CFF */
+  JoiLev1_00100,  /* 88D00..88DFF */
+  JoiLev1_00100,  /* 88E00..88EFF */
+  JoiLev1_00100,  /* 88F00..88FFF */
+  JoiLev1_00100,  /* 89000..890FF */
+  JoiLev1_00100,  /* 89100..891FF */
+  JoiLev1_00100,  /* 89200..892FF */
+  JoiLev1_00100,  /* 89300..893FF */
+  JoiLev1_00100,  /* 89400..894FF */
+  JoiLev1_00100,  /* 89500..895FF */
+  JoiLev1_00100,  /* 89600..896FF */
+  JoiLev1_00100,  /* 89700..897FF */
+  JoiLev1_00100,  /* 89800..898FF */
+  JoiLev1_00100,  /* 89900..899FF */
+  JoiLev1_00100,  /* 89A00..89AFF */
+  JoiLev1_00100,  /* 89B00..89BFF */
+  JoiLev1_00100,  /* 89C00..89CFF */
+  JoiLev1_00100,  /* 89D00..89DFF */
+  JoiLev1_00100,  /* 89E00..89EFF */
+  JoiLev1_00100,  /* 89F00..89FFF */
+  JoiLev1_00100,  /* 8A000..8A0FF */
+  JoiLev1_00100,  /* 8A100..8A1FF */
+  JoiLev1_00100,  /* 8A200..8A2FF */
+  JoiLev1_00100,  /* 8A300..8A3FF */
+  JoiLev1_00100,  /* 8A400..8A4FF */
+  JoiLev1_00100,  /* 8A500..8A5FF */
+  JoiLev1_00100,  /* 8A600..8A6FF */
+  JoiLev1_00100,  /* 8A700..8A7FF */
+  JoiLev1_00100,  /* 8A800..8A8FF */
+  JoiLev1_00100,  /* 8A900..8A9FF */
+  JoiLev1_00100,  /* 8AA00..8AAFF */
+  JoiLev1_00100,  /* 8AB00..8ABFF */
+  JoiLev1_00100,  /* 8AC00..8ACFF */
+  JoiLev1_00100,  /* 8AD00..8ADFF */
+  JoiLev1_00100,  /* 8AE00..8AEFF */
+  JoiLev1_00100,  /* 8AF00..8AFFF */
+  JoiLev1_00100,  /* 8B000..8B0FF */
+  JoiLev1_00100,  /* 8B100..8B1FF */
+  JoiLev1_00100,  /* 8B200..8B2FF */
+  JoiLev1_00100,  /* 8B300..8B3FF */
+  JoiLev1_00100,  /* 8B400..8B4FF */
+  JoiLev1_00100,  /* 8B500..8B5FF */
+  JoiLev1_00100,  /* 8B600..8B6FF */
+  JoiLev1_00100,  /* 8B700..8B7FF */
+  JoiLev1_00100,  /* 8B800..8B8FF */
+  JoiLev1_00100,  /* 8B900..8B9FF */
+  JoiLev1_00100,  /* 8BA00..8BAFF */
+  JoiLev1_00100,  /* 8BB00..8BBFF */
+  JoiLev1_00100,  /* 8BC00..8BCFF */
+  JoiLev1_00100,  /* 8BD00..8BDFF */
+  JoiLev1_00100,  /* 8BE00..8BEFF */
+  JoiLev1_00100,  /* 8BF00..8BFFF */
+  JoiLev1_00100,  /* 8C000..8C0FF */
+  JoiLev1_00100,  /* 8C100..8C1FF */
+  JoiLev1_00100,  /* 8C200..8C2FF */
+  JoiLev1_00100,  /* 8C300..8C3FF */
+  JoiLev1_00100,  /* 8C400..8C4FF */
+  JoiLev1_00100,  /* 8C500..8C5FF */
+  JoiLev1_00100,  /* 8C600..8C6FF */
+  JoiLev1_00100,  /* 8C700..8C7FF */
+  JoiLev1_00100,  /* 8C800..8C8FF */
+  JoiLev1_00100,  /* 8C900..8C9FF */
+  JoiLev1_00100,  /* 8CA00..8CAFF */
+  JoiLev1_00100,  /* 8CB00..8CBFF */
+  JoiLev1_00100,  /* 8CC00..8CCFF */
+  JoiLev1_00100,  /* 8CD00..8CDFF */
+  JoiLev1_00100,  /* 8CE00..8CEFF */
+  JoiLev1_00100,  /* 8CF00..8CFFF */
+  JoiLev1_00100,  /* 8D000..8D0FF */
+  JoiLev1_00100,  /* 8D100..8D1FF */
+  JoiLev1_00100,  /* 8D200..8D2FF */
+  JoiLev1_00100,  /* 8D300..8D3FF */
+  JoiLev1_00100,  /* 8D400..8D4FF */
+  JoiLev1_00100,  /* 8D500..8D5FF */
+  JoiLev1_00100,  /* 8D600..8D6FF */
+  JoiLev1_00100,  /* 8D700..8D7FF */
+  JoiLev1_00100,  /* 8D800..8D8FF */
+  JoiLev1_00100,  /* 8D900..8D9FF */
+  JoiLev1_00100,  /* 8DA00..8DAFF */
+  JoiLev1_00100,  /* 8DB00..8DBFF */
+  JoiLev1_00100,  /* 8DC00..8DCFF */
+  JoiLev1_00100,  /* 8DD00..8DDFF */
+  JoiLev1_00100,  /* 8DE00..8DEFF */
+  JoiLev1_00100,  /* 8DF00..8DFFF */
+  JoiLev1_00100,  /* 8E000..8E0FF */
+  JoiLev1_00100,  /* 8E100..8E1FF */
+  JoiLev1_00100,  /* 8E200..8E2FF */
+  JoiLev1_00100,  /* 8E300..8E3FF */
+  JoiLev1_00100,  /* 8E400..8E4FF */
+  JoiLev1_00100,  /* 8E500..8E5FF */
+  JoiLev1_00100,  /* 8E600..8E6FF */
+  JoiLev1_00100,  /* 8E700..8E7FF */
+  JoiLev1_00100,  /* 8E800..8E8FF */
+  JoiLev1_00100,  /* 8E900..8E9FF */
+  JoiLev1_00100,  /* 8EA00..8EAFF */
+  JoiLev1_00100,  /* 8EB00..8EBFF */
+  JoiLev1_00100,  /* 8EC00..8ECFF */
+  JoiLev1_00100,  /* 8ED00..8EDFF */
+  JoiLev1_00100,  /* 8EE00..8EEFF */
+  JoiLev1_00100,  /* 8EF00..8EFFF */
+  JoiLev1_00100,  /* 8F000..8F0FF */
+  JoiLev1_00100,  /* 8F100..8F1FF */
+  JoiLev1_00100,  /* 8F200..8F2FF */
+  JoiLev1_00100,  /* 8F300..8F3FF */
+  JoiLev1_00100,  /* 8F400..8F4FF */
+  JoiLev1_00100,  /* 8F500..8F5FF */
+  JoiLev1_00100,  /* 8F600..8F6FF */
+  JoiLev1_00100,  /* 8F700..8F7FF */
+  JoiLev1_00100,  /* 8F800..8F8FF */
+  JoiLev1_00100,  /* 8F900..8F9FF */
+  JoiLev1_00100,  /* 8FA00..8FAFF */
+  JoiLev1_00100,  /* 8FB00..8FBFF */
+  JoiLev1_00100,  /* 8FC00..8FCFF */
+  JoiLev1_00100,  /* 8FD00..8FDFF */
+  JoiLev1_00100,  /* 8FE00..8FEFF */
+  JoiLev1_00100,  /* 8FF00..8FFFF */
+  JoiLev1_00100,  /* 90000..900FF */
+  JoiLev1_00100,  /* 90100..901FF */
+  JoiLev1_00100,  /* 90200..902FF */
+  JoiLev1_00100,  /* 90300..903FF */
+  JoiLev1_00100,  /* 90400..904FF */
+  JoiLev1_00100,  /* 90500..905FF */
+  JoiLev1_00100,  /* 90600..906FF */
+  JoiLev1_00100,  /* 90700..907FF */
+  JoiLev1_00100,  /* 90800..908FF */
+  JoiLev1_00100,  /* 90900..909FF */
+  JoiLev1_00100,  /* 90A00..90AFF */
+  JoiLev1_00100,  /* 90B00..90BFF */
+  JoiLev1_00100,  /* 90C00..90CFF */
+  JoiLev1_00100,  /* 90D00..90DFF */
+  JoiLev1_00100,  /* 90E00..90EFF */
+  JoiLev1_00100,  /* 90F00..90FFF */
+  JoiLev1_00100,  /* 91000..910FF */
+  JoiLev1_00100,  /* 91100..911FF */
+  JoiLev1_00100,  /* 91200..912FF */
+  JoiLev1_00100,  /* 91300..913FF */
+  JoiLev1_00100,  /* 91400..914FF */
+  JoiLev1_00100,  /* 91500..915FF */
+  JoiLev1_00100,  /* 91600..916FF */
+  JoiLev1_00100,  /* 91700..917FF */
+  JoiLev1_00100,  /* 91800..918FF */
+  JoiLev1_00100,  /* 91900..919FF */
+  JoiLev1_00100,  /* 91A00..91AFF */
+  JoiLev1_00100,  /* 91B00..91BFF */
+  JoiLev1_00100,  /* 91C00..91CFF */
+  JoiLev1_00100,  /* 91D00..91DFF */
+  JoiLev1_00100,  /* 91E00..91EFF */
+  JoiLev1_00100,  /* 91F00..91FFF */
+  JoiLev1_00100,  /* 92000..920FF */
+  JoiLev1_00100,  /* 92100..921FF */
+  JoiLev1_00100,  /* 92200..922FF */
+  JoiLev1_00100,  /* 92300..923FF */
+  JoiLev1_00100,  /* 92400..924FF */
+  JoiLev1_00100,  /* 92500..925FF */
+  JoiLev1_00100,  /* 92600..926FF */
+  JoiLev1_00100,  /* 92700..927FF */
+  JoiLev1_00100,  /* 92800..928FF */
+  JoiLev1_00100,  /* 92900..929FF */
+  JoiLev1_00100,  /* 92A00..92AFF */
+  JoiLev1_00100,  /* 92B00..92BFF */
+  JoiLev1_00100,  /* 92C00..92CFF */
+  JoiLev1_00100,  /* 92D00..92DFF */
+  JoiLev1_00100,  /* 92E00..92EFF */
+  JoiLev1_00100,  /* 92F00..92FFF */
+  JoiLev1_00100,  /* 93000..930FF */
+  JoiLev1_00100,  /* 93100..931FF */
+  JoiLev1_00100,  /* 93200..932FF */
+  JoiLev1_00100,  /* 93300..933FF */
+  JoiLev1_00100,  /* 93400..934FF */
+  JoiLev1_00100,  /* 93500..935FF */
+  JoiLev1_00100,  /* 93600..936FF */
+  JoiLev1_00100,  /* 93700..937FF */
+  JoiLev1_00100,  /* 93800..938FF */
+  JoiLev1_00100,  /* 93900..939FF */
+  JoiLev1_00100,  /* 93A00..93AFF */
+  JoiLev1_00100,  /* 93B00..93BFF */
+  JoiLev1_00100,  /* 93C00..93CFF */
+  JoiLev1_00100,  /* 93D00..93DFF */
+  JoiLev1_00100,  /* 93E00..93EFF */
+  JoiLev1_00100,  /* 93F00..93FFF */
+  JoiLev1_00100,  /* 94000..940FF */
+  JoiLev1_00100,  /* 94100..941FF */
+  JoiLev1_00100,  /* 94200..942FF */
+  JoiLev1_00100,  /* 94300..943FF */
+  JoiLev1_00100,  /* 94400..944FF */
+  JoiLev1_00100,  /* 94500..945FF */
+  JoiLev1_00100,  /* 94600..946FF */
+  JoiLev1_00100,  /* 94700..947FF */
+  JoiLev1_00100,  /* 94800..948FF */
+  JoiLev1_00100,  /* 94900..949FF */
+  JoiLev1_00100,  /* 94A00..94AFF */
+  JoiLev1_00100,  /* 94B00..94BFF */
+  JoiLev1_00100,  /* 94C00..94CFF */
+  JoiLev1_00100,  /* 94D00..94DFF */
+  JoiLev1_00100,  /* 94E00..94EFF */
+  JoiLev1_00100,  /* 94F00..94FFF */
+  JoiLev1_00100,  /* 95000..950FF */
+  JoiLev1_00100,  /* 95100..951FF */
+  JoiLev1_00100,  /* 95200..952FF */
+  JoiLev1_00100,  /* 95300..953FF */
+  JoiLev1_00100,  /* 95400..954FF */
+  JoiLev1_00100,  /* 95500..955FF */
+  JoiLev1_00100,  /* 95600..956FF */
+  JoiLev1_00100,  /* 95700..957FF */
+  JoiLev1_00100,  /* 95800..958FF */
+  JoiLev1_00100,  /* 95900..959FF */
+  JoiLev1_00100,  /* 95A00..95AFF */
+  JoiLev1_00100,  /* 95B00..95BFF */
+  JoiLev1_00100,  /* 95C00..95CFF */
+  JoiLev1_00100,  /* 95D00..95DFF */
+  JoiLev1_00100,  /* 95E00..95EFF */
+  JoiLev1_00100,  /* 95F00..95FFF */
+  JoiLev1_00100,  /* 96000..960FF */
+  JoiLev1_00100,  /* 96100..961FF */
+  JoiLev1_00100,  /* 96200..962FF */
+  JoiLev1_00100,  /* 96300..963FF */
+  JoiLev1_00100,  /* 96400..964FF */
+  JoiLev1_00100,  /* 96500..965FF */
+  JoiLev1_00100,  /* 96600..966FF */
+  JoiLev1_00100,  /* 96700..967FF */
+  JoiLev1_00100,  /* 96800..968FF */
+  JoiLev1_00100,  /* 96900..969FF */
+  JoiLev1_00100,  /* 96A00..96AFF */
+  JoiLev1_00100,  /* 96B00..96BFF */
+  JoiLev1_00100,  /* 96C00..96CFF */
+  JoiLev1_00100,  /* 96D00..96DFF */
+  JoiLev1_00100,  /* 96E00..96EFF */
+  JoiLev1_00100,  /* 96F00..96FFF */
+  JoiLev1_00100,  /* 97000..970FF */
+  JoiLev1_00100,  /* 97100..971FF */
+  JoiLev1_00100,  /* 97200..972FF */
+  JoiLev1_00100,  /* 97300..973FF */
+  JoiLev1_00100,  /* 97400..974FF */
+  JoiLev1_00100,  /* 97500..975FF */
+  JoiLev1_00100,  /* 97600..976FF */
+  JoiLev1_00100,  /* 97700..977FF */
+  JoiLev1_00100,  /* 97800..978FF */
+  JoiLev1_00100,  /* 97900..979FF */
+  JoiLev1_00100,  /* 97A00..97AFF */
+  JoiLev1_00100,  /* 97B00..97BFF */
+  JoiLev1_00100,  /* 97C00..97CFF */
+  JoiLev1_00100,  /* 97D00..97DFF */
+  JoiLev1_00100,  /* 97E00..97EFF */
+  JoiLev1_00100,  /* 97F00..97FFF */
+  JoiLev1_00100,  /* 98000..980FF */
+  JoiLev1_00100,  /* 98100..981FF */
+  JoiLev1_00100,  /* 98200..982FF */
+  JoiLev1_00100,  /* 98300..983FF */
+  JoiLev1_00100,  /* 98400..984FF */
+  JoiLev1_00100,  /* 98500..985FF */
+  JoiLev1_00100,  /* 98600..986FF */
+  JoiLev1_00100,  /* 98700..987FF */
+  JoiLev1_00100,  /* 98800..988FF */
+  JoiLev1_00100,  /* 98900..989FF */
+  JoiLev1_00100,  /* 98A00..98AFF */
+  JoiLev1_00100,  /* 98B00..98BFF */
+  JoiLev1_00100,  /* 98C00..98CFF */
+  JoiLev1_00100,  /* 98D00..98DFF */
+  JoiLev1_00100,  /* 98E00..98EFF */
+  JoiLev1_00100,  /* 98F00..98FFF */
+  JoiLev1_00100,  /* 99000..990FF */
+  JoiLev1_00100,  /* 99100..991FF */
+  JoiLev1_00100,  /* 99200..992FF */
+  JoiLev1_00100,  /* 99300..993FF */
+  JoiLev1_00100,  /* 99400..994FF */
+  JoiLev1_00100,  /* 99500..995FF */
+  JoiLev1_00100,  /* 99600..996FF */
+  JoiLev1_00100,  /* 99700..997FF */
+  JoiLev1_00100,  /* 99800..998FF */
+  JoiLev1_00100,  /* 99900..999FF */
+  JoiLev1_00100,  /* 99A00..99AFF */
+  JoiLev1_00100,  /* 99B00..99BFF */
+  JoiLev1_00100,  /* 99C00..99CFF */
+  JoiLev1_00100,  /* 99D00..99DFF */
+  JoiLev1_00100,  /* 99E00..99EFF */
+  JoiLev1_00100,  /* 99F00..99FFF */
+  JoiLev1_00100,  /* 9A000..9A0FF */
+  JoiLev1_00100,  /* 9A100..9A1FF */
+  JoiLev1_00100,  /* 9A200..9A2FF */
+  JoiLev1_00100,  /* 9A300..9A3FF */
+  JoiLev1_00100,  /* 9A400..9A4FF */
+  JoiLev1_00100,  /* 9A500..9A5FF */
+  JoiLev1_00100,  /* 9A600..9A6FF */
+  JoiLev1_00100,  /* 9A700..9A7FF */
+  JoiLev1_00100,  /* 9A800..9A8FF */
+  JoiLev1_00100,  /* 9A900..9A9FF */
+  JoiLev1_00100,  /* 9AA00..9AAFF */
+  JoiLev1_00100,  /* 9AB00..9ABFF */
+  JoiLev1_00100,  /* 9AC00..9ACFF */
+  JoiLev1_00100,  /* 9AD00..9ADFF */
+  JoiLev1_00100,  /* 9AE00..9AEFF */
+  JoiLev1_00100,  /* 9AF00..9AFFF */
+  JoiLev1_00100,  /* 9B000..9B0FF */
+  JoiLev1_00100,  /* 9B100..9B1FF */
+  JoiLev1_00100,  /* 9B200..9B2FF */
+  JoiLev1_00100,  /* 9B300..9B3FF */
+  JoiLev1_00100,  /* 9B400..9B4FF */
+  JoiLev1_00100,  /* 9B500..9B5FF */
+  JoiLev1_00100,  /* 9B600..9B6FF */
+  JoiLev1_00100,  /* 9B700..9B7FF */
+  JoiLev1_00100,  /* 9B800..9B8FF */
+  JoiLev1_00100,  /* 9B900..9B9FF */
+  JoiLev1_00100,  /* 9BA00..9BAFF */
+  JoiLev1_00100,  /* 9BB00..9BBFF */
+  JoiLev1_00100,  /* 9BC00..9BCFF */
+  JoiLev1_00100,  /* 9BD00..9BDFF */
+  JoiLev1_00100,  /* 9BE00..9BEFF */
+  JoiLev1_00100,  /* 9BF00..9BFFF */
+  JoiLev1_00100,  /* 9C000..9C0FF */
+  JoiLev1_00100,  /* 9C100..9C1FF */
+  JoiLev1_00100,  /* 9C200..9C2FF */
+  JoiLev1_00100,  /* 9C300..9C3FF */
+  JoiLev1_00100,  /* 9C400..9C4FF */
+  JoiLev1_00100,  /* 9C500..9C5FF */
+  JoiLev1_00100,  /* 9C600..9C6FF */
+  JoiLev1_00100,  /* 9C700..9C7FF */
+  JoiLev1_00100,  /* 9C800..9C8FF */
+  JoiLev1_00100,  /* 9C900..9C9FF */
+  JoiLev1_00100,  /* 9CA00..9CAFF */
+  JoiLev1_00100,  /* 9CB00..9CBFF */
+  JoiLev1_00100,  /* 9CC00..9CCFF */
+  JoiLev1_00100,  /* 9CD00..9CDFF */
+  JoiLev1_00100,  /* 9CE00..9CEFF */
+  JoiLev1_00100,  /* 9CF00..9CFFF */
+  JoiLev1_00100,  /* 9D000..9D0FF */
+  JoiLev1_00100,  /* 9D100..9D1FF */
+  JoiLev1_00100,  /* 9D200..9D2FF */
+  JoiLev1_00100,  /* 9D300..9D3FF */
+  JoiLev1_00100,  /* 9D400..9D4FF */
+  JoiLev1_00100,  /* 9D500..9D5FF */
+  JoiLev1_00100,  /* 9D600..9D6FF */
+  JoiLev1_00100,  /* 9D700..9D7FF */
+  JoiLev1_00100,  /* 9D800..9D8FF */
+  JoiLev1_00100,  /* 9D900..9D9FF */
+  JoiLev1_00100,  /* 9DA00..9DAFF */
+  JoiLev1_00100,  /* 9DB00..9DBFF */
+  JoiLev1_00100,  /* 9DC00..9DCFF */
+  JoiLev1_00100,  /* 9DD00..9DDFF */
+  JoiLev1_00100,  /* 9DE00..9DEFF */
+  JoiLev1_00100,  /* 9DF00..9DFFF */
+  JoiLev1_00100,  /* 9E000..9E0FF */
+  JoiLev1_00100,  /* 9E100..9E1FF */
+  JoiLev1_00100,  /* 9E200..9E2FF */
+  JoiLev1_00100,  /* 9E300..9E3FF */
+  JoiLev1_00100,  /* 9E400..9E4FF */
+  JoiLev1_00100,  /* 9E500..9E5FF */
+  JoiLev1_00100,  /* 9E600..9E6FF */
+  JoiLev1_00100,  /* 9E700..9E7FF */
+  JoiLev1_00100,  /* 9E800..9E8FF */
+  JoiLev1_00100,  /* 9E900..9E9FF */
+  JoiLev1_00100,  /* 9EA00..9EAFF */
+  JoiLev1_00100,  /* 9EB00..9EBFF */
+  JoiLev1_00100,  /* 9EC00..9ECFF */
+  JoiLev1_00100,  /* 9ED00..9EDFF */
+  JoiLev1_00100,  /* 9EE00..9EEFF */
+  JoiLev1_00100,  /* 9EF00..9EFFF */
+  JoiLev1_00100,  /* 9F000..9F0FF */
+  JoiLev1_00100,  /* 9F100..9F1FF */
+  JoiLev1_00100,  /* 9F200..9F2FF */
+  JoiLev1_00100,  /* 9F300..9F3FF */
+  JoiLev1_00100,  /* 9F400..9F4FF */
+  JoiLev1_00100,  /* 9F500..9F5FF */
+  JoiLev1_00100,  /* 9F600..9F6FF */
+  JoiLev1_00100,  /* 9F700..9F7FF */
+  JoiLev1_00100,  /* 9F800..9F8FF */
+  JoiLev1_00100,  /* 9F900..9F9FF */
+  JoiLev1_00100,  /* 9FA00..9FAFF */
+  JoiLev1_00100,  /* 9FB00..9FBFF */
+  JoiLev1_00100,  /* 9FC00..9FCFF */
+  JoiLev1_00100,  /* 9FD00..9FDFF */
+  JoiLev1_00100,  /* 9FE00..9FEFF */
+  JoiLev1_00100,  /* 9FF00..9FFFF */
+  JoiLev1_00100,  /* A0000..A00FF */
+  JoiLev1_00100,  /* A0100..A01FF */
+  JoiLev1_00100,  /* A0200..A02FF */
+  JoiLev1_00100,  /* A0300..A03FF */
+  JoiLev1_00100,  /* A0400..A04FF */
+  JoiLev1_00100,  /* A0500..A05FF */
+  JoiLev1_00100,  /* A0600..A06FF */
+  JoiLev1_00100,  /* A0700..A07FF */
+  JoiLev1_00100,  /* A0800..A08FF */
+  JoiLev1_00100,  /* A0900..A09FF */
+  JoiLev1_00100,  /* A0A00..A0AFF */
+  JoiLev1_00100,  /* A0B00..A0BFF */
+  JoiLev1_00100,  /* A0C00..A0CFF */
+  JoiLev1_00100,  /* A0D00..A0DFF */
+  JoiLev1_00100,  /* A0E00..A0EFF */
+  JoiLev1_00100,  /* A0F00..A0FFF */
+  JoiLev1_00100,  /* A1000..A10FF */
+  JoiLev1_00100,  /* A1100..A11FF */
+  JoiLev1_00100,  /* A1200..A12FF */
+  JoiLev1_00100,  /* A1300..A13FF */
+  JoiLev1_00100,  /* A1400..A14FF */
+  JoiLev1_00100,  /* A1500..A15FF */
+  JoiLev1_00100,  /* A1600..A16FF */
+  JoiLev1_00100,  /* A1700..A17FF */
+  JoiLev1_00100,  /* A1800..A18FF */
+  JoiLev1_00100,  /* A1900..A19FF */
+  JoiLev1_00100,  /* A1A00..A1AFF */
+  JoiLev1_00100,  /* A1B00..A1BFF */
+  JoiLev1_00100,  /* A1C00..A1CFF */
+  JoiLev1_00100,  /* A1D00..A1DFF */
+  JoiLev1_00100,  /* A1E00..A1EFF */
+  JoiLev1_00100,  /* A1F00..A1FFF */
+  JoiLev1_00100,  /* A2000..A20FF */
+  JoiLev1_00100,  /* A2100..A21FF */
+  JoiLev1_00100,  /* A2200..A22FF */
+  JoiLev1_00100,  /* A2300..A23FF */
+  JoiLev1_00100,  /* A2400..A24FF */
+  JoiLev1_00100,  /* A2500..A25FF */
+  JoiLev1_00100,  /* A2600..A26FF */
+  JoiLev1_00100,  /* A2700..A27FF */
+  JoiLev1_00100,  /* A2800..A28FF */
+  JoiLev1_00100,  /* A2900..A29FF */
+  JoiLev1_00100,  /* A2A00..A2AFF */
+  JoiLev1_00100,  /* A2B00..A2BFF */
+  JoiLev1_00100,  /* A2C00..A2CFF */
+  JoiLev1_00100,  /* A2D00..A2DFF */
+  JoiLev1_00100,  /* A2E00..A2EFF */
+  JoiLev1_00100,  /* A2F00..A2FFF */
+  JoiLev1_00100,  /* A3000..A30FF */
+  JoiLev1_00100,  /* A3100..A31FF */
+  JoiLev1_00100,  /* A3200..A32FF */
+  JoiLev1_00100,  /* A3300..A33FF */
+  JoiLev1_00100,  /* A3400..A34FF */
+  JoiLev1_00100,  /* A3500..A35FF */
+  JoiLev1_00100,  /* A3600..A36FF */
+  JoiLev1_00100,  /* A3700..A37FF */
+  JoiLev1_00100,  /* A3800..A38FF */
+  JoiLev1_00100,  /* A3900..A39FF */
+  JoiLev1_00100,  /* A3A00..A3AFF */
+  JoiLev1_00100,  /* A3B00..A3BFF */
+  JoiLev1_00100,  /* A3C00..A3CFF */
+  JoiLev1_00100,  /* A3D00..A3DFF */
+  JoiLev1_00100,  /* A3E00..A3EFF */
+  JoiLev1_00100,  /* A3F00..A3FFF */
+  JoiLev1_00100,  /* A4000..A40FF */
+  JoiLev1_00100,  /* A4100..A41FF */
+  JoiLev1_00100,  /* A4200..A42FF */
+  JoiLev1_00100,  /* A4300..A43FF */
+  JoiLev1_00100,  /* A4400..A44FF */
+  JoiLev1_00100,  /* A4500..A45FF */
+  JoiLev1_00100,  /* A4600..A46FF */
+  JoiLev1_00100,  /* A4700..A47FF */
+  JoiLev1_00100,  /* A4800..A48FF */
+  JoiLev1_00100,  /* A4900..A49FF */
+  JoiLev1_00100,  /* A4A00..A4AFF */
+  JoiLev1_00100,  /* A4B00..A4BFF */
+  JoiLev1_00100,  /* A4C00..A4CFF */
+  JoiLev1_00100,  /* A4D00..A4DFF */
+  JoiLev1_00100,  /* A4E00..A4EFF */
+  JoiLev1_00100,  /* A4F00..A4FFF */
+  JoiLev1_00100,  /* A5000..A50FF */
+  JoiLev1_00100,  /* A5100..A51FF */
+  JoiLev1_00100,  /* A5200..A52FF */
+  JoiLev1_00100,  /* A5300..A53FF */
+  JoiLev1_00100,  /* A5400..A54FF */
+  JoiLev1_00100,  /* A5500..A55FF */
+  JoiLev1_00100,  /* A5600..A56FF */
+  JoiLev1_00100,  /* A5700..A57FF */
+  JoiLev1_00100,  /* A5800..A58FF */
+  JoiLev1_00100,  /* A5900..A59FF */
+  JoiLev1_00100,  /* A5A00..A5AFF */
+  JoiLev1_00100,  /* A5B00..A5BFF */
+  JoiLev1_00100,  /* A5C00..A5CFF */
+  JoiLev1_00100,  /* A5D00..A5DFF */
+  JoiLev1_00100,  /* A5E00..A5EFF */
+  JoiLev1_00100,  /* A5F00..A5FFF */
+  JoiLev1_00100,  /* A6000..A60FF */
+  JoiLev1_00100,  /* A6100..A61FF */
+  JoiLev1_00100,  /* A6200..A62FF */
+  JoiLev1_00100,  /* A6300..A63FF */
+  JoiLev1_00100,  /* A6400..A64FF */
+  JoiLev1_00100,  /* A6500..A65FF */
+  JoiLev1_00100,  /* A6600..A66FF */
+  JoiLev1_00100,  /* A6700..A67FF */
+  JoiLev1_00100,  /* A6800..A68FF */
+  JoiLev1_00100,  /* A6900..A69FF */
+  JoiLev1_00100,  /* A6A00..A6AFF */
+  JoiLev1_00100,  /* A6B00..A6BFF */
+  JoiLev1_00100,  /* A6C00..A6CFF */
+  JoiLev1_00100,  /* A6D00..A6DFF */
+  JoiLev1_00100,  /* A6E00..A6EFF */
+  JoiLev1_00100,  /* A6F00..A6FFF */
+  JoiLev1_00100,  /* A7000..A70FF */
+  JoiLev1_00100,  /* A7100..A71FF */
+  JoiLev1_00100,  /* A7200..A72FF */
+  JoiLev1_00100,  /* A7300..A73FF */
+  JoiLev1_00100,  /* A7400..A74FF */
+  JoiLev1_00100,  /* A7500..A75FF */
+  JoiLev1_00100,  /* A7600..A76FF */
+  JoiLev1_00100,  /* A7700..A77FF */
+  JoiLev1_00100,  /* A7800..A78FF */
+  JoiLev1_00100,  /* A7900..A79FF */
+  JoiLev1_00100,  /* A7A00..A7AFF */
+  JoiLev1_00100,  /* A7B00..A7BFF */
+  JoiLev1_00100,  /* A7C00..A7CFF */
+  JoiLev1_00100,  /* A7D00..A7DFF */
+  JoiLev1_00100,  /* A7E00..A7EFF */
+  JoiLev1_00100,  /* A7F00..A7FFF */
+  JoiLev1_00100,  /* A8000..A80FF */
+  JoiLev1_00100,  /* A8100..A81FF */
+  JoiLev1_00100,  /* A8200..A82FF */
+  JoiLev1_00100,  /* A8300..A83FF */
+  JoiLev1_00100,  /* A8400..A84FF */
+  JoiLev1_00100,  /* A8500..A85FF */
+  JoiLev1_00100,  /* A8600..A86FF */
+  JoiLev1_00100,  /* A8700..A87FF */
+  JoiLev1_00100,  /* A8800..A88FF */
+  JoiLev1_00100,  /* A8900..A89FF */
+  JoiLev1_00100,  /* A8A00..A8AFF */
+  JoiLev1_00100,  /* A8B00..A8BFF */
+  JoiLev1_00100,  /* A8C00..A8CFF */
+  JoiLev1_00100,  /* A8D00..A8DFF */
+  JoiLev1_00100,  /* A8E00..A8EFF */
+  JoiLev1_00100,  /* A8F00..A8FFF */
+  JoiLev1_00100,  /* A9000..A90FF */
+  JoiLev1_00100,  /* A9100..A91FF */
+  JoiLev1_00100,  /* A9200..A92FF */
+  JoiLev1_00100,  /* A9300..A93FF */
+  JoiLev1_00100,  /* A9400..A94FF */
+  JoiLev1_00100,  /* A9500..A95FF */
+  JoiLev1_00100,  /* A9600..A96FF */
+  JoiLev1_00100,  /* A9700..A97FF */
+  JoiLev1_00100,  /* A9800..A98FF */
+  JoiLev1_00100,  /* A9900..A99FF */
+  JoiLev1_00100,  /* A9A00..A9AFF */
+  JoiLev1_00100,  /* A9B00..A9BFF */
+  JoiLev1_00100,  /* A9C00..A9CFF */
+  JoiLev1_00100,  /* A9D00..A9DFF */
+  JoiLev1_00100,  /* A9E00..A9EFF */
+  JoiLev1_00100,  /* A9F00..A9FFF */
+  JoiLev1_00100,  /* AA000..AA0FF */
+  JoiLev1_00100,  /* AA100..AA1FF */
+  JoiLev1_00100,  /* AA200..AA2FF */
+  JoiLev1_00100,  /* AA300..AA3FF */
+  JoiLev1_00100,  /* AA400..AA4FF */
+  JoiLev1_00100,  /* AA500..AA5FF */
+  JoiLev1_00100,  /* AA600..AA6FF */
+  JoiLev1_00100,  /* AA700..AA7FF */
+  JoiLev1_00100,  /* AA800..AA8FF */
+  JoiLev1_00100,  /* AA900..AA9FF */
+  JoiLev1_00100,  /* AAA00..AAAFF */
+  JoiLev1_00100,  /* AAB00..AABFF */
+  JoiLev1_00100,  /* AAC00..AACFF */
+  JoiLev1_00100,  /* AAD00..AADFF */
+  JoiLev1_00100,  /* AAE00..AAEFF */
+  JoiLev1_00100,  /* AAF00..AAFFF */
+  JoiLev1_00100,  /* AB000..AB0FF */
+  JoiLev1_00100,  /* AB100..AB1FF */
+  JoiLev1_00100,  /* AB200..AB2FF */
+  JoiLev1_00100,  /* AB300..AB3FF */
+  JoiLev1_00100,  /* AB400..AB4FF */
+  JoiLev1_00100,  /* AB500..AB5FF */
+  JoiLev1_00100,  /* AB600..AB6FF */
+  JoiLev1_00100,  /* AB700..AB7FF */
+  JoiLev1_00100,  /* AB800..AB8FF */
+  JoiLev1_00100,  /* AB900..AB9FF */
+  JoiLev1_00100,  /* ABA00..ABAFF */
+  JoiLev1_00100,  /* ABB00..ABBFF */
+  JoiLev1_00100,  /* ABC00..ABCFF */
+  JoiLev1_00100,  /* ABD00..ABDFF */
+  JoiLev1_00100,  /* ABE00..ABEFF */
+  JoiLev1_00100,  /* ABF00..ABFFF */
+  JoiLev1_00100,  /* AC000..AC0FF */
+  JoiLev1_00100,  /* AC100..AC1FF */
+  JoiLev1_00100,  /* AC200..AC2FF */
+  JoiLev1_00100,  /* AC300..AC3FF */
+  JoiLev1_00100,  /* AC400..AC4FF */
+  JoiLev1_00100,  /* AC500..AC5FF */
+  JoiLev1_00100,  /* AC600..AC6FF */
+  JoiLev1_00100,  /* AC700..AC7FF */
+  JoiLev1_00100,  /* AC800..AC8FF */
+  JoiLev1_00100,  /* AC900..AC9FF */
+  JoiLev1_00100,  /* ACA00..ACAFF */
+  JoiLev1_00100,  /* ACB00..ACBFF */
+  JoiLev1_00100,  /* ACC00..ACCFF */
+  JoiLev1_00100,  /* ACD00..ACDFF */
+  JoiLev1_00100,  /* ACE00..ACEFF */
+  JoiLev1_00100,  /* ACF00..ACFFF */
+  JoiLev1_00100,  /* AD000..AD0FF */
+  JoiLev1_00100,  /* AD100..AD1FF */
+  JoiLev1_00100,  /* AD200..AD2FF */
+  JoiLev1_00100,  /* AD300..AD3FF */
+  JoiLev1_00100,  /* AD400..AD4FF */
+  JoiLev1_00100,  /* AD500..AD5FF */
+  JoiLev1_00100,  /* AD600..AD6FF */
+  JoiLev1_00100,  /* AD700..AD7FF */
+  JoiLev1_00100,  /* AD800..AD8FF */
+  JoiLev1_00100,  /* AD900..AD9FF */
+  JoiLev1_00100,  /* ADA00..ADAFF */
+  JoiLev1_00100,  /* ADB00..ADBFF */
+  JoiLev1_00100,  /* ADC00..ADCFF */
+  JoiLev1_00100,  /* ADD00..ADDFF */
+  JoiLev1_00100,  /* ADE00..ADEFF */
+  JoiLev1_00100,  /* ADF00..ADFFF */
+  JoiLev1_00100,  /* AE000..AE0FF */
+  JoiLev1_00100,  /* AE100..AE1FF */
+  JoiLev1_00100,  /* AE200..AE2FF */
+  JoiLev1_00100,  /* AE300..AE3FF */
+  JoiLev1_00100,  /* AE400..AE4FF */
+  JoiLev1_00100,  /* AE500..AE5FF */
+  JoiLev1_00100,  /* AE600..AE6FF */
+  JoiLev1_00100,  /* AE700..AE7FF */
+  JoiLev1_00100,  /* AE800..AE8FF */
+  JoiLev1_00100,  /* AE900..AE9FF */
+  JoiLev1_00100,  /* AEA00..AEAFF */
+  JoiLev1_00100,  /* AEB00..AEBFF */
+  JoiLev1_00100,  /* AEC00..AECFF */
+  JoiLev1_00100,  /* AED00..AEDFF */
+  JoiLev1_00100,  /* AEE00..AEEFF */
+  JoiLev1_00100,  /* AEF00..AEFFF */
+  JoiLev1_00100,  /* AF000..AF0FF */
+  JoiLev1_00100,  /* AF100..AF1FF */
+  JoiLev1_00100,  /* AF200..AF2FF */
+  JoiLev1_00100,  /* AF300..AF3FF */
+  JoiLev1_00100,  /* AF400..AF4FF */
+  JoiLev1_00100,  /* AF500..AF5FF */
+  JoiLev1_00100,  /* AF600..AF6FF */
+  JoiLev1_00100,  /* AF700..AF7FF */
+  JoiLev1_00100,  /* AF800..AF8FF */
+  JoiLev1_00100,  /* AF900..AF9FF */
+  JoiLev1_00100,  /* AFA00..AFAFF */
+  JoiLev1_00100,  /* AFB00..AFBFF */
+  JoiLev1_00100,  /* AFC00..AFCFF */
+  JoiLev1_00100,  /* AFD00..AFDFF */
+  JoiLev1_00100,  /* AFE00..AFEFF */
+  JoiLev1_00100,  /* AFF00..AFFFF */
+  JoiLev1_00100,  /* B0000..B00FF */
+  JoiLev1_00100,  /* B0100..B01FF */
+  JoiLev1_00100,  /* B0200..B02FF */
+  JoiLev1_00100,  /* B0300..B03FF */
+  JoiLev1_00100,  /* B0400..B04FF */
+  JoiLev1_00100,  /* B0500..B05FF */
+  JoiLev1_00100,  /* B0600..B06FF */
+  JoiLev1_00100,  /* B0700..B07FF */
+  JoiLev1_00100,  /* B0800..B08FF */
+  JoiLev1_00100,  /* B0900..B09FF */
+  JoiLev1_00100,  /* B0A00..B0AFF */
+  JoiLev1_00100,  /* B0B00..B0BFF */
+  JoiLev1_00100,  /* B0C00..B0CFF */
+  JoiLev1_00100,  /* B0D00..B0DFF */
+  JoiLev1_00100,  /* B0E00..B0EFF */
+  JoiLev1_00100,  /* B0F00..B0FFF */
+  JoiLev1_00100,  /* B1000..B10FF */
+  JoiLev1_00100,  /* B1100..B11FF */
+  JoiLev1_00100,  /* B1200..B12FF */
+  JoiLev1_00100,  /* B1300..B13FF */
+  JoiLev1_00100,  /* B1400..B14FF */
+  JoiLev1_00100,  /* B1500..B15FF */
+  JoiLev1_00100,  /* B1600..B16FF */
+  JoiLev1_00100,  /* B1700..B17FF */
+  JoiLev1_00100,  /* B1800..B18FF */
+  JoiLev1_00100,  /* B1900..B19FF */
+  JoiLev1_00100,  /* B1A00..B1AFF */
+  JoiLev1_00100,  /* B1B00..B1BFF */
+  JoiLev1_00100,  /* B1C00..B1CFF */
+  JoiLev1_00100,  /* B1D00..B1DFF */
+  JoiLev1_00100,  /* B1E00..B1EFF */
+  JoiLev1_00100,  /* B1F00..B1FFF */
+  JoiLev1_00100,  /* B2000..B20FF */
+  JoiLev1_00100,  /* B2100..B21FF */
+  JoiLev1_00100,  /* B2200..B22FF */
+  JoiLev1_00100,  /* B2300..B23FF */
+  JoiLev1_00100,  /* B2400..B24FF */
+  JoiLev1_00100,  /* B2500..B25FF */
+  JoiLev1_00100,  /* B2600..B26FF */
+  JoiLev1_00100,  /* B2700..B27FF */
+  JoiLev1_00100,  /* B2800..B28FF */
+  JoiLev1_00100,  /* B2900..B29FF */
+  JoiLev1_00100,  /* B2A00..B2AFF */
+  JoiLev1_00100,  /* B2B00..B2BFF */
+  JoiLev1_00100,  /* B2C00..B2CFF */
+  JoiLev1_00100,  /* B2D00..B2DFF */
+  JoiLev1_00100,  /* B2E00..B2EFF */
+  JoiLev1_00100,  /* B2F00..B2FFF */
+  JoiLev1_00100,  /* B3000..B30FF */
+  JoiLev1_00100,  /* B3100..B31FF */
+  JoiLev1_00100,  /* B3200..B32FF */
+  JoiLev1_00100,  /* B3300..B33FF */
+  JoiLev1_00100,  /* B3400..B34FF */
+  JoiLev1_00100,  /* B3500..B35FF */
+  JoiLev1_00100,  /* B3600..B36FF */
+  JoiLev1_00100,  /* B3700..B37FF */
+  JoiLev1_00100,  /* B3800..B38FF */
+  JoiLev1_00100,  /* B3900..B39FF */
+  JoiLev1_00100,  /* B3A00..B3AFF */
+  JoiLev1_00100,  /* B3B00..B3BFF */
+  JoiLev1_00100,  /* B3C00..B3CFF */
+  JoiLev1_00100,  /* B3D00..B3DFF */
+  JoiLev1_00100,  /* B3E00..B3EFF */
+  JoiLev1_00100,  /* B3F00..B3FFF */
+  JoiLev1_00100,  /* B4000..B40FF */
+  JoiLev1_00100,  /* B4100..B41FF */
+  JoiLev1_00100,  /* B4200..B42FF */
+  JoiLev1_00100,  /* B4300..B43FF */
+  JoiLev1_00100,  /* B4400..B44FF */
+  JoiLev1_00100,  /* B4500..B45FF */
+  JoiLev1_00100,  /* B4600..B46FF */
+  JoiLev1_00100,  /* B4700..B47FF */
+  JoiLev1_00100,  /* B4800..B48FF */
+  JoiLev1_00100,  /* B4900..B49FF */
+  JoiLev1_00100,  /* B4A00..B4AFF */
+  JoiLev1_00100,  /* B4B00..B4BFF */
+  JoiLev1_00100,  /* B4C00..B4CFF */
+  JoiLev1_00100,  /* B4D00..B4DFF */
+  JoiLev1_00100,  /* B4E00..B4EFF */
+  JoiLev1_00100,  /* B4F00..B4FFF */
+  JoiLev1_00100,  /* B5000..B50FF */
+  JoiLev1_00100,  /* B5100..B51FF */
+  JoiLev1_00100,  /* B5200..B52FF */
+  JoiLev1_00100,  /* B5300..B53FF */
+  JoiLev1_00100,  /* B5400..B54FF */
+  JoiLev1_00100,  /* B5500..B55FF */
+  JoiLev1_00100,  /* B5600..B56FF */
+  JoiLev1_00100,  /* B5700..B57FF */
+  JoiLev1_00100,  /* B5800..B58FF */
+  JoiLev1_00100,  /* B5900..B59FF */
+  JoiLev1_00100,  /* B5A00..B5AFF */
+  JoiLev1_00100,  /* B5B00..B5BFF */
+  JoiLev1_00100,  /* B5C00..B5CFF */
+  JoiLev1_00100,  /* B5D00..B5DFF */
+  JoiLev1_00100,  /* B5E00..B5EFF */
+  JoiLev1_00100,  /* B5F00..B5FFF */
+  JoiLev1_00100,  /* B6000..B60FF */
+  JoiLev1_00100,  /* B6100..B61FF */
+  JoiLev1_00100,  /* B6200..B62FF */
+  JoiLev1_00100,  /* B6300..B63FF */
+  JoiLev1_00100,  /* B6400..B64FF */
+  JoiLev1_00100,  /* B6500..B65FF */
+  JoiLev1_00100,  /* B6600..B66FF */
+  JoiLev1_00100,  /* B6700..B67FF */
+  JoiLev1_00100,  /* B6800..B68FF */
+  JoiLev1_00100,  /* B6900..B69FF */
+  JoiLev1_00100,  /* B6A00..B6AFF */
+  JoiLev1_00100,  /* B6B00..B6BFF */
+  JoiLev1_00100,  /* B6C00..B6CFF */
+  JoiLev1_00100,  /* B6D00..B6DFF */
+  JoiLev1_00100,  /* B6E00..B6EFF */
+  JoiLev1_00100,  /* B6F00..B6FFF */
+  JoiLev1_00100,  /* B7000..B70FF */
+  JoiLev1_00100,  /* B7100..B71FF */
+  JoiLev1_00100,  /* B7200..B72FF */
+  JoiLev1_00100,  /* B7300..B73FF */
+  JoiLev1_00100,  /* B7400..B74FF */
+  JoiLev1_00100,  /* B7500..B75FF */
+  JoiLev1_00100,  /* B7600..B76FF */
+  JoiLev1_00100,  /* B7700..B77FF */
+  JoiLev1_00100,  /* B7800..B78FF */
+  JoiLev1_00100,  /* B7900..B79FF */
+  JoiLev1_00100,  /* B7A00..B7AFF */
+  JoiLev1_00100,  /* B7B00..B7BFF */
+  JoiLev1_00100,  /* B7C00..B7CFF */
+  JoiLev1_00100,  /* B7D00..B7DFF */
+  JoiLev1_00100,  /* B7E00..B7EFF */
+  JoiLev1_00100,  /* B7F00..B7FFF */
+  JoiLev1_00100,  /* B8000..B80FF */
+  JoiLev1_00100,  /* B8100..B81FF */
+  JoiLev1_00100,  /* B8200..B82FF */
+  JoiLev1_00100,  /* B8300..B83FF */
+  JoiLev1_00100,  /* B8400..B84FF */
+  JoiLev1_00100,  /* B8500..B85FF */
+  JoiLev1_00100,  /* B8600..B86FF */
+  JoiLev1_00100,  /* B8700..B87FF */
+  JoiLev1_00100,  /* B8800..B88FF */
+  JoiLev1_00100,  /* B8900..B89FF */
+  JoiLev1_00100,  /* B8A00..B8AFF */
+  JoiLev1_00100,  /* B8B00..B8BFF */
+  JoiLev1_00100,  /* B8C00..B8CFF */
+  JoiLev1_00100,  /* B8D00..B8DFF */
+  JoiLev1_00100,  /* B8E00..B8EFF */
+  JoiLev1_00100,  /* B8F00..B8FFF */
+  JoiLev1_00100,  /* B9000..B90FF */
+  JoiLev1_00100,  /* B9100..B91FF */
+  JoiLev1_00100,  /* B9200..B92FF */
+  JoiLev1_00100,  /* B9300..B93FF */
+  JoiLev1_00100,  /* B9400..B94FF */
+  JoiLev1_00100,  /* B9500..B95FF */
+  JoiLev1_00100,  /* B9600..B96FF */
+  JoiLev1_00100,  /* B9700..B97FF */
+  JoiLev1_00100,  /* B9800..B98FF */
+  JoiLev1_00100,  /* B9900..B99FF */
+  JoiLev1_00100,  /* B9A00..B9AFF */
+  JoiLev1_00100,  /* B9B00..B9BFF */
+  JoiLev1_00100,  /* B9C00..B9CFF */
+  JoiLev1_00100,  /* B9D00..B9DFF */
+  JoiLev1_00100,  /* B9E00..B9EFF */
+  JoiLev1_00100,  /* B9F00..B9FFF */
+  JoiLev1_00100,  /* BA000..BA0FF */
+  JoiLev1_00100,  /* BA100..BA1FF */
+  JoiLev1_00100,  /* BA200..BA2FF */
+  JoiLev1_00100,  /* BA300..BA3FF */
+  JoiLev1_00100,  /* BA400..BA4FF */
+  JoiLev1_00100,  /* BA500..BA5FF */
+  JoiLev1_00100,  /* BA600..BA6FF */
+  JoiLev1_00100,  /* BA700..BA7FF */
+  JoiLev1_00100,  /* BA800..BA8FF */
+  JoiLev1_00100,  /* BA900..BA9FF */
+  JoiLev1_00100,  /* BAA00..BAAFF */
+  JoiLev1_00100,  /* BAB00..BABFF */
+  JoiLev1_00100,  /* BAC00..BACFF */
+  JoiLev1_00100,  /* BAD00..BADFF */
+  JoiLev1_00100,  /* BAE00..BAEFF */
+  JoiLev1_00100,  /* BAF00..BAFFF */
+  JoiLev1_00100,  /* BB000..BB0FF */
+  JoiLev1_00100,  /* BB100..BB1FF */
+  JoiLev1_00100,  /* BB200..BB2FF */
+  JoiLev1_00100,  /* BB300..BB3FF */
+  JoiLev1_00100,  /* BB400..BB4FF */
+  JoiLev1_00100,  /* BB500..BB5FF */
+  JoiLev1_00100,  /* BB600..BB6FF */
+  JoiLev1_00100,  /* BB700..BB7FF */
+  JoiLev1_00100,  /* BB800..BB8FF */
+  JoiLev1_00100,  /* BB900..BB9FF */
+  JoiLev1_00100,  /* BBA00..BBAFF */
+  JoiLev1_00100,  /* BBB00..BBBFF */
+  JoiLev1_00100,  /* BBC00..BBCFF */
+  JoiLev1_00100,  /* BBD00..BBDFF */
+  JoiLev1_00100,  /* BBE00..BBEFF */
+  JoiLev1_00100,  /* BBF00..BBFFF */
+  JoiLev1_00100,  /* BC000..BC0FF */
+  JoiLev1_00100,  /* BC100..BC1FF */
+  JoiLev1_00100,  /* BC200..BC2FF */
+  JoiLev1_00100,  /* BC300..BC3FF */
+  JoiLev1_00100,  /* BC400..BC4FF */
+  JoiLev1_00100,  /* BC500..BC5FF */
+  JoiLev1_00100,  /* BC600..BC6FF */
+  JoiLev1_00100,  /* BC700..BC7FF */
+  JoiLev1_00100,  /* BC800..BC8FF */
+  JoiLev1_00100,  /* BC900..BC9FF */
+  JoiLev1_00100,  /* BCA00..BCAFF */
+  JoiLev1_00100,  /* BCB00..BCBFF */
+  JoiLev1_00100,  /* BCC00..BCCFF */
+  JoiLev1_00100,  /* BCD00..BCDFF */
+  JoiLev1_00100,  /* BCE00..BCEFF */
+  JoiLev1_00100,  /* BCF00..BCFFF */
+  JoiLev1_00100,  /* BD000..BD0FF */
+  JoiLev1_00100,  /* BD100..BD1FF */
+  JoiLev1_00100,  /* BD200..BD2FF */
+  JoiLev1_00100,  /* BD300..BD3FF */
+  JoiLev1_00100,  /* BD400..BD4FF */
+  JoiLev1_00100,  /* BD500..BD5FF */
+  JoiLev1_00100,  /* BD600..BD6FF */
+  JoiLev1_00100,  /* BD700..BD7FF */
+  JoiLev1_00100,  /* BD800..BD8FF */
+  JoiLev1_00100,  /* BD900..BD9FF */
+  JoiLev1_00100,  /* BDA00..BDAFF */
+  JoiLev1_00100,  /* BDB00..BDBFF */
+  JoiLev1_00100,  /* BDC00..BDCFF */
+  JoiLev1_00100,  /* BDD00..BDDFF */
+  JoiLev1_00100,  /* BDE00..BDEFF */
+  JoiLev1_00100,  /* BDF00..BDFFF */
+  JoiLev1_00100,  /* BE000..BE0FF */
+  JoiLev1_00100,  /* BE100..BE1FF */
+  JoiLev1_00100,  /* BE200..BE2FF */
+  JoiLev1_00100,  /* BE300..BE3FF */
+  JoiLev1_00100,  /* BE400..BE4FF */
+  JoiLev1_00100,  /* BE500..BE5FF */
+  JoiLev1_00100,  /* BE600..BE6FF */
+  JoiLev1_00100,  /* BE700..BE7FF */
+  JoiLev1_00100,  /* BE800..BE8FF */
+  JoiLev1_00100,  /* BE900..BE9FF */
+  JoiLev1_00100,  /* BEA00..BEAFF */
+  JoiLev1_00100,  /* BEB00..BEBFF */
+  JoiLev1_00100,  /* BEC00..BECFF */
+  JoiLev1_00100,  /* BED00..BEDFF */
+  JoiLev1_00100,  /* BEE00..BEEFF */
+  JoiLev1_00100,  /* BEF00..BEFFF */
+  JoiLev1_00100,  /* BF000..BF0FF */
+  JoiLev1_00100,  /* BF100..BF1FF */
+  JoiLev1_00100,  /* BF200..BF2FF */
+  JoiLev1_00100,  /* BF300..BF3FF */
+  JoiLev1_00100,  /* BF400..BF4FF */
+  JoiLev1_00100,  /* BF500..BF5FF */
+  JoiLev1_00100,  /* BF600..BF6FF */
+  JoiLev1_00100,  /* BF700..BF7FF */
+  JoiLev1_00100,  /* BF800..BF8FF */
+  JoiLev1_00100,  /* BF900..BF9FF */
+  JoiLev1_00100,  /* BFA00..BFAFF */
+  JoiLev1_00100,  /* BFB00..BFBFF */
+  JoiLev1_00100,  /* BFC00..BFCFF */
+  JoiLev1_00100,  /* BFD00..BFDFF */
+  JoiLev1_00100,  /* BFE00..BFEFF */
+  JoiLev1_00100,  /* BFF00..BFFFF */
+  JoiLev1_00100,  /* C0000..C00FF */
+  JoiLev1_00100,  /* C0100..C01FF */
+  JoiLev1_00100,  /* C0200..C02FF */
+  JoiLev1_00100,  /* C0300..C03FF */
+  JoiLev1_00100,  /* C0400..C04FF */
+  JoiLev1_00100,  /* C0500..C05FF */
+  JoiLev1_00100,  /* C0600..C06FF */
+  JoiLev1_00100,  /* C0700..C07FF */
+  JoiLev1_00100,  /* C0800..C08FF */
+  JoiLev1_00100,  /* C0900..C09FF */
+  JoiLev1_00100,  /* C0A00..C0AFF */
+  JoiLev1_00100,  /* C0B00..C0BFF */
+  JoiLev1_00100,  /* C0C00..C0CFF */
+  JoiLev1_00100,  /* C0D00..C0DFF */
+  JoiLev1_00100,  /* C0E00..C0EFF */
+  JoiLev1_00100,  /* C0F00..C0FFF */
+  JoiLev1_00100,  /* C1000..C10FF */
+  JoiLev1_00100,  /* C1100..C11FF */
+  JoiLev1_00100,  /* C1200..C12FF */
+  JoiLev1_00100,  /* C1300..C13FF */
+  JoiLev1_00100,  /* C1400..C14FF */
+  JoiLev1_00100,  /* C1500..C15FF */
+  JoiLev1_00100,  /* C1600..C16FF */
+  JoiLev1_00100,  /* C1700..C17FF */
+  JoiLev1_00100,  /* C1800..C18FF */
+  JoiLev1_00100,  /* C1900..C19FF */
+  JoiLev1_00100,  /* C1A00..C1AFF */
+  JoiLev1_00100,  /* C1B00..C1BFF */
+  JoiLev1_00100,  /* C1C00..C1CFF */
+  JoiLev1_00100,  /* C1D00..C1DFF */
+  JoiLev1_00100,  /* C1E00..C1EFF */
+  JoiLev1_00100,  /* C1F00..C1FFF */
+  JoiLev1_00100,  /* C2000..C20FF */
+  JoiLev1_00100,  /* C2100..C21FF */
+  JoiLev1_00100,  /* C2200..C22FF */
+  JoiLev1_00100,  /* C2300..C23FF */
+  JoiLev1_00100,  /* C2400..C24FF */
+  JoiLev1_00100,  /* C2500..C25FF */
+  JoiLev1_00100,  /* C2600..C26FF */
+  JoiLev1_00100,  /* C2700..C27FF */
+  JoiLev1_00100,  /* C2800..C28FF */
+  JoiLev1_00100,  /* C2900..C29FF */
+  JoiLev1_00100,  /* C2A00..C2AFF */
+  JoiLev1_00100,  /* C2B00..C2BFF */
+  JoiLev1_00100,  /* C2C00..C2CFF */
+  JoiLev1_00100,  /* C2D00..C2DFF */
+  JoiLev1_00100,  /* C2E00..C2EFF */
+  JoiLev1_00100,  /* C2F00..C2FFF */
+  JoiLev1_00100,  /* C3000..C30FF */
+  JoiLev1_00100,  /* C3100..C31FF */
+  JoiLev1_00100,  /* C3200..C32FF */
+  JoiLev1_00100,  /* C3300..C33FF */
+  JoiLev1_00100,  /* C3400..C34FF */
+  JoiLev1_00100,  /* C3500..C35FF */
+  JoiLev1_00100,  /* C3600..C36FF */
+  JoiLev1_00100,  /* C3700..C37FF */
+  JoiLev1_00100,  /* C3800..C38FF */
+  JoiLev1_00100,  /* C3900..C39FF */
+  JoiLev1_00100,  /* C3A00..C3AFF */
+  JoiLev1_00100,  /* C3B00..C3BFF */
+  JoiLev1_00100,  /* C3C00..C3CFF */
+  JoiLev1_00100,  /* C3D00..C3DFF */
+  JoiLev1_00100,  /* C3E00..C3EFF */
+  JoiLev1_00100,  /* C3F00..C3FFF */
+  JoiLev1_00100,  /* C4000..C40FF */
+  JoiLev1_00100,  /* C4100..C41FF */
+  JoiLev1_00100,  /* C4200..C42FF */
+  JoiLev1_00100,  /* C4300..C43FF */
+  JoiLev1_00100,  /* C4400..C44FF */
+  JoiLev1_00100,  /* C4500..C45FF */
+  JoiLev1_00100,  /* C4600..C46FF */
+  JoiLev1_00100,  /* C4700..C47FF */
+  JoiLev1_00100,  /* C4800..C48FF */
+  JoiLev1_00100,  /* C4900..C49FF */
+  JoiLev1_00100,  /* C4A00..C4AFF */
+  JoiLev1_00100,  /* C4B00..C4BFF */
+  JoiLev1_00100,  /* C4C00..C4CFF */
+  JoiLev1_00100,  /* C4D00..C4DFF */
+  JoiLev1_00100,  /* C4E00..C4EFF */
+  JoiLev1_00100,  /* C4F00..C4FFF */
+  JoiLev1_00100,  /* C5000..C50FF */
+  JoiLev1_00100,  /* C5100..C51FF */
+  JoiLev1_00100,  /* C5200..C52FF */
+  JoiLev1_00100,  /* C5300..C53FF */
+  JoiLev1_00100,  /* C5400..C54FF */
+  JoiLev1_00100,  /* C5500..C55FF */
+  JoiLev1_00100,  /* C5600..C56FF */
+  JoiLev1_00100,  /* C5700..C57FF */
+  JoiLev1_00100,  /* C5800..C58FF */
+  JoiLev1_00100,  /* C5900..C59FF */
+  JoiLev1_00100,  /* C5A00..C5AFF */
+  JoiLev1_00100,  /* C5B00..C5BFF */
+  JoiLev1_00100,  /* C5C00..C5CFF */
+  JoiLev1_00100,  /* C5D00..C5DFF */
+  JoiLev1_00100,  /* C5E00..C5EFF */
+  JoiLev1_00100,  /* C5F00..C5FFF */
+  JoiLev1_00100,  /* C6000..C60FF */
+  JoiLev1_00100,  /* C6100..C61FF */
+  JoiLev1_00100,  /* C6200..C62FF */
+  JoiLev1_00100,  /* C6300..C63FF */
+  JoiLev1_00100,  /* C6400..C64FF */
+  JoiLev1_00100,  /* C6500..C65FF */
+  JoiLev1_00100,  /* C6600..C66FF */
+  JoiLev1_00100,  /* C6700..C67FF */
+  JoiLev1_00100,  /* C6800..C68FF */
+  JoiLev1_00100,  /* C6900..C69FF */
+  JoiLev1_00100,  /* C6A00..C6AFF */
+  JoiLev1_00100,  /* C6B00..C6BFF */
+  JoiLev1_00100,  /* C6C00..C6CFF */
+  JoiLev1_00100,  /* C6D00..C6DFF */
+  JoiLev1_00100,  /* C6E00..C6EFF */
+  JoiLev1_00100,  /* C6F00..C6FFF */
+  JoiLev1_00100,  /* C7000..C70FF */
+  JoiLev1_00100,  /* C7100..C71FF */
+  JoiLev1_00100,  /* C7200..C72FF */
+  JoiLev1_00100,  /* C7300..C73FF */
+  JoiLev1_00100,  /* C7400..C74FF */
+  JoiLev1_00100,  /* C7500..C75FF */
+  JoiLev1_00100,  /* C7600..C76FF */
+  JoiLev1_00100,  /* C7700..C77FF */
+  JoiLev1_00100,  /* C7800..C78FF */
+  JoiLev1_00100,  /* C7900..C79FF */
+  JoiLev1_00100,  /* C7A00..C7AFF */
+  JoiLev1_00100,  /* C7B00..C7BFF */
+  JoiLev1_00100,  /* C7C00..C7CFF */
+  JoiLev1_00100,  /* C7D00..C7DFF */
+  JoiLev1_00100,  /* C7E00..C7EFF */
+  JoiLev1_00100,  /* C7F00..C7FFF */
+  JoiLev1_00100,  /* C8000..C80FF */
+  JoiLev1_00100,  /* C8100..C81FF */
+  JoiLev1_00100,  /* C8200..C82FF */
+  JoiLev1_00100,  /* C8300..C83FF */
+  JoiLev1_00100,  /* C8400..C84FF */
+  JoiLev1_00100,  /* C8500..C85FF */
+  JoiLev1_00100,  /* C8600..C86FF */
+  JoiLev1_00100,  /* C8700..C87FF */
+  JoiLev1_00100,  /* C8800..C88FF */
+  JoiLev1_00100,  /* C8900..C89FF */
+  JoiLev1_00100,  /* C8A00..C8AFF */
+  JoiLev1_00100,  /* C8B00..C8BFF */
+  JoiLev1_00100,  /* C8C00..C8CFF */
+  JoiLev1_00100,  /* C8D00..C8DFF */
+  JoiLev1_00100,  /* C8E00..C8EFF */
+  JoiLev1_00100,  /* C8F00..C8FFF */
+  JoiLev1_00100,  /* C9000..C90FF */
+  JoiLev1_00100,  /* C9100..C91FF */
+  JoiLev1_00100,  /* C9200..C92FF */
+  JoiLev1_00100,  /* C9300..C93FF */
+  JoiLev1_00100,  /* C9400..C94FF */
+  JoiLev1_00100,  /* C9500..C95FF */
+  JoiLev1_00100,  /* C9600..C96FF */
+  JoiLev1_00100,  /* C9700..C97FF */
+  JoiLev1_00100,  /* C9800..C98FF */
+  JoiLev1_00100,  /* C9900..C99FF */
+  JoiLev1_00100,  /* C9A00..C9AFF */
+  JoiLev1_00100,  /* C9B00..C9BFF */
+  JoiLev1_00100,  /* C9C00..C9CFF */
+  JoiLev1_00100,  /* C9D00..C9DFF */
+  JoiLev1_00100,  /* C9E00..C9EFF */
+  JoiLev1_00100,  /* C9F00..C9FFF */
+  JoiLev1_00100,  /* CA000..CA0FF */
+  JoiLev1_00100,  /* CA100..CA1FF */
+  JoiLev1_00100,  /* CA200..CA2FF */
+  JoiLev1_00100,  /* CA300..CA3FF */
+  JoiLev1_00100,  /* CA400..CA4FF */
+  JoiLev1_00100,  /* CA500..CA5FF */
+  JoiLev1_00100,  /* CA600..CA6FF */
+  JoiLev1_00100,  /* CA700..CA7FF */
+  JoiLev1_00100,  /* CA800..CA8FF */
+  JoiLev1_00100,  /* CA900..CA9FF */
+  JoiLev1_00100,  /* CAA00..CAAFF */
+  JoiLev1_00100,  /* CAB00..CABFF */
+  JoiLev1_00100,  /* CAC00..CACFF */
+  JoiLev1_00100,  /* CAD00..CADFF */
+  JoiLev1_00100,  /* CAE00..CAEFF */
+  JoiLev1_00100,  /* CAF00..CAFFF */
+  JoiLev1_00100,  /* CB000..CB0FF */
+  JoiLev1_00100,  /* CB100..CB1FF */
+  JoiLev1_00100,  /* CB200..CB2FF */
+  JoiLev1_00100,  /* CB300..CB3FF */
+  JoiLev1_00100,  /* CB400..CB4FF */
+  JoiLev1_00100,  /* CB500..CB5FF */
+  JoiLev1_00100,  /* CB600..CB6FF */
+  JoiLev1_00100,  /* CB700..CB7FF */
+  JoiLev1_00100,  /* CB800..CB8FF */
+  JoiLev1_00100,  /* CB900..CB9FF */
+  JoiLev1_00100,  /* CBA00..CBAFF */
+  JoiLev1_00100,  /* CBB00..CBBFF */
+  JoiLev1_00100,  /* CBC00..CBCFF */
+  JoiLev1_00100,  /* CBD00..CBDFF */
+  JoiLev1_00100,  /* CBE00..CBEFF */
+  JoiLev1_00100,  /* CBF00..CBFFF */
+  JoiLev1_00100,  /* CC000..CC0FF */
+  JoiLev1_00100,  /* CC100..CC1FF */
+  JoiLev1_00100,  /* CC200..CC2FF */
+  JoiLev1_00100,  /* CC300..CC3FF */
+  JoiLev1_00100,  /* CC400..CC4FF */
+  JoiLev1_00100,  /* CC500..CC5FF */
+  JoiLev1_00100,  /* CC600..CC6FF */
+  JoiLev1_00100,  /* CC700..CC7FF */
+  JoiLev1_00100,  /* CC800..CC8FF */
+  JoiLev1_00100,  /* CC900..CC9FF */
+  JoiLev1_00100,  /* CCA00..CCAFF */
+  JoiLev1_00100,  /* CCB00..CCBFF */
+  JoiLev1_00100,  /* CCC00..CCCFF */
+  JoiLev1_00100,  /* CCD00..CCDFF */
+  JoiLev1_00100,  /* CCE00..CCEFF */
+  JoiLev1_00100,  /* CCF00..CCFFF */
+  JoiLev1_00100,  /* CD000..CD0FF */
+  JoiLev1_00100,  /* CD100..CD1FF */
+  JoiLev1_00100,  /* CD200..CD2FF */
+  JoiLev1_00100,  /* CD300..CD3FF */
+  JoiLev1_00100,  /* CD400..CD4FF */
+  JoiLev1_00100,  /* CD500..CD5FF */
+  JoiLev1_00100,  /* CD600..CD6FF */
+  JoiLev1_00100,  /* CD700..CD7FF */
+  JoiLev1_00100,  /* CD800..CD8FF */
+  JoiLev1_00100,  /* CD900..CD9FF */
+  JoiLev1_00100,  /* CDA00..CDAFF */
+  JoiLev1_00100,  /* CDB00..CDBFF */
+  JoiLev1_00100,  /* CDC00..CDCFF */
+  JoiLev1_00100,  /* CDD00..CDDFF */
+  JoiLev1_00100,  /* CDE00..CDEFF */
+  JoiLev1_00100,  /* CDF00..CDFFF */
+  JoiLev1_00100,  /* CE000..CE0FF */
+  JoiLev1_00100,  /* CE100..CE1FF */
+  JoiLev1_00100,  /* CE200..CE2FF */
+  JoiLev1_00100,  /* CE300..CE3FF */
+  JoiLev1_00100,  /* CE400..CE4FF */
+  JoiLev1_00100,  /* CE500..CE5FF */
+  JoiLev1_00100,  /* CE600..CE6FF */
+  JoiLev1_00100,  /* CE700..CE7FF */
+  JoiLev1_00100,  /* CE800..CE8FF */
+  JoiLev1_00100,  /* CE900..CE9FF */
+  JoiLev1_00100,  /* CEA00..CEAFF */
+  JoiLev1_00100,  /* CEB00..CEBFF */
+  JoiLev1_00100,  /* CEC00..CECFF */
+  JoiLev1_00100,  /* CED00..CEDFF */
+  JoiLev1_00100,  /* CEE00..CEEFF */
+  JoiLev1_00100,  /* CEF00..CEFFF */
+  JoiLev1_00100,  /* CF000..CF0FF */
+  JoiLev1_00100,  /* CF100..CF1FF */
+  JoiLev1_00100,  /* CF200..CF2FF */
+  JoiLev1_00100,  /* CF300..CF3FF */
+  JoiLev1_00100,  /* CF400..CF4FF */
+  JoiLev1_00100,  /* CF500..CF5FF */
+  JoiLev1_00100,  /* CF600..CF6FF */
+  JoiLev1_00100,  /* CF700..CF7FF */
+  JoiLev1_00100,  /* CF800..CF8FF */
+  JoiLev1_00100,  /* CF900..CF9FF */
+  JoiLev1_00100,  /* CFA00..CFAFF */
+  JoiLev1_00100,  /* CFB00..CFBFF */
+  JoiLev1_00100,  /* CFC00..CFCFF */
+  JoiLev1_00100,  /* CFD00..CFDFF */
+  JoiLev1_00100,  /* CFE00..CFEFF */
+  JoiLev1_00100,  /* CFF00..CFFFF */
+  JoiLev1_00100,  /* D0000..D00FF */
+  JoiLev1_00100,  /* D0100..D01FF */
+  JoiLev1_00100,  /* D0200..D02FF */
+  JoiLev1_00100,  /* D0300..D03FF */
+  JoiLev1_00100,  /* D0400..D04FF */
+  JoiLev1_00100,  /* D0500..D05FF */
+  JoiLev1_00100,  /* D0600..D06FF */
+  JoiLev1_00100,  /* D0700..D07FF */
+  JoiLev1_00100,  /* D0800..D08FF */
+  JoiLev1_00100,  /* D0900..D09FF */
+  JoiLev1_00100,  /* D0A00..D0AFF */
+  JoiLev1_00100,  /* D0B00..D0BFF */
+  JoiLev1_00100,  /* D0C00..D0CFF */
+  JoiLev1_00100,  /* D0D00..D0DFF */
+  JoiLev1_00100,  /* D0E00..D0EFF */
+  JoiLev1_00100,  /* D0F00..D0FFF */
+  JoiLev1_00100,  /* D1000..D10FF */
+  JoiLev1_00100,  /* D1100..D11FF */
+  JoiLev1_00100,  /* D1200..D12FF */
+  JoiLev1_00100,  /* D1300..D13FF */
+  JoiLev1_00100,  /* D1400..D14FF */
+  JoiLev1_00100,  /* D1500..D15FF */
+  JoiLev1_00100,  /* D1600..D16FF */
+  JoiLev1_00100,  /* D1700..D17FF */
+  JoiLev1_00100,  /* D1800..D18FF */
+  JoiLev1_00100,  /* D1900..D19FF */
+  JoiLev1_00100,  /* D1A00..D1AFF */
+  JoiLev1_00100,  /* D1B00..D1BFF */
+  JoiLev1_00100,  /* D1C00..D1CFF */
+  JoiLev1_00100,  /* D1D00..D1DFF */
+  JoiLev1_00100,  /* D1E00..D1EFF */
+  JoiLev1_00100,  /* D1F00..D1FFF */
+  JoiLev1_00100,  /* D2000..D20FF */
+  JoiLev1_00100,  /* D2100..D21FF */
+  JoiLev1_00100,  /* D2200..D22FF */
+  JoiLev1_00100,  /* D2300..D23FF */
+  JoiLev1_00100,  /* D2400..D24FF */
+  JoiLev1_00100,  /* D2500..D25FF */
+  JoiLev1_00100,  /* D2600..D26FF */
+  JoiLev1_00100,  /* D2700..D27FF */
+  JoiLev1_00100,  /* D2800..D28FF */
+  JoiLev1_00100,  /* D2900..D29FF */
+  JoiLev1_00100,  /* D2A00..D2AFF */
+  JoiLev1_00100,  /* D2B00..D2BFF */
+  JoiLev1_00100,  /* D2C00..D2CFF */
+  JoiLev1_00100,  /* D2D00..D2DFF */
+  JoiLev1_00100,  /* D2E00..D2EFF */
+  JoiLev1_00100,  /* D2F00..D2FFF */
+  JoiLev1_00100,  /* D3000..D30FF */
+  JoiLev1_00100,  /* D3100..D31FF */
+  JoiLev1_00100,  /* D3200..D32FF */
+  JoiLev1_00100,  /* D3300..D33FF */
+  JoiLev1_00100,  /* D3400..D34FF */
+  JoiLev1_00100,  /* D3500..D35FF */
+  JoiLev1_00100,  /* D3600..D36FF */
+  JoiLev1_00100,  /* D3700..D37FF */
+  JoiLev1_00100,  /* D3800..D38FF */
+  JoiLev1_00100,  /* D3900..D39FF */
+  JoiLev1_00100,  /* D3A00..D3AFF */
+  JoiLev1_00100,  /* D3B00..D3BFF */
+  JoiLev1_00100,  /* D3C00..D3CFF */
+  JoiLev1_00100,  /* D3D00..D3DFF */
+  JoiLev1_00100,  /* D3E00..D3EFF */
+  JoiLev1_00100,  /* D3F00..D3FFF */
+  JoiLev1_00100,  /* D4000..D40FF */
+  JoiLev1_00100,  /* D4100..D41FF */
+  JoiLev1_00100,  /* D4200..D42FF */
+  JoiLev1_00100,  /* D4300..D43FF */
+  JoiLev1_00100,  /* D4400..D44FF */
+  JoiLev1_00100,  /* D4500..D45FF */
+  JoiLev1_00100,  /* D4600..D46FF */
+  JoiLev1_00100,  /* D4700..D47FF */
+  JoiLev1_00100,  /* D4800..D48FF */
+  JoiLev1_00100,  /* D4900..D49FF */
+  JoiLev1_00100,  /* D4A00..D4AFF */
+  JoiLev1_00100,  /* D4B00..D4BFF */
+  JoiLev1_00100,  /* D4C00..D4CFF */
+  JoiLev1_00100,  /* D4D00..D4DFF */
+  JoiLev1_00100,  /* D4E00..D4EFF */
+  JoiLev1_00100,  /* D4F00..D4FFF */
+  JoiLev1_00100,  /* D5000..D50FF */
+  JoiLev1_00100,  /* D5100..D51FF */
+  JoiLev1_00100,  /* D5200..D52FF */
+  JoiLev1_00100,  /* D5300..D53FF */
+  JoiLev1_00100,  /* D5400..D54FF */
+  JoiLev1_00100,  /* D5500..D55FF */
+  JoiLev1_00100,  /* D5600..D56FF */
+  JoiLev1_00100,  /* D5700..D57FF */
+  JoiLev1_00100,  /* D5800..D58FF */
+  JoiLev1_00100,  /* D5900..D59FF */
+  JoiLev1_00100,  /* D5A00..D5AFF */
+  JoiLev1_00100,  /* D5B00..D5BFF */
+  JoiLev1_00100,  /* D5C00..D5CFF */
+  JoiLev1_00100,  /* D5D00..D5DFF */
+  JoiLev1_00100,  /* D5E00..D5EFF */
+  JoiLev1_00100,  /* D5F00..D5FFF */
+  JoiLev1_00100,  /* D6000..D60FF */
+  JoiLev1_00100,  /* D6100..D61FF */
+  JoiLev1_00100,  /* D6200..D62FF */
+  JoiLev1_00100,  /* D6300..D63FF */
+  JoiLev1_00100,  /* D6400..D64FF */
+  JoiLev1_00100,  /* D6500..D65FF */
+  JoiLev1_00100,  /* D6600..D66FF */
+  JoiLev1_00100,  /* D6700..D67FF */
+  JoiLev1_00100,  /* D6800..D68FF */
+  JoiLev1_00100,  /* D6900..D69FF */
+  JoiLev1_00100,  /* D6A00..D6AFF */
+  JoiLev1_00100,  /* D6B00..D6BFF */
+  JoiLev1_00100,  /* D6C00..D6CFF */
+  JoiLev1_00100,  /* D6D00..D6DFF */
+  JoiLev1_00100,  /* D6E00..D6EFF */
+  JoiLev1_00100,  /* D6F00..D6FFF */
+  JoiLev1_00100,  /* D7000..D70FF */
+  JoiLev1_00100,  /* D7100..D71FF */
+  JoiLev1_00100,  /* D7200..D72FF */
+  JoiLev1_00100,  /* D7300..D73FF */
+  JoiLev1_00100,  /* D7400..D74FF */
+  JoiLev1_00100,  /* D7500..D75FF */
+  JoiLev1_00100,  /* D7600..D76FF */
+  JoiLev1_00100,  /* D7700..D77FF */
+  JoiLev1_00100,  /* D7800..D78FF */
+  JoiLev1_00100,  /* D7900..D79FF */
+  JoiLev1_00100,  /* D7A00..D7AFF */
+  JoiLev1_00100,  /* D7B00..D7BFF */
+  JoiLev1_00100,  /* D7C00..D7CFF */
+  JoiLev1_00100,  /* D7D00..D7DFF */
+  JoiLev1_00100,  /* D7E00..D7EFF */
+  JoiLev1_00100,  /* D7F00..D7FFF */
+  JoiLev1_00100,  /* D8000..D80FF */
+  JoiLev1_00100,  /* D8100..D81FF */
+  JoiLev1_00100,  /* D8200..D82FF */
+  JoiLev1_00100,  /* D8300..D83FF */
+  JoiLev1_00100,  /* D8400..D84FF */
+  JoiLev1_00100,  /* D8500..D85FF */
+  JoiLev1_00100,  /* D8600..D86FF */
+  JoiLev1_00100,  /* D8700..D87FF */
+  JoiLev1_00100,  /* D8800..D88FF */
+  JoiLev1_00100,  /* D8900..D89FF */
+  JoiLev1_00100,  /* D8A00..D8AFF */
+  JoiLev1_00100,  /* D8B00..D8BFF */
+  JoiLev1_00100,  /* D8C00..D8CFF */
+  JoiLev1_00100,  /* D8D00..D8DFF */
+  JoiLev1_00100,  /* D8E00..D8EFF */
+  JoiLev1_00100,  /* D8F00..D8FFF */
+  JoiLev1_00100,  /* D9000..D90FF */
+  JoiLev1_00100,  /* D9100..D91FF */
+  JoiLev1_00100,  /* D9200..D92FF */
+  JoiLev1_00100,  /* D9300..D93FF */
+  JoiLev1_00100,  /* D9400..D94FF */
+  JoiLev1_00100,  /* D9500..D95FF */
+  JoiLev1_00100,  /* D9600..D96FF */
+  JoiLev1_00100,  /* D9700..D97FF */
+  JoiLev1_00100,  /* D9800..D98FF */
+  JoiLev1_00100,  /* D9900..D99FF */
+  JoiLev1_00100,  /* D9A00..D9AFF */
+  JoiLev1_00100,  /* D9B00..D9BFF */
+  JoiLev1_00100,  /* D9C00..D9CFF */
+  JoiLev1_00100,  /* D9D00..D9DFF */
+  JoiLev1_00100,  /* D9E00..D9EFF */
+  JoiLev1_00100,  /* D9F00..D9FFF */
+  JoiLev1_00100,  /* DA000..DA0FF */
+  JoiLev1_00100,  /* DA100..DA1FF */
+  JoiLev1_00100,  /* DA200..DA2FF */
+  JoiLev1_00100,  /* DA300..DA3FF */
+  JoiLev1_00100,  /* DA400..DA4FF */
+  JoiLev1_00100,  /* DA500..DA5FF */
+  JoiLev1_00100,  /* DA600..DA6FF */
+  JoiLev1_00100,  /* DA700..DA7FF */
+  JoiLev1_00100,  /* DA800..DA8FF */
+  JoiLev1_00100,  /* DA900..DA9FF */
+  JoiLev1_00100,  /* DAA00..DAAFF */
+  JoiLev1_00100,  /* DAB00..DABFF */
+  JoiLev1_00100,  /* DAC00..DACFF */
+  JoiLev1_00100,  /* DAD00..DADFF */
+  JoiLev1_00100,  /* DAE00..DAEFF */
+  JoiLev1_00100,  /* DAF00..DAFFF */
+  JoiLev1_00100,  /* DB000..DB0FF */
+  JoiLev1_00100,  /* DB100..DB1FF */
+  JoiLev1_00100,  /* DB200..DB2FF */
+  JoiLev1_00100,  /* DB300..DB3FF */
+  JoiLev1_00100,  /* DB400..DB4FF */
+  JoiLev1_00100,  /* DB500..DB5FF */
+  JoiLev1_00100,  /* DB600..DB6FF */
+  JoiLev1_00100,  /* DB700..DB7FF */
+  JoiLev1_00100,  /* DB800..DB8FF */
+  JoiLev1_00100,  /* DB900..DB9FF */
+  JoiLev1_00100,  /* DBA00..DBAFF */
+  JoiLev1_00100,  /* DBB00..DBBFF */
+  JoiLev1_00100,  /* DBC00..DBCFF */
+  JoiLev1_00100,  /* DBD00..DBDFF */
+  JoiLev1_00100,  /* DBE00..DBEFF */
+  JoiLev1_00100,  /* DBF00..DBFFF */
+  JoiLev1_00100,  /* DC000..DC0FF */
+  JoiLev1_00100,  /* DC100..DC1FF */
+  JoiLev1_00100,  /* DC200..DC2FF */
+  JoiLev1_00100,  /* DC300..DC3FF */
+  JoiLev1_00100,  /* DC400..DC4FF */
+  JoiLev1_00100,  /* DC500..DC5FF */
+  JoiLev1_00100,  /* DC600..DC6FF */
+  JoiLev1_00100,  /* DC700..DC7FF */
+  JoiLev1_00100,  /* DC800..DC8FF */
+  JoiLev1_00100,  /* DC900..DC9FF */
+  JoiLev1_00100,  /* DCA00..DCAFF */
+  JoiLev1_00100,  /* DCB00..DCBFF */
+  JoiLev1_00100,  /* DCC00..DCCFF */
+  JoiLev1_00100,  /* DCD00..DCDFF */
+  JoiLev1_00100,  /* DCE00..DCEFF */
+  JoiLev1_00100,  /* DCF00..DCFFF */
+  JoiLev1_00100,  /* DD000..DD0FF */
+  JoiLev1_00100,  /* DD100..DD1FF */
+  JoiLev1_00100,  /* DD200..DD2FF */
+  JoiLev1_00100,  /* DD300..DD3FF */
+  JoiLev1_00100,  /* DD400..DD4FF */
+  JoiLev1_00100,  /* DD500..DD5FF */
+  JoiLev1_00100,  /* DD600..DD6FF */
+  JoiLev1_00100,  /* DD700..DD7FF */
+  JoiLev1_00100,  /* DD800..DD8FF */
+  JoiLev1_00100,  /* DD900..DD9FF */
+  JoiLev1_00100,  /* DDA00..DDAFF */
+  JoiLev1_00100,  /* DDB00..DDBFF */
+  JoiLev1_00100,  /* DDC00..DDCFF */
+  JoiLev1_00100,  /* DDD00..DDDFF */
+  JoiLev1_00100,  /* DDE00..DDEFF */
+  JoiLev1_00100,  /* DDF00..DDFFF */
+  JoiLev1_00100,  /* DE000..DE0FF */
+  JoiLev1_00100,  /* DE100..DE1FF */
+  JoiLev1_00100,  /* DE200..DE2FF */
+  JoiLev1_00100,  /* DE300..DE3FF */
+  JoiLev1_00100,  /* DE400..DE4FF */
+  JoiLev1_00100,  /* DE500..DE5FF */
+  JoiLev1_00100,  /* DE600..DE6FF */
+  JoiLev1_00100,  /* DE700..DE7FF */
+  JoiLev1_00100,  /* DE800..DE8FF */
+  JoiLev1_00100,  /* DE900..DE9FF */
+  JoiLev1_00100,  /* DEA00..DEAFF */
+  JoiLev1_00100,  /* DEB00..DEBFF */
+  JoiLev1_00100,  /* DEC00..DECFF */
+  JoiLev1_00100,  /* DED00..DEDFF */
+  JoiLev1_00100,  /* DEE00..DEEFF */
+  JoiLev1_00100,  /* DEF00..DEFFF */
+  JoiLev1_00100,  /* DF000..DF0FF */
+  JoiLev1_00100,  /* DF100..DF1FF */
+  JoiLev1_00100,  /* DF200..DF2FF */
+  JoiLev1_00100,  /* DF300..DF3FF */
+  JoiLev1_00100,  /* DF400..DF4FF */
+  JoiLev1_00100,  /* DF500..DF5FF */
+  JoiLev1_00100,  /* DF600..DF6FF */
+  JoiLev1_00100,  /* DF700..DF7FF */
+  JoiLev1_00100,  /* DF800..DF8FF */
+  JoiLev1_00100,  /* DF900..DF9FF */
+  JoiLev1_00100,  /* DFA00..DFAFF */
+  JoiLev1_00100,  /* DFB00..DFBFF */
+  JoiLev1_00100,  /* DFC00..DFCFF */
+  JoiLev1_00100,  /* DFD00..DFDFF */
+  JoiLev1_00100,  /* DFE00..DFEFF */
+  JoiLev1_00100,  /* DFF00..DFFFF */
+  JoiLev1_E0000,  /* E0000..E00FF */
+  JoiLev1_E0100,  /* E0100..E01FF */
+  JoiLev1_00100,  /* E0200..E02FF */
+  JoiLev1_00100,  /* E0300..E03FF */
+  JoiLev1_00100,  /* E0400..E04FF */
+  JoiLev1_00100,  /* E0500..E05FF */
+  JoiLev1_00100,  /* E0600..E06FF */
+  JoiLev1_00100,  /* E0700..E07FF */
+  JoiLev1_00100,  /* E0800..E08FF */
+  JoiLev1_00100,  /* E0900..E09FF */
+  JoiLev1_00100,  /* E0A00..E0AFF */
+  JoiLev1_00100,  /* E0B00..E0BFF */
+  JoiLev1_00100,  /* E0C00..E0CFF */
+  JoiLev1_00100,  /* E0D00..E0DFF */
+  JoiLev1_00100,  /* E0E00..E0EFF */
+  JoiLev1_00100,  /* E0F00..E0FFF */
+  JoiLev1_00100,  /* E1000..E10FF */
+  JoiLev1_00100,  /* E1100..E11FF */
+  JoiLev1_00100,  /* E1200..E12FF */
+  JoiLev1_00100,  /* E1300..E13FF */
+  JoiLev1_00100,  /* E1400..E14FF */
+  JoiLev1_00100,  /* E1500..E15FF */
+  JoiLev1_00100,  /* E1600..E16FF */
+  JoiLev1_00100,  /* E1700..E17FF */
+  JoiLev1_00100,  /* E1800..E18FF */
+  JoiLev1_00100,  /* E1900..E19FF */
+  JoiLev1_00100,  /* E1A00..E1AFF */
+  JoiLev1_00100,  /* E1B00..E1BFF */
+  JoiLev1_00100,  /* E1C00..E1CFF */
+  JoiLev1_00100,  /* E1D00..E1DFF */
+  JoiLev1_00100,  /* E1E00..E1EFF */
+  JoiLev1_00100,  /* E1F00..E1FFF */
+  JoiLev1_00100,  /* E2000..E20FF */
+  JoiLev1_00100,  /* E2100..E21FF */
+  JoiLev1_00100,  /* E2200..E22FF */
+  JoiLev1_00100,  /* E2300..E23FF */
+  JoiLev1_00100,  /* E2400..E24FF */
+  JoiLev1_00100,  /* E2500..E25FF */
+  JoiLev1_00100,  /* E2600..E26FF */
+  JoiLev1_00100,  /* E2700..E27FF */
+  JoiLev1_00100,  /* E2800..E28FF */
+  JoiLev1_00100,  /* E2900..E29FF */
+  JoiLev1_00100,  /* E2A00..E2AFF */
+  JoiLev1_00100,  /* E2B00..E2BFF */
+  JoiLev1_00100,  /* E2C00..E2CFF */
+  JoiLev1_00100,  /* E2D00..E2DFF */
+  JoiLev1_00100,  /* E2E00..E2EFF */
+  JoiLev1_00100,  /* E2F00..E2FFF */
+  JoiLev1_00100,  /* E3000..E30FF */
+  JoiLev1_00100,  /* E3100..E31FF */
+  JoiLev1_00100,  /* E3200..E32FF */
+  JoiLev1_00100,  /* E3300..E33FF */
+  JoiLev1_00100,  /* E3400..E34FF */
+  JoiLev1_00100,  /* E3500..E35FF */
+  JoiLev1_00100,  /* E3600..E36FF */
+  JoiLev1_00100,  /* E3700..E37FF */
+  JoiLev1_00100,  /* E3800..E38FF */
+  JoiLev1_00100,  /* E3900..E39FF */
+  JoiLev1_00100,  /* E3A00..E3AFF */
+  JoiLev1_00100,  /* E3B00..E3BFF */
+  JoiLev1_00100,  /* E3C00..E3CFF */
+  JoiLev1_00100,  /* E3D00..E3DFF */
+  JoiLev1_00100,  /* E3E00..E3EFF */
+  JoiLev1_00100,  /* E3F00..E3FFF */
+  JoiLev1_00100,  /* E4000..E40FF */
+  JoiLev1_00100,  /* E4100..E41FF */
+  JoiLev1_00100,  /* E4200..E42FF */
+  JoiLev1_00100,  /* E4300..E43FF */
+  JoiLev1_00100,  /* E4400..E44FF */
+  JoiLev1_00100,  /* E4500..E45FF */
+  JoiLev1_00100,  /* E4600..E46FF */
+  JoiLev1_00100,  /* E4700..E47FF */
+  JoiLev1_00100,  /* E4800..E48FF */
+  JoiLev1_00100,  /* E4900..E49FF */
+  JoiLev1_00100,  /* E4A00..E4AFF */
+  JoiLev1_00100,  /* E4B00..E4BFF */
+  JoiLev1_00100,  /* E4C00..E4CFF */
+  JoiLev1_00100,  /* E4D00..E4DFF */
+  JoiLev1_00100,  /* E4E00..E4EFF */
+  JoiLev1_00100,  /* E4F00..E4FFF */
+  JoiLev1_00100,  /* E5000..E50FF */
+  JoiLev1_00100,  /* E5100..E51FF */
+  JoiLev1_00100,  /* E5200..E52FF */
+  JoiLev1_00100,  /* E5300..E53FF */
+  JoiLev1_00100,  /* E5400..E54FF */
+  JoiLev1_00100,  /* E5500..E55FF */
+  JoiLev1_00100,  /* E5600..E56FF */
+  JoiLev1_00100,  /* E5700..E57FF */
+  JoiLev1_00100,  /* E5800..E58FF */
+  JoiLev1_00100,  /* E5900..E59FF */
+  JoiLev1_00100,  /* E5A00..E5AFF */
+  JoiLev1_00100,  /* E5B00..E5BFF */
+  JoiLev1_00100,  /* E5C00..E5CFF */
+  JoiLev1_00100,  /* E5D00..E5DFF */
+  JoiLev1_00100,  /* E5E00..E5EFF */
+  JoiLev1_00100,  /* E5F00..E5FFF */
+  JoiLev1_00100,  /* E6000..E60FF */
+  JoiLev1_00100,  /* E6100..E61FF */
+  JoiLev1_00100,  /* E6200..E62FF */
+  JoiLev1_00100,  /* E6300..E63FF */
+  JoiLev1_00100,  /* E6400..E64FF */
+  JoiLev1_00100,  /* E6500..E65FF */
+  JoiLev1_00100,  /* E6600..E66FF */
+  JoiLev1_00100,  /* E6700..E67FF */
+  JoiLev1_00100,  /* E6800..E68FF */
+  JoiLev1_00100,  /* E6900..E69FF */
+  JoiLev1_00100,  /* E6A00..E6AFF */
+  JoiLev1_00100,  /* E6B00..E6BFF */
+  JoiLev1_00100,  /* E6C00..E6CFF */
+  JoiLev1_00100,  /* E6D00..E6DFF */
+  JoiLev1_00100,  /* E6E00..E6EFF */
+  JoiLev1_00100,  /* E6F00..E6FFF */
+  JoiLev1_00100,  /* E7000..E70FF */
+  JoiLev1_00100,  /* E7100..E71FF */
+  JoiLev1_00100,  /* E7200..E72FF */
+  JoiLev1_00100,  /* E7300..E73FF */
+  JoiLev1_00100,  /* E7400..E74FF */
+  JoiLev1_00100,  /* E7500..E75FF */
+  JoiLev1_00100,  /* E7600..E76FF */
+  JoiLev1_00100,  /* E7700..E77FF */
+  JoiLev1_00100,  /* E7800..E78FF */
+  JoiLev1_00100,  /* E7900..E79FF */
+  JoiLev1_00100,  /* E7A00..E7AFF */
+  JoiLev1_00100,  /* E7B00..E7BFF */
+  JoiLev1_00100,  /* E7C00..E7CFF */
+  JoiLev1_00100,  /* E7D00..E7DFF */
+  JoiLev1_00100,  /* E7E00..E7EFF */
+  JoiLev1_00100,  /* E7F00..E7FFF */
+  JoiLev1_00100,  /* E8000..E80FF */
+  JoiLev1_00100,  /* E8100..E81FF */
+  JoiLev1_00100,  /* E8200..E82FF */
+  JoiLev1_00100,  /* E8300..E83FF */
+  JoiLev1_00100,  /* E8400..E84FF */
+  JoiLev1_00100,  /* E8500..E85FF */
+  JoiLev1_00100,  /* E8600..E86FF */
+  JoiLev1_00100,  /* E8700..E87FF */
+  JoiLev1_00100,  /* E8800..E88FF */
+  JoiLev1_00100,  /* E8900..E89FF */
+  JoiLev1_00100,  /* E8A00..E8AFF */
+  JoiLev1_00100,  /* E8B00..E8BFF */
+  JoiLev1_00100,  /* E8C00..E8CFF */
+  JoiLev1_00100,  /* E8D00..E8DFF */
+  JoiLev1_00100,  /* E8E00..E8EFF */
+  JoiLev1_00100,  /* E8F00..E8FFF */
+  JoiLev1_00100,  /* E9000..E90FF */
+  JoiLev1_00100,  /* E9100..E91FF */
+  JoiLev1_00100,  /* E9200..E92FF */
+  JoiLev1_00100,  /* E9300..E93FF */
+  JoiLev1_00100,  /* E9400..E94FF */
+  JoiLev1_00100,  /* E9500..E95FF */
+  JoiLev1_00100,  /* E9600..E96FF */
+  JoiLev1_00100,  /* E9700..E97FF */
+  JoiLev1_00100,  /* E9800..E98FF */
+  JoiLev1_00100,  /* E9900..E99FF */
+  JoiLev1_00100,  /* E9A00..E9AFF */
+  JoiLev1_00100,  /* E9B00..E9BFF */
+  JoiLev1_00100,  /* E9C00..E9CFF */
+  JoiLev1_00100,  /* E9D00..E9DFF */
+  JoiLev1_00100,  /* E9E00..E9EFF */
+  JoiLev1_00100,  /* E9F00..E9FFF */
+  JoiLev1_00100,  /* EA000..EA0FF */
+  JoiLev1_00100,  /* EA100..EA1FF */
+  JoiLev1_00100,  /* EA200..EA2FF */
+  JoiLev1_00100,  /* EA300..EA3FF */
+  JoiLev1_00100,  /* EA400..EA4FF */
+  JoiLev1_00100,  /* EA500..EA5FF */
+  JoiLev1_00100,  /* EA600..EA6FF */
+  JoiLev1_00100,  /* EA700..EA7FF */
+  JoiLev1_00100,  /* EA800..EA8FF */
+  JoiLev1_00100,  /* EA900..EA9FF */
+  JoiLev1_00100,  /* EAA00..EAAFF */
+  JoiLev1_00100,  /* EAB00..EABFF */
+  JoiLev1_00100,  /* EAC00..EACFF */
+  JoiLev1_00100,  /* EAD00..EADFF */
+  JoiLev1_00100,  /* EAE00..EAEFF */
+  JoiLev1_00100,  /* EAF00..EAFFF */
+  JoiLev1_00100,  /* EB000..EB0FF */
+  JoiLev1_00100,  /* EB100..EB1FF */
+  JoiLev1_00100,  /* EB200..EB2FF */
+  JoiLev1_00100,  /* EB300..EB3FF */
+  JoiLev1_00100,  /* EB400..EB4FF */
+  JoiLev1_00100,  /* EB500..EB5FF */
+  JoiLev1_00100,  /* EB600..EB6FF */
+  JoiLev1_00100,  /* EB700..EB7FF */
+  JoiLev1_00100,  /* EB800..EB8FF */
+  JoiLev1_00100,  /* EB900..EB9FF */
+  JoiLev1_00100,  /* EBA00..EBAFF */
+  JoiLev1_00100,  /* EBB00..EBBFF */
+  JoiLev1_00100,  /* EBC00..EBCFF */
+  JoiLev1_00100,  /* EBD00..EBDFF */
+  JoiLev1_00100,  /* EBE00..EBEFF */
+  JoiLev1_00100,  /* EBF00..EBFFF */
+  JoiLev1_00100,  /* EC000..EC0FF */
+  JoiLev1_00100,  /* EC100..EC1FF */
+  JoiLev1_00100,  /* EC200..EC2FF */
+  JoiLev1_00100,  /* EC300..EC3FF */
+  JoiLev1_00100,  /* EC400..EC4FF */
+  JoiLev1_00100,  /* EC500..EC5FF */
+  JoiLev1_00100,  /* EC600..EC6FF */
+  JoiLev1_00100,  /* EC700..EC7FF */
+  JoiLev1_00100,  /* EC800..EC8FF */
+  JoiLev1_00100,  /* EC900..EC9FF */
+  JoiLev1_00100,  /* ECA00..ECAFF */
+  JoiLev1_00100,  /* ECB00..ECBFF */
+  JoiLev1_00100,  /* ECC00..ECCFF */
+  JoiLev1_00100,  /* ECD00..ECDFF */
+  JoiLev1_00100,  /* ECE00..ECEFF */
+  JoiLev1_00100,  /* ECF00..ECFFF */
+  JoiLev1_00100,  /* ED000..ED0FF */
+  JoiLev1_00100,  /* ED100..ED1FF */
+  JoiLev1_00100,  /* ED200..ED2FF */
+  JoiLev1_00100,  /* ED300..ED3FF */
+  JoiLev1_00100,  /* ED400..ED4FF */
+  JoiLev1_00100,  /* ED500..ED5FF */
+  JoiLev1_00100,  /* ED600..ED6FF */
+  JoiLev1_00100,  /* ED700..ED7FF */
+  JoiLev1_00100,  /* ED800..ED8FF */
+  JoiLev1_00100,  /* ED900..ED9FF */
+  JoiLev1_00100,  /* EDA00..EDAFF */
+  JoiLev1_00100,  /* EDB00..EDBFF */
+  JoiLev1_00100,  /* EDC00..EDCFF */
+  JoiLev1_00100,  /* EDD00..EDDFF */
+  JoiLev1_00100,  /* EDE00..EDEFF */
+  JoiLev1_00100,  /* EDF00..EDFFF */
+  JoiLev1_00100,  /* EE000..EE0FF */
+  JoiLev1_00100,  /* EE100..EE1FF */
+  JoiLev1_00100,  /* EE200..EE2FF */
+  JoiLev1_00100,  /* EE300..EE3FF */
+  JoiLev1_00100,  /* EE400..EE4FF */
+  JoiLev1_00100,  /* EE500..EE5FF */
+  JoiLev1_00100,  /* EE600..EE6FF */
+  JoiLev1_00100,  /* EE700..EE7FF */
+  JoiLev1_00100,  /* EE800..EE8FF */
+  JoiLev1_00100,  /* EE900..EE9FF */
+  JoiLev1_00100,  /* EEA00..EEAFF */
+  JoiLev1_00100,  /* EEB00..EEBFF */
+  JoiLev1_00100,  /* EEC00..EECFF */
+  JoiLev1_00100,  /* EED00..EEDFF */
+  JoiLev1_00100,  /* EEE00..EEEFF */
+  JoiLev1_00100,  /* EEF00..EEFFF */
+  JoiLev1_00100,  /* EF000..EF0FF */
+  JoiLev1_00100,  /* EF100..EF1FF */
+  JoiLev1_00100,  /* EF200..EF2FF */
+  JoiLev1_00100,  /* EF300..EF3FF */
+  JoiLev1_00100,  /* EF400..EF4FF */
+  JoiLev1_00100,  /* EF500..EF5FF */
+  JoiLev1_00100,  /* EF600..EF6FF */
+  JoiLev1_00100,  /* EF700..EF7FF */
+  JoiLev1_00100,  /* EF800..EF8FF */
+  JoiLev1_00100,  /* EF900..EF9FF */
+  JoiLev1_00100,  /* EFA00..EFAFF */
+  JoiLev1_00100,  /* EFB00..EFBFF */
+  JoiLev1_00100,  /* EFC00..EFCFF */
+  JoiLev1_00100,  /* EFD00..EFDFF */
+  JoiLev1_00100,  /* EFE00..EFEFF */
+  JoiLev1_00100,  /* EFF00..EFFFF */
+  JoiLev1_00100,  /* F0000..F00FF */
+  JoiLev1_00100,  /* F0100..F01FF */
+  JoiLev1_00100,  /* F0200..F02FF */
+  JoiLev1_00100,  /* F0300..F03FF */
+  JoiLev1_00100,  /* F0400..F04FF */
+  JoiLev1_00100,  /* F0500..F05FF */
+  JoiLev1_00100,  /* F0600..F06FF */
+  JoiLev1_00100,  /* F0700..F07FF */
+  JoiLev1_00100,  /* F0800..F08FF */
+  JoiLev1_00100,  /* F0900..F09FF */
+  JoiLev1_00100,  /* F0A00..F0AFF */
+  JoiLev1_00100,  /* F0B00..F0BFF */
+  JoiLev1_00100,  /* F0C00..F0CFF */
+  JoiLev1_00100,  /* F0D00..F0DFF */
+  JoiLev1_00100,  /* F0E00..F0EFF */
+  JoiLev1_00100,  /* F0F00..F0FFF */
+  JoiLev1_00100,  /* F1000..F10FF */
+  JoiLev1_00100,  /* F1100..F11FF */
+  JoiLev1_00100,  /* F1200..F12FF */
+  JoiLev1_00100,  /* F1300..F13FF */
+  JoiLev1_00100,  /* F1400..F14FF */
+  JoiLev1_00100,  /* F1500..F15FF */
+  JoiLev1_00100,  /* F1600..F16FF */
+  JoiLev1_00100,  /* F1700..F17FF */
+  JoiLev1_00100,  /* F1800..F18FF */
+  JoiLev1_00100,  /* F1900..F19FF */
+  JoiLev1_00100,  /* F1A00..F1AFF */
+  JoiLev1_00100,  /* F1B00..F1BFF */
+  JoiLev1_00100,  /* F1C00..F1CFF */
+  JoiLev1_00100,  /* F1D00..F1DFF */
+  JoiLev1_00100,  /* F1E00..F1EFF */
+  JoiLev1_00100,  /* F1F00..F1FFF */
+  JoiLev1_00100,  /* F2000..F20FF */
+  JoiLev1_00100,  /* F2100..F21FF */
+  JoiLev1_00100,  /* F2200..F22FF */
+  JoiLev1_00100,  /* F2300..F23FF */
+  JoiLev1_00100,  /* F2400..F24FF */
+  JoiLev1_00100,  /* F2500..F25FF */
+  JoiLev1_00100,  /* F2600..F26FF */
+  JoiLev1_00100,  /* F2700..F27FF */
+  JoiLev1_00100,  /* F2800..F28FF */
+  JoiLev1_00100,  /* F2900..F29FF */
+  JoiLev1_00100,  /* F2A00..F2AFF */
+  JoiLev1_00100,  /* F2B00..F2BFF */
+  JoiLev1_00100,  /* F2C00..F2CFF */
+  JoiLev1_00100,  /* F2D00..F2DFF */
+  JoiLev1_00100,  /* F2E00..F2EFF */
+  JoiLev1_00100,  /* F2F00..F2FFF */
+  JoiLev1_00100,  /* F3000..F30FF */
+  JoiLev1_00100,  /* F3100..F31FF */
+  JoiLev1_00100,  /* F3200..F32FF */
+  JoiLev1_00100,  /* F3300..F33FF */
+  JoiLev1_00100,  /* F3400..F34FF */
+  JoiLev1_00100,  /* F3500..F35FF */
+  JoiLev1_00100,  /* F3600..F36FF */
+  JoiLev1_00100,  /* F3700..F37FF */
+  JoiLev1_00100,  /* F3800..F38FF */
+  JoiLev1_00100,  /* F3900..F39FF */
+  JoiLev1_00100,  /* F3A00..F3AFF */
+  JoiLev1_00100,  /* F3B00..F3BFF */
+  JoiLev1_00100,  /* F3C00..F3CFF */
+  JoiLev1_00100,  /* F3D00..F3DFF */
+  JoiLev1_00100,  /* F3E00..F3EFF */
+  JoiLev1_00100,  /* F3F00..F3FFF */
+  JoiLev1_00100,  /* F4000..F40FF */
+  JoiLev1_00100,  /* F4100..F41FF */
+  JoiLev1_00100,  /* F4200..F42FF */
+  JoiLev1_00100,  /* F4300..F43FF */
+  JoiLev1_00100,  /* F4400..F44FF */
+  JoiLev1_00100,  /* F4500..F45FF */
+  JoiLev1_00100,  /* F4600..F46FF */
+  JoiLev1_00100,  /* F4700..F47FF */
+  JoiLev1_00100,  /* F4800..F48FF */
+  JoiLev1_00100,  /* F4900..F49FF */
+  JoiLev1_00100,  /* F4A00..F4AFF */
+  JoiLev1_00100,  /* F4B00..F4BFF */
+  JoiLev1_00100,  /* F4C00..F4CFF */
+  JoiLev1_00100,  /* F4D00..F4DFF */
+  JoiLev1_00100,  /* F4E00..F4EFF */
+  JoiLev1_00100,  /* F4F00..F4FFF */
+  JoiLev1_00100,  /* F5000..F50FF */
+  JoiLev1_00100,  /* F5100..F51FF */
+  JoiLev1_00100,  /* F5200..F52FF */
+  JoiLev1_00100,  /* F5300..F53FF */
+  JoiLev1_00100,  /* F5400..F54FF */
+  JoiLev1_00100,  /* F5500..F55FF */
+  JoiLev1_00100,  /* F5600..F56FF */
+  JoiLev1_00100,  /* F5700..F57FF */
+  JoiLev1_00100,  /* F5800..F58FF */
+  JoiLev1_00100,  /* F5900..F59FF */
+  JoiLev1_00100,  /* F5A00..F5AFF */
+  JoiLev1_00100,  /* F5B00..F5BFF */
+  JoiLev1_00100,  /* F5C00..F5CFF */
+  JoiLev1_00100,  /* F5D00..F5DFF */
+  JoiLev1_00100,  /* F5E00..F5EFF */
+  JoiLev1_00100,  /* F5F00..F5FFF */
+  JoiLev1_00100,  /* F6000..F60FF */
+  JoiLev1_00100,  /* F6100..F61FF */
+  JoiLev1_00100,  /* F6200..F62FF */
+  JoiLev1_00100,  /* F6300..F63FF */
+  JoiLev1_00100,  /* F6400..F64FF */
+  JoiLev1_00100,  /* F6500..F65FF */
+  JoiLev1_00100,  /* F6600..F66FF */
+  JoiLev1_00100,  /* F6700..F67FF */
+  JoiLev1_00100,  /* F6800..F68FF */
+  JoiLev1_00100,  /* F6900..F69FF */
+  JoiLev1_00100,  /* F6A00..F6AFF */
+  JoiLev1_00100,  /* F6B00..F6BFF */
+  JoiLev1_00100,  /* F6C00..F6CFF */
+  JoiLev1_00100,  /* F6D00..F6DFF */
+  JoiLev1_00100,  /* F6E00..F6EFF */
+  JoiLev1_00100,  /* F6F00..F6FFF */
+  JoiLev1_00100,  /* F7000..F70FF */
+  JoiLev1_00100,  /* F7100..F71FF */
+  JoiLev1_00100,  /* F7200..F72FF */
+  JoiLev1_00100,  /* F7300..F73FF */
+  JoiLev1_00100,  /* F7400..F74FF */
+  JoiLev1_00100,  /* F7500..F75FF */
+  JoiLev1_00100,  /* F7600..F76FF */
+  JoiLev1_00100,  /* F7700..F77FF */
+  JoiLev1_00100,  /* F7800..F78FF */
+  JoiLev1_00100,  /* F7900..F79FF */
+  JoiLev1_00100,  /* F7A00..F7AFF */
+  JoiLev1_00100,  /* F7B00..F7BFF */
+  JoiLev1_00100,  /* F7C00..F7CFF */
+  JoiLev1_00100,  /* F7D00..F7DFF */
+  JoiLev1_00100,  /* F7E00..F7EFF */
+  JoiLev1_00100,  /* F7F00..F7FFF */
+  JoiLev1_00100,  /* F8000..F80FF */
+  JoiLev1_00100,  /* F8100..F81FF */
+  JoiLev1_00100,  /* F8200..F82FF */
+  JoiLev1_00100,  /* F8300..F83FF */
+  JoiLev1_00100,  /* F8400..F84FF */
+  JoiLev1_00100,  /* F8500..F85FF */
+  JoiLev1_00100,  /* F8600..F86FF */
+  JoiLev1_00100,  /* F8700..F87FF */
+  JoiLev1_00100,  /* F8800..F88FF */
+  JoiLev1_00100,  /* F8900..F89FF */
+  JoiLev1_00100,  /* F8A00..F8AFF */
+  JoiLev1_00100,  /* F8B00..F8BFF */
+  JoiLev1_00100,  /* F8C00..F8CFF */
+  JoiLev1_00100,  /* F8D00..F8DFF */
+  JoiLev1_00100,  /* F8E00..F8EFF */
+  JoiLev1_00100,  /* F8F00..F8FFF */
+  JoiLev1_00100,  /* F9000..F90FF */
+  JoiLev1_00100,  /* F9100..F91FF */
+  JoiLev1_00100,  /* F9200..F92FF */
+  JoiLev1_00100,  /* F9300..F93FF */
+  JoiLev1_00100,  /* F9400..F94FF */
+  JoiLev1_00100,  /* F9500..F95FF */
+  JoiLev1_00100,  /* F9600..F96FF */
+  JoiLev1_00100,  /* F9700..F97FF */
+  JoiLev1_00100,  /* F9800..F98FF */
+  JoiLev1_00100,  /* F9900..F99FF */
+  JoiLev1_00100,  /* F9A00..F9AFF */
+  JoiLev1_00100,  /* F9B00..F9BFF */
+  JoiLev1_00100,  /* F9C00..F9CFF */
+  JoiLev1_00100,  /* F9D00..F9DFF */
+  JoiLev1_00100,  /* F9E00..F9EFF */
+  JoiLev1_00100,  /* F9F00..F9FFF */
+  JoiLev1_00100,  /* FA000..FA0FF */
+  JoiLev1_00100,  /* FA100..FA1FF */
+  JoiLev1_00100,  /* FA200..FA2FF */
+  JoiLev1_00100,  /* FA300..FA3FF */
+  JoiLev1_00100,  /* FA400..FA4FF */
+  JoiLev1_00100,  /* FA500..FA5FF */
+  JoiLev1_00100,  /* FA600..FA6FF */
+  JoiLev1_00100,  /* FA700..FA7FF */
+  JoiLev1_00100,  /* FA800..FA8FF */
+  JoiLev1_00100,  /* FA900..FA9FF */
+  JoiLev1_00100,  /* FAA00..FAAFF */
+  JoiLev1_00100,  /* FAB00..FABFF */
+  JoiLev1_00100,  /* FAC00..FACFF */
+  JoiLev1_00100,  /* FAD00..FADFF */
+  JoiLev1_00100,  /* FAE00..FAEFF */
+  JoiLev1_00100,  /* FAF00..FAFFF */
+  JoiLev1_00100,  /* FB000..FB0FF */
+  JoiLev1_00100,  /* FB100..FB1FF */
+  JoiLev1_00100,  /* FB200..FB2FF */
+  JoiLev1_00100,  /* FB300..FB3FF */
+  JoiLev1_00100,  /* FB400..FB4FF */
+  JoiLev1_00100,  /* FB500..FB5FF */
+  JoiLev1_00100,  /* FB600..FB6FF */
+  JoiLev1_00100,  /* FB700..FB7FF */
+  JoiLev1_00100,  /* FB800..FB8FF */
+  JoiLev1_00100,  /* FB900..FB9FF */
+  JoiLev1_00100,  /* FBA00..FBAFF */
+  JoiLev1_00100,  /* FBB00..FBBFF */
+  JoiLev1_00100,  /* FBC00..FBCFF */
+  JoiLev1_00100,  /* FBD00..FBDFF */
+  JoiLev1_00100,  /* FBE00..FBEFF */
+  JoiLev1_00100,  /* FBF00..FBFFF */
+  JoiLev1_00100,  /* FC000..FC0FF */
+  JoiLev1_00100,  /* FC100..FC1FF */
+  JoiLev1_00100,  /* FC200..FC2FF */
+  JoiLev1_00100,  /* FC300..FC3FF */
+  JoiLev1_00100,  /* FC400..FC4FF */
+  JoiLev1_00100,  /* FC500..FC5FF */
+  JoiLev1_00100,  /* FC600..FC6FF */
+  JoiLev1_00100,  /* FC700..FC7FF */
+  JoiLev1_00100,  /* FC800..FC8FF */
+  JoiLev1_00100,  /* FC900..FC9FF */
+  JoiLev1_00100,  /* FCA00..FCAFF */
+  JoiLev1_00100,  /* FCB00..FCBFF */
+  JoiLev1_00100,  /* FCC00..FCCFF */
+  JoiLev1_00100,  /* FCD00..FCDFF */
+  JoiLev1_00100,  /* FCE00..FCEFF */
+  JoiLev1_00100,  /* FCF00..FCFFF */
+  JoiLev1_00100,  /* FD000..FD0FF */
+  JoiLev1_00100,  /* FD100..FD1FF */
+  JoiLev1_00100,  /* FD200..FD2FF */
+  JoiLev1_00100,  /* FD300..FD3FF */
+  JoiLev1_00100,  /* FD400..FD4FF */
+  JoiLev1_00100,  /* FD500..FD5FF */
+  JoiLev1_00100,  /* FD600..FD6FF */
+  JoiLev1_00100,  /* FD700..FD7FF */
+  JoiLev1_00100,  /* FD800..FD8FF */
+  JoiLev1_00100,  /* FD900..FD9FF */
+  JoiLev1_00100,  /* FDA00..FDAFF */
+  JoiLev1_00100,  /* FDB00..FDBFF */
+  JoiLev1_00100,  /* FDC00..FDCFF */
+  JoiLev1_00100,  /* FDD00..FDDFF */
+  JoiLev1_00100,  /* FDE00..FDEFF */
+  JoiLev1_00100,  /* FDF00..FDFFF */
+  JoiLev1_00100,  /* FE000..FE0FF */
+  JoiLev1_00100,  /* FE100..FE1FF */
+  JoiLev1_00100,  /* FE200..FE2FF */
+  JoiLev1_00100,  /* FE300..FE3FF */
+  JoiLev1_00100,  /* FE400..FE4FF */
+  JoiLev1_00100,  /* FE500..FE5FF */
+  JoiLev1_00100,  /* FE600..FE6FF */
+  JoiLev1_00100,  /* FE700..FE7FF */
+  JoiLev1_00100,  /* FE800..FE8FF */
+  JoiLev1_00100,  /* FE900..FE9FF */
+  JoiLev1_00100,  /* FEA00..FEAFF */
+  JoiLev1_00100,  /* FEB00..FEBFF */
+  JoiLev1_00100,  /* FEC00..FECFF */
+  JoiLev1_00100,  /* FED00..FEDFF */
+  JoiLev1_00100,  /* FEE00..FEEFF */
+  JoiLev1_00100,  /* FEF00..FEFFF */
+  JoiLev1_00100,  /* FF000..FF0FF */
+  JoiLev1_00100,  /* FF100..FF1FF */
+  JoiLev1_00100,  /* FF200..FF2FF */
+  JoiLev1_00100,  /* FF300..FF3FF */
+  JoiLev1_00100,  /* FF400..FF4FF */
+  JoiLev1_00100,  /* FF500..FF5FF */
+  JoiLev1_00100,  /* FF600..FF6FF */
+  JoiLev1_00100,  /* FF700..FF7FF */
+  JoiLev1_00100,  /* FF800..FF8FF */
+  JoiLev1_00100,  /* FF900..FF9FF */
+  JoiLev1_00100,  /* FFA00..FFAFF */
+  JoiLev1_00100,  /* FFB00..FFBFF */
+  JoiLev1_00100,  /* FFC00..FFCFF */
+  JoiLev1_00100,  /* FFD00..FFDFF */
+  JoiLev1_00100,  /* FFE00..FFEFF */
+  JoiLev1_00100,  /* FFF00..FFFFF */
+};
+
+/* *INDENT-ON* */
+
+#define FRIBIDI_GET_JOINING_TYPE(x) \
+	((x) >= 0x100000 ? U :  \
+	JoiLev1[((x) & 0xff) + \
+	JoiLev0[((x) >> 8)]])
+
+#undef PACKTAB_UINT8
+#undef PACKTAB_UINT16
+#undef PACKTAB_UINT32
+
+/* End of generated joining-type.tab.i */
diff -rupN orginal/scribus/fribidi/mem.h patched/scribus/fribidi/mem.h
--- orginal/scribus/fribidi/mem.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/fribidi/mem.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,97 @@
+/* FriBidi
+ * mem.h - memory manipulation routines
+ *
+ * $Id: mem.h,v 1.7 2006/01/31 03:23:13 behdad Exp $
+ * $Author: behdad $
+ * $Date: 2006/01/31 03:23:13 $
+ * $Revision: 1.7 $
+ * $Source: /cvs/fribidi/fribidi2/lib/mem.h,v $
+ *
+ * Author:
+ *   Behdad Esfahbod, 2001, 2002, 2004
+ *
+ * Copyright (C) 2004 Sharif FarsiWeb, Inc
+ * Copyright (C) 2001,2002 Behdad Esfahbod
+ * 
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ * 
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library, in a file named COPYING; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA
+ * 
+ * For licensing issues, contact <license@farsiweb.info>.
+ */
+#ifndef _MEM_H
+#define _MEM_H
+
+#include "common.h"
+
+#include <fribidi-types.h>
+
+#include <fribidi-begindecls.h>
+
+#if FRIBIDI_USE_GLIB+0
+
+#ifndef __FRIBIDI_DOC
+# include <glib/gmem.h>
+#endif /* !__FRIBIDI_DOC */
+
+#define FriBidiMemChunk GMemChunk
+#define FRIBIDI_ALLOC_ONLY G_ALLOC_ONLY
+#define fribidi_mem_chunk_new g_mem_chunk_new
+#define fribidi_mem_chunk_alloc g_mem_chunk_alloc
+#define fribidi_mem_chunk_destroy g_mem_chunk_destroy
+
+#else /* !FRIBIDI_USE_GLIB */
+
+typedef struct _FriBidiMemChunk FriBidiMemChunk;
+
+#define FRIBIDI_ALLOC_ONLY      1
+
+#define fribidi_mem_chunk_new FRIBIDI_PRIVATESPACE(mem_chunk_new)
+FriBidiMemChunk *
+fribidi_mem_chunk_new (
+  const char *name,
+  int atom_size,
+  unsigned long area_size,
+  int alloc_type
+)
+     FRIBIDI_GNUC_HIDDEN FRIBIDI_GNUC_MALLOC FRIBIDI_GNUC_WARN_UNUSED;
+
+#define fribidi_mem_chunk_alloc FRIBIDI_PRIVATESPACE(mem_chunk_alloc)
+     void *fribidi_mem_chunk_alloc (
+  FriBidiMemChunk *mem_chunk
+)
+     FRIBIDI_GNUC_HIDDEN FRIBIDI_GNUC_MALLOC FRIBIDI_GNUC_WARN_UNUSED;
+
+#define fribidi_mem_chunk_destroy FRIBIDI_PRIVATESPACE(mem_chunk_destroy)
+     void fribidi_mem_chunk_destroy (
+  FriBidiMemChunk *mem_chunk
+) FRIBIDI_GNUC_HIDDEN;
+
+#endif /* !FRIBIDI_USE_GLIB */
+
+#define fribidi_chunk_new(type, chunk)        ( \
+		(type *) fribidi_mem_chunk_alloc (chunk) \
+	)
+
+#define fribidi_chunk_new_for_type(type) ( \
+		fribidi_mem_chunk_new(FRIBIDI, sizeof (type), \
+				FRIBIDI_CHUNK_SIZE, FRIBIDI_ALLOC_ONLY) \
+	)
+
+#include <fribidi-enddecls.h>
+
+#endif /* !_MEM_H */
+/* Editor directions:
+ * vim:textwidth=78:tabstop=8:shiftwidth=2:autoindent:cindent
+ */
diff -rupN orginal/scribus/fribidi/mirroring.tab.i patched/scribus/fribidi/mirroring.tab.i
--- orginal/scribus/fribidi/mirroring.tab.i	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/fribidi/mirroring.tab.i	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,1148 @@
+/* mirroring.tab.i
+ * generated by gen-mirroring-tab (GNU FriBidi 0.19.1)
+ * from the file BidiMirroring.txt of Unicode version 5.1.0. */
+
+#define PACKTAB_UINT8 fribidi_uint8
+#define PACKTAB_UINT16 fribidi_uint16
+#define PACKTAB_UINT32 fribidi_uint32
+
+/*
+  generated by packtab.c version 3
+
+  use FRIBIDI_GET_MIRRORING_DELTA(key) to access your table
+
+  assumed sizeof(fribidi_int16): 2
+  required memory: 5504
+  lookups: 2
+  partition shape: Mir[1024][64]
+  different table entries: 1 27
+*/
+
+/* *INDENT-OFF* */
+
+static const fribidi_int16 MirLev1[64*27] = {
+#define MirLev1_0000 0x0
+  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+  0,0,0,0,0,0,0,0,1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,-2,0,
+#define MirLev1_0040 0x40
+  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,-2,0,0,
+  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,-2,0,0,
+#define MirLev1_0080 0x80
+  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+  0,0,0,0,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-16,0,0,0,0,
+#define MirLev1_00C0 0xC0
+  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+#define MirLev1_0F00 0x100
+  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,-1,1,-1,0,0,
+#define MirLev1_1680 0x140
+  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,-1,0,0,0,
+  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+#define MirLev1_2000 0x180
+  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,-1,0,0,0,0,0,
+#define MirLev1_2040 0x1C0
+  0,0,0,0,0,1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,-1,0,
+#define MirLev1_2080 0x200
+  0,0,0,0,0,0,0,0,0,0,0,0,0,1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+#define MirLev1_2200 0x240
+  0,0,0,0,0,0,0,0,3,3,3,-3,-3,-3,0,0,0,0,0,0,0,2016,0,0,0,0,0,0,0,0,0,0,
+  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,-1,0,0,
+#define MirLev1_2240 0x280
+  0,0,0,138,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,-1,1,-1,0,0,0,0,0,0,0,0,0,0,
+  0,0,0,0,1,-1,1,-1,1,-1,1,-1,0,0,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,
+#define MirLev1_2280 0x2C0
+  1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,0,0,0,1,-1,1,-1,0,0,0,0,0,1824,0,0,0,0,0,0,0,
+  0,0,1,-1,0,0,2104,0,2108,2106,0,2106,0,0,0,0,1,-1,1,-1,1,-1,1,-1,0,0,0,0,0,0,0,0,
+#define MirLev1_22C0 0x300
+  0,0,0,0,0,0,0,0,0,1,-1,1,-1,-138,0,0,1,-1,0,0,0,0,1,-1,1,-1,1,-1,1,-1,1,-1,
+  1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,0,0,1,-1,8,8,8,0,7,7,0,0,-8,-8,-8,-7,-7,0,
+#define MirLev1_2300 0x340
+  0,0,0,0,0,0,0,0,1,-1,1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+  0,0,0,0,0,0,0,0,0,1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+#define MirLev1_2740 0x380
+  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+  0,0,0,0,0,0,0,0,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,0,0,0,0,0,0,0,0,0,0,
+#define MirLev1_27C0 0x3C0
+  0,0,0,1,-1,1,-1,0,1,-1,0,0,0,0,0,0,0,0,0,0,0,1,-1,0,0,0,0,0,0,1,-1,0,
+  0,0,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+#define MirLev1_2980 0x400
+  0,0,0,1,-1,1,-1,1,-1,1,-1,1,-1,3,1,-1,-3,1,-1,1,-1,1,-1,1,-1,0,0,0,0,0,0,0,
+  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1824,0,0,0,0,0,0,0,
+#define MirLev1_29C0 0x440
+  1,-1,0,0,1,-1,0,0,0,0,0,0,0,0,0,1,-1,1,-1,0,1,-1,0,0,1,-1,1,-1,0,0,0,0,
+  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-2016,0,0,1,-1,0,0,1,-1,0,0,
+#define MirLev1_2A00 0x480
+  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+  0,0,0,0,0,0,0,0,0,0,0,1,-1,1,-1,0,0,0,0,0,1,-1,0,0,0,0,0,0,1,-1,0,0,
+#define MirLev1_2A40 0x4C0
+  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+  0,0,0,0,1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,-1,0,0,1,-1,1,
+#define MirLev1_2A80 0x500
+  -1,1,-1,1,-1,0,0,0,0,0,0,1,-1,0,0,0,0,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,0,0,0,
+  0,1,-1,0,0,0,1,-1,1,-1,1,-1,1,-1,0,1,-1,0,0,1,-1,0,0,0,0,0,0,1,-1,1,-1,1,
+#define MirLev1_2AC0 0x540
+  -1,1,-1,1,-1,1,-1,0,0,0,0,0,0,1,-1,1,-1,1,-1,1,-1,1,-1,0,0,0,0,0,0,0,-2104,0,
+  0,0,0,-2106,-2108,-2106,0,0,0,0,0,0,1,-1,0,0,0,0,0,0,0,0,0,1,-1,1,-1,0,0,0,0,0,
+#define MirLev1_2E00 0x580
+  0,0,1,-1,1,-1,0,0,0,1,-1,0,1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,-1,0,0,
+  1,-1,1,-1,1,-1,1,-1,1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+#define MirLev1_3000 0x5C0
+  0,0,0,0,0,0,0,0,1,-1,1,-1,1,-1,1,-1,1,-1,0,0,1,-1,1,-1,1,-1,1,-1,0,0,0,0,
+  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+#define MirLev1_FE40 0x600
+  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,-1,1,-1,1,-1,0,
+  0,0,0,0,1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+#define MirLev1_FF00 0x640
+  0,0,0,0,0,0,0,0,1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,-2,0,
+  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,-2,0,0,
+#define MirLev1_FF40 0x680
+  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,-2,0,1,
+  -1,0,1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+};
+
+static const PACKTAB_UINT16 MirLev0[1024*1] = {
+#define MirLev0_0000 0x0
+  MirLev1_0000,  /* 0000..003F */
+  MirLev1_0040,  /* 0040..007F */
+  MirLev1_0080,  /* 0080..00BF */
+  MirLev1_00C0,  /* 00C0..00FF */
+  MirLev1_00C0,  /* 0100..013F */
+  MirLev1_00C0,  /* 0140..017F */
+  MirLev1_00C0,  /* 0180..01BF */
+  MirLev1_00C0,  /* 01C0..01FF */
+  MirLev1_00C0,  /* 0200..023F */
+  MirLev1_00C0,  /* 0240..027F */
+  MirLev1_00C0,  /* 0280..02BF */
+  MirLev1_00C0,  /* 02C0..02FF */
+  MirLev1_00C0,  /* 0300..033F */
+  MirLev1_00C0,  /* 0340..037F */
+  MirLev1_00C0,  /* 0380..03BF */
+  MirLev1_00C0,  /* 03C0..03FF */
+  MirLev1_00C0,  /* 0400..043F */
+  MirLev1_00C0,  /* 0440..047F */
+  MirLev1_00C0,  /* 0480..04BF */
+  MirLev1_00C0,  /* 04C0..04FF */
+  MirLev1_00C0,  /* 0500..053F */
+  MirLev1_00C0,  /* 0540..057F */
+  MirLev1_00C0,  /* 0580..05BF */
+  MirLev1_00C0,  /* 05C0..05FF */
+  MirLev1_00C0,  /* 0600..063F */
+  MirLev1_00C0,  /* 0640..067F */
+  MirLev1_00C0,  /* 0680..06BF */
+  MirLev1_00C0,  /* 06C0..06FF */
+  MirLev1_00C0,  /* 0700..073F */
+  MirLev1_00C0,  /* 0740..077F */
+  MirLev1_00C0,  /* 0780..07BF */
+  MirLev1_00C0,  /* 07C0..07FF */
+  MirLev1_00C0,  /* 0800..083F */
+  MirLev1_00C0,  /* 0840..087F */
+  MirLev1_00C0,  /* 0880..08BF */
+  MirLev1_00C0,  /* 08C0..08FF */
+  MirLev1_00C0,  /* 0900..093F */
+  MirLev1_00C0,  /* 0940..097F */
+  MirLev1_00C0,  /* 0980..09BF */
+  MirLev1_00C0,  /* 09C0..09FF */
+  MirLev1_00C0,  /* 0A00..0A3F */
+  MirLev1_00C0,  /* 0A40..0A7F */
+  MirLev1_00C0,  /* 0A80..0ABF */
+  MirLev1_00C0,  /* 0AC0..0AFF */
+  MirLev1_00C0,  /* 0B00..0B3F */
+  MirLev1_00C0,  /* 0B40..0B7F */
+  MirLev1_00C0,  /* 0B80..0BBF */
+  MirLev1_00C0,  /* 0BC0..0BFF */
+  MirLev1_00C0,  /* 0C00..0C3F */
+  MirLev1_00C0,  /* 0C40..0C7F */
+  MirLev1_00C0,  /* 0C80..0CBF */
+  MirLev1_00C0,  /* 0CC0..0CFF */
+  MirLev1_00C0,  /* 0D00..0D3F */
+  MirLev1_00C0,  /* 0D40..0D7F */
+  MirLev1_00C0,  /* 0D80..0DBF */
+  MirLev1_00C0,  /* 0DC0..0DFF */
+  MirLev1_00C0,  /* 0E00..0E3F */
+  MirLev1_00C0,  /* 0E40..0E7F */
+  MirLev1_00C0,  /* 0E80..0EBF */
+  MirLev1_00C0,  /* 0EC0..0EFF */
+  MirLev1_0F00,  /* 0F00..0F3F */
+  MirLev1_00C0,  /* 0F40..0F7F */
+  MirLev1_00C0,  /* 0F80..0FBF */
+  MirLev1_00C0,  /* 0FC0..0FFF */
+  MirLev1_00C0,  /* 1000..103F */
+  MirLev1_00C0,  /* 1040..107F */
+  MirLev1_00C0,  /* 1080..10BF */
+  MirLev1_00C0,  /* 10C0..10FF */
+  MirLev1_00C0,  /* 1100..113F */
+  MirLev1_00C0,  /* 1140..117F */
+  MirLev1_00C0,  /* 1180..11BF */
+  MirLev1_00C0,  /* 11C0..11FF */
+  MirLev1_00C0,  /* 1200..123F */
+  MirLev1_00C0,  /* 1240..127F */
+  MirLev1_00C0,  /* 1280..12BF */
+  MirLev1_00C0,  /* 12C0..12FF */
+  MirLev1_00C0,  /* 1300..133F */
+  MirLev1_00C0,  /* 1340..137F */
+  MirLev1_00C0,  /* 1380..13BF */
+  MirLev1_00C0,  /* 13C0..13FF */
+  MirLev1_00C0,  /* 1400..143F */
+  MirLev1_00C0,  /* 1440..147F */
+  MirLev1_00C0,  /* 1480..14BF */
+  MirLev1_00C0,  /* 14C0..14FF */
+  MirLev1_00C0,  /* 1500..153F */
+  MirLev1_00C0,  /* 1540..157F */
+  MirLev1_00C0,  /* 1580..15BF */
+  MirLev1_00C0,  /* 15C0..15FF */
+  MirLev1_00C0,  /* 1600..163F */
+  MirLev1_00C0,  /* 1640..167F */
+  MirLev1_1680,  /* 1680..16BF */
+  MirLev1_00C0,  /* 16C0..16FF */
+  MirLev1_00C0,  /* 1700..173F */
+  MirLev1_00C0,  /* 1740..177F */
+  MirLev1_00C0,  /* 1780..17BF */
+  MirLev1_00C0,  /* 17C0..17FF */
+  MirLev1_00C0,  /* 1800..183F */
+  MirLev1_00C0,  /* 1840..187F */
+  MirLev1_00C0,  /* 1880..18BF */
+  MirLev1_00C0,  /* 18C0..18FF */
+  MirLev1_00C0,  /* 1900..193F */
+  MirLev1_00C0,  /* 1940..197F */
+  MirLev1_00C0,  /* 1980..19BF */
+  MirLev1_00C0,  /* 19C0..19FF */
+  MirLev1_00C0,  /* 1A00..1A3F */
+  MirLev1_00C0,  /* 1A40..1A7F */
+  MirLev1_00C0,  /* 1A80..1ABF */
+  MirLev1_00C0,  /* 1AC0..1AFF */
+  MirLev1_00C0,  /* 1B00..1B3F */
+  MirLev1_00C0,  /* 1B40..1B7F */
+  MirLev1_00C0,  /* 1B80..1BBF */
+  MirLev1_00C0,  /* 1BC0..1BFF */
+  MirLev1_00C0,  /* 1C00..1C3F */
+  MirLev1_00C0,  /* 1C40..1C7F */
+  MirLev1_00C0,  /* 1C80..1CBF */
+  MirLev1_00C0,  /* 1CC0..1CFF */
+  MirLev1_00C0,  /* 1D00..1D3F */
+  MirLev1_00C0,  /* 1D40..1D7F */
+  MirLev1_00C0,  /* 1D80..1DBF */
+  MirLev1_00C0,  /* 1DC0..1DFF */
+  MirLev1_00C0,  /* 1E00..1E3F */
+  MirLev1_00C0,  /* 1E40..1E7F */
+  MirLev1_00C0,  /* 1E80..1EBF */
+  MirLev1_00C0,  /* 1EC0..1EFF */
+  MirLev1_00C0,  /* 1F00..1F3F */
+  MirLev1_00C0,  /* 1F40..1F7F */
+  MirLev1_00C0,  /* 1F80..1FBF */
+  MirLev1_00C0,  /* 1FC0..1FFF */
+  MirLev1_2000,  /* 2000..203F */
+  MirLev1_2040,  /* 2040..207F */
+  MirLev1_2080,  /* 2080..20BF */
+  MirLev1_00C0,  /* 20C0..20FF */
+  MirLev1_00C0,  /* 2100..213F */
+  MirLev1_00C0,  /* 2140..217F */
+  MirLev1_00C0,  /* 2180..21BF */
+  MirLev1_00C0,  /* 21C0..21FF */
+  MirLev1_2200,  /* 2200..223F */
+  MirLev1_2240,  /* 2240..227F */
+  MirLev1_2280,  /* 2280..22BF */
+  MirLev1_22C0,  /* 22C0..22FF */
+  MirLev1_2300,  /* 2300..233F */
+  MirLev1_00C0,  /* 2340..237F */
+  MirLev1_00C0,  /* 2380..23BF */
+  MirLev1_00C0,  /* 23C0..23FF */
+  MirLev1_00C0,  /* 2400..243F */
+  MirLev1_00C0,  /* 2440..247F */
+  MirLev1_00C0,  /* 2480..24BF */
+  MirLev1_00C0,  /* 24C0..24FF */
+  MirLev1_00C0,  /* 2500..253F */
+  MirLev1_00C0,  /* 2540..257F */
+  MirLev1_00C0,  /* 2580..25BF */
+  MirLev1_00C0,  /* 25C0..25FF */
+  MirLev1_00C0,  /* 2600..263F */
+  MirLev1_00C0,  /* 2640..267F */
+  MirLev1_00C0,  /* 2680..26BF */
+  MirLev1_00C0,  /* 26C0..26FF */
+  MirLev1_00C0,  /* 2700..273F */
+  MirLev1_2740,  /* 2740..277F */
+  MirLev1_00C0,  /* 2780..27BF */
+  MirLev1_27C0,  /* 27C0..27FF */
+  MirLev1_00C0,  /* 2800..283F */
+  MirLev1_00C0,  /* 2840..287F */
+  MirLev1_00C0,  /* 2880..28BF */
+  MirLev1_00C0,  /* 28C0..28FF */
+  MirLev1_00C0,  /* 2900..293F */
+  MirLev1_00C0,  /* 2940..297F */
+  MirLev1_2980,  /* 2980..29BF */
+  MirLev1_29C0,  /* 29C0..29FF */
+  MirLev1_2A00,  /* 2A00..2A3F */
+  MirLev1_2A40,  /* 2A40..2A7F */
+  MirLev1_2A80,  /* 2A80..2ABF */
+  MirLev1_2AC0,  /* 2AC0..2AFF */
+  MirLev1_00C0,  /* 2B00..2B3F */
+  MirLev1_00C0,  /* 2B40..2B7F */
+  MirLev1_00C0,  /* 2B80..2BBF */
+  MirLev1_00C0,  /* 2BC0..2BFF */
+  MirLev1_00C0,  /* 2C00..2C3F */
+  MirLev1_00C0,  /* 2C40..2C7F */
+  MirLev1_00C0,  /* 2C80..2CBF */
+  MirLev1_00C0,  /* 2CC0..2CFF */
+  MirLev1_00C0,  /* 2D00..2D3F */
+  MirLev1_00C0,  /* 2D40..2D7F */
+  MirLev1_00C0,  /* 2D80..2DBF */
+  MirLev1_00C0,  /* 2DC0..2DFF */
+  MirLev1_2E00,  /* 2E00..2E3F */
+  MirLev1_00C0,  /* 2E40..2E7F */
+  MirLev1_00C0,  /* 2E80..2EBF */
+  MirLev1_00C0,  /* 2EC0..2EFF */
+  MirLev1_00C0,  /* 2F00..2F3F */
+  MirLev1_00C0,  /* 2F40..2F7F */
+  MirLev1_00C0,  /* 2F80..2FBF */
+  MirLev1_00C0,  /* 2FC0..2FFF */
+  MirLev1_3000,  /* 3000..303F */
+  MirLev1_00C0,  /* 3040..307F */
+  MirLev1_00C0,  /* 3080..30BF */
+  MirLev1_00C0,  /* 30C0..30FF */
+  MirLev1_00C0,  /* 3100..313F */
+  MirLev1_00C0,  /* 3140..317F */
+  MirLev1_00C0,  /* 3180..31BF */
+  MirLev1_00C0,  /* 31C0..31FF */
+  MirLev1_00C0,  /* 3200..323F */
+  MirLev1_00C0,  /* 3240..327F */
+  MirLev1_00C0,  /* 3280..32BF */
+  MirLev1_00C0,  /* 32C0..32FF */
+  MirLev1_00C0,  /* 3300..333F */
+  MirLev1_00C0,  /* 3340..337F */
+  MirLev1_00C0,  /* 3380..33BF */
+  MirLev1_00C0,  /* 33C0..33FF */
+  MirLev1_00C0,  /* 3400..343F */
+  MirLev1_00C0,  /* 3440..347F */
+  MirLev1_00C0,  /* 3480..34BF */
+  MirLev1_00C0,  /* 34C0..34FF */
+  MirLev1_00C0,  /* 3500..353F */
+  MirLev1_00C0,  /* 3540..357F */
+  MirLev1_00C0,  /* 3580..35BF */
+  MirLev1_00C0,  /* 35C0..35FF */
+  MirLev1_00C0,  /* 3600..363F */
+  MirLev1_00C0,  /* 3640..367F */
+  MirLev1_00C0,  /* 3680..36BF */
+  MirLev1_00C0,  /* 36C0..36FF */
+  MirLev1_00C0,  /* 3700..373F */
+  MirLev1_00C0,  /* 3740..377F */
+  MirLev1_00C0,  /* 3780..37BF */
+  MirLev1_00C0,  /* 37C0..37FF */
+  MirLev1_00C0,  /* 3800..383F */
+  MirLev1_00C0,  /* 3840..387F */
+  MirLev1_00C0,  /* 3880..38BF */
+  MirLev1_00C0,  /* 38C0..38FF */
+  MirLev1_00C0,  /* 3900..393F */
+  MirLev1_00C0,  /* 3940..397F */
+  MirLev1_00C0,  /* 3980..39BF */
+  MirLev1_00C0,  /* 39C0..39FF */
+  MirLev1_00C0,  /* 3A00..3A3F */
+  MirLev1_00C0,  /* 3A40..3A7F */
+  MirLev1_00C0,  /* 3A80..3ABF */
+  MirLev1_00C0,  /* 3AC0..3AFF */
+  MirLev1_00C0,  /* 3B00..3B3F */
+  MirLev1_00C0,  /* 3B40..3B7F */
+  MirLev1_00C0,  /* 3B80..3BBF */
+  MirLev1_00C0,  /* 3BC0..3BFF */
+  MirLev1_00C0,  /* 3C00..3C3F */
+  MirLev1_00C0,  /* 3C40..3C7F */
+  MirLev1_00C0,  /* 3C80..3CBF */
+  MirLev1_00C0,  /* 3CC0..3CFF */
+  MirLev1_00C0,  /* 3D00..3D3F */
+  MirLev1_00C0,  /* 3D40..3D7F */
+  MirLev1_00C0,  /* 3D80..3DBF */
+  MirLev1_00C0,  /* 3DC0..3DFF */
+  MirLev1_00C0,  /* 3E00..3E3F */
+  MirLev1_00C0,  /* 3E40..3E7F */
+  MirLev1_00C0,  /* 3E80..3EBF */
+  MirLev1_00C0,  /* 3EC0..3EFF */
+  MirLev1_00C0,  /* 3F00..3F3F */
+  MirLev1_00C0,  /* 3F40..3F7F */
+  MirLev1_00C0,  /* 3F80..3FBF */
+  MirLev1_00C0,  /* 3FC0..3FFF */
+  MirLev1_00C0,  /* 4000..403F */
+  MirLev1_00C0,  /* 4040..407F */
+  MirLev1_00C0,  /* 4080..40BF */
+  MirLev1_00C0,  /* 40C0..40FF */
+  MirLev1_00C0,  /* 4100..413F */
+  MirLev1_00C0,  /* 4140..417F */
+  MirLev1_00C0,  /* 4180..41BF */
+  MirLev1_00C0,  /* 41C0..41FF */
+  MirLev1_00C0,  /* 4200..423F */
+  MirLev1_00C0,  /* 4240..427F */
+  MirLev1_00C0,  /* 4280..42BF */
+  MirLev1_00C0,  /* 42C0..42FF */
+  MirLev1_00C0,  /* 4300..433F */
+  MirLev1_00C0,  /* 4340..437F */
+  MirLev1_00C0,  /* 4380..43BF */
+  MirLev1_00C0,  /* 43C0..43FF */
+  MirLev1_00C0,  /* 4400..443F */
+  MirLev1_00C0,  /* 4440..447F */
+  MirLev1_00C0,  /* 4480..44BF */
+  MirLev1_00C0,  /* 44C0..44FF */
+  MirLev1_00C0,  /* 4500..453F */
+  MirLev1_00C0,  /* 4540..457F */
+  MirLev1_00C0,  /* 4580..45BF */
+  MirLev1_00C0,  /* 45C0..45FF */
+  MirLev1_00C0,  /* 4600..463F */
+  MirLev1_00C0,  /* 4640..467F */
+  MirLev1_00C0,  /* 4680..46BF */
+  MirLev1_00C0,  /* 46C0..46FF */
+  MirLev1_00C0,  /* 4700..473F */
+  MirLev1_00C0,  /* 4740..477F */
+  MirLev1_00C0,  /* 4780..47BF */
+  MirLev1_00C0,  /* 47C0..47FF */
+  MirLev1_00C0,  /* 4800..483F */
+  MirLev1_00C0,  /* 4840..487F */
+  MirLev1_00C0,  /* 4880..48BF */
+  MirLev1_00C0,  /* 48C0..48FF */
+  MirLev1_00C0,  /* 4900..493F */
+  MirLev1_00C0,  /* 4940..497F */
+  MirLev1_00C0,  /* 4980..49BF */
+  MirLev1_00C0,  /* 49C0..49FF */
+  MirLev1_00C0,  /* 4A00..4A3F */
+  MirLev1_00C0,  /* 4A40..4A7F */
+  MirLev1_00C0,  /* 4A80..4ABF */
+  MirLev1_00C0,  /* 4AC0..4AFF */
+  MirLev1_00C0,  /* 4B00..4B3F */
+  MirLev1_00C0,  /* 4B40..4B7F */
+  MirLev1_00C0,  /* 4B80..4BBF */
+  MirLev1_00C0,  /* 4BC0..4BFF */
+  MirLev1_00C0,  /* 4C00..4C3F */
+  MirLev1_00C0,  /* 4C40..4C7F */
+  MirLev1_00C0,  /* 4C80..4CBF */
+  MirLev1_00C0,  /* 4CC0..4CFF */
+  MirLev1_00C0,  /* 4D00..4D3F */
+  MirLev1_00C0,  /* 4D40..4D7F */
+  MirLev1_00C0,  /* 4D80..4DBF */
+  MirLev1_00C0,  /* 4DC0..4DFF */
+  MirLev1_00C0,  /* 4E00..4E3F */
+  MirLev1_00C0,  /* 4E40..4E7F */
+  MirLev1_00C0,  /* 4E80..4EBF */
+  MirLev1_00C0,  /* 4EC0..4EFF */
+  MirLev1_00C0,  /* 4F00..4F3F */
+  MirLev1_00C0,  /* 4F40..4F7F */
+  MirLev1_00C0,  /* 4F80..4FBF */
+  MirLev1_00C0,  /* 4FC0..4FFF */
+  MirLev1_00C0,  /* 5000..503F */
+  MirLev1_00C0,  /* 5040..507F */
+  MirLev1_00C0,  /* 5080..50BF */
+  MirLev1_00C0,  /* 50C0..50FF */
+  MirLev1_00C0,  /* 5100..513F */
+  MirLev1_00C0,  /* 5140..517F */
+  MirLev1_00C0,  /* 5180..51BF */
+  MirLev1_00C0,  /* 51C0..51FF */
+  MirLev1_00C0,  /* 5200..523F */
+  MirLev1_00C0,  /* 5240..527F */
+  MirLev1_00C0,  /* 5280..52BF */
+  MirLev1_00C0,  /* 52C0..52FF */
+  MirLev1_00C0,  /* 5300..533F */
+  MirLev1_00C0,  /* 5340..537F */
+  MirLev1_00C0,  /* 5380..53BF */
+  MirLev1_00C0,  /* 53C0..53FF */
+  MirLev1_00C0,  /* 5400..543F */
+  MirLev1_00C0,  /* 5440..547F */
+  MirLev1_00C0,  /* 5480..54BF */
+  MirLev1_00C0,  /* 54C0..54FF */
+  MirLev1_00C0,  /* 5500..553F */
+  MirLev1_00C0,  /* 5540..557F */
+  MirLev1_00C0,  /* 5580..55BF */
+  MirLev1_00C0,  /* 55C0..55FF */
+  MirLev1_00C0,  /* 5600..563F */
+  MirLev1_00C0,  /* 5640..567F */
+  MirLev1_00C0,  /* 5680..56BF */
+  MirLev1_00C0,  /* 56C0..56FF */
+  MirLev1_00C0,  /* 5700..573F */
+  MirLev1_00C0,  /* 5740..577F */
+  MirLev1_00C0,  /* 5780..57BF */
+  MirLev1_00C0,  /* 57C0..57FF */
+  MirLev1_00C0,  /* 5800..583F */
+  MirLev1_00C0,  /* 5840..587F */
+  MirLev1_00C0,  /* 5880..58BF */
+  MirLev1_00C0,  /* 58C0..58FF */
+  MirLev1_00C0,  /* 5900..593F */
+  MirLev1_00C0,  /* 5940..597F */
+  MirLev1_00C0,  /* 5980..59BF */
+  MirLev1_00C0,  /* 59C0..59FF */
+  MirLev1_00C0,  /* 5A00..5A3F */
+  MirLev1_00C0,  /* 5A40..5A7F */
+  MirLev1_00C0,  /* 5A80..5ABF */
+  MirLev1_00C0,  /* 5AC0..5AFF */
+  MirLev1_00C0,  /* 5B00..5B3F */
+  MirLev1_00C0,  /* 5B40..5B7F */
+  MirLev1_00C0,  /* 5B80..5BBF */
+  MirLev1_00C0,  /* 5BC0..5BFF */
+  MirLev1_00C0,  /* 5C00..5C3F */
+  MirLev1_00C0,  /* 5C40..5C7F */
+  MirLev1_00C0,  /* 5C80..5CBF */
+  MirLev1_00C0,  /* 5CC0..5CFF */
+  MirLev1_00C0,  /* 5D00..5D3F */
+  MirLev1_00C0,  /* 5D40..5D7F */
+  MirLev1_00C0,  /* 5D80..5DBF */
+  MirLev1_00C0,  /* 5DC0..5DFF */
+  MirLev1_00C0,  /* 5E00..5E3F */
+  MirLev1_00C0,  /* 5E40..5E7F */
+  MirLev1_00C0,  /* 5E80..5EBF */
+  MirLev1_00C0,  /* 5EC0..5EFF */
+  MirLev1_00C0,  /* 5F00..5F3F */
+  MirLev1_00C0,  /* 5F40..5F7F */
+  MirLev1_00C0,  /* 5F80..5FBF */
+  MirLev1_00C0,  /* 5FC0..5FFF */
+  MirLev1_00C0,  /* 6000..603F */
+  MirLev1_00C0,  /* 6040..607F */
+  MirLev1_00C0,  /* 6080..60BF */
+  MirLev1_00C0,  /* 60C0..60FF */
+  MirLev1_00C0,  /* 6100..613F */
+  MirLev1_00C0,  /* 6140..617F */
+  MirLev1_00C0,  /* 6180..61BF */
+  MirLev1_00C0,  /* 61C0..61FF */
+  MirLev1_00C0,  /* 6200..623F */
+  MirLev1_00C0,  /* 6240..627F */
+  MirLev1_00C0,  /* 6280..62BF */
+  MirLev1_00C0,  /* 62C0..62FF */
+  MirLev1_00C0,  /* 6300..633F */
+  MirLev1_00C0,  /* 6340..637F */
+  MirLev1_00C0,  /* 6380..63BF */
+  MirLev1_00C0,  /* 63C0..63FF */
+  MirLev1_00C0,  /* 6400..643F */
+  MirLev1_00C0,  /* 6440..647F */
+  MirLev1_00C0,  /* 6480..64BF */
+  MirLev1_00C0,  /* 64C0..64FF */
+  MirLev1_00C0,  /* 6500..653F */
+  MirLev1_00C0,  /* 6540..657F */
+  MirLev1_00C0,  /* 6580..65BF */
+  MirLev1_00C0,  /* 65C0..65FF */
+  MirLev1_00C0,  /* 6600..663F */
+  MirLev1_00C0,  /* 6640..667F */
+  MirLev1_00C0,  /* 6680..66BF */
+  MirLev1_00C0,  /* 66C0..66FF */
+  MirLev1_00C0,  /* 6700..673F */
+  MirLev1_00C0,  /* 6740..677F */
+  MirLev1_00C0,  /* 6780..67BF */
+  MirLev1_00C0,  /* 67C0..67FF */
+  MirLev1_00C0,  /* 6800..683F */
+  MirLev1_00C0,  /* 6840..687F */
+  MirLev1_00C0,  /* 6880..68BF */
+  MirLev1_00C0,  /* 68C0..68FF */
+  MirLev1_00C0,  /* 6900..693F */
+  MirLev1_00C0,  /* 6940..697F */
+  MirLev1_00C0,  /* 6980..69BF */
+  MirLev1_00C0,  /* 69C0..69FF */
+  MirLev1_00C0,  /* 6A00..6A3F */
+  MirLev1_00C0,  /* 6A40..6A7F */
+  MirLev1_00C0,  /* 6A80..6ABF */
+  MirLev1_00C0,  /* 6AC0..6AFF */
+  MirLev1_00C0,  /* 6B00..6B3F */
+  MirLev1_00C0,  /* 6B40..6B7F */
+  MirLev1_00C0,  /* 6B80..6BBF */
+  MirLev1_00C0,  /* 6BC0..6BFF */
+  MirLev1_00C0,  /* 6C00..6C3F */
+  MirLev1_00C0,  /* 6C40..6C7F */
+  MirLev1_00C0,  /* 6C80..6CBF */
+  MirLev1_00C0,  /* 6CC0..6CFF */
+  MirLev1_00C0,  /* 6D00..6D3F */
+  MirLev1_00C0,  /* 6D40..6D7F */
+  MirLev1_00C0,  /* 6D80..6DBF */
+  MirLev1_00C0,  /* 6DC0..6DFF */
+  MirLev1_00C0,  /* 6E00..6E3F */
+  MirLev1_00C0,  /* 6E40..6E7F */
+  MirLev1_00C0,  /* 6E80..6EBF */
+  MirLev1_00C0,  /* 6EC0..6EFF */
+  MirLev1_00C0,  /* 6F00..6F3F */
+  MirLev1_00C0,  /* 6F40..6F7F */
+  MirLev1_00C0,  /* 6F80..6FBF */
+  MirLev1_00C0,  /* 6FC0..6FFF */
+  MirLev1_00C0,  /* 7000..703F */
+  MirLev1_00C0,  /* 7040..707F */
+  MirLev1_00C0,  /* 7080..70BF */
+  MirLev1_00C0,  /* 70C0..70FF */
+  MirLev1_00C0,  /* 7100..713F */
+  MirLev1_00C0,  /* 7140..717F */
+  MirLev1_00C0,  /* 7180..71BF */
+  MirLev1_00C0,  /* 71C0..71FF */
+  MirLev1_00C0,  /* 7200..723F */
+  MirLev1_00C0,  /* 7240..727F */
+  MirLev1_00C0,  /* 7280..72BF */
+  MirLev1_00C0,  /* 72C0..72FF */
+  MirLev1_00C0,  /* 7300..733F */
+  MirLev1_00C0,  /* 7340..737F */
+  MirLev1_00C0,  /* 7380..73BF */
+  MirLev1_00C0,  /* 73C0..73FF */
+  MirLev1_00C0,  /* 7400..743F */
+  MirLev1_00C0,  /* 7440..747F */
+  MirLev1_00C0,  /* 7480..74BF */
+  MirLev1_00C0,  /* 74C0..74FF */
+  MirLev1_00C0,  /* 7500..753F */
+  MirLev1_00C0,  /* 7540..757F */
+  MirLev1_00C0,  /* 7580..75BF */
+  MirLev1_00C0,  /* 75C0..75FF */
+  MirLev1_00C0,  /* 7600..763F */
+  MirLev1_00C0,  /* 7640..767F */
+  MirLev1_00C0,  /* 7680..76BF */
+  MirLev1_00C0,  /* 76C0..76FF */
+  MirLev1_00C0,  /* 7700..773F */
+  MirLev1_00C0,  /* 7740..777F */
+  MirLev1_00C0,  /* 7780..77BF */
+  MirLev1_00C0,  /* 77C0..77FF */
+  MirLev1_00C0,  /* 7800..783F */
+  MirLev1_00C0,  /* 7840..787F */
+  MirLev1_00C0,  /* 7880..78BF */
+  MirLev1_00C0,  /* 78C0..78FF */
+  MirLev1_00C0,  /* 7900..793F */
+  MirLev1_00C0,  /* 7940..797F */
+  MirLev1_00C0,  /* 7980..79BF */
+  MirLev1_00C0,  /* 79C0..79FF */
+  MirLev1_00C0,  /* 7A00..7A3F */
+  MirLev1_00C0,  /* 7A40..7A7F */
+  MirLev1_00C0,  /* 7A80..7ABF */
+  MirLev1_00C0,  /* 7AC0..7AFF */
+  MirLev1_00C0,  /* 7B00..7B3F */
+  MirLev1_00C0,  /* 7B40..7B7F */
+  MirLev1_00C0,  /* 7B80..7BBF */
+  MirLev1_00C0,  /* 7BC0..7BFF */
+  MirLev1_00C0,  /* 7C00..7C3F */
+  MirLev1_00C0,  /* 7C40..7C7F */
+  MirLev1_00C0,  /* 7C80..7CBF */
+  MirLev1_00C0,  /* 7CC0..7CFF */
+  MirLev1_00C0,  /* 7D00..7D3F */
+  MirLev1_00C0,  /* 7D40..7D7F */
+  MirLev1_00C0,  /* 7D80..7DBF */
+  MirLev1_00C0,  /* 7DC0..7DFF */
+  MirLev1_00C0,  /* 7E00..7E3F */
+  MirLev1_00C0,  /* 7E40..7E7F */
+  MirLev1_00C0,  /* 7E80..7EBF */
+  MirLev1_00C0,  /* 7EC0..7EFF */
+  MirLev1_00C0,  /* 7F00..7F3F */
+  MirLev1_00C0,  /* 7F40..7F7F */
+  MirLev1_00C0,  /* 7F80..7FBF */
+  MirLev1_00C0,  /* 7FC0..7FFF */
+  MirLev1_00C0,  /* 8000..803F */
+  MirLev1_00C0,  /* 8040..807F */
+  MirLev1_00C0,  /* 8080..80BF */
+  MirLev1_00C0,  /* 80C0..80FF */
+  MirLev1_00C0,  /* 8100..813F */
+  MirLev1_00C0,  /* 8140..817F */
+  MirLev1_00C0,  /* 8180..81BF */
+  MirLev1_00C0,  /* 81C0..81FF */
+  MirLev1_00C0,  /* 8200..823F */
+  MirLev1_00C0,  /* 8240..827F */
+  MirLev1_00C0,  /* 8280..82BF */
+  MirLev1_00C0,  /* 82C0..82FF */
+  MirLev1_00C0,  /* 8300..833F */
+  MirLev1_00C0,  /* 8340..837F */
+  MirLev1_00C0,  /* 8380..83BF */
+  MirLev1_00C0,  /* 83C0..83FF */
+  MirLev1_00C0,  /* 8400..843F */
+  MirLev1_00C0,  /* 8440..847F */
+  MirLev1_00C0,  /* 8480..84BF */
+  MirLev1_00C0,  /* 84C0..84FF */
+  MirLev1_00C0,  /* 8500..853F */
+  MirLev1_00C0,  /* 8540..857F */
+  MirLev1_00C0,  /* 8580..85BF */
+  MirLev1_00C0,  /* 85C0..85FF */
+  MirLev1_00C0,  /* 8600..863F */
+  MirLev1_00C0,  /* 8640..867F */
+  MirLev1_00C0,  /* 8680..86BF */
+  MirLev1_00C0,  /* 86C0..86FF */
+  MirLev1_00C0,  /* 8700..873F */
+  MirLev1_00C0,  /* 8740..877F */
+  MirLev1_00C0,  /* 8780..87BF */
+  MirLev1_00C0,  /* 87C0..87FF */
+  MirLev1_00C0,  /* 8800..883F */
+  MirLev1_00C0,  /* 8840..887F */
+  MirLev1_00C0,  /* 8880..88BF */
+  MirLev1_00C0,  /* 88C0..88FF */
+  MirLev1_00C0,  /* 8900..893F */
+  MirLev1_00C0,  /* 8940..897F */
+  MirLev1_00C0,  /* 8980..89BF */
+  MirLev1_00C0,  /* 89C0..89FF */
+  MirLev1_00C0,  /* 8A00..8A3F */
+  MirLev1_00C0,  /* 8A40..8A7F */
+  MirLev1_00C0,  /* 8A80..8ABF */
+  MirLev1_00C0,  /* 8AC0..8AFF */
+  MirLev1_00C0,  /* 8B00..8B3F */
+  MirLev1_00C0,  /* 8B40..8B7F */
+  MirLev1_00C0,  /* 8B80..8BBF */
+  MirLev1_00C0,  /* 8BC0..8BFF */
+  MirLev1_00C0,  /* 8C00..8C3F */
+  MirLev1_00C0,  /* 8C40..8C7F */
+  MirLev1_00C0,  /* 8C80..8CBF */
+  MirLev1_00C0,  /* 8CC0..8CFF */
+  MirLev1_00C0,  /* 8D00..8D3F */
+  MirLev1_00C0,  /* 8D40..8D7F */
+  MirLev1_00C0,  /* 8D80..8DBF */
+  MirLev1_00C0,  /* 8DC0..8DFF */
+  MirLev1_00C0,  /* 8E00..8E3F */
+  MirLev1_00C0,  /* 8E40..8E7F */
+  MirLev1_00C0,  /* 8E80..8EBF */
+  MirLev1_00C0,  /* 8EC0..8EFF */
+  MirLev1_00C0,  /* 8F00..8F3F */
+  MirLev1_00C0,  /* 8F40..8F7F */
+  MirLev1_00C0,  /* 8F80..8FBF */
+  MirLev1_00C0,  /* 8FC0..8FFF */
+  MirLev1_00C0,  /* 9000..903F */
+  MirLev1_00C0,  /* 9040..907F */
+  MirLev1_00C0,  /* 9080..90BF */
+  MirLev1_00C0,  /* 90C0..90FF */
+  MirLev1_00C0,  /* 9100..913F */
+  MirLev1_00C0,  /* 9140..917F */
+  MirLev1_00C0,  /* 9180..91BF */
+  MirLev1_00C0,  /* 91C0..91FF */
+  MirLev1_00C0,  /* 9200..923F */
+  MirLev1_00C0,  /* 9240..927F */
+  MirLev1_00C0,  /* 9280..92BF */
+  MirLev1_00C0,  /* 92C0..92FF */
+  MirLev1_00C0,  /* 9300..933F */
+  MirLev1_00C0,  /* 9340..937F */
+  MirLev1_00C0,  /* 9380..93BF */
+  MirLev1_00C0,  /* 93C0..93FF */
+  MirLev1_00C0,  /* 9400..943F */
+  MirLev1_00C0,  /* 9440..947F */
+  MirLev1_00C0,  /* 9480..94BF */
+  MirLev1_00C0,  /* 94C0..94FF */
+  MirLev1_00C0,  /* 9500..953F */
+  MirLev1_00C0,  /* 9540..957F */
+  MirLev1_00C0,  /* 9580..95BF */
+  MirLev1_00C0,  /* 95C0..95FF */
+  MirLev1_00C0,  /* 9600..963F */
+  MirLev1_00C0,  /* 9640..967F */
+  MirLev1_00C0,  /* 9680..96BF */
+  MirLev1_00C0,  /* 96C0..96FF */
+  MirLev1_00C0,  /* 9700..973F */
+  MirLev1_00C0,  /* 9740..977F */
+  MirLev1_00C0,  /* 9780..97BF */
+  MirLev1_00C0,  /* 97C0..97FF */
+  MirLev1_00C0,  /* 9800..983F */
+  MirLev1_00C0,  /* 9840..987F */
+  MirLev1_00C0,  /* 9880..98BF */
+  MirLev1_00C0,  /* 98C0..98FF */
+  MirLev1_00C0,  /* 9900..993F */
+  MirLev1_00C0,  /* 9940..997F */
+  MirLev1_00C0,  /* 9980..99BF */
+  MirLev1_00C0,  /* 99C0..99FF */
+  MirLev1_00C0,  /* 9A00..9A3F */
+  MirLev1_00C0,  /* 9A40..9A7F */
+  MirLev1_00C0,  /* 9A80..9ABF */
+  MirLev1_00C0,  /* 9AC0..9AFF */
+  MirLev1_00C0,  /* 9B00..9B3F */
+  MirLev1_00C0,  /* 9B40..9B7F */
+  MirLev1_00C0,  /* 9B80..9BBF */
+  MirLev1_00C0,  /* 9BC0..9BFF */
+  MirLev1_00C0,  /* 9C00..9C3F */
+  MirLev1_00C0,  /* 9C40..9C7F */
+  MirLev1_00C0,  /* 9C80..9CBF */
+  MirLev1_00C0,  /* 9CC0..9CFF */
+  MirLev1_00C0,  /* 9D00..9D3F */
+  MirLev1_00C0,  /* 9D40..9D7F */
+  MirLev1_00C0,  /* 9D80..9DBF */
+  MirLev1_00C0,  /* 9DC0..9DFF */
+  MirLev1_00C0,  /* 9E00..9E3F */
+  MirLev1_00C0,  /* 9E40..9E7F */
+  MirLev1_00C0,  /* 9E80..9EBF */
+  MirLev1_00C0,  /* 9EC0..9EFF */
+  MirLev1_00C0,  /* 9F00..9F3F */
+  MirLev1_00C0,  /* 9F40..9F7F */
+  MirLev1_00C0,  /* 9F80..9FBF */
+  MirLev1_00C0,  /* 9FC0..9FFF */
+  MirLev1_00C0,  /* A000..A03F */
+  MirLev1_00C0,  /* A040..A07F */
+  MirLev1_00C0,  /* A080..A0BF */
+  MirLev1_00C0,  /* A0C0..A0FF */
+  MirLev1_00C0,  /* A100..A13F */
+  MirLev1_00C0,  /* A140..A17F */
+  MirLev1_00C0,  /* A180..A1BF */
+  MirLev1_00C0,  /* A1C0..A1FF */
+  MirLev1_00C0,  /* A200..A23F */
+  MirLev1_00C0,  /* A240..A27F */
+  MirLev1_00C0,  /* A280..A2BF */
+  MirLev1_00C0,  /* A2C0..A2FF */
+  MirLev1_00C0,  /* A300..A33F */
+  MirLev1_00C0,  /* A340..A37F */
+  MirLev1_00C0,  /* A380..A3BF */
+  MirLev1_00C0,  /* A3C0..A3FF */
+  MirLev1_00C0,  /* A400..A43F */
+  MirLev1_00C0,  /* A440..A47F */
+  MirLev1_00C0,  /* A480..A4BF */
+  MirLev1_00C0,  /* A4C0..A4FF */
+  MirLev1_00C0,  /* A500..A53F */
+  MirLev1_00C0,  /* A540..A57F */
+  MirLev1_00C0,  /* A580..A5BF */
+  MirLev1_00C0,  /* A5C0..A5FF */
+  MirLev1_00C0,  /* A600..A63F */
+  MirLev1_00C0,  /* A640..A67F */
+  MirLev1_00C0,  /* A680..A6BF */
+  MirLev1_00C0,  /* A6C0..A6FF */
+  MirLev1_00C0,  /* A700..A73F */
+  MirLev1_00C0,  /* A740..A77F */
+  MirLev1_00C0,  /* A780..A7BF */
+  MirLev1_00C0,  /* A7C0..A7FF */
+  MirLev1_00C0,  /* A800..A83F */
+  MirLev1_00C0,  /* A840..A87F */
+  MirLev1_00C0,  /* A880..A8BF */
+  MirLev1_00C0,  /* A8C0..A8FF */
+  MirLev1_00C0,  /* A900..A93F */
+  MirLev1_00C0,  /* A940..A97F */
+  MirLev1_00C0,  /* A980..A9BF */
+  MirLev1_00C0,  /* A9C0..A9FF */
+  MirLev1_00C0,  /* AA00..AA3F */
+  MirLev1_00C0,  /* AA40..AA7F */
+  MirLev1_00C0,  /* AA80..AABF */
+  MirLev1_00C0,  /* AAC0..AAFF */
+  MirLev1_00C0,  /* AB00..AB3F */
+  MirLev1_00C0,  /* AB40..AB7F */
+  MirLev1_00C0,  /* AB80..ABBF */
+  MirLev1_00C0,  /* ABC0..ABFF */
+  MirLev1_00C0,  /* AC00..AC3F */
+  MirLev1_00C0,  /* AC40..AC7F */
+  MirLev1_00C0,  /* AC80..ACBF */
+  MirLev1_00C0,  /* ACC0..ACFF */
+  MirLev1_00C0,  /* AD00..AD3F */
+  MirLev1_00C0,  /* AD40..AD7F */
+  MirLev1_00C0,  /* AD80..ADBF */
+  MirLev1_00C0,  /* ADC0..ADFF */
+  MirLev1_00C0,  /* AE00..AE3F */
+  MirLev1_00C0,  /* AE40..AE7F */
+  MirLev1_00C0,  /* AE80..AEBF */
+  MirLev1_00C0,  /* AEC0..AEFF */
+  MirLev1_00C0,  /* AF00..AF3F */
+  MirLev1_00C0,  /* AF40..AF7F */
+  MirLev1_00C0,  /* AF80..AFBF */
+  MirLev1_00C0,  /* AFC0..AFFF */
+  MirLev1_00C0,  /* B000..B03F */
+  MirLev1_00C0,  /* B040..B07F */
+  MirLev1_00C0,  /* B080..B0BF */
+  MirLev1_00C0,  /* B0C0..B0FF */
+  MirLev1_00C0,  /* B100..B13F */
+  MirLev1_00C0,  /* B140..B17F */
+  MirLev1_00C0,  /* B180..B1BF */
+  MirLev1_00C0,  /* B1C0..B1FF */
+  MirLev1_00C0,  /* B200..B23F */
+  MirLev1_00C0,  /* B240..B27F */
+  MirLev1_00C0,  /* B280..B2BF */
+  MirLev1_00C0,  /* B2C0..B2FF */
+  MirLev1_00C0,  /* B300..B33F */
+  MirLev1_00C0,  /* B340..B37F */
+  MirLev1_00C0,  /* B380..B3BF */
+  MirLev1_00C0,  /* B3C0..B3FF */
+  MirLev1_00C0,  /* B400..B43F */
+  MirLev1_00C0,  /* B440..B47F */
+  MirLev1_00C0,  /* B480..B4BF */
+  MirLev1_00C0,  /* B4C0..B4FF */
+  MirLev1_00C0,  /* B500..B53F */
+  MirLev1_00C0,  /* B540..B57F */
+  MirLev1_00C0,  /* B580..B5BF */
+  MirLev1_00C0,  /* B5C0..B5FF */
+  MirLev1_00C0,  /* B600..B63F */
+  MirLev1_00C0,  /* B640..B67F */
+  MirLev1_00C0,  /* B680..B6BF */
+  MirLev1_00C0,  /* B6C0..B6FF */
+  MirLev1_00C0,  /* B700..B73F */
+  MirLev1_00C0,  /* B740..B77F */
+  MirLev1_00C0,  /* B780..B7BF */
+  MirLev1_00C0,  /* B7C0..B7FF */
+  MirLev1_00C0,  /* B800..B83F */
+  MirLev1_00C0,  /* B840..B87F */
+  MirLev1_00C0,  /* B880..B8BF */
+  MirLev1_00C0,  /* B8C0..B8FF */
+  MirLev1_00C0,  /* B900..B93F */
+  MirLev1_00C0,  /* B940..B97F */
+  MirLev1_00C0,  /* B980..B9BF */
+  MirLev1_00C0,  /* B9C0..B9FF */
+  MirLev1_00C0,  /* BA00..BA3F */
+  MirLev1_00C0,  /* BA40..BA7F */
+  MirLev1_00C0,  /* BA80..BABF */
+  MirLev1_00C0,  /* BAC0..BAFF */
+  MirLev1_00C0,  /* BB00..BB3F */
+  MirLev1_00C0,  /* BB40..BB7F */
+  MirLev1_00C0,  /* BB80..BBBF */
+  MirLev1_00C0,  /* BBC0..BBFF */
+  MirLev1_00C0,  /* BC00..BC3F */
+  MirLev1_00C0,  /* BC40..BC7F */
+  MirLev1_00C0,  /* BC80..BCBF */
+  MirLev1_00C0,  /* BCC0..BCFF */
+  MirLev1_00C0,  /* BD00..BD3F */
+  MirLev1_00C0,  /* BD40..BD7F */
+  MirLev1_00C0,  /* BD80..BDBF */
+  MirLev1_00C0,  /* BDC0..BDFF */
+  MirLev1_00C0,  /* BE00..BE3F */
+  MirLev1_00C0,  /* BE40..BE7F */
+  MirLev1_00C0,  /* BE80..BEBF */
+  MirLev1_00C0,  /* BEC0..BEFF */
+  MirLev1_00C0,  /* BF00..BF3F */
+  MirLev1_00C0,  /* BF40..BF7F */
+  MirLev1_00C0,  /* BF80..BFBF */
+  MirLev1_00C0,  /* BFC0..BFFF */
+  MirLev1_00C0,  /* C000..C03F */
+  MirLev1_00C0,  /* C040..C07F */
+  MirLev1_00C0,  /* C080..C0BF */
+  MirLev1_00C0,  /* C0C0..C0FF */
+  MirLev1_00C0,  /* C100..C13F */
+  MirLev1_00C0,  /* C140..C17F */
+  MirLev1_00C0,  /* C180..C1BF */
+  MirLev1_00C0,  /* C1C0..C1FF */
+  MirLev1_00C0,  /* C200..C23F */
+  MirLev1_00C0,  /* C240..C27F */
+  MirLev1_00C0,  /* C280..C2BF */
+  MirLev1_00C0,  /* C2C0..C2FF */
+  MirLev1_00C0,  /* C300..C33F */
+  MirLev1_00C0,  /* C340..C37F */
+  MirLev1_00C0,  /* C380..C3BF */
+  MirLev1_00C0,  /* C3C0..C3FF */
+  MirLev1_00C0,  /* C400..C43F */
+  MirLev1_00C0,  /* C440..C47F */
+  MirLev1_00C0,  /* C480..C4BF */
+  MirLev1_00C0,  /* C4C0..C4FF */
+  MirLev1_00C0,  /* C500..C53F */
+  MirLev1_00C0,  /* C540..C57F */
+  MirLev1_00C0,  /* C580..C5BF */
+  MirLev1_00C0,  /* C5C0..C5FF */
+  MirLev1_00C0,  /* C600..C63F */
+  MirLev1_00C0,  /* C640..C67F */
+  MirLev1_00C0,  /* C680..C6BF */
+  MirLev1_00C0,  /* C6C0..C6FF */
+  MirLev1_00C0,  /* C700..C73F */
+  MirLev1_00C0,  /* C740..C77F */
+  MirLev1_00C0,  /* C780..C7BF */
+  MirLev1_00C0,  /* C7C0..C7FF */
+  MirLev1_00C0,  /* C800..C83F */
+  MirLev1_00C0,  /* C840..C87F */
+  MirLev1_00C0,  /* C880..C8BF */
+  MirLev1_00C0,  /* C8C0..C8FF */
+  MirLev1_00C0,  /* C900..C93F */
+  MirLev1_00C0,  /* C940..C97F */
+  MirLev1_00C0,  /* C980..C9BF */
+  MirLev1_00C0,  /* C9C0..C9FF */
+  MirLev1_00C0,  /* CA00..CA3F */
+  MirLev1_00C0,  /* CA40..CA7F */
+  MirLev1_00C0,  /* CA80..CABF */
+  MirLev1_00C0,  /* CAC0..CAFF */
+  MirLev1_00C0,  /* CB00..CB3F */
+  MirLev1_00C0,  /* CB40..CB7F */
+  MirLev1_00C0,  /* CB80..CBBF */
+  MirLev1_00C0,  /* CBC0..CBFF */
+  MirLev1_00C0,  /* CC00..CC3F */
+  MirLev1_00C0,  /* CC40..CC7F */
+  MirLev1_00C0,  /* CC80..CCBF */
+  MirLev1_00C0,  /* CCC0..CCFF */
+  MirLev1_00C0,  /* CD00..CD3F */
+  MirLev1_00C0,  /* CD40..CD7F */
+  MirLev1_00C0,  /* CD80..CDBF */
+  MirLev1_00C0,  /* CDC0..CDFF */
+  MirLev1_00C0,  /* CE00..CE3F */
+  MirLev1_00C0,  /* CE40..CE7F */
+  MirLev1_00C0,  /* CE80..CEBF */
+  MirLev1_00C0,  /* CEC0..CEFF */
+  MirLev1_00C0,  /* CF00..CF3F */
+  MirLev1_00C0,  /* CF40..CF7F */
+  MirLev1_00C0,  /* CF80..CFBF */
+  MirLev1_00C0,  /* CFC0..CFFF */
+  MirLev1_00C0,  /* D000..D03F */
+  MirLev1_00C0,  /* D040..D07F */
+  MirLev1_00C0,  /* D080..D0BF */
+  MirLev1_00C0,  /* D0C0..D0FF */
+  MirLev1_00C0,  /* D100..D13F */
+  MirLev1_00C0,  /* D140..D17F */
+  MirLev1_00C0,  /* D180..D1BF */
+  MirLev1_00C0,  /* D1C0..D1FF */
+  MirLev1_00C0,  /* D200..D23F */
+  MirLev1_00C0,  /* D240..D27F */
+  MirLev1_00C0,  /* D280..D2BF */
+  MirLev1_00C0,  /* D2C0..D2FF */
+  MirLev1_00C0,  /* D300..D33F */
+  MirLev1_00C0,  /* D340..D37F */
+  MirLev1_00C0,  /* D380..D3BF */
+  MirLev1_00C0,  /* D3C0..D3FF */
+  MirLev1_00C0,  /* D400..D43F */
+  MirLev1_00C0,  /* D440..D47F */
+  MirLev1_00C0,  /* D480..D4BF */
+  MirLev1_00C0,  /* D4C0..D4FF */
+  MirLev1_00C0,  /* D500..D53F */
+  MirLev1_00C0,  /* D540..D57F */
+  MirLev1_00C0,  /* D580..D5BF */
+  MirLev1_00C0,  /* D5C0..D5FF */
+  MirLev1_00C0,  /* D600..D63F */
+  MirLev1_00C0,  /* D640..D67F */
+  MirLev1_00C0,  /* D680..D6BF */
+  MirLev1_00C0,  /* D6C0..D6FF */
+  MirLev1_00C0,  /* D700..D73F */
+  MirLev1_00C0,  /* D740..D77F */
+  MirLev1_00C0,  /* D780..D7BF */
+  MirLev1_00C0,  /* D7C0..D7FF */
+  MirLev1_00C0,  /* D800..D83F */
+  MirLev1_00C0,  /* D840..D87F */
+  MirLev1_00C0,  /* D880..D8BF */
+  MirLev1_00C0,  /* D8C0..D8FF */
+  MirLev1_00C0,  /* D900..D93F */
+  MirLev1_00C0,  /* D940..D97F */
+  MirLev1_00C0,  /* D980..D9BF */
+  MirLev1_00C0,  /* D9C0..D9FF */
+  MirLev1_00C0,  /* DA00..DA3F */
+  MirLev1_00C0,  /* DA40..DA7F */
+  MirLev1_00C0,  /* DA80..DABF */
+  MirLev1_00C0,  /* DAC0..DAFF */
+  MirLev1_00C0,  /* DB00..DB3F */
+  MirLev1_00C0,  /* DB40..DB7F */
+  MirLev1_00C0,  /* DB80..DBBF */
+  MirLev1_00C0,  /* DBC0..DBFF */
+  MirLev1_00C0,  /* DC00..DC3F */
+  MirLev1_00C0,  /* DC40..DC7F */
+  MirLev1_00C0,  /* DC80..DCBF */
+  MirLev1_00C0,  /* DCC0..DCFF */
+  MirLev1_00C0,  /* DD00..DD3F */
+  MirLev1_00C0,  /* DD40..DD7F */
+  MirLev1_00C0,  /* DD80..DDBF */
+  MirLev1_00C0,  /* DDC0..DDFF */
+  MirLev1_00C0,  /* DE00..DE3F */
+  MirLev1_00C0,  /* DE40..DE7F */
+  MirLev1_00C0,  /* DE80..DEBF */
+  MirLev1_00C0,  /* DEC0..DEFF */
+  MirLev1_00C0,  /* DF00..DF3F */
+  MirLev1_00C0,  /* DF40..DF7F */
+  MirLev1_00C0,  /* DF80..DFBF */
+  MirLev1_00C0,  /* DFC0..DFFF */
+  MirLev1_00C0,  /* E000..E03F */
+  MirLev1_00C0,  /* E040..E07F */
+  MirLev1_00C0,  /* E080..E0BF */
+  MirLev1_00C0,  /* E0C0..E0FF */
+  MirLev1_00C0,  /* E100..E13F */
+  MirLev1_00C0,  /* E140..E17F */
+  MirLev1_00C0,  /* E180..E1BF */
+  MirLev1_00C0,  /* E1C0..E1FF */
+  MirLev1_00C0,  /* E200..E23F */
+  MirLev1_00C0,  /* E240..E27F */
+  MirLev1_00C0,  /* E280..E2BF */
+  MirLev1_00C0,  /* E2C0..E2FF */
+  MirLev1_00C0,  /* E300..E33F */
+  MirLev1_00C0,  /* E340..E37F */
+  MirLev1_00C0,  /* E380..E3BF */
+  MirLev1_00C0,  /* E3C0..E3FF */
+  MirLev1_00C0,  /* E400..E43F */
+  MirLev1_00C0,  /* E440..E47F */
+  MirLev1_00C0,  /* E480..E4BF */
+  MirLev1_00C0,  /* E4C0..E4FF */
+  MirLev1_00C0,  /* E500..E53F */
+  MirLev1_00C0,  /* E540..E57F */
+  MirLev1_00C0,  /* E580..E5BF */
+  MirLev1_00C0,  /* E5C0..E5FF */
+  MirLev1_00C0,  /* E600..E63F */
+  MirLev1_00C0,  /* E640..E67F */
+  MirLev1_00C0,  /* E680..E6BF */
+  MirLev1_00C0,  /* E6C0..E6FF */
+  MirLev1_00C0,  /* E700..E73F */
+  MirLev1_00C0,  /* E740..E77F */
+  MirLev1_00C0,  /* E780..E7BF */
+  MirLev1_00C0,  /* E7C0..E7FF */
+  MirLev1_00C0,  /* E800..E83F */
+  MirLev1_00C0,  /* E840..E87F */
+  MirLev1_00C0,  /* E880..E8BF */
+  MirLev1_00C0,  /* E8C0..E8FF */
+  MirLev1_00C0,  /* E900..E93F */
+  MirLev1_00C0,  /* E940..E97F */
+  MirLev1_00C0,  /* E980..E9BF */
+  MirLev1_00C0,  /* E9C0..E9FF */
+  MirLev1_00C0,  /* EA00..EA3F */
+  MirLev1_00C0,  /* EA40..EA7F */
+  MirLev1_00C0,  /* EA80..EABF */
+  MirLev1_00C0,  /* EAC0..EAFF */
+  MirLev1_00C0,  /* EB00..EB3F */
+  MirLev1_00C0,  /* EB40..EB7F */
+  MirLev1_00C0,  /* EB80..EBBF */
+  MirLev1_00C0,  /* EBC0..EBFF */
+  MirLev1_00C0,  /* EC00..EC3F */
+  MirLev1_00C0,  /* EC40..EC7F */
+  MirLev1_00C0,  /* EC80..ECBF */
+  MirLev1_00C0,  /* ECC0..ECFF */
+  MirLev1_00C0,  /* ED00..ED3F */
+  MirLev1_00C0,  /* ED40..ED7F */
+  MirLev1_00C0,  /* ED80..EDBF */
+  MirLev1_00C0,  /* EDC0..EDFF */
+  MirLev1_00C0,  /* EE00..EE3F */
+  MirLev1_00C0,  /* EE40..EE7F */
+  MirLev1_00C0,  /* EE80..EEBF */
+  MirLev1_00C0,  /* EEC0..EEFF */
+  MirLev1_00C0,  /* EF00..EF3F */
+  MirLev1_00C0,  /* EF40..EF7F */
+  MirLev1_00C0,  /* EF80..EFBF */
+  MirLev1_00C0,  /* EFC0..EFFF */
+  MirLev1_00C0,  /* F000..F03F */
+  MirLev1_00C0,  /* F040..F07F */
+  MirLev1_00C0,  /* F080..F0BF */
+  MirLev1_00C0,  /* F0C0..F0FF */
+  MirLev1_00C0,  /* F100..F13F */
+  MirLev1_00C0,  /* F140..F17F */
+  MirLev1_00C0,  /* F180..F1BF */
+  MirLev1_00C0,  /* F1C0..F1FF */
+  MirLev1_00C0,  /* F200..F23F */
+  MirLev1_00C0,  /* F240..F27F */
+  MirLev1_00C0,  /* F280..F2BF */
+  MirLev1_00C0,  /* F2C0..F2FF */
+  MirLev1_00C0,  /* F300..F33F */
+  MirLev1_00C0,  /* F340..F37F */
+  MirLev1_00C0,  /* F380..F3BF */
+  MirLev1_00C0,  /* F3C0..F3FF */
+  MirLev1_00C0,  /* F400..F43F */
+  MirLev1_00C0,  /* F440..F47F */
+  MirLev1_00C0,  /* F480..F4BF */
+  MirLev1_00C0,  /* F4C0..F4FF */
+  MirLev1_00C0,  /* F500..F53F */
+  MirLev1_00C0,  /* F540..F57F */
+  MirLev1_00C0,  /* F580..F5BF */
+  MirLev1_00C0,  /* F5C0..F5FF */
+  MirLev1_00C0,  /* F600..F63F */
+  MirLev1_00C0,  /* F640..F67F */
+  MirLev1_00C0,  /* F680..F6BF */
+  MirLev1_00C0,  /* F6C0..F6FF */
+  MirLev1_00C0,  /* F700..F73F */
+  MirLev1_00C0,  /* F740..F77F */
+  MirLev1_00C0,  /* F780..F7BF */
+  MirLev1_00C0,  /* F7C0..F7FF */
+  MirLev1_00C0,  /* F800..F83F */
+  MirLev1_00C0,  /* F840..F87F */
+  MirLev1_00C0,  /* F880..F8BF */
+  MirLev1_00C0,  /* F8C0..F8FF */
+  MirLev1_00C0,  /* F900..F93F */
+  MirLev1_00C0,  /* F940..F97F */
+  MirLev1_00C0,  /* F980..F9BF */
+  MirLev1_00C0,  /* F9C0..F9FF */
+  MirLev1_00C0,  /* FA00..FA3F */
+  MirLev1_00C0,  /* FA40..FA7F */
+  MirLev1_00C0,  /* FA80..FABF */
+  MirLev1_00C0,  /* FAC0..FAFF */
+  MirLev1_00C0,  /* FB00..FB3F */
+  MirLev1_00C0,  /* FB40..FB7F */
+  MirLev1_00C0,  /* FB80..FBBF */
+  MirLev1_00C0,  /* FBC0..FBFF */
+  MirLev1_00C0,  /* FC00..FC3F */
+  MirLev1_00C0,  /* FC40..FC7F */
+  MirLev1_00C0,  /* FC80..FCBF */
+  MirLev1_00C0,  /* FCC0..FCFF */
+  MirLev1_00C0,  /* FD00..FD3F */
+  MirLev1_00C0,  /* FD40..FD7F */
+  MirLev1_00C0,  /* FD80..FDBF */
+  MirLev1_00C0,  /* FDC0..FDFF */
+  MirLev1_00C0,  /* FE00..FE3F */
+  MirLev1_FE40,  /* FE40..FE7F */
+  MirLev1_00C0,  /* FE80..FEBF */
+  MirLev1_00C0,  /* FEC0..FEFF */
+  MirLev1_FF00,  /* FF00..FF3F */
+  MirLev1_FF40,  /* FF40..FF7F */
+  MirLev1_00C0,  /* FF80..FFBF */
+  MirLev1_00C0,  /* FFC0..FFFF */
+};
+
+/* *INDENT-ON* */
+
+#define FRIBIDI_GET_MIRRORING_DELTA(x) \
+	((x) >= 0x10000 ? 0 :  \
+	MirLev1[((x) & 0x3f) + \
+	MirLev0[((x) >> 6)]])
+
+#undef PACKTAB_UINT8
+#undef PACKTAB_UINT16
+#undef PACKTAB_UINT32
+
+#define FRIBIDI_GET_MIRRORING(x) ((x) + FRIBIDI_GET_MIRRORING_DELTA(x))
+
+/* End of generated mirroring.tab.i */
diff -rupN orginal/scribus/fribidi/NEWS patched/scribus/fribidi/NEWS
--- orginal/scribus/fribidi/NEWS	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/fribidi/NEWS	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,52 @@
+Overview of changes between 0.19.1 and 0.19.2
+=============================================
+* Update to Unicode Character Database 5.1.0
+* Fixed bug in Arabic ligature table (bug #208870)
+* Handle RLM/LRM in CP1255 charset converter. (bug #15328, Artyom)
+
+Overview of changes between 0.10.9 and 0.19.1
+=============================================
+* This is the first release of the fribidi2 module in CVS, mostly
+  developed in 2004 and 2005.
+* Support for Arabic joining/shaping added.
+* API for correct handling of multi-line paragraphs added.
+* Restructured code base.
+* Supposed to be fully API/ABI compatible with 0.10 releases.
+  Please report if it is not.
+
+Overview of changes between 0.10.8 and 0.10.9
+=============================================
+* Minor bugfix.
+
+Overview of changes between 0.10.7 and 0.10.8
+=============================================
+* Update to Unicode Character Database 5.0.0
+
+Overview of changes between 0.10.6 and 0.10.7
+=============================================
+* Nothing really.  Just to fix my mess with 0.10.6 release (that never left
+  the door.)
+
+Overview of changes between 0.10.5 and 0.10.6
+=============================================
+* Fixed type sizes when stdint.h is not available.
+
+Overview of changes between 0.10.4 and 0.10.5
+=============================================
+* Unicode 4.1.0 character database used.
+* Fixed type sizes on 64-bit architectures.
+* We've become GNU FriBidi.  Note capitalization please.
+* We have moved to http://fribidi.org/, hosted on freedesktop.org.
+
+Overview of changes between 0.10.2 and 0.10.4
+=============================================
+* Unicode 3.2 data files used.
+
+Overview of changes between 0.10.1 and 0.10.2
+=============================================
+* Rule L3 of UAX#9 implemented.  Now fribidi implements the whole Unicode
+  BiDi Algorithm.
+* The autogenerated table files now contain much fewer symbols, which reduces
+  the relocation time of the library.
+
+See ChangeLog for more descriptive list of changes.
diff -rupN orginal/scribus/fribidi/README patched/scribus/fribidi/README
--- orginal/scribus/fribidi/README	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/fribidi/README	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,153 @@
+This is GNU FriBidi
+The Free Implementation of the Unicode Bidirectional Algorithm.
+
+Background
+==========
+
+One of the missing links stopping the penetration of free software in Middle
+East is the lack of support for the Arabic and Hebrew alphabets. In order to
+have proper Arabic and Hebrew support, the BiDi algorithm should have been
+implemented. It is our hope that this library will stimulate more free
+software in the Middle Eastern countries.
+
+Audience
+========
+
+It is our hope that this library will stimulate the implementation of Hebrew
+and Arabic in lots of free software. Here is a small list of projects that
+would benefit from the use of the GNU FriBidi library, but of course there are
+many more: Wine, Mozilla, Qt, KDE, lynx, OpenOffice.
+
+GNU FriBidi is already being used in projects like Pango (resulting in GTK+
+and GNOME using GNU FriBidi), AbiWord, MLTerm, MPlayer, and BiCon.
+
+Dependencies
+============
+
+Currently GNU FriBidi does not depend on any other library, but uses Glib if
+available.  It uses GNU Build System for build and installation on POSIX
+systems.
+
+Downloading
+===========
+
+The latest version of GNU FriBidi may be found at:
+
+   http://fribidi.org/
+
+Building
+========
+
+See INSTALL for a description of how to build and install GNU FriBidi.
+
+License
+=========
+
+GNU FriBidi is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public License
+as published by the Free Software Foundation; either version 2.1
+of the License, or (at your option) any later version.
+
+GNU FriBidi is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public License
+along with GNU FriBidi, in a file named COPYING; if not, write to the
+Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+Boston, MA  02111-1307  USA
+
+For licensing issues, contact <license@farsiweb.info>.
+
+Implementation
+==============
+
+The library implements the algorithm described in the "Unicode Standard
+Annex #9, The Bidirectional Algorithm", available at
+http://www.unicode.org/unicode/reports/tr9/. GNU Fribidi has been tested
+exhaustively against the Unicode Reference Code, and to the best of our
+knowledge, it completely conforms to the specification, always producing
+the same result as the Reference Code.
+
+The library uses Unicode (UTF32) entirely. The character properties are
+automatically extracted from the Unicode data files, available from:
+
+	http://www.unicode.org/Public/UNIDATA/
+
+This means that every Unicode character is treated in strict accordance
+with the Unicode specification.
+
+There is a limited support for character set conversion from/to the UTF32
+encoding.  Data in these character sets must be converted into UTF32 before
+the library may be used.  iconv(3) can always do a better job on that, so you
+may find that the character sets conversion code is typically turned off on
+POSIX machines.
+
+The reordering of characters is typically done through the function:
+      
+     fribidi_boolean
+     fribidi_log2vis(/* input */
+		     FriBidiChar *str,
+		     FriBidiStrIndex len,
+		     FriBidiCharType *pbase_dir,
+		     /* output */
+		     FriBidiChar *visual_str,
+		     FriBidiStrIndex *position_L_to_V_list,
+		     FriBidiStrIndex *position_V_to_L_list,
+		     FriBidiLevel    *embedding_level_list
+		     )
+    
+
+where
+     str                    is the Unicode input string
+     len                    is the length of the unicode string
+     pbase_dir              is the input and output base direction. If 
+                            base == FRIBIDI_TYPE_ON then fribidi_log2vis 
+                            calculates the base direction on its own
+                            according to the BiDi algorithm.
+     visual_str             The reordered output unicode string.
+     position_L_to_V_list   Maps the positions in the logical string to 
+                            positions in the visual string.
+     position_V_to_L_list   Maps the positions in the visual string to 
+                            the positions in the logical string.
+     embedding_level_list   Returns the classification of each character. Even
+                            levels indicate LTR characters, and odd levels
+                            indicate RTL characters. The main use of this
+                            list is in interactive applications when the
+                            embedding e.g. level determines cursor display.
+
+In any of the output pointers == NULL, then that information is not 
+calculated.
+
+How it looks like
+=================
+
+Have a look at tests directory, to see some input and outputs, which
+CapRTL charset means that CAPITAL letters are right to left, and digits
+6, 7, 8, 9 are Arabic digits, try 'fribidi --charsetdesc CapRTL' for the
+full description.
+
+Executable
+==========
+
+There is also a command-line utilitity called fribidi that loops over
+the text of a file and performs the BiDi algorithm on each line, also
+used for testing the algorithm. Run fribidi with the --help option to
+learn about usage.  The command-line utility is known to have problems
+with line-breaking and ltov/vtol lists.
+
+Bugs and comments
+=================
+
+Report GNU FriBidi bugs at:
+
+	http://fribidi.org/bug
+
+And send your comments to:
+
+	fribidi@freedesktop.org
+
+
+Behdad Esfahbod
+behdad@gnu.org
diff -rupN orginal/scribus/fribidi/run.h patched/scribus/fribidi/run.h
--- orginal/scribus/fribidi/run.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/fribidi/run.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,157 @@
+/* FriBidi
+ * run.h - text run data type
+ *
+ * $Id: run.h,v 1.9 2006/01/31 03:23:13 behdad Exp $
+ * $Author: behdad $
+ * $Date: 2006/01/31 03:23:13 $
+ * $Revision: 1.9 $
+ * $Source: /cvs/fribidi/fribidi2/lib/run.h,v $
+ *
+ * Authors:
+ *   Behdad Esfahbod, 2001, 2002, 2004
+ *   Dov Grobgeld, 1999, 2000
+ *
+ * Copyright (C) 2004 Sharif FarsiWeb, Inc
+ * Copyright (C) 2001,2002 Behdad Esfahbod
+ * Copyright (C) 1999,2000 Dov Grobgeld
+ * 
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ * 
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library, in a file named COPYING; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA
+ * 
+ * For licensing issues, contact <license@farsiweb.info>.
+ */
+#ifndef _RUN_H
+#define _RUN_H
+
+#include "common.h"
+
+#include <fribidi-common.h>
+
+#include <fribidi-types.h>
+#include <fribidi-bidi-types.h>
+
+#include <fribidi-begindecls.h>
+
+typedef struct _FriBidiRunStruct FriBidiRun;
+
+struct _FriBidiRunStruct
+{
+  FriBidiRun *prev;
+  FriBidiRun *next;
+
+  FriBidiCharType type;
+  FriBidiStrIndex pos, len;
+  FriBidiLevel level;
+};
+
+
+#define new_run FRIBIDI_PRIVATESPACE(new_run)
+FriBidiRun *
+new_run (
+  void
+)
+     FRIBIDI_GNUC_HIDDEN FRIBIDI_GNUC_MALLOC FRIBIDI_GNUC_WARN_UNUSED;
+
+#define free_run FRIBIDI_PRIVATESPACE(free_run)
+     void free_run (
+  FriBidiRun *run
+) FRIBIDI_GNUC_HIDDEN;
+
+#define new_run_list FRIBIDI_PRIVATESPACE(new_run_list)
+     FriBidiRun *new_run_list (
+  void
+)
+     FRIBIDI_GNUC_HIDDEN FRIBIDI_GNUC_MALLOC FRIBIDI_GNUC_WARN_UNUSED;
+
+#define free_run_list FRIBIDI_PRIVATESPACE(free_run_list)
+     void free_run_list (
+  FriBidiRun *run_list
+) FRIBIDI_GNUC_HIDDEN;
+
+#define run_list_encode_bidi_types FRIBIDI_PRIVATESPACE(run_list_encode_bidi_types)
+     FriBidiRun *run_list_encode_bidi_types (
+  const FriBidiCharType *bidi_types,
+  const FriBidiStrIndex len
+)
+     FRIBIDI_GNUC_HIDDEN FRIBIDI_GNUC_WARN_UNUSED;
+
+#define shadow_run_list FRIBIDI_PRIVATESPACE(shadow_run_list)
+     fribidi_boolean shadow_run_list (
+  FriBidiRun *base,
+  FriBidiRun *over,
+  fribidi_boolean preserve_length
+)
+     FRIBIDI_GNUC_HIDDEN FRIBIDI_GNUC_WARN_UNUSED;
+
+
+#define swap(a,b) \
+	FRIBIDI_BEGIN_STMT \
+	void *t; \
+	(t) = (a); \
+	(a) = (b); \
+	(b) = (t); \
+	FRIBIDI_END_STMT
+
+#define merge_lists(a,b) \
+	FRIBIDI_BEGIN_STMT \
+	swap((a)->prev->next, (b)->prev->next); \
+	swap((a)->prev, (b)->prev); \
+	FRIBIDI_END_STMT
+
+#define delete_node(x) \
+	FRIBIDI_BEGIN_STMT \
+	(x)->prev->next = (x)->next; \
+	(x)->next->prev = (x)->prev; \
+	FRIBIDI_END_STMT
+
+#define insert_node_before(x, list) \
+	FRIBIDI_BEGIN_STMT \
+	(x)->prev = (list)->prev; \
+	(list)->prev->next = (x); \
+	(x)->next = (list); \
+	(list)->prev = (x); \
+	FRIBIDI_END_STMT
+
+#define move_node_before(x, list) \
+	FRIBIDI_BEGIN_STMT \
+	if ((x)->prev) { \
+	  delete_node(x); \
+	} \
+	insert_node_before((x), (list)); \
+	FRIBIDI_END_STMT
+
+#define for_run_list(x, list) \
+	for ((x) = (list)->next; (x)->type != FRIBIDI_TYPE_SENTINEL; (x) = (x)->next)
+
+
+#if DEBUG+0
+
+#define fribidi_validate_run_list FRIBIDI_PRIVATESPACE(validate_run_list)
+     void fribidi_validate_run_list (
+  FriBidiRun *run_list		/* input run list */
+) FRIBIDI_GNUC_HIDDEN;
+
+#else /* !DEBUG */
+
+#define fribidi_validate_run_list(run_list) fribidi_assert(run_list)
+
+#endif /* !DEBUG */
+
+#include <fribidi-enddecls.h>
+
+#endif /* !_RUN_H */
+/* Editor directions:
+ * vim:textwidth=78:tabstop=8:shiftwidth=2:autoindent:cindent
+ */
diff -rupN orginal/scribus/fribidi/THANKS patched/scribus/fribidi/THANKS
--- orginal/scribus/fribidi/THANKS	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/fribidi/THANKS	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,30 @@
+Thanks to:
+
+Behnam Esfahbod <behnam@esfahbod.info>
+	* Testing and auditing code.
+
+
+And for the previous versions of FriBidi (pre 2002), thanks to:
+
+
+Tomas Frydrych <tomas@frydrych.uklinux.net>
+	* Contirbuted patches for compiling GNU FriBidi under other OSes.
+
+Dov Grobgeld <dov@imagic.weizmann.ac.il>
+	* Initial author, and maintainer before the 0.9 releases.
+   
+Franck Portaneri
+	* For the Mozilla BiDi languges support document;
+
+Roozbeh Pournader <roozbeh@sharif.edu>
+	* Fixed things here and there.
+
+Pablo Saratxaga <pablo@mandrakesoft.com>  
+	* Contributed several Arabic charset converters.
+
+Owen Tayler <otaylor@redhat.com>
+	* Contributed very important memory leak and speed patches.
+
+Omer Zak <omerz@actcom.co.il>
+	* Contributed several bug fixes, and several considerations for
+	  embedded systems.
diff -rupN orginal/scribus/fribidi/TODO patched/scribus/fribidi/TODO
--- orginal/scribus/fribidi/TODO	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/fribidi/TODO	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,88 @@
+Before release:
+
+* Use gtk-doc?
+
+* Implement fribidi_wcwidth()?
+
+* Port fribidi-main.c to new API.
+
+* help2man.
+
+Implementation issues:
+
+* Add API to get and pass on TypeLink*, to not allocate bidi levels.
+  Something like that.  Also the UTF-8 stuff from pango/mini-fribidi.
+
+* Explore vis2log.
+
+* Clean caprtl2utf8 to do arbitrary charset conversion?
+
+* add --output-charset.
+
+* Update README, etc...
+
+* Mix __attr... with DLLIMPORT?
+
+* Update all files headers/footers.  For c/h files, lib/fribidi-mirroring.[ch]
+  is always the reference.
+
+* In fribidi_main.c reorder after line break.
+
+* Change fribidi-main cmd-line parameters: --mirror --no-mirror...  change the
+  defaults too.
+
+* Add an option to fribidi_main.c to assume two consecutive returns as
+  paragraph separators.
+
+* Add more tests.  For:
+  - Checking that not removing explicit marks in analyze is not changing the
+    output in anyway.
+  - Tests with BN.  Right now ^ is BN in CapRTL scheme.
+  - Test tables.
+
+* indent:  support function attributes and _PARAMS like things.  Also
+  FRIBIDI_BEGIN_DECLS, and LIKELY.
+
+* Cleanup gen.tab/gen-*.c files.
+
+* Override pkgincludedir and append interface version.  Should we go the GNOME
+  parallel install way?
+
+* c2man:  parse Author and Copyright from the whole file.
+
+* Write texinfo documentation.
+
+* Set up gnu.org web pages, and update the entry in Free Software Directory.
+
+* Use gengetopt.
+
+* Add FriBidiEnv functionality at compile time.  Also, ifdef out the memory
+  cleanup stuff if asked to fail on memory allocation failure (xmalloc).  When
+  this is done, FRIBIDI_GNUC_WARN_UNUSEDS can be turned off conditionally.
+
+* Generate HTML and DVI documentation.
+
+* Rewrite fribidi.spec.in
+
+* Add make rules for lib/$(BUILT_SOURCES) to depend on gen.tab/ stuff?
+
+* When called in interactive mode, fribidi cmd-line should greet, write
+  about copyrtight stuff, and shared-libs' version and Unicode version.
+
+* Configure gen.tab/ with host=build to avoid cross-compiling table
+  generators.
+
+* Replace test/run.tests with something better, Makefile foo, etc.
+
+* Clean up README and NEWS, and check all files' headers.  Write
+  gen.tab/README.  Also add UniData license file.
+
+From GNU Coding Standards:
+
+* The distribution should contain a file named `README' which gives the name
+  of the package, and a general description of what it does. It is also good
+  to explain the purpose of each of the first-level subdirectories in the
+  package, if there are any. The `README' file should either state the version
+  number of the package, or refer to where in the package it can be found.
+
+* Add ^L to all sources.
diff -rupN orginal/scribus/harfbuzz/AUTHORS patched/scribus/harfbuzz/AUTHORS
--- orginal/scribus/harfbuzz/AUTHORS	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/AUTHORS	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,6 @@
+David Turner
+Werner Lemberg
+Owen Taylor
+Behdad Esfahbod
+Lars Knoll
+Simon Hausmann
diff -rupN orginal/scribus/harfbuzz/CMakeLists.txt patched/scribus/harfbuzz/CMakeLists.txt
--- orginal/scribus/harfbuzz/CMakeLists.txt	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/CMakeLists.txt	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,41 @@
+INCLUDE_DIRECTORIES(
+${CMAKE_SOURCE_DIR}
+${CMAKE_SOURCE_DIR}/scribus
+${FREETYPE_INCLUDE_DIRS}
+)
+
+SET(SCRIBUS_HARFBUZZ_LIB_SOURCES
+harfbuzz-arabic.c
+harfbuzz-buffer.c
+harfbuzz-dump.c
+harfbuzz-freetype.c
+harfbuzz-gdef.c
+harfbuzz-gpos.c
+harfbuzz-gsub.c
+harfbuzz-hangul.c
+harfbuzz-hebrew.c
+harfbuzz-impl.c
+harfbuzz-khmer.c
+harfbuzz-myanmar.c
+harfbuzz-open.c
+harfbuzz-stream.c
+harfbuzz-thai.c
+harfbuzz-tibetan.c
+harfbuzz-unicode.c
+harfbuzz-unicode-tables.c
+harfbuzz-indic.cpp
+harfbuzz-shaper-all.cpp
+harfbuzz-shaper.cpp
+)
+
+
+SET(SCRIBUS_HARFBUZZ_LIB "scribus_harfbuzz_lib")
+ADD_LIBRARY(${SCRIBUS_HARFBUZZ_LIB} STATIC ${SCRIBUS_HARFBUZZ_LIB_SOURCES})
+# This is a convenience library that for linkage purposes is part of Scribus's
+# main API.
+# SET_TARGET_PROPERTIES(${SCRIBUS_HARFBUZZ_LIB}
+# PROPERTIES
+# COMPILE_FLAGS -DCOMPILE_SCRIBUS_MAIN_APP
+# )
+
+
diff -rupN orginal/scribus/harfbuzz/config.h patched/scribus/harfbuzz/config.h
--- orginal/scribus/harfbuzz/config.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/config.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,63 @@
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define HAVE_DLFCN_H 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to the sub-directory in which libtool stores uninstalled libraries.
+   */
+#define LT_OBJDIR ".libs/"
+
+/* Name of package */
+#define PACKAGE "harfbuzz"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT ""
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME ""
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING ""
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME ""
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL ""
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION ""
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Version number of package */
+#define VERSION "0.1"
diff -rupN orginal/scribus/harfbuzz/COPYING patched/scribus/harfbuzz/COPYING
--- orginal/scribus/harfbuzz/COPYING	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/COPYING	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,24 @@
+HarfBuzz was previously licensed under different licenses.  This was
+changed in January 2008.  If you need to relicense your old copies,
+consult the announcement of the license change on the internet.
+Other than that, each copy of HarfBuzz is licensed under the COPYING
+file included with it.  The actual license follows:
+
+
+Permission is hereby granted, without written agreement and without
+license or royalty fees, to use, copy, modify, and distribute this
+software and its documentation for any purpose, provided that the
+above copyright notice and the following two paragraphs appear in
+all copies of this software.
+
+IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+DAMAGE.
+
+THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
diff -rupN orginal/scribus/harfbuzz/harfbuzz-arabic.c patched/scribus/harfbuzz/harfbuzz-arabic.c
--- orginal/scribus/harfbuzz/harfbuzz-arabic.c	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/harfbuzz-arabic.c	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,1144 @@
+/*
+ * Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies)
+ *
+ * This is part of HarfBuzz, an OpenType Layout engine library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ */
+
+#include "harfbuzz-shaper.h"
+#include "harfbuzz-shaper-private.h"
+
+#include <assert.h>
+
+static const HB_UChar16 ReplacementCharacter = 0xfffd;
+
+typedef struct {
+    unsigned char shape;
+    unsigned char justification;
+} HB_ArabicProperties;
+
+typedef enum {
+    XIsolated,
+    XFinal,
+    XInitial,
+    XMedial,
+    /* intermediate state */
+    XCausing
+} ArabicShape;
+
+/*
+// these groups correspond to the groups defined in the Unicode standard.
+// Some of these groups are equal with regards to both joining and line breaking behaviour,
+// and thus have the same enum value
+//
+// I'm not sure the mapping of syriac to arabic enums is correct with regards to justification, but as
+// I couldn't find any better document I'll hope for the best.
+*/
+typedef enum {
+    /* NonJoining */
+    ArabicNone,
+    ArabicSpace,
+    /* Transparent */
+    Transparent,
+    /* Causing */
+    Center,
+    Kashida,
+
+    /* Arabic */
+    /* Dual */
+    Beh,
+    Noon,
+    Meem = Noon,
+    Heh = Noon,
+    KnottedHeh = Noon,
+    HehGoal = Noon,
+    SwashKaf = Noon,
+    Yeh,
+    Hah,
+    Seen,
+    Sad = Seen,
+    Tah,
+    Kaf = Tah,
+    Gaf = Tah,
+    Lam = Tah,
+    Ain,
+    Feh = Ain,
+    Qaf = Ain,
+    /* Right */
+    Alef,
+    Waw,
+    Dal,
+    TehMarbuta = Dal,
+    Reh,
+    HamzaOnHehGoal,
+    YehWithTail = HamzaOnHehGoal,
+    YehBarre = HamzaOnHehGoal,
+
+    /* Syriac */
+    /* Dual */
+    Beth = Beh,
+    Gamal = Ain,
+    Heth = Noon,
+    Teth = Hah,
+    Yudh = Noon,
+    Kaph = Noon,
+    Lamadh = Lam,
+    Mim = Noon,
+    Nun = Noon,
+    Semakh = Noon,
+    FinalSemakh = Noon,
+    SyriacE = Ain,
+    Pe = Ain,
+    ReversedPe = Hah,
+    Qaph = Noon,
+    Shin = Noon,
+    Fe = Ain,
+
+    /* Right */
+    Alaph = Alef,
+    Dalath = Dal,
+    He = Dal,
+    SyriacWaw = Waw,
+    Zain = Alef,
+    YudhHe = Waw,
+    Sadhe = HamzaOnHehGoal,
+    Taw = Dal,
+
+    /* Compiler bug? Otherwise ArabicGroupsEnd would be equal to Dal + 1. */
+    Dummy = HamzaOnHehGoal,
+    ArabicGroupsEnd
+} ArabicGroup;
+
+static const unsigned char arabic_group[0x150] = {
+    ArabicNone, ArabicNone, ArabicNone, ArabicNone,
+    ArabicNone, ArabicNone, ArabicNone, ArabicNone,
+    ArabicNone, ArabicNone, ArabicNone, ArabicNone,
+    ArabicNone, ArabicNone, ArabicNone, ArabicNone,
+
+    Transparent, Transparent, Transparent, Transparent,
+    Transparent, Transparent, ArabicNone, ArabicNone,
+    ArabicNone, ArabicNone, ArabicNone, ArabicNone,
+    ArabicNone, ArabicNone, ArabicNone, ArabicNone,
+
+    ArabicNone, ArabicNone, Alef, Alef,
+    Waw, Alef, Yeh, Alef,
+    Beh, TehMarbuta, Beh, Beh,
+    Hah, Hah, Hah, Dal,
+
+    Dal, Reh, Reh, Seen,
+    Seen, Sad, Sad, Tah,
+    Tah, Ain, Ain, ArabicNone,
+    ArabicNone, ArabicNone, ArabicNone, ArabicNone,
+
+    /* 0x640 */
+    Kashida, Feh, Qaf, Kaf,
+    Lam, Meem, Noon, Heh,
+    Waw, Yeh, Yeh, Transparent,
+    Transparent, Transparent, Transparent, Transparent,
+
+    Transparent, Transparent, Transparent, Transparent,
+    Transparent, Transparent, Transparent, Transparent,
+    Transparent, ArabicNone, ArabicNone, ArabicNone,
+    ArabicNone, ArabicNone, ArabicNone, ArabicNone,
+
+    ArabicNone, ArabicNone, ArabicNone, ArabicNone,
+    ArabicNone, ArabicNone, ArabicNone, ArabicNone,
+    ArabicNone, ArabicNone, ArabicNone, ArabicNone,
+    ArabicNone, ArabicNone, Beh, Qaf,
+
+    Transparent, Alef, Alef, Alef,
+    ArabicNone, Alef, Waw, Waw,
+    Yeh, Beh, Beh, Beh,
+    Beh, Beh, Beh, Beh,
+
+    /* 0x680 */
+    Beh, Hah, Hah, Hah,
+    Hah, Hah, Hah, Hah,
+    Dal, Dal, Dal, Dal,
+    Dal, Dal, Dal, Dal,
+
+    Dal, Reh, Reh, Reh,
+    Reh, Reh, Reh, Reh,
+    Reh, Reh, Seen, Seen,
+    Seen, Sad, Sad, Tah,
+
+    Ain, Feh, Feh, Feh,
+    Feh, Feh, Feh, Qaf,
+    Qaf, Gaf, SwashKaf, Gaf,
+    Kaf, Kaf, Kaf, Gaf,
+
+    Gaf, Gaf, Gaf, Gaf,
+    Gaf, Lam, Lam, Lam,
+    Lam, Noon, Noon, Noon,
+    Noon, Noon, KnottedHeh, Hah,
+
+    /* 0x6c0 */
+    TehMarbuta, HehGoal, HamzaOnHehGoal, HamzaOnHehGoal,
+    Waw, Waw, Waw, Waw,
+    Waw, Waw, Waw, Waw,
+    Yeh, YehWithTail, Yeh, Waw,
+
+    Yeh, Yeh, YehBarre, YehBarre,
+    ArabicNone, TehMarbuta, Transparent, Transparent,
+    Transparent, Transparent, Transparent, Transparent,
+    Transparent, ArabicNone, ArabicNone, Transparent,
+
+    Transparent, Transparent, Transparent, Transparent,
+    Transparent, ArabicNone, ArabicNone, Transparent,
+    Transparent, ArabicNone, Transparent, Transparent,
+    Transparent, Transparent, Dal, Reh,
+
+    ArabicNone, ArabicNone, ArabicNone, ArabicNone,
+    ArabicNone, ArabicNone, ArabicNone, ArabicNone,
+    ArabicNone, ArabicNone, Seen, Sad,
+    Ain, ArabicNone, ArabicNone, KnottedHeh,
+
+    /* 0x700 */
+    ArabicNone, ArabicNone, ArabicNone, ArabicNone,
+    ArabicNone, ArabicNone, ArabicNone, ArabicNone,
+    ArabicNone, ArabicNone, ArabicNone, ArabicNone,
+    ArabicNone, ArabicNone, ArabicNone, ArabicNone,
+
+    Alaph, Transparent, Beth, Gamal,
+    Gamal, Dalath, Dalath, He,
+    SyriacWaw, Zain, Heth, Teth,
+    Teth, Yudh, YudhHe, Kaph,
+
+    Lamadh, Mim, Nun, Semakh,
+    FinalSemakh, SyriacE, Pe, ReversedPe,
+    Sadhe, Qaph, Dalath, Shin,
+    Taw, Beth, Gamal, Dalath,
+
+    Transparent, Transparent, Transparent, Transparent,
+    Transparent, Transparent, Transparent, Transparent,
+    Transparent, Transparent, Transparent, Transparent,
+    Transparent, Transparent, Transparent, Transparent,
+
+    Transparent, Transparent, Transparent, Transparent,
+    Transparent, Transparent, Transparent, Transparent,
+    Transparent, Transparent, Transparent, ArabicNone,
+    ArabicNone, Zain, Kaph, Fe,
+};
+
+static ArabicGroup arabicGroup(unsigned short uc)
+{
+    if (uc >= 0x0600 && uc < 0x750)
+        return (ArabicGroup) arabic_group[uc-0x600];
+    else if (uc == 0x200d)
+        return Center;
+    else if (HB_GetUnicodeCharCategory(uc) == HB_Separator_Space)
+        return ArabicSpace;
+    else
+        return ArabicNone;
+}
+
+
+/*
+   Arabic shaping obeys a number of rules according to the joining classes (see Unicode book, section on
+   arabic).
+
+   Each unicode char has a joining class (right, dual (left&right), center (joincausing) or transparent).
+   transparent joining is not encoded in HB_UChar16::joining(), but applies to all combining marks and format marks.
+
+   Right join-causing: dual + center
+   Left join-causing: dual + right + center
+
+   Rules are as follows (for a string already in visual order, as we have it here):
+
+   R1 Transparent characters do not affect joining behaviour.
+   R2 A right joining character, that has a right join-causing char on the right will get form XRight
+   (R3 A left joining character, that has a left join-causing char on the left will get form XLeft)
+   Note: the above rule is meaningless, as there are no pure left joining characters defined in Unicode
+   R4 A dual joining character, that has a left join-causing char on the left and a right join-causing char on
+             the right will get form XMedial
+   R5  A dual joining character, that has a right join causing char on the right, and no left join causing char on the left
+         will get form XRight
+   R6 A dual joining character, that has a  left join causing char on the left, and no right join causing char on the right
+         will get form XLeft
+   R7 Otherwise the character will get form XIsolated
+
+   Additionally we have to do the minimal ligature support for lam-alef ligatures:
+
+   L1 Transparent characters do not affect ligature behaviour.
+   L2 Any sequence of Alef(XRight) + Lam(XMedial) will form the ligature Alef.Lam(XLeft)
+   L3 Any sequence of Alef(XRight) + Lam(XLeft) will form the ligature Alef.Lam(XIsolated)
+
+   The state table below handles rules R1-R7.
+*/
+
+typedef enum {
+    JNone,
+    JCausing,
+    JDual,
+    JRight,
+    JTransparent
+} Joining;
+
+static const Joining joining_for_group[ArabicGroupsEnd] = {
+    /* NonJoining */
+    JNone, /* ArabicNone */
+    JNone, /* ArabicSpace */
+    /* Transparent */
+    JTransparent, /* Transparent */
+    /* Causing */
+    JCausing, /* Center */
+    JCausing, /* Kashida */
+    /* Dual */
+    JDual, /* Beh */
+    JDual, /* Noon */
+    JDual, /* Yeh */
+    JDual, /* Hah */
+    JDual, /* Seen */
+    JDual, /* Tah */
+    JDual, /* Ain */
+    /* Right */
+    JRight, /* Alef */
+    JRight, /* Waw */
+    JRight, /* Dal */
+    JRight, /* Reh */
+    JRight  /* HamzaOnHehGoal */
+};
+
+
+typedef struct {
+    ArabicShape form1;
+    ArabicShape form2;
+} JoiningPair;
+
+static const JoiningPair joining_table[5][4] =
+/* None, Causing, Dual, Right */
+{
+    { { XIsolated, XIsolated }, { XIsolated, XCausing }, { XIsolated, XInitial }, { XIsolated, XIsolated } }, /* XIsolated */
+    { { XFinal, XIsolated }, { XFinal, XCausing }, { XFinal, XInitial }, { XFinal, XIsolated } }, /* XFinal */
+    { { XIsolated, XIsolated }, { XInitial, XCausing }, { XInitial, XMedial }, { XInitial, XFinal } }, /* XInitial */
+    { { XFinal, XIsolated }, { XMedial, XCausing }, { XMedial, XMedial }, { XMedial, XFinal } }, /* XMedial */
+    { { XIsolated, XIsolated }, { XIsolated, XCausing }, { XIsolated, XMedial }, { XIsolated, XFinal } }, /* XCausing */
+};
+
+
+/*
+According to http://www.microsoft.com/middleeast/Arabicdev/IE6/KBase.asp
+
+1. Find the priority of the connecting opportunities in each word
+2. Add expansion at the highest priority connection opportunity
+3. If more than one connection opportunity have the same highest value,
+   use the opportunity closest to the end of the word.
+
+Following is a chart that provides the priority for connection
+opportunities and where expansion occurs. The character group names
+are those in table 6.6 of the UNICODE 2.0 book.
+
+
+PrioritY        Glyph                   Condition                                       Kashida Location
+
+Arabic_Kashida        User inserted Kashida   The user entered a Kashida in a position.       After the user
+                (Shift+j or Shift+[E with hat])    Thus, it is the highest priority to insert an   inserted kashida
+                                        automatic kashida.
+
+Arabic_Seen        Seen, Sad               Connecting to the next character.               After the character.
+                                        (Initial or medial form).
+
+Arabic_HaaDal        Teh Marbutah, Haa, Dal  Connecting to previous character.               Before the final form
+                                                                                        of these characters.
+
+Arabic_Alef     Alef, Tah, Lam,         Connecting to previous character.               Before the final form
+                Kaf and Gaf                                                             of these characters.
+
+Arabic_BaRa     Reh, Yeh                Connected to medial Beh                         Before preceding medial Baa
+
+Arabic_Waw        Waw, Ain, Qaf, Feh      Connecting to previous character.               Before the final form of
+                                                                                        these characters.
+
+Arabic_Normal   Other connecting        Connecting to previous character.               Before the final form
+                characters                                                              of these characters.
+
+
+
+This seems to imply that we have at most one kashida point per arabic word.
+
+*/
+
+static void getArabicProperties(const unsigned short *chars, int len, HB_ArabicProperties *properties)
+{
+/*     qDebug("arabicSyriacOpenTypeShape: properties:"); */
+    int lastPos = 0;
+    int lastGroup = ArabicNone;
+    int i = 0;
+
+    ArabicGroup group = arabicGroup(chars[0]);
+    Joining j = joining_for_group[group];
+    ArabicShape shape = joining_table[XIsolated][j].form2;
+    properties[0].justification = HB_NoJustification;
+
+    for (i = 1; i < len; ++i) {
+        /* #### fix handling for spaces and punktuation */
+        properties[i].justification = HB_NoJustification;
+
+        group = arabicGroup(chars[i]);
+        j = joining_for_group[group];
+
+        if (j == JTransparent) {
+            properties[i].shape = XIsolated;
+            continue;
+        }
+
+        properties[lastPos].shape = joining_table[shape][j].form1;
+        shape = joining_table[shape][j].form2;
+
+        switch(lastGroup) {
+        case Seen:
+            if (properties[lastPos].shape == XInitial || properties[lastPos].shape == XMedial)
+                properties[i-1].justification = HB_Arabic_Seen;
+            break;
+        case Hah:
+            if (properties[lastPos].shape == XFinal)
+                properties[lastPos-1].justification = HB_Arabic_HaaDal;
+            break;
+        case Alef:
+            if (properties[lastPos].shape == XFinal)
+                properties[lastPos-1].justification = HB_Arabic_Alef;
+            break;
+        case Ain:
+            if (properties[lastPos].shape == XFinal)
+                properties[lastPos-1].justification = HB_Arabic_Waw;
+            break;
+        case Noon:
+            if (properties[lastPos].shape == XFinal)
+                properties[lastPos-1].justification = HB_Arabic_Normal;
+            break;
+        case ArabicNone:
+            break;
+
+        default:
+            assert(FALSE);
+        }
+
+        lastGroup = ArabicNone;
+
+        switch(group) {
+        case ArabicNone:
+        case Transparent:
+        /* ### Center should probably be treated as transparent when it comes to justification. */
+        case Center:
+            break;
+        case ArabicSpace:
+            properties[i].justification = HB_Arabic_Space;
+            break;
+        case Kashida:
+            properties[i].justification = HB_Arabic_Kashida;
+            break;
+        case Seen:
+            lastGroup = Seen;
+            break;
+
+        case Hah:
+        case Dal:
+            lastGroup = Hah;
+            break;
+
+        case Alef:
+        case Tah:
+            lastGroup = Alef;
+            break;
+
+        case Yeh:
+        case Reh:
+            if (properties[lastPos].shape == XMedial && arabicGroup(chars[lastPos]) == Beh)
+                properties[lastPos-1].justification = HB_Arabic_BaRa;
+            break;
+
+        case Ain:
+        case Waw:
+            lastGroup = Ain;
+            break;
+
+        case Noon:
+        case Beh:
+        case HamzaOnHehGoal:
+            lastGroup = Noon;
+            break;
+        case ArabicGroupsEnd:
+            assert(FALSE);
+        }
+
+        lastPos = i;
+    }
+    properties[lastPos].shape = joining_table[shape][JNone].form1;
+
+
+    /*
+     for (int i = 0; i < len; ++i)
+         qDebug("arabic properties(%d): uc=%x shape=%d, justification=%d", i, chars[i], properties[i].shape, properties[i].justification);
+    */
+}
+
+static Joining getNkoJoining(unsigned short uc)
+{
+    if (uc < 0x7ca)
+        return JNone;
+    if (uc <= 0x7ea)
+        return JDual;
+    if (uc <= 0x7f3)
+        return JTransparent;
+    if (uc <= 0x7f9)
+        return JNone;
+    if (uc == 0x7fa)
+        return JCausing;
+    return JNone;
+}
+
+static void getNkoProperties(const unsigned short *chars, int len, HB_ArabicProperties *properties)
+{
+    int lastPos = 0;
+    int i = 0;
+
+    Joining j = getNkoJoining(chars[0]);
+    ArabicShape shape = joining_table[XIsolated][j].form2;
+    properties[0].justification = HB_NoJustification;
+
+    for (i = 1; i < len; ++i) {
+        properties[i].justification = (HB_GetUnicodeCharCategory(chars[i]) == HB_Separator_Space) ?
+                                      ArabicSpace : ArabicNone;
+
+        j = getNkoJoining(chars[i]);
+
+        if (j == JTransparent) {
+            properties[i].shape = XIsolated;
+            continue;
+        }
+
+        properties[lastPos].shape = joining_table[shape][j].form1;
+        shape = joining_table[shape][j].form2;
+
+
+        lastPos = i;
+    }
+    properties[lastPos].shape = joining_table[shape][JNone].form1;
+
+
+    /*
+     for (int i = 0; i < len; ++i)
+         qDebug("nko properties(%d): uc=%x shape=%d, justification=%d", i, chars[i], properties[i].shape, properties[i].justification);
+    */
+}
+
+/*
+// The unicode to unicode shaping codec.
+// does only presentation forms B at the moment, but that should be enough for
+// simple display
+*/
+static const hb_uint16 arabicUnicodeMapping[256][2] = {
+    /* base of shaped forms, and number-1 of them (0 for non shaping,
+       1 for right binding and 3 for dual binding */
+
+    /* These are just the glyphs available in Unicode,
+       some characters are in R class, but have no glyphs in Unicode. */
+
+    { 0x0600, 0 }, /* 0x0600 */
+    { 0x0601, 0 }, /* 0x0601 */
+    { 0x0602, 0 }, /* 0x0602 */
+    { 0x0603, 0 }, /* 0x0603 */
+    { 0x0604, 0 }, /* 0x0604 */
+    { 0x0605, 0 }, /* 0x0605 */
+    { 0x0606, 0 }, /* 0x0606 */
+    { 0x0607, 0 }, /* 0x0607 */
+    { 0x0608, 0 }, /* 0x0608 */
+    { 0x0609, 0 }, /* 0x0609 */
+    { 0x060A, 0 }, /* 0x060A */
+    { 0x060B, 0 }, /* 0x060B */
+    { 0x060C, 0 }, /* 0x060C */
+    { 0x060D, 0 }, /* 0x060D */
+    { 0x060E, 0 }, /* 0x060E */
+    { 0x060F, 0 }, /* 0x060F */
+
+    { 0x0610, 0 }, /* 0x0610 */
+    { 0x0611, 0 }, /* 0x0611 */
+    { 0x0612, 0 }, /* 0x0612 */
+    { 0x0613, 0 }, /* 0x0613 */
+    { 0x0614, 0 }, /* 0x0614 */
+    { 0x0615, 0 }, /* 0x0615 */
+    { 0x0616, 0 }, /* 0x0616 */
+    { 0x0617, 0 }, /* 0x0617 */
+    { 0x0618, 0 }, /* 0x0618 */
+    { 0x0619, 0 }, /* 0x0619 */
+    { 0x061A, 0 }, /* 0x061A */
+    { 0x061B, 0 }, /* 0x061B */
+    { 0x061C, 0 }, /* 0x061C */
+    { 0x061D, 0 }, /* 0x061D */
+    { 0x061E, 0 }, /* 0x061E */
+    { 0x061F, 0 }, /* 0x061F */
+
+    { 0x0620, 0 }, /* 0x0620 */
+    { 0xFE80, 0 }, /* 0x0621            HAMZA */
+    { 0xFE81, 1 }, /* 0x0622    R       ALEF WITH MADDA ABOVE */
+    { 0xFE83, 1 }, /* 0x0623    R       ALEF WITH HAMZA ABOVE */
+    { 0xFE85, 1 }, /* 0x0624    R       WAW WITH HAMZA ABOVE */
+    { 0xFE87, 1 }, /* 0x0625    R       ALEF WITH HAMZA BELOW */
+    { 0xFE89, 3 }, /* 0x0626    D       YEH WITH HAMZA ABOVE */
+    { 0xFE8D, 1 }, /* 0x0627    R       ALEF */
+    { 0xFE8F, 3 }, /* 0x0628    D       BEH */
+    { 0xFE93, 1 }, /* 0x0629    R       TEH MARBUTA */
+    { 0xFE95, 3 }, /* 0x062A    D       TEH */
+    { 0xFE99, 3 }, /* 0x062B    D       THEH */
+    { 0xFE9D, 3 }, /* 0x062C    D       JEEM */
+    { 0xFEA1, 3 }, /* 0x062D    D       HAH */
+    { 0xFEA5, 3 }, /* 0x062E    D       KHAH */
+    { 0xFEA9, 1 }, /* 0x062F    R       DAL */
+
+    { 0xFEAB, 1 }, /* 0x0630    R       THAL */
+    { 0xFEAD, 1 }, /* 0x0631    R       REH */
+    { 0xFEAF, 1 }, /* 0x0632    R       ZAIN */
+    { 0xFEB1, 3 }, /* 0x0633    D       SEEN */
+    { 0xFEB5, 3 }, /* 0x0634    D       SHEEN */
+    { 0xFEB9, 3 }, /* 0x0635    D       SAD */
+    { 0xFEBD, 3 }, /* 0x0636    D       DAD */
+    { 0xFEC1, 3 }, /* 0x0637    D       TAH */
+    { 0xFEC5, 3 }, /* 0x0638    D       ZAH */
+    { 0xFEC9, 3 }, /* 0x0639    D       AIN */
+    { 0xFECD, 3 }, /* 0x063A    D       GHAIN */
+    { 0x063B, 0 }, /* 0x063B */
+    { 0x063C, 0 }, /* 0x063C */
+    { 0x063D, 0 }, /* 0x063D */
+    { 0x063E, 0 }, /* 0x063E */
+    { 0x063F, 0 }, /* 0x063F */
+
+    { 0x0640, 0 }, /* 0x0640    C       TATWEEL // ### Join Causing, only one glyph */
+    { 0xFED1, 3 }, /* 0x0641    D       FEH */
+    { 0xFED5, 3 }, /* 0x0642    D       QAF */
+    { 0xFED9, 3 }, /* 0x0643    D       KAF */
+    { 0xFEDD, 3 }, /* 0x0644    D       LAM */
+    { 0xFEE1, 3 }, /* 0x0645    D       MEEM */
+    { 0xFEE5, 3 }, /* 0x0646    D       NOON */
+    { 0xFEE9, 3 }, /* 0x0647    D       HEH */
+    { 0xFEED, 1 }, /* 0x0648    R       WAW */
+    { 0x0649, 3 }, /* 0x0649            ALEF MAKSURA // ### Dual, glyphs not consecutive, handle in code. */
+    { 0xFEF1, 3 }, /* 0x064A    D       YEH */
+    { 0x064B, 0 }, /* 0x064B */
+    { 0x064C, 0 }, /* 0x064C */
+    { 0x064D, 0 }, /* 0x064D */
+    { 0x064E, 0 }, /* 0x064E */
+    { 0x064F, 0 }, /* 0x064F */
+
+    { 0x0650, 0 }, /* 0x0650 */
+    { 0x0651, 0 }, /* 0x0651 */
+    { 0x0652, 0 }, /* 0x0652 */
+    { 0x0653, 0 }, /* 0x0653 */
+    { 0x0654, 0 }, /* 0x0654 */
+    { 0x0655, 0 }, /* 0x0655 */
+    { 0x0656, 0 }, /* 0x0656 */
+    { 0x0657, 0 }, /* 0x0657 */
+    { 0x0658, 0 }, /* 0x0658 */
+    { 0x0659, 0 }, /* 0x0659 */
+    { 0x065A, 0 }, /* 0x065A */
+    { 0x065B, 0 }, /* 0x065B */
+    { 0x065C, 0 }, /* 0x065C */
+    { 0x065D, 0 }, /* 0x065D */
+    { 0x065E, 0 }, /* 0x065E */
+    { 0x065F, 0 }, /* 0x065F */
+
+    { 0x0660, 0 }, /* 0x0660 */
+    { 0x0661, 0 }, /* 0x0661 */
+    { 0x0662, 0 }, /* 0x0662 */
+    { 0x0663, 0 }, /* 0x0663 */
+    { 0x0664, 0 }, /* 0x0664 */
+    { 0x0665, 0 }, /* 0x0665 */
+    { 0x0666, 0 }, /* 0x0666 */
+    { 0x0667, 0 }, /* 0x0667 */
+    { 0x0668, 0 }, /* 0x0668 */
+    { 0x0669, 0 }, /* 0x0669 */
+    { 0x066A, 0 }, /* 0x066A */
+    { 0x066B, 0 }, /* 0x066B */
+    { 0x066C, 0 }, /* 0x066C */
+    { 0x066D, 0 }, /* 0x066D */
+    { 0x066E, 0 }, /* 0x066E */
+    { 0x066F, 0 }, /* 0x066F */
+
+    { 0x0670, 0 }, /* 0x0670 */
+    { 0xFB50, 1 }, /* 0x0671    R       ALEF WASLA */
+    { 0x0672, 0 }, /* 0x0672 */
+    { 0x0673, 0 }, /* 0x0673 */
+    { 0x0674, 0 }, /* 0x0674 */
+    { 0x0675, 0 }, /* 0x0675 */
+    { 0x0676, 0 }, /* 0x0676 */
+    { 0x0677, 0 }, /* 0x0677 */
+    { 0x0678, 0 }, /* 0x0678 */
+    { 0xFB66, 3 }, /* 0x0679    D       TTEH */
+    { 0xFB5E, 3 }, /* 0x067A    D       TTEHEH */
+    { 0xFB52, 3 }, /* 0x067B    D       BEEH */
+    { 0x067C, 0 }, /* 0x067C */
+    { 0x067D, 0 }, /* 0x067D */
+    { 0xFB56, 3 }, /* 0x067E    D       PEH */
+    { 0xFB62, 3 }, /* 0x067F    D       TEHEH */
+
+    { 0xFB5A, 3 }, /* 0x0680    D       BEHEH */
+    { 0x0681, 0 }, /* 0x0681 */
+    { 0x0682, 0 }, /* 0x0682 */
+    { 0xFB76, 3 }, /* 0x0683    D       NYEH */
+    { 0xFB72, 3 }, /* 0x0684    D       DYEH */
+    { 0x0685, 0 }, /* 0x0685 */
+    { 0xFB7A, 3 }, /* 0x0686    D       TCHEH */
+    { 0xFB7E, 3 }, /* 0x0687    D       TCHEHEH */
+    { 0xFB88, 1 }, /* 0x0688    R       DDAL */
+    { 0x0689, 0 }, /* 0x0689 */
+    { 0x068A, 0 }, /* 0x068A */
+    { 0x068B, 0 }, /* 0x068B */
+    { 0xFB84, 1 }, /* 0x068C    R       DAHAL */
+    { 0xFB82, 1 }, /* 0x068D    R       DDAHAL */
+    { 0xFB86, 1 }, /* 0x068E    R       DUL */
+    { 0x068F, 0 }, /* 0x068F */
+
+    { 0x0690, 0 }, /* 0x0690 */
+    { 0xFB8C, 1 }, /* 0x0691    R       RREH */
+    { 0x0692, 0 }, /* 0x0692 */
+    { 0x0693, 0 }, /* 0x0693 */
+    { 0x0694, 0 }, /* 0x0694 */
+    { 0x0695, 0 }, /* 0x0695 */
+    { 0x0696, 0 }, /* 0x0696 */
+    { 0x0697, 0 }, /* 0x0697 */
+    { 0xFB8A, 1 }, /* 0x0698    R       JEH */
+    { 0x0699, 0 }, /* 0x0699 */
+    { 0x069A, 0 }, /* 0x069A */
+    { 0x069B, 0 }, /* 0x069B */
+    { 0x069C, 0 }, /* 0x069C */
+    { 0x069D, 0 }, /* 0x069D */
+    { 0x069E, 0 }, /* 0x069E */
+    { 0x069F, 0 }, /* 0x069F */
+
+    { 0x06A0, 0 }, /* 0x06A0 */
+    { 0x06A1, 0 }, /* 0x06A1 */
+    { 0x06A2, 0 }, /* 0x06A2 */
+    { 0x06A3, 0 }, /* 0x06A3 */
+    { 0xFB6A, 3 }, /* 0x06A4    D       VEH */
+    { 0x06A5, 0 }, /* 0x06A5 */
+    { 0xFB6E, 3 }, /* 0x06A6    D       PEHEH */
+    { 0x06A7, 0 }, /* 0x06A7 */
+    { 0x06A8, 0 }, /* 0x06A8 */
+    { 0xFB8E, 3 }, /* 0x06A9    D       KEHEH */
+    { 0x06AA, 0 }, /* 0x06AA */
+    { 0x06AB, 0 }, /* 0x06AB */
+    { 0x06AC, 0 }, /* 0x06AC */
+    { 0xFBD3, 3 }, /* 0x06AD    D       NG */
+    { 0x06AE, 0 }, /* 0x06AE */
+    { 0xFB92, 3 }, /* 0x06AF    D       GAF */
+
+    { 0x06B0, 0 }, /* 0x06B0 */
+    { 0xFB9A, 3 }, /* 0x06B1    D       NGOEH */
+    { 0x06B2, 0 }, /* 0x06B2 */
+    { 0xFB96, 3 }, /* 0x06B3    D       GUEH */
+    { 0x06B4, 0 }, /* 0x06B4 */
+    { 0x06B5, 0 }, /* 0x06B5 */
+    { 0x06B6, 0 }, /* 0x06B6 */
+    { 0x06B7, 0 }, /* 0x06B7 */
+    { 0x06B8, 0 }, /* 0x06B8 */
+    { 0x06B9, 0 }, /* 0x06B9 */
+    { 0xFB9E, 1 }, /* 0x06BA    R       NOON GHUNNA */
+    { 0xFBA0, 3 }, /* 0x06BB    D       RNOON */
+    { 0x06BC, 0 }, /* 0x06BC */
+    { 0x06BD, 0 }, /* 0x06BD */
+    { 0xFBAA, 3 }, /* 0x06BE    D       HEH DOACHASHMEE */
+    { 0x06BF, 0 }, /* 0x06BF */
+
+    { 0xFBA4, 1 }, /* 0x06C0    R       HEH WITH YEH ABOVE */
+    { 0xFBA6, 3 }, /* 0x06C1    D       HEH GOAL */
+    { 0x06C2, 0 }, /* 0x06C2 */
+    { 0x06C3, 0 }, /* 0x06C3 */
+    { 0x06C4, 0 }, /* 0x06C4 */
+    { 0xFBE0, 1 }, /* 0x06C5    R       KIRGHIZ OE */
+    { 0xFBD9, 1 }, /* 0x06C6    R       OE */
+    { 0xFBD7, 1 }, /* 0x06C7    R       U */
+    { 0xFBDB, 1 }, /* 0x06C8    R       YU */
+    { 0xFBE2, 1 }, /* 0x06C9    R       KIRGHIZ YU */
+    { 0x06CA, 0 }, /* 0x06CA */
+    { 0xFBDE, 1 }, /* 0x06CB    R       VE */
+    { 0xFBFC, 3 }, /* 0x06CC    D       FARSI YEH */
+    { 0x06CD, 0 }, /* 0x06CD */
+    { 0x06CE, 0 }, /* 0x06CE */
+    { 0x06CF, 0 }, /* 0x06CF */
+
+    { 0xFBE4, 3 }, /* 0x06D0    D       E */
+    { 0x06D1, 0 }, /* 0x06D1 */
+    { 0xFBAE, 1 }, /* 0x06D2    R       YEH BARREE */
+    { 0xFBB0, 1 }, /* 0x06D3    R       YEH BARREE WITH HAMZA ABOVE */
+    { 0x06D4, 0 }, /* 0x06D4 */
+    { 0x06D5, 0 }, /* 0x06D5 */
+    { 0x06D6, 0 }, /* 0x06D6 */
+    { 0x06D7, 0 }, /* 0x06D7 */
+    { 0x06D8, 0 }, /* 0x06D8 */
+    { 0x06D9, 0 }, /* 0x06D9 */
+    { 0x06DA, 0 }, /* 0x06DA */
+    { 0x06DB, 0 }, /* 0x06DB */
+    { 0x06DC, 0 }, /* 0x06DC */
+    { 0x06DD, 0 }, /* 0x06DD */
+    { 0x06DE, 0 }, /* 0x06DE */
+    { 0x06DF, 0 }, /* 0x06DF */
+
+    { 0x06E0, 0 }, /* 0x06E0 */
+    { 0x06E1, 0 }, /* 0x06E1 */
+    { 0x06E2, 0 }, /* 0x06E2 */
+    { 0x06E3, 0 }, /* 0x06E3 */
+    { 0x06E4, 0 }, /* 0x06E4 */
+    { 0x06E5, 0 }, /* 0x06E5 */
+    { 0x06E6, 0 }, /* 0x06E6 */
+    { 0x06E7, 0 }, /* 0x06E7 */
+    { 0x06E8, 0 }, /* 0x06E8 */
+    { 0x06E9, 0 }, /* 0x06E9 */
+    { 0x06EA, 0 }, /* 0x06EA */
+    { 0x06EB, 0 }, /* 0x06EB */
+    { 0x06EC, 0 }, /* 0x06EC */
+    { 0x06ED, 0 }, /* 0x06ED */
+    { 0x06EE, 0 }, /* 0x06EE */
+    { 0x06EF, 0 }, /* 0x06EF */
+
+    { 0x06F0, 0 }, /* 0x06F0 */
+    { 0x06F1, 0 }, /* 0x06F1 */
+    { 0x06F2, 0 }, /* 0x06F2 */
+    { 0x06F3, 0 }, /* 0x06F3 */
+    { 0x06F4, 0 }, /* 0x06F4 */
+    { 0x06F5, 0 }, /* 0x06F5 */
+    { 0x06F6, 0 }, /* 0x06F6 */
+    { 0x06F7, 0 }, /* 0x06F7 */
+    { 0x06F8, 0 }, /* 0x06F8 */
+    { 0x06F9, 0 }, /* 0x06F9 */
+    { 0x06FA, 0 }, /* 0x06FA */
+    { 0x06FB, 0 }, /* 0x06FB */
+    { 0x06FC, 0 }, /* 0x06FC */
+    { 0x06FD, 0 }, /* 0x06FD */
+    { 0x06FE, 0 }, /* 0x06FE */
+    { 0x06FF, 0 }  /* 0x06FF */
+};
+
+/* the arabicUnicodeMapping does not work for U+0649 ALEF MAKSURA, this table does */
+static const hb_uint16 alefMaksura[4] = {0xFEEF, 0xFEF0, 0xFBE8, 0xFBE9};
+
+/*
+// this is a bit tricky. Alef always binds to the right, so the second parameter descibing the shape
+// of the lam can be either initial of medial. So initial maps to the isolated form of the ligature,
+// medial to the final form
+*/
+static const hb_uint16 arabicUnicodeLamAlefMapping[6][4] = {
+    { 0xfffd, 0xfffd, 0xfef5, 0xfef6 }, /* 0x622        R       Alef with Madda above */
+    { 0xfffd, 0xfffd, 0xfef7, 0xfef8 }, /* 0x623        R       Alef with Hamza above */
+    { 0xfffd, 0xfffd, 0xfffd, 0xfffd }, /* 0x624        // Just to fill the table ;-) */
+    { 0xfffd, 0xfffd, 0xfef9, 0xfefa }, /* 0x625        R       Alef with Hamza below */
+    { 0xfffd, 0xfffd, 0xfffd, 0xfffd }, /* 0x626        // Just to fill the table ;-) */
+    { 0xfffd, 0xfffd, 0xfefb, 0xfefc }  /* 0x627        R       Alef */
+};
+
+static int getShape(hb_uint8 cell, int shape)
+{
+    /* the arabicUnicodeMapping does not work for U+0649 ALEF MAKSURA, handle this here */
+    int ch = (cell != 0x49)
+              ? (shape ? arabicUnicodeMapping[cell][0] + shape : 0x600+cell)
+              : alefMaksura[shape] ;
+    return ch;
+}
+
+
+/*
+  Two small helper functions for arabic shaping.
+*/
+static HB_UChar16 prevChar(const HB_UChar16 *str, int pos)
+{
+    /*qDebug("leftChar: pos=%d", pos); */
+    const HB_UChar16 *ch = str + pos - 1;
+    pos--;
+    while(pos > -1) {
+        if(HB_GetUnicodeCharCategory(*ch) != HB_Mark_NonSpacing)
+            return *ch;
+        pos--;
+        ch--;
+    }
+    return ReplacementCharacter;
+}
+
+static HB_UChar16 nextChar(const HB_UChar16 *str, hb_uint32 len, hb_uint32 pos)
+{
+    const HB_UChar16 *ch = str + pos + 1;
+    pos++;
+    while(pos < len) {
+        /*qDebug("rightChar: %d isLetter=%d, joining=%d", pos, ch.isLetter(), ch.joining()); */
+        if(HB_GetUnicodeCharCategory(*ch) != HB_Mark_NonSpacing)
+            return *ch;
+        /* assume it's a transparent char, this might not be 100% correct */
+        pos++;
+        ch++;
+    }
+    return ReplacementCharacter;
+}
+
+static void shapedString(const HB_UChar16 *uc, hb_uint32 stringLength, hb_uint32 from, hb_uint32 len, HB_UChar16 *shapeBuffer, int *shapedLength,
+                         HB_Bool reverse, HB_GlyphAttributes *attributes, unsigned short *logClusters)
+{
+    HB_ArabicProperties *properties;
+    hb_int32 f = from;
+    hb_uint32 l = len;
+    const HB_UChar16 *ch;
+    HB_UChar16 *data;
+    int clusterStart;
+    hb_uint32 i;
+    HB_STACKARRAY(HB_ArabicProperties, props, len + 2);
+    properties = props;
+
+    assert(stringLength >= from + len);
+
+    if(len == 0) {
+        *shapedLength = 0;
+        return;
+    }
+
+    if (from > 0) {
+        --f;
+        ++l;
+        ++properties;
+    }
+    if (f + l < stringLength)
+        ++l;
+    getArabicProperties(uc+f, l, props);
+
+    ch = uc + from;
+    data = shapeBuffer;
+    clusterStart = 0;
+
+    for (i = 0; i < len; i++) {
+        hb_uint8 r = *ch >> 8;
+        int gpos = data - shapeBuffer;
+
+        if (r != 0x06) {
+            if (r == 0x20) {
+                if (*ch == 0x200c || *ch == 0x200d)
+                    /* remove ZWJ and ZWNJ */
+                    goto skip;
+            }
+            if (reverse)
+                *data = HB_GetMirroredChar(*ch);
+            else
+                *data = *ch;
+        } else {
+            hb_uint8 c = *ch & 0xff;
+            int pos = i + from;
+            int shape = properties[i].shape;
+/*            qDebug("mapping U+%x to shape %d glyph=0x%x", ch->unicode(), shape, getShape(c, shape)); */
+            /* take care of lam-alef ligatures (lam right of alef) */
+            hb_uint16 map;
+            switch (c) {
+                case 0x44: { /* lam */
+                    const HB_UChar16 pch = nextChar(uc, stringLength, pos);
+                    if ((pch >> 8) == 0x06) {
+                        switch (pch & 0xff) {
+                            case 0x22:
+                            case 0x23:
+                            case 0x25:
+                            case 0x27:
+/*                                 qDebug(" lam of lam-alef ligature"); */
+                                map = arabicUnicodeLamAlefMapping[(pch & 0xff) - 0x22][shape];
+                                goto next;
+                            default:
+                                break;
+                        }
+                    }
+                    break;
+                }
+                case 0x22: /* alef with madda */
+                case 0x23: /* alef with hamza above */
+                case 0x25: /* alef with hamza below */
+                case 0x27: /* alef */
+                    if (prevChar(uc, pos) == 0x0644) {
+                        /* have a lam alef ligature */
+                        /*qDebug(" alef of lam-alef ligature"); */
+                        goto skip;
+                    }
+                default:
+                    break;
+            }
+            map = getShape(c, shape);
+        next:
+            *data = map;
+        }
+        /* ##### Fixme */
+        /*glyphs[gpos].attributes.zeroWidth = zeroWidth; */
+        if (HB_GetUnicodeCharCategory(*ch) == HB_Mark_NonSpacing) {
+            attributes[gpos].mark = TRUE;
+/*             qDebug("glyph %d (char %d) is mark!", gpos, i); */
+        } else {
+            attributes[gpos].mark = FALSE;
+            clusterStart = data - shapeBuffer;
+        }
+        attributes[gpos].clusterStart = !attributes[gpos].mark;
+        attributes[gpos].combiningClass = HB_GetUnicodeCharCombiningClass(*ch);
+        attributes[gpos].justification = properties[i].justification;
+/*         qDebug("data[%d] = %x (from %x)", gpos, (uint)data->unicode(), ch->unicode());*/
+        data++;
+    skip:
+        ch++;
+        logClusters[i] = clusterStart;
+    }
+    *shapedLength = data - shapeBuffer;
+
+    HB_FREE_STACKARRAY(props);
+}
+
+#ifndef NO_OPENTYPE
+
+static const HB_OpenTypeFeature arabic_features[] = {
+    { HB_MAKE_TAG('c', 'c', 'm', 'p'), CcmpProperty },
+    { HB_MAKE_TAG('i', 's', 'o', 'l'), IsolProperty },
+    { HB_MAKE_TAG('f', 'i', 'n', 'a'), FinaProperty },
+    { HB_MAKE_TAG('m', 'e', 'd', 'i'), MediProperty },
+    { HB_MAKE_TAG('i', 'n', 'i', 't'), InitProperty },
+    { HB_MAKE_TAG('r', 'l', 'i', 'g'), RligProperty },
+    { HB_MAKE_TAG('c', 'a', 'l', 't'), CaltProperty },
+    { HB_MAKE_TAG('l', 'i', 'g', 'a'), LigaProperty },
+    { HB_MAKE_TAG('d', 'l', 'i', 'g'), DligProperty },
+    { HB_MAKE_TAG('c', 's', 'w', 'h'), CswhProperty },
+    /* mset is used in old Win95 fonts that don't have a 'mark' positioning table. */
+    { HB_MAKE_TAG('m', 's', 'e', 't'), MsetProperty },
+    {0, 0}
+};
+
+static const HB_OpenTypeFeature syriac_features[] = {
+    { HB_MAKE_TAG('c', 'c', 'm', 'p'), CcmpProperty },
+    { HB_MAKE_TAG('i', 's', 'o', 'l'), IsolProperty },
+    { HB_MAKE_TAG('f', 'i', 'n', 'a'), FinaProperty },
+    { HB_MAKE_TAG('f', 'i', 'n', '2'), FinaProperty },
+    { HB_MAKE_TAG('f', 'i', 'n', '3'), FinaProperty },
+    { HB_MAKE_TAG('m', 'e', 'd', 'i'), MediProperty },
+    { HB_MAKE_TAG('m', 'e', 'd', '2'), MediProperty },
+    { HB_MAKE_TAG('i', 'n', 'i', 't'), InitProperty },
+    { HB_MAKE_TAG('r', 'l', 'i', 'g'), RligProperty },
+    { HB_MAKE_TAG('c', 'a', 'l', 't'), CaltProperty },
+    { HB_MAKE_TAG('l', 'i', 'g', 'a'), LigaProperty },
+    { HB_MAKE_TAG('d', 'l', 'i', 'g'), DligProperty },
+    {0, 0}
+};
+
+static HB_Bool arabicSyriacOpenTypeShape(HB_ShaperItem *item, HB_Bool *ot_ok)
+{
+    const HB_UChar16 *uc;
+    const int nglyphs = item->num_glyphs;
+    hb_int32 f;
+    hb_uint32 l;
+    HB_ArabicProperties *properties;
+    HB_DECLARE_STACKARRAY(HB_ArabicProperties, props)
+    HB_DECLARE_STACKARRAY(hb_uint32, apply)
+    HB_Bool shaped;
+    int i = 0;
+
+    *ot_ok = TRUE;
+
+    if (!HB_ConvertStringToGlyphIndices(item))
+        return FALSE;
+    HB_HeuristicSetGlyphAttributes(item);
+
+    HB_INIT_STACKARRAY(HB_ArabicProperties, props, item->item.length + 2);
+    HB_INIT_STACKARRAY(hb_uint32, apply, item->num_glyphs);
+
+    uc = item->string + item->item.pos;
+
+    properties = props;
+    f = 0;
+    l = item->item.length;
+    if (item->item.pos > 0) {
+        --f;
+        ++l;
+        ++properties;
+    }
+    if (f + l + item->item.pos < item->stringLength) {
+        ++l;
+    }
+    if (item->item.script == HB_Script_Nko)
+        getNkoProperties(uc+f, l, props);
+    else
+        getArabicProperties(uc+f, l, props);
+
+    for (i = 0; i < (int)item->num_glyphs; i++) {
+        apply[i] = 0;
+
+        if (properties[i].shape == XIsolated)
+            apply[i] |= MediProperty|FinaProperty|InitProperty;
+        else if (properties[i].shape == XMedial)
+            apply[i] |= IsolProperty|FinaProperty|InitProperty;
+        else if (properties[i].shape == XFinal)
+            apply[i] |= IsolProperty|MediProperty|InitProperty;
+        else if (properties[i].shape == XInitial)
+            apply[i] |= IsolProperty|MediProperty|FinaProperty;
+
+        item->attributes[i].justification = properties[i].justification;
+    }
+
+    HB_FREE_STACKARRAY(props);
+
+    shaped = HB_OpenTypeShape(item, apply);
+
+    HB_FREE_STACKARRAY(apply);
+
+    if (!shaped) {
+        *ot_ok = FALSE;
+        return FALSE;
+    }
+    return HB_OpenTypePosition(item, nglyphs, /*doLogClusters*/TRUE);
+}
+
+#endif
+
+/* #### stil missing: identify invalid character combinations */
+HB_Bool HB_ArabicShape(HB_ShaperItem *item)
+{
+    int slen;
+    HB_Bool haveGlyphs;
+    HB_STACKARRAY(HB_UChar16, shapedChars, item->item.length);
+
+    assert(item->item.script == HB_Script_Arabic || item->item.script == HB_Script_Syriac
+           || item->item.script == HB_Script_Nko);
+
+#ifndef NO_OPENTYPE
+
+    if (HB_SelectScript(item, item->item.script == HB_Script_Arabic ? arabic_features : syriac_features)) {
+        HB_Bool ot_ok;
+        if (arabicSyriacOpenTypeShape(item, &ot_ok))
+            return TRUE;
+        if (ot_ok)
+            return FALSE;
+            /* fall through to the non OT code*/
+    }
+#endif
+
+    if (item->item.script != HB_Script_Arabic)
+        return HB_BasicShape(item);
+
+    shapedString(item->string, item->stringLength, item->item.pos, item->item.length, shapedChars, &slen,
+                  item->item.bidiLevel % 2,
+                  item->attributes, item->log_clusters);
+
+    haveGlyphs = item->font->klass
+        ->convertStringToGlyphIndices(item->font,
+                                      shapedChars, slen,
+                                      item->glyphs, &item->num_glyphs,
+                                      item->item.bidiLevel % 2);
+
+    HB_FREE_STACKARRAY(shapedChars);
+
+    if (!haveGlyphs)
+        return FALSE;
+
+    HB_HeuristicPosition(item);
+    return TRUE;
+}
+
+
diff -rupN orginal/scribus/harfbuzz/harfbuzz-buffer-private.h patched/scribus/harfbuzz/harfbuzz-buffer-private.h
--- orginal/scribus/harfbuzz/harfbuzz-buffer-private.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/harfbuzz-buffer-private.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,107 @@
+/*
+ * Copyright (C) 1998-2004  David Turner and Werner Lemberg
+ * Copyright (C) 2004,2007  Red Hat, Inc.
+ *
+ * This is part of HarfBuzz, an OpenType Layout engine library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Owen Taylor, Behdad Esfahbod
+ */
+
+#ifndef HARFBUZZ_BUFFER_PRIVATE_H
+#define HARFBUZZ_BUFFER_PRIVATE_H
+
+#include "harfbuzz-impl.h"
+#include "harfbuzz-buffer.h"
+
+HB_BEGIN_HEADER
+
+#define HB_GLYPH_PROPERTIES_UNKNOWN 0xFFFF
+
+HB_INTERNAL void
+_hb_buffer_swap( HB_Buffer buffer );
+
+HB_INTERNAL void
+_hb_buffer_clear_output( HB_Buffer buffer );
+
+HB_INTERNAL HB_Error
+_hb_buffer_clear_positions( HB_Buffer buffer );
+
+HB_INTERNAL HB_Error
+_hb_buffer_add_output_glyphs( HB_Buffer  buffer,
+			      HB_UShort  num_in,
+			      HB_UShort  num_out,
+			      HB_UShort *glyph_data,
+			      HB_UShort  component,
+			      HB_UShort  ligID );
+
+HB_INTERNAL HB_Error
+_hb_buffer_add_output_glyph ( HB_Buffer buffer,
+			      HB_UInt   glyph_index,
+			      HB_UShort component,
+			      HB_UShort ligID );
+
+HB_INTERNAL HB_Error
+_hb_buffer_copy_output_glyph ( HB_Buffer buffer );
+
+HB_INTERNAL HB_Error
+_hb_buffer_replace_output_glyph ( HB_Buffer buffer,
+				  HB_UInt   glyph_index,
+				  HB_Bool   inplace );
+
+HB_INTERNAL HB_UShort
+_hb_buffer_allocate_ligid( HB_Buffer buffer );
+
+
+/* convenience macros */
+
+#define IN_GLYPH( pos )        (buffer->in_string[(pos)].gindex)
+#define IN_ITEM( pos )         (&buffer->in_string[(pos)])
+#define IN_CURGLYPH()          (buffer->in_string[buffer->in_pos].gindex)
+#define IN_CURITEM()           (&buffer->in_string[buffer->in_pos])
+#define IN_PROPERTIES( pos )   (buffer->in_string[(pos)].properties)
+#define IN_LIGID( pos )        (buffer->in_string[(pos)].ligID)
+#define IN_COMPONENT( pos )    (buffer->in_string[(pos)].component)
+#define POSITION( pos )        (&buffer->positions[(pos)])
+#define OUT_GLYPH( pos )       (buffer->out_string[(pos)].gindex)
+#define OUT_ITEM( pos )        (&buffer->out_string[(pos)])
+
+#define CHECK_Property( gdef, index, flags, property )					\
+          ( ( error = _HB_GDEF_Check_Property( (gdef), (index), (flags),		\
+                                      (property) ) ) != HB_Err_Ok )
+
+#define ADD_String( buffer, num_in, num_out, glyph_data, component, ligID )             \
+          ( ( error = _hb_buffer_add_output_glyphs( (buffer),                            \
+						    (num_in), (num_out),                \
+                                                    (glyph_data), (component), (ligID)  \
+                                                  ) ) != HB_Err_Ok )
+#define ADD_Glyph( buffer, glyph_index, component, ligID )				\
+          ( ( error = _hb_buffer_add_output_glyph( (buffer),                             \
+                                                    (glyph_index), (component), (ligID) \
+                                                  ) ) != HB_Err_Ok )
+#define REPLACE_Glyph( buffer, glyph_index, nesting_level )				\
+          ( ( error = _hb_buffer_replace_output_glyph( (buffer), (glyph_index),		\
+						      (nesting_level) == 1 ) ) != HB_Err_Ok )
+#define COPY_Glyph( buffer )								\
+	  ( (error = _hb_buffer_copy_output_glyph ( buffer ) ) != HB_Err_Ok )
+
+HB_END_HEADER
+
+#endif /* HARFBUZZ_BUFFER_PRIVATE_H */
diff -rupN orginal/scribus/harfbuzz/harfbuzz-buffer.c patched/scribus/harfbuzz/harfbuzz-buffer.c
--- orginal/scribus/harfbuzz/harfbuzz-buffer.c	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/harfbuzz-buffer.c	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,383 @@
+/*
+ * Copyright (C) 1998-2004  David Turner and Werner Lemberg
+ * Copyright (C) 2004,2007  Red Hat, Inc.
+ *
+ * This is part of HarfBuzz, an OpenType Layout engine library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Owen Taylor, Behdad Esfahbod
+ */
+
+#include "harfbuzz-impl.h"
+#include "harfbuzz-buffer-private.h"
+#include "harfbuzz-gsub-private.h"
+#include "harfbuzz-gpos-private.h"
+
+/* Here is how the buffer works internally:
+ *
+ * There are two string pointers: in_string and out_string.  They
+ * always have same allocated size, but different length and positions.
+ *
+ * As an optimization, both in_string and out_string may point to the
+ * same piece of memory, which is owned by in_string.  This remains the
+ * case as long as:
+ *
+ *   - copy_glyph() is called
+ *   - replace_glyph() is called with inplace=TRUE
+ *   - add_output_glyph() and add_output_glyphs() are not called
+ *
+ * In that case swap(), and copy_glyph(), and replace_glyph() are all
+ * mostly no-op.
+ *
+ * As soon an add_output_glyph[s]() or replace_glyph() with inplace=FALSE is
+ * called, out_string is moved over to an alternate buffer (alt_string), and
+ * its current contents (out_length entries) are copied to the alt buffer.
+ * This should all remain transparent to the user.  swap() then switches
+ * in_string and alt_string.  alt_string is not allocated until its needed,
+ * but after that it's grown with in_string unconditionally.
+ *
+ * The buffer->separate_out boolean keeps status of whether out_string points
+ * to in_string (FALSE) or alt_string (TRUE).
+ */
+
+/* Internal API */
+
+static HB_Error
+hb_buffer_ensure( HB_Buffer buffer,
+		   HB_UInt   size )
+{
+  HB_UInt new_allocated = buffer->allocated;
+
+  if (size > new_allocated)
+    {
+      HB_Error error;
+
+      while (size > new_allocated)
+	new_allocated += (new_allocated >> 1) + 8;
+      
+      if ( buffer->positions )
+        {
+	  if ( REALLOC_ARRAY( buffer->positions, new_allocated, HB_PositionRec ) )
+	    return error;
+	}
+
+      if ( REALLOC_ARRAY( buffer->in_string, new_allocated, HB_GlyphItemRec ) )
+	return error;
+
+      if ( buffer->separate_out )
+        {
+	  if ( REALLOC_ARRAY( buffer->alt_string, new_allocated, HB_GlyphItemRec ) )
+	    return error;
+
+	  buffer->out_string = buffer->alt_string;
+	}
+      else
+        {
+	  buffer->out_string = buffer->in_string;
+
+	  if ( buffer->alt_string )
+	    {
+	      if ( REALLOC_ARRAY( buffer->alt_string, new_allocated, HB_GlyphItemRec ) )
+		return error;
+	    }
+	}
+
+      buffer->allocated = new_allocated;
+    }
+
+  return HB_Err_Ok;
+}
+
+static HB_Error
+hb_buffer_duplicate_out_buffer( HB_Buffer buffer )
+{
+  if ( !buffer->alt_string )
+    {
+      HB_Error error;
+
+      if ( ALLOC_ARRAY( buffer->alt_string, buffer->allocated, HB_GlyphItemRec ) )
+	return error;
+    }
+
+  buffer->out_string = buffer->alt_string;
+  memcpy( buffer->out_string, buffer->in_string, buffer->out_length * sizeof (buffer->out_string[0]) );
+  buffer->separate_out = TRUE;
+
+  return HB_Err_Ok;
+}
+
+/* Public API */
+
+HB_Error
+hb_buffer_new( HB_Buffer *pbuffer )
+{
+  HB_Buffer buffer;
+  HB_Error error;
+
+  if ( ALLOC( buffer, sizeof( HB_BufferRec ) ) )
+    return error;
+
+  buffer->allocated = 0;
+  buffer->in_string = NULL;
+  buffer->alt_string = NULL;
+  buffer->positions = NULL;
+
+  hb_buffer_clear( buffer );
+
+  *pbuffer = buffer;
+
+  return HB_Err_Ok;
+}
+
+void
+hb_buffer_free( HB_Buffer buffer )
+{
+  FREE( buffer->in_string );
+  FREE( buffer->alt_string );
+  buffer->out_string = NULL;
+  FREE( buffer->positions );
+  FREE( buffer );
+}
+
+void
+hb_buffer_clear( HB_Buffer buffer )
+{
+  buffer->in_length = 0;
+  buffer->out_length = 0;
+  buffer->in_pos = 0;
+  buffer->out_pos = 0;
+  buffer->out_string = buffer->in_string;
+  buffer->separate_out = FALSE;
+  buffer->max_ligID = 0;
+}
+
+HB_Error
+hb_buffer_add_glyph( HB_Buffer buffer,
+		      HB_UInt   glyph_index,
+		      HB_UInt   properties,
+		      HB_UInt   cluster )
+{
+  HB_Error error;
+  HB_GlyphItem glyph;
+  
+  error = hb_buffer_ensure( buffer, buffer->in_length + 1 );
+  if ( error )
+    return error;
+
+  glyph = &buffer->in_string[buffer->in_length];
+  glyph->gindex = glyph_index;
+  glyph->properties = properties;
+  glyph->cluster = cluster;
+  glyph->component = 0;
+  glyph->ligID = 0;
+  glyph->gproperties = HB_GLYPH_PROPERTIES_UNKNOWN;
+  
+  buffer->in_length++;
+
+  return HB_Err_Ok;
+}
+
+/* HarfBuzz-Internal API */
+
+HB_INTERNAL void
+_hb_buffer_clear_output( HB_Buffer buffer )
+{
+  buffer->out_length = 0;
+  buffer->out_pos = 0;
+  buffer->out_string = buffer->in_string;
+  buffer->separate_out = FALSE;
+}
+
+HB_INTERNAL HB_Error
+_hb_buffer_clear_positions( HB_Buffer buffer )
+{
+  if ( !buffer->positions )
+    {
+      HB_Error error;
+
+      if ( ALLOC_ARRAY( buffer->positions, buffer->allocated, HB_PositionRec ) )
+	return error;
+    }
+
+  memset (buffer->positions, 0, sizeof (buffer->positions[0]) * buffer->in_length);
+
+  return HB_Err_Ok;
+}
+
+HB_INTERNAL void
+_hb_buffer_swap( HB_Buffer buffer )
+{
+  HB_GlyphItem tmp_string;
+  int tmp_length;
+  int tmp_pos;
+
+  if ( buffer->separate_out )
+    {
+      tmp_string = buffer->in_string;
+      buffer->in_string = buffer->out_string;
+      buffer->out_string = tmp_string;
+      buffer->alt_string = buffer->out_string;
+    }
+
+  tmp_length = buffer->in_length;
+  buffer->in_length = buffer->out_length;
+  buffer->out_length = tmp_length;
+
+  tmp_pos = buffer->in_pos;
+  buffer->in_pos = buffer->out_pos;
+  buffer->out_pos = tmp_pos;
+}
+
+/* The following function copies `num_out' elements from `glyph_data'
+   to `buffer->out_string', advancing the in array pointer in the structure
+   by `num_in' elements, and the out array pointer by `num_out' elements.
+   Finally, it sets the `length' field of `out' equal to
+   `pos' of the `out' structure.
+
+   If `component' is 0xFFFF, the component value from buffer->in_pos
+   will copied `num_out' times, otherwise `component' itself will
+   be used to fill the `component' fields.
+
+   If `ligID' is 0xFFFF, the ligID value from buffer->in_pos
+   will copied `num_out' times, otherwise `ligID' itself will
+   be used to fill the `ligID' fields.
+
+   The properties for all replacement glyphs are taken
+   from the glyph at position `buffer->in_pos'.
+
+   The cluster value for the glyph at position buffer->in_pos is used
+   for all replacement glyphs */
+HB_INTERNAL HB_Error
+_hb_buffer_add_output_glyphs( HB_Buffer  buffer,
+			      HB_UShort  num_in,
+			      HB_UShort  num_out,
+			      HB_UShort *glyph_data,
+			      HB_UShort  component,
+			      HB_UShort  ligID )
+{
+  HB_Error  error;
+  HB_UShort i;
+  HB_UInt properties;
+  HB_UInt cluster;
+
+  error = hb_buffer_ensure( buffer, buffer->out_pos + num_out );
+  if ( error )
+    return error;
+
+  if ( !buffer->separate_out )
+    {
+      error = hb_buffer_duplicate_out_buffer( buffer );
+      if ( error )
+	return error;
+    }
+
+  properties = buffer->in_string[buffer->in_pos].properties;
+  cluster = buffer->in_string[buffer->in_pos].cluster;
+  if ( component == 0xFFFF )
+    component = buffer->in_string[buffer->in_pos].component;
+  if ( ligID == 0xFFFF )
+    ligID = buffer->in_string[buffer->in_pos].ligID;
+
+  for ( i = 0; i < num_out; i++ )
+  {
+    HB_GlyphItem item = &buffer->out_string[buffer->out_pos + i];
+
+    item->gindex = glyph_data[i];
+    item->properties = properties;
+    item->cluster = cluster;
+    item->component = component;
+    item->ligID = ligID;
+    item->gproperties = HB_GLYPH_PROPERTIES_UNKNOWN;
+  }
+
+  buffer->in_pos  += num_in;
+  buffer->out_pos += num_out;
+
+  buffer->out_length = buffer->out_pos;
+
+  return HB_Err_Ok;
+}
+
+HB_INTERNAL HB_Error
+_hb_buffer_add_output_glyph( HB_Buffer buffer,
+			     HB_UInt   glyph_index,
+			     HB_UShort component,
+			     HB_UShort ligID )
+{
+  HB_UShort glyph_data =  glyph_index;
+
+  return _hb_buffer_add_output_glyphs ( buffer, 1, 1,
+					&glyph_data, component, ligID );
+}
+
+HB_INTERNAL HB_Error
+_hb_buffer_copy_output_glyph ( HB_Buffer buffer )
+{  
+  HB_Error  error;
+
+  error = hb_buffer_ensure( buffer, buffer->out_pos + 1 );
+  if ( error )
+    return error;
+  
+  if ( buffer->separate_out )
+    {
+      buffer->out_string[buffer->out_pos] = buffer->in_string[buffer->in_pos];
+    }
+
+  buffer->in_pos++;
+  buffer->out_pos++;
+  buffer->out_length = buffer->out_pos;
+
+  return HB_Err_Ok;
+}
+
+HB_INTERNAL HB_Error
+_hb_buffer_replace_output_glyph( HB_Buffer buffer,
+				 HB_UInt   glyph_index,
+				 HB_Bool   inplace )
+{
+
+  HB_Error error;
+
+  if ( inplace )
+    {
+      error = _hb_buffer_copy_output_glyph ( buffer );
+      if ( error )
+	return error;
+
+      buffer->out_string[buffer->out_pos-1].gindex = glyph_index;
+    }
+  else
+    {
+      return _hb_buffer_add_output_glyph( buffer, glyph_index, 0xFFFF, 0xFFFF );
+    }
+
+  return HB_Err_Ok;
+}
+
+HB_INTERNAL HB_UShort
+_hb_buffer_allocate_ligid( HB_Buffer buffer )
+{
+  buffer->max_ligID++;
+  if (HB_UNLIKELY (buffer->max_ligID == 0))
+    buffer->max_ligID++;
+
+  return buffer->max_ligID;
+}
diff -rupN orginal/scribus/harfbuzz/harfbuzz-buffer.h patched/scribus/harfbuzz/harfbuzz-buffer.h
--- orginal/scribus/harfbuzz/harfbuzz-buffer.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/harfbuzz-buffer.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,94 @@
+/*
+ * Copyright (C) 1998-2004  David Turner and Werner Lemberg
+ * Copyright (C) 2004,2007  Red Hat, Inc.
+ *
+ * This is part of HarfBuzz, an OpenType Layout engine library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Owen Taylor, Behdad Esfahbod
+ */
+
+#ifndef HARFBUZZ_BUFFER_H
+#define HARFBUZZ_BUFFER_H
+
+#include "harfbuzz-global.h"
+
+HB_BEGIN_HEADER
+
+typedef struct HB_GlyphItemRec_ {
+  HB_UInt     gindex;
+  HB_UInt     properties;
+  HB_UInt     cluster;
+  HB_UShort   component;
+  HB_UShort   ligID;
+  HB_UShort   gproperties;
+} HB_GlyphItemRec, *HB_GlyphItem;
+
+typedef struct HB_PositionRec_ {
+  HB_Fixed   x_pos;
+  HB_Fixed   y_pos;
+  HB_Fixed   x_advance;
+  HB_Fixed   y_advance;
+  HB_UShort  back;            /* number of glyphs to go back
+				 for drawing current glyph   */
+  HB_Bool    new_advance;     /* if set, the advance width values are
+				 absolute, i.e., they won't be
+				 added to the original glyph's value
+				 but rather replace them.            */
+  HB_Short  cursive_chain;   /* character to which this connects,
+				 may be positive or negative; used
+				 only internally                     */
+} HB_PositionRec, *HB_Position;
+
+
+typedef struct HB_BufferRec_{ 
+  HB_UInt    allocated;
+
+  HB_UInt    in_length;
+  HB_UInt    out_length;
+  HB_UInt    in_pos;
+  HB_UInt    out_pos;
+  
+  HB_Bool       separate_out;
+  HB_GlyphItem  in_string;
+  HB_GlyphItem  out_string;
+  HB_GlyphItem  alt_string;
+  HB_Position   positions;
+  HB_UShort      max_ligID;
+} HB_BufferRec, *HB_Buffer;
+
+HB_Error
+hb_buffer_new( HB_Buffer *buffer );
+
+void
+hb_buffer_free( HB_Buffer buffer );
+
+void
+hb_buffer_clear( HB_Buffer buffer );
+
+HB_Error
+hb_buffer_add_glyph( HB_Buffer buffer,
+		      HB_UInt    glyph_index,
+		      HB_UInt    properties,
+		      HB_UInt    cluster );
+
+HB_END_HEADER
+
+#endif /* HARFBUZZ_BUFFER_H */
diff -rupN orginal/scribus/harfbuzz/harfbuzz-dump-main.c patched/scribus/harfbuzz/harfbuzz-dump-main.c
--- orginal/scribus/harfbuzz/harfbuzz-dump-main.c	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/harfbuzz-dump-main.c	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,97 @@
+/*
+ * Copyright (C) 2000  Red Hat, Inc.
+ *
+ * This is part of HarfBuzz, an OpenType Layout engine library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Owen Taylor
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "harfbuzz.h"
+#include "harfbuzz-dump.h"
+
+#define N_ELEMENTS(arr) (sizeof(arr)/ sizeof((arr)[0]))
+
+static int
+croak (const char *situation, HB_Error error)
+{
+  fprintf (stderr, "%s: Error %d\n", situation, error);
+
+  exit (1);
+}
+
+int 
+main (int argc, char **argv)
+{
+  HB_Error error;
+  FT_Library library;
+  HB_Font font;
+  HB_GSUB gsub;
+  HB_GPOS gpos;
+
+  if (argc != 2)
+    {
+      fprintf (stderr, "Usage: harfbuzz-dump MYFONT.TTF\n");
+      exit(1);
+    }
+
+  if ((error = FT_Init_FreeType (&library)))
+    croak ("FT_Init_FreeType", error);
+
+  if ((error = FT_New_Face (library, argv[1], 0, &font)))
+    croak ("FT_New_Face", error);
+
+  printf ("<?xml version=\"1.0\"?>\n");
+  printf ("<OpenType>\n");
+
+  if (!(error = HB_Load_GSUB_Table (font, &gsub, NULL)))
+    {
+      HB_Dump_GSUB_Table (gsub, stdout);
+      
+      if ((error = HB_Done_GSUB_Table (gsub)))
+	croak ("HB_Done_GSUB_Table", error);
+    }
+  else if (error != HB_Err_Not_Covered)
+    fprintf (stderr, "HB_Load_GSUB_Table: error 0x%x\n", error);
+
+  if (!(error = HB_Load_GPOS_Table (font, &gpos, NULL)))
+    {
+      HB_Dump_GPOS_Table (gpos, stdout);
+      
+      if ((error = HB_Done_GPOS_Table (gpos)))
+	croak ("HB_Done_GPOS_Table", error);
+    }
+  else if (error != HB_Err_Not_Covered)
+    fprintf (stderr, "HB_Load_GPOS_Table: error 0x%x\n", error);
+
+  printf ("</OpenType>\n");
+
+  if ((error = FT_Done_Face (font)))
+    croak ("FT_Done_Face", error);
+
+  if ((error = FT_Done_FreeType (library)))
+    croak ("FT_Done_FreeType", error);
+  
+  return 0;
+}
+
diff -rupN orginal/scribus/harfbuzz/harfbuzz-dump.c patched/scribus/harfbuzz/harfbuzz-dump.c
--- orginal/scribus/harfbuzz/harfbuzz-dump.c	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/harfbuzz-dump.c	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,765 @@
+/*
+ * Copyright (C) 2000, 2007  Red Hat, Inc.
+ *
+ * This is part of HarfBuzz, an OpenType Layout engine library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Owen Taylor, Behdad Esfahbod
+ */
+
+#include "harfbuzz-impl.h"
+#include "harfbuzz-dump.h"
+#include "harfbuzz-gdef-private.h"
+#include "harfbuzz-gsub-private.h"
+#include "harfbuzz-gpos-private.h"
+#include "harfbuzz-open-private.h"
+#include <stdarg.h>
+
+#define DUMP(format) dump (stream, indent, format)
+#define DUMP1(format, arg1) dump (stream, indent, format, arg1)
+#define DUMP2(format, arg1, arg2) dump (stream, indent, format, arg1, arg2)
+#define DUMP3(format, arg1, arg2, arg3) dump (stream, indent, format, arg1, arg2, arg3)
+
+#define DUMP_FINT(strct,fld) dump (stream, indent, "<" #fld ">%d</" #fld ">\n", (strct)->fld)
+#define DUMP_FUINT(strct,fld) dump (stream, indent, "<" #fld ">%u</" #fld ">\n", (strct)->fld)
+#define DUMP_FGLYPH(strct,fld) dump (stream, indent, "<" #fld ">%#06x</" #fld ">\n", (strct)->fld)
+#define DUMP_FGLYPH(strct,fld) dump (stream, indent, "<" #fld ">%#06x</" #fld ">\n", (strct)->fld)
+#define DUMP_USHORT_ARRAY(strct,fld,cnt) Dump_UShort_Array ((strct)->fld, cnt, #fld, stream, indent);
+
+#define DEF_DUMP(type) static void Dump_ ## type (HB_ ## type *type, FILE *stream, int indent, HB_Type hb_type)
+#define RECURSE(name, type, val) do {  DUMP ("<" #name ">\n"); Dump_ ## type (val, stream, indent + 1, hb_type); DUMP ("</" #name ">\n"); } while (0)
+#define RECURSE_NUM(name, i, type, val) do {  DUMP1 ("<" #name "> <!-- %d -->\n", i); Dump_ ## type (val, stream, indent + 1, hb_type); DUMP ("</" #name ">\n"); } while (0)
+#define DUMP_VALUE_RECORD(val, frmt) do {  DUMP ("<ValueRecord>\n"); Dump_ValueRecord (val, stream, indent + 1, hb_type, frmt); DUMP ("</ValueRecord>\n"); } while (0)
+
+static void
+do_indent (FILE *stream, int indent)
+{
+  fprintf (stream, "%*s", indent * 3, "");
+}
+
+static void
+dump (FILE *stream, int indent, const char *format, ...)
+{
+  va_list list;
+
+  do_indent (stream, indent);
+
+  va_start (list, format);
+  vfprintf (stream, format, list);
+  va_end (list);
+}
+
+static void
+Dump_UShort_Array (HB_UShort *array, int count, const char *name, FILE *stream, int indent)
+{
+  int i;
+
+  do_indent (stream, indent);
+
+  fprintf (stream, "<%s>", name);
+  for (i = 0; i < count; i++)
+    fprintf (stream, "%d%s", array[i], i == 0 ? "" : " ");
+  fprintf (stream, "</%s>\n", name);
+}
+
+static void
+Print_Tag (HB_UInt tag, FILE *stream)
+{
+  fprintf (stream, "%c%c%c%c",
+	   (unsigned char)(tag >> 24),
+	   (unsigned char)((tag >> 16) & 0xff),
+	   (unsigned char)((tag >> 8) & 0xff),
+	   (unsigned char)(tag & 0xff));
+}
+
+DEF_DUMP (LangSys)
+{
+  int i;
+
+  HB_UNUSED(hb_type);
+
+  DUMP_FUINT (LangSys, LookupOrderOffset);
+  DUMP_FUINT (LangSys, ReqFeatureIndex);
+  DUMP_FUINT (LangSys, FeatureCount);
+
+  for (i=0; i < LangSys->FeatureCount; i++)
+    DUMP1("<FeatureIndex>%d</FeatureIndex>\n", LangSys->FeatureIndex[i]);
+}
+
+DEF_DUMP (ScriptTable)
+{
+  int i;
+
+  RECURSE (DefaultLangSys, LangSys, &ScriptTable->DefaultLangSys);
+
+  DUMP_FUINT (ScriptTable, LangSysCount);
+
+  for (i=0; i < ScriptTable->LangSysCount; i++)
+    {
+      do_indent (stream, indent);
+      fprintf (stream, "<LangSysTag>");
+      Print_Tag (ScriptTable->LangSysRecord[i].LangSysTag, stream);
+      fprintf (stream, "</LangSysTag>\n");
+      RECURSE_NUM (LangSys, i, LangSys, &ScriptTable->LangSysRecord[i].LangSys);
+    }
+}
+
+DEF_DUMP (ScriptList)
+{
+  int i;
+
+  DUMP_FUINT (ScriptList, ScriptCount);
+
+  for (i=0; i < ScriptList->ScriptCount; i++)
+    {
+      do_indent (stream, indent);
+      fprintf (stream, "<ScriptTag>");
+      Print_Tag (ScriptList->ScriptRecord[i].ScriptTag, stream);
+      fprintf (stream, "</ScriptTag>\n");
+      RECURSE_NUM (Script, i, ScriptTable, &ScriptList->ScriptRecord[i].Script);
+    }
+}
+
+DEF_DUMP (Feature)
+{
+  int i;
+
+  HB_UNUSED(hb_type);
+
+  DUMP_FUINT (Feature, FeatureParams);
+  DUMP_FUINT (Feature, LookupListCount);
+
+  for (i=0; i < Feature->LookupListCount; i++)
+    DUMP1("<LookupIndex>%d</LookupIndex>\n", Feature->LookupListIndex[i]);
+}
+
+DEF_DUMP (MarkRecord)
+{
+  HB_UNUSED(hb_type);
+
+  DUMP_FUINT (MarkRecord, Class);
+  DUMP1("<Anchor>%d</Anchor>\n", MarkRecord->MarkAnchor.PosFormat );
+}
+
+DEF_DUMP (MarkArray)
+{
+  int i;
+
+  DUMP_FUINT (MarkArray, MarkCount);
+
+  for (i=0; i < MarkArray->MarkCount; i++)
+    RECURSE_NUM (MarkRecord, i, MarkRecord, &MarkArray->MarkRecord[i]);
+}
+
+DEF_DUMP (FeatureList)
+{
+  int i;
+
+  DUMP_FUINT (FeatureList, FeatureCount);
+
+  for (i=0; i < FeatureList->FeatureCount; i++)
+    {
+      do_indent (stream, indent);
+      fprintf (stream, "<FeatureTag>");
+      Print_Tag (FeatureList->FeatureRecord[i].FeatureTag, stream);
+      fprintf (stream, "</FeatureTag> <!-- %d -->\n", i);
+      RECURSE_NUM (Feature, i, Feature, &FeatureList->FeatureRecord[i].Feature);
+    }
+}
+
+DEF_DUMP (Coverage)
+{
+  HB_UNUSED(hb_type);
+
+  DUMP_FUINT (Coverage, CoverageFormat);
+
+  if (Coverage->CoverageFormat == 1)
+    {
+      int i;
+      DUMP_FUINT (&Coverage->cf.cf1, GlyphCount);
+
+      for (i = 0; i < Coverage->cf.cf1.GlyphCount; i++)
+	DUMP2("<Glyph>%#06x</Glyph> <!-- %d -->\n",
+	      Coverage->cf.cf1.GlyphArray[i], i);
+    }
+  else
+    {
+      int i;
+      DUMP_FUINT (&Coverage->cf.cf2, RangeCount);
+
+      for ( i = 0; i < Coverage->cf.cf2.RangeCount; i++ )
+	  DUMP3("<Glyph>%#06x - %#06x</Glyph> <!-- %d -->\n",
+	        Coverage->cf.cf2.RangeRecord[i].Start,
+	        Coverage->cf.cf2.RangeRecord[i].End, i);
+    }
+}
+
+DEF_DUMP (ClassRangeRecord)
+{
+  HB_UNUSED(hb_type);
+
+  DUMP_FGLYPH (ClassRangeRecord, Start);
+  DUMP_FGLYPH (ClassRangeRecord, End);
+  DUMP_FUINT (ClassRangeRecord, Class);
+}
+
+DEF_DUMP (ClassDefinition)
+{
+  HB_UNUSED(hb_type);
+
+  DUMP_FUINT( ClassDefinition, ClassFormat);
+  DUMP_FUINT( ClassDefinition, loaded);
+
+  if (ClassDefinition->ClassFormat == 1)
+    {
+      int i;
+      HB_ClassDefFormat1 *ClassDefFormat1 = &ClassDefinition->cd.cd1;
+      DUMP("<ClassDefinition>\n");
+      DUMP_FUINT (ClassDefFormat1, StartGlyph );
+      DUMP_FUINT (ClassDefFormat1, GlyphCount );
+      for (i = 0; i < ClassDefFormat1->GlyphCount; i++)
+	DUMP2(" <Class>%d</Class> <!-- %#06x -->", ClassDefFormat1->ClassValueArray[i],
+	      ClassDefFormat1->StartGlyph+i );
+    }
+  else if (ClassDefinition->ClassFormat == 2)
+    {
+      int i;
+      HB_ClassDefFormat2 *ClassDefFormat2 = &ClassDefinition->cd.cd2;
+      DUMP_FUINT (ClassDefFormat2, ClassRangeCount);
+
+      for (i = 0; i < ClassDefFormat2->ClassRangeCount; i++)
+	RECURSE_NUM (ClassRangeRecord, i, ClassRangeRecord, &ClassDefFormat2->ClassRangeRecord[i]);
+    }
+  else
+    fprintf(stderr, "invalid class def table!!!\n");
+}
+
+DEF_DUMP (SubstLookupRecord)
+{
+  HB_UNUSED(hb_type);
+
+  DUMP_FUINT (SubstLookupRecord, SequenceIndex);
+  DUMP_FUINT (SubstLookupRecord, LookupListIndex);
+}
+
+DEF_DUMP (ChainSubClassRule)
+{
+  int i;
+
+  DUMP_USHORT_ARRAY (ChainSubClassRule, Backtrack, ChainSubClassRule->BacktrackGlyphCount);
+  DUMP_USHORT_ARRAY (ChainSubClassRule, Input, ChainSubClassRule->InputGlyphCount - 1);
+  DUMP_USHORT_ARRAY (ChainSubClassRule, Lookahead, ChainSubClassRule->LookaheadGlyphCount);
+
+  for (i = 0; i < ChainSubClassRule->SubstCount; i++)
+    RECURSE_NUM (SubstLookupRecord, i, SubstLookupRecord, &ChainSubClassRule->SubstLookupRecord[i]);
+
+  indent--;
+}
+
+DEF_DUMP (ChainSubClassSet)
+{
+  int i;
+
+  DUMP_FUINT( ChainSubClassSet, ChainSubClassRuleCount );
+  for (i = 0; i < ChainSubClassSet->ChainSubClassRuleCount; i++)
+    RECURSE_NUM (ChainSubClassRule, i, ChainSubClassRule, &ChainSubClassSet->ChainSubClassRule[i]);
+}
+
+static void
+Dump_GSUB_Lookup_Single (HB_SubTable *subtable, FILE *stream, int indent, HB_Type hb_type)
+{
+  HB_SingleSubst *SingleSubst = &subtable->st.gsub.single;
+
+  DUMP_FUINT (SingleSubst, SubstFormat);
+  RECURSE (Coverage, Coverage, &SingleSubst->Coverage);
+
+  if (SingleSubst->SubstFormat == 1)
+    {
+      DUMP_FINT (&SingleSubst->ssf.ssf1, DeltaGlyphID);
+    }
+  else
+    {
+      int i;
+
+      DUMP_FINT (&SingleSubst->ssf.ssf2, GlyphCount);
+      for (i=0; i < SingleSubst->ssf.ssf2.GlyphCount; i++)
+	DUMP2("<Substitute>%#06x</Substitute> <!-- %d -->\n", SingleSubst->ssf.ssf2.Substitute[i], i);
+    }
+}
+
+DEF_DUMP (Ligature)
+{
+  int i;
+
+  HB_UNUSED(hb_type);
+
+  DUMP_FGLYPH (Ligature, LigGlyph);
+  DUMP_FUINT (Ligature, ComponentCount);
+
+  for (i=0; i < Ligature->ComponentCount - 1; i++)
+    DUMP1("<Component>%#06x</Component>\n", Ligature->Component[i]);
+}
+
+DEF_DUMP (LigatureSet)
+{
+  int i;
+
+  DUMP_FUINT (LigatureSet, LigatureCount);
+
+  for (i=0; i < LigatureSet->LigatureCount; i++)
+    RECURSE_NUM (Ligature, i, Ligature, &LigatureSet->Ligature[i]);
+}
+
+static void
+Dump_GSUB_Lookup_Ligature (HB_SubTable *subtable, FILE *stream, int indent, HB_Type hb_type)
+{
+  int i;
+  HB_LigatureSubst *LigatureSubst = &subtable->st.gsub.ligature;
+
+  DUMP_FUINT (LigatureSubst, SubstFormat);
+  RECURSE (Coverage, Coverage, &LigatureSubst->Coverage);
+
+  DUMP_FUINT (LigatureSubst, LigatureSetCount);
+
+  for (i=0; i < LigatureSubst->LigatureSetCount; i++)
+    RECURSE_NUM (LigatureSet, i, LigatureSet, &LigatureSubst->LigatureSet[i]);
+}
+
+DEF_DUMP (ContextSubstFormat1)
+{
+  HB_UNUSED(hb_type);
+  HB_UNUSED(ContextSubstFormat1);
+
+
+  DUMP("<!-- Not implemented!!! -->\n");
+}
+
+DEF_DUMP (ContextSubstFormat2)
+{
+  DUMP_FUINT (ContextSubstFormat2, MaxContextLength);
+  RECURSE (Coverage, Coverage, &ContextSubstFormat2->Coverage);
+  RECURSE (ClassDefinition, ClassDefinition, &ContextSubstFormat2->ClassDef);
+}
+
+DEF_DUMP (ContextSubstFormat3)
+{
+  HB_UNUSED(hb_type);
+  HB_UNUSED(ContextSubstFormat3);
+
+  DUMP("<!-- Not implemented!!! -->\n");
+}
+
+static void
+Dump_GSUB_Lookup_Context (HB_SubTable *subtable, FILE *stream, int indent, HB_Type hb_type)
+{
+  HB_ContextSubst *ContextSubst = &subtable->st.gsub.context;
+
+  DUMP_FUINT (ContextSubst, SubstFormat);
+  switch( ContextSubst->SubstFormat )
+    {
+    case 1:
+      Dump_ContextSubstFormat1 (&ContextSubst->csf.csf1, stream, indent+2, hb_type);
+      break;
+    case 2:
+      Dump_ContextSubstFormat2 (&ContextSubst->csf.csf2, stream, indent+2, hb_type);
+      break;
+    case 3:
+      Dump_ContextSubstFormat3 (&ContextSubst->csf.csf3, stream, indent+2, hb_type);
+      break;
+    default:
+      fprintf(stderr, "invalid subformat!!!!!\n");
+    }
+}
+
+DEF_DUMP (ChainContextSubstFormat1)
+{
+  HB_UNUSED(hb_type);
+  HB_UNUSED(ChainContextSubstFormat1);
+
+  DUMP("<!-- Not implemented!!! -->\n");
+}
+
+DEF_DUMP (ChainContextSubstFormat2)
+{
+  int i;
+
+  RECURSE (Coverage, Coverage, &ChainContextSubstFormat2->Coverage);
+  DUMP_FUINT (ChainContextSubstFormat2, MaxBacktrackLength);
+  RECURSE (ClassDefinition, ClassDefinition, &ChainContextSubstFormat2->BacktrackClassDef);
+  DUMP_FUINT (ChainContextSubstFormat2, MaxInputLength);
+  RECURSE (ClassDefinition, ClassDefinition, &ChainContextSubstFormat2->InputClassDef);
+  DUMP_FUINT (ChainContextSubstFormat2, MaxLookaheadLength);
+  RECURSE (ClassDefinition, ClassDefinition, &ChainContextSubstFormat2->LookaheadClassDef);
+
+  DUMP_FUINT (ChainContextSubstFormat2, ChainSubClassSetCount);
+  for (i = 0; i < ChainContextSubstFormat2->ChainSubClassSetCount; i++)
+    RECURSE (ChainSubClassSet, ChainSubClassSet, &ChainContextSubstFormat2->ChainSubClassSet[i]);
+}
+
+DEF_DUMP (ChainContextSubstFormat3)
+{
+  int i;
+
+  DUMP_FUINT (ChainContextSubstFormat3, BacktrackGlyphCount);
+  for (i = 0; i < ChainContextSubstFormat3->BacktrackGlyphCount; i++)
+    RECURSE (BacktrackCoverage, Coverage, &ChainContextSubstFormat3->BacktrackCoverage[i]);
+  DUMP_FUINT (ChainContextSubstFormat3, InputGlyphCount);
+  for (i = 0; i < ChainContextSubstFormat3->InputGlyphCount; i++)
+    RECURSE (InputCoverage, Coverage, &ChainContextSubstFormat3->InputCoverage[i]);
+  DUMP_FUINT (ChainContextSubstFormat3, LookaheadGlyphCount);
+  for (i = 0; i < ChainContextSubstFormat3->LookaheadGlyphCount; i++)
+    RECURSE (LookaheadCoverage, Coverage, &ChainContextSubstFormat3->LookaheadCoverage[i]);
+
+  for (i = 0; i < ChainContextSubstFormat3->SubstCount; i++)
+    RECURSE_NUM (SubstLookupRecord, i, SubstLookupRecord, &ChainContextSubstFormat3->SubstLookupRecord[i]);
+
+}
+
+static void
+Dump_GSUB_Lookup_Chain (HB_SubTable *subtable, FILE *stream, int indent, HB_Type hb_type)
+{
+  HB_ChainContextSubst *chain = &subtable->st.gsub.chain;
+
+  DUMP_FUINT (chain, SubstFormat);
+  switch (chain->SubstFormat)
+    {
+    case 1:
+      Dump_ChainContextSubstFormat1 (&chain->ccsf.ccsf1, stream, indent+2, hb_type);
+      break;
+    case 2:
+      Dump_ChainContextSubstFormat2 (&chain->ccsf.ccsf2, stream, indent+2, hb_type);
+      break;
+    case 3:
+      Dump_ChainContextSubstFormat3 (&chain->ccsf.ccsf3, stream, indent+2, hb_type);
+      break;
+    default:
+      fprintf(stderr, "invalid subformat!!!!!\n");
+    }
+}
+
+static void
+Dump_Device (HB_Device *Device, FILE *stream, int indent, HB_Type hb_type)
+{
+  int i;
+  int bits;
+  int n_per;
+  unsigned int mask;
+
+  HB_UNUSED(hb_type);
+
+  DUMP_FUINT (Device, StartSize);
+  DUMP_FUINT (Device, EndSize);
+  DUMP_FUINT (Device, DeltaFormat);
+  switch (Device->DeltaFormat)
+    {
+    case 1:
+      bits = 2;
+      break;
+    case 2:
+      bits = 4;
+      break;
+    case 3:
+      bits = 8;
+      break;
+    default:
+      bits = 0;
+      break;
+    }
+
+  DUMP ("<DeltaValue>");
+  if (!bits)
+    {
+
+      fprintf(stderr, "invalid DeltaFormat!!!!!\n");
+    }
+  else
+    {
+      n_per = 16 / bits;
+      mask = (1 << bits) - 1;
+      mask = mask << (16 - bits);
+
+      for (i = Device->StartSize; i <= Device->EndSize ; i++)
+	{
+	  HB_UShort val = Device->DeltaValue[i / n_per];
+	  HB_Short signed_val = ((val << ((i % n_per) * bits)) & mask);
+	  dump (stream, indent, "%d", signed_val >> (16 - bits));
+	  if (i != Device->EndSize)
+	    DUMP (", ");
+	}
+    }
+  DUMP ("</DeltaValue>\n");
+}
+
+static void
+Dump_ValueRecord (HB_ValueRecord *ValueRecord, FILE *stream, int indent, HB_Type hb_type, HB_UShort value_format)
+{
+  if (value_format & HB_GPOS_FORMAT_HAVE_X_PLACEMENT)
+    DUMP_FINT (ValueRecord, XPlacement);
+  if (value_format & HB_GPOS_FORMAT_HAVE_Y_PLACEMENT)
+    DUMP_FINT (ValueRecord, YPlacement);
+  if (value_format & HB_GPOS_FORMAT_HAVE_X_ADVANCE)
+    DUMP_FINT (ValueRecord, XAdvance);
+  if (value_format & HB_GPOS_FORMAT_HAVE_Y_ADVANCE)
+    DUMP_FINT (ValueRecord, XAdvance);
+  if (value_format & HB_GPOS_FORMAT_HAVE_X_PLACEMENT_DEVICE)
+    RECURSE (Device, Device, &ValueRecord->XPlacementDevice);
+  if (value_format & HB_GPOS_FORMAT_HAVE_Y_PLACEMENT_DEVICE)
+    RECURSE (Device, Device, &ValueRecord->YPlacementDevice);
+  if (value_format & HB_GPOS_FORMAT_HAVE_X_ADVANCE_DEVICE)
+    RECURSE (Device, Device, &ValueRecord->XAdvanceDevice);
+  if (value_format & HB_GPOS_FORMAT_HAVE_Y_ADVANCE_DEVICE)
+    RECURSE (Device, Device, &ValueRecord->YAdvanceDevice);
+  if (value_format & HB_GPOS_FORMAT_HAVE_X_ID_PLACEMENT)
+    DUMP_FUINT (ValueRecord, XIdPlacement);
+  if (value_format & HB_GPOS_FORMAT_HAVE_Y_ID_PLACEMENT)
+    DUMP_FUINT (ValueRecord, YIdPlacement);
+  if (value_format & HB_GPOS_FORMAT_HAVE_X_ID_ADVANCE)
+    DUMP_FUINT (ValueRecord, XIdAdvance);
+  if (value_format & HB_GPOS_FORMAT_HAVE_Y_ID_ADVANCE)
+    DUMP_FUINT (ValueRecord, XIdAdvance);
+}
+
+static void
+Dump_GPOS_Lookup_Single (HB_SubTable *subtable, FILE *stream, int indent, HB_Type hb_type)
+{
+  HB_SinglePos *SinglePos = &subtable->st.gpos.single;
+
+  DUMP_FUINT (SinglePos, PosFormat);
+  RECURSE (Coverage, Coverage, &SinglePos->Coverage);
+
+  DUMP_FUINT (SinglePos, ValueFormat);
+
+  if (SinglePos->PosFormat == 1)
+    {
+      DUMP_VALUE_RECORD (&SinglePos->spf.spf1.Value, SinglePos->ValueFormat);
+    }
+  else
+    {
+      int i;
+
+      DUMP_FUINT (&SinglePos->spf.spf2, ValueCount);
+      for (i = 0; i < SinglePos->spf.spf2.ValueCount; i++)
+	DUMP_VALUE_RECORD (&SinglePos->spf.spf2.Value[i], SinglePos->ValueFormat);
+    }
+}
+
+static void
+Dump_PairValueRecord (HB_PairValueRecord *PairValueRecord, FILE *stream, int indent, HB_Type hb_type, HB_UShort ValueFormat1, HB_UShort ValueFormat2)
+{
+  DUMP_FUINT (PairValueRecord, SecondGlyph);
+  DUMP_VALUE_RECORD (&PairValueRecord->Value1, ValueFormat1);
+  DUMP_VALUE_RECORD (&PairValueRecord->Value2, ValueFormat2);
+}
+
+static void
+Dump_PairSet (HB_PairSet *PairSet, FILE *stream, int indent, HB_Type hb_type, HB_UShort ValueFormat1, HB_UShort ValueFormat2)
+{
+  int i;
+  DUMP_FUINT (PairSet, PairValueCount);
+
+  for (i = 0; i < PairSet->PairValueCount; i++)
+    {
+      DUMP ("<PairValueRecord>\n");
+      Dump_PairValueRecord (&PairSet->PairValueRecord[i], stream, indent + 1, hb_type, ValueFormat1, ValueFormat2);
+      DUMP ("</PairValueRecord>\n");
+    }
+}
+
+static void
+Dump_GPOS_Lookup_Pair (HB_SubTable *subtable, FILE *stream, int indent, HB_Type hb_type)
+{
+  HB_PairPos *PairPos = &subtable->st.gpos.pair;
+
+  DUMP_FUINT (PairPos, PosFormat);
+  RECURSE (Coverage, Coverage, &PairPos->Coverage);
+
+  DUMP_FUINT (PairPos, ValueFormat1);
+  DUMP_FUINT (PairPos, ValueFormat2);
+
+  if (PairPos->PosFormat == 1)
+    {
+      int i;
+
+      DUMP_FUINT (&PairPos->ppf.ppf1, PairSetCount);
+      for (i = 0; i < PairPos->ppf.ppf1.PairSetCount; i++)
+	{
+	  DUMP ("<PairSet>\n");
+	  Dump_PairSet (&PairPos->ppf.ppf1.PairSet[i], stream, indent + 1, hb_type, PairPos->ValueFormat1, PairPos->ValueFormat2);
+	  DUMP ("</PairSet>\n");
+	}
+    }
+  else
+    {
+    }
+}
+
+static void
+Dump_GPOS_Lookup_Markbase (HB_SubTable *subtable, FILE *stream, int indent, HB_Type hb_type)
+{
+  int i;
+  HB_MarkBasePos *markbase = &subtable->st.gpos.markbase;
+
+  DUMP_FUINT (markbase, PosFormat);
+  RECURSE (Coverage, Coverage, &markbase->MarkCoverage);
+  RECURSE (Coverage, Coverage, &markbase->BaseCoverage);
+  DUMP_FUINT (markbase, ClassCount);
+  RECURSE (MarkArray, MarkArray, &markbase->MarkArray);
+
+  DUMP ("<BaseArray>\n");
+  indent++;
+
+  DUMP_FUINT (&markbase->BaseArray, BaseCount);
+  for (i = 0; i < markbase->BaseArray.BaseCount; i++)
+    {
+      int j;
+      HB_BaseRecord *r = &markbase->BaseArray.BaseRecord[i];
+      DUMP1 ("<BaseRecord> <!-- %d -->\n",  i);
+      for (j = 0; j < markbase->ClassCount; j++)
+	DUMP1 ("  <Anchor>%d</Anchor>\n", r->BaseAnchor->PosFormat);
+      DUMP ("<BaseRecord>\n");
+    }
+
+  indent--;
+  DUMP ("</BaseArray>\n");
+}
+
+DEF_DUMP (Lookup)
+{
+  int i;
+  const char *lookup_name;
+  void (*lookup_func) (HB_SubTable *subtable, FILE *stream, int indent, HB_Type hb_type) = NULL;
+
+  if (hb_type == HB_Type_GSUB)
+    {
+      switch (Lookup->LookupType)
+	{
+	case  HB_GSUB_LOOKUP_SINGLE:
+	  lookup_name = "SINGLE";
+	  lookup_func = Dump_GSUB_Lookup_Single;
+	  break;
+	case  HB_GSUB_LOOKUP_MULTIPLE:
+	  lookup_name = "MULTIPLE";
+	  break;
+	case  HB_GSUB_LOOKUP_ALTERNATE:
+	  lookup_name = "ALTERNATE";
+	  break;
+	case  HB_GSUB_LOOKUP_LIGATURE:
+	  lookup_name = "LIGATURE";
+	  lookup_func = Dump_GSUB_Lookup_Ligature;
+	  break;
+	case  HB_GSUB_LOOKUP_CONTEXT:
+	  lookup_name = "CONTEXT";
+	  lookup_func = Dump_GSUB_Lookup_Context;
+	  break;
+	case  HB_GSUB_LOOKUP_CHAIN:
+	  lookup_name = "CHAIN";
+	  lookup_func = Dump_GSUB_Lookup_Chain;
+	  break;
+	default:
+	  lookup_name = "(unknown)";
+	  lookup_func = NULL;
+	  break;
+	}
+    }
+  else
+    {
+      switch (Lookup->LookupType)
+	{
+	case HB_GPOS_LOOKUP_SINGLE:
+	  lookup_name = "SINGLE";
+	  lookup_func = Dump_GPOS_Lookup_Single;
+	  break;
+	case HB_GPOS_LOOKUP_PAIR:
+	  lookup_name = "PAIR";
+	  lookup_func = Dump_GPOS_Lookup_Pair;
+	  break;
+	case HB_GPOS_LOOKUP_CURSIVE:
+	  lookup_name = "CURSIVE";
+	  break;
+	case HB_GPOS_LOOKUP_MARKBASE:
+	  lookup_name = "MARKBASE";
+	  lookup_func = Dump_GPOS_Lookup_Markbase;
+	  break;
+	case HB_GPOS_LOOKUP_MARKLIG:
+	  lookup_name = "MARKLIG";
+	  break;
+	case HB_GPOS_LOOKUP_MARKMARK:
+	  lookup_name = "MARKMARK";
+	  break;
+	case HB_GPOS_LOOKUP_CONTEXT:
+	  lookup_name = "CONTEXT";
+	  break;
+	case HB_GPOS_LOOKUP_CHAIN:
+	  lookup_name = "CHAIN";
+	  break;
+	default:
+	  lookup_name = "(unknown)";
+	  lookup_func = NULL;
+	  break;
+	}
+    }
+
+  DUMP2("<LookupType>%s</LookupType> <!-- %d -->\n", lookup_name, Lookup->LookupType);
+  DUMP1("<LookupFlag>%#06x</LookupFlag>\n", Lookup->LookupFlag);
+
+  for (i=0; i < Lookup->SubTableCount; i++)
+    {
+      DUMP ("<Subtable>\n");
+      if (lookup_func)
+	(*lookup_func) (&Lookup->SubTable[i], stream, indent + 1, hb_type);
+      DUMP ("</Subtable>\n");
+    }
+}
+
+DEF_DUMP (LookupList)
+{
+  int i;
+
+  DUMP_FUINT (LookupList, LookupCount);
+
+  for (i=0; i < LookupList->LookupCount; i++)
+    RECURSE_NUM (Lookup, i, Lookup, &LookupList->Lookup[i]);
+}
+
+void
+HB_Dump_GSUB_Table (HB_GSUB gsub, FILE *stream)
+{
+  int indent = 1;
+  HB_Type hb_type = HB_Type_GSUB;
+
+  do_indent (stream, indent);
+  fprintf(stream, "<!-- GSUB -->\n");
+  RECURSE (ScriptList, ScriptList, &gsub->ScriptList);
+  RECURSE (FeatureList, FeatureList, &gsub->FeatureList);
+  RECURSE (LookupList, LookupList, &gsub->LookupList);
+}
+
+void
+HB_Dump_GPOS_Table (HB_GPOS gpos, FILE *stream)
+{
+  int indent = 1;
+  HB_Type hb_type = HB_Type_GPOS;
+
+  do_indent (stream, indent);
+  fprintf(stream, "<!-- GPOS -->\n");
+  RECURSE (ScriptList, ScriptList, &gpos->ScriptList);
+  RECURSE (FeatureList, FeatureList, &gpos->FeatureList);
+  RECURSE (LookupList, LookupList, &gpos->LookupList);
+}
diff -rupN orginal/scribus/harfbuzz/harfbuzz-dump.h patched/scribus/harfbuzz/harfbuzz-dump.h
--- orginal/scribus/harfbuzz/harfbuzz-dump.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/harfbuzz-dump.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2000, 2007  Red Hat, Inc.
+ *
+ * This is part of HarfBuzz, an OpenType Layout engine library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Owen Taylor, Behdad Esfahbod
+ */
+
+#ifndef HARFBUZZ_DUMP_H
+#define HARFBUZZ_DUMP_H
+
+#include <stdio.h>
+#include "harfbuzz-gsub.h"
+#include "harfbuzz-gpos.h"
+
+HB_BEGIN_HEADER
+
+void HB_Dump_GSUB_Table (HB_GSUB gsub, FILE *stream);
+void HB_Dump_GPOS_Table (HB_GPOS gpos, FILE *stream);
+
+HB_END_HEADER
+
+#endif /* HARFBUZZ_DUMP_H */
diff -rupN orginal/scribus/harfbuzz/harfbuzz-external.h patched/scribus/harfbuzz/harfbuzz-external.h
--- orginal/scribus/harfbuzz/harfbuzz-external.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/harfbuzz-external.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,157 @@
+/*
+ * Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies)
+ *
+ * This is part of HarfBuzz, an OpenType Layout engine library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ */
+
+#ifndef HARFBUZZ_EXTERNAL_H
+#define HARFBUZZ_EXTERNAL_H
+
+#include "harfbuzz-global.h"
+
+HB_BEGIN_HEADER
+
+/* This header contains some methods that are not part of
+   Harfbuzz itself, but referenced by it.
+   They need to be provided by the application/library
+*/
+
+
+/*
+ see http://www.unicode.org/reports/tr14/tr14-19.html
+ we don't use the XX, AI and CB properties and map them to AL instead.
+ as we don't support any EBDIC based OS'es, NL is ignored and mapped to AL as well.
+*/
+typedef enum {
+    HB_LineBreak_OP, HB_LineBreak_CL, HB_LineBreak_QU, HB_LineBreak_GL, HB_LineBreak_NS,
+    HB_LineBreak_EX, HB_LineBreak_SY, HB_LineBreak_IS, HB_LineBreak_PR, HB_LineBreak_PO,
+    HB_LineBreak_NU, HB_LineBreak_AL, HB_LineBreak_ID, HB_LineBreak_IN, HB_LineBreak_HY,
+    HB_LineBreak_BA, HB_LineBreak_BB, HB_LineBreak_B2, HB_LineBreak_ZW, HB_LineBreak_CM,
+    HB_LineBreak_WJ, HB_LineBreak_H2, HB_LineBreak_H3, HB_LineBreak_JL, HB_LineBreak_JV,
+    HB_LineBreak_JT, HB_LineBreak_SA, HB_LineBreak_SG,
+    HB_LineBreak_SP, HB_LineBreak_CR, HB_LineBreak_LF, HB_LineBreak_BK
+} HB_LineBreakClass;
+
+typedef enum 
+{
+    HB_NoCategory,
+
+    HB_Mark_NonSpacing,          /*   Mn */
+    HB_Mark_SpacingCombining,    /*   Mc */
+    HB_Mark_Enclosing,           /*   Me */
+
+    HB_Number_DecimalDigit,      /*   Nd */
+    HB_Number_Letter,            /*   Nl */
+    HB_Number_Other,             /*   No */
+
+    HB_Separator_Space,          /*   Zs */
+    HB_Separator_Line,           /*   Zl */
+    HB_Separator_Paragraph,      /*   Zp */
+
+    HB_Other_Control,            /*   Cc */
+    HB_Other_Format,             /*   Cf */
+    HB_Other_Surrogate,          /*   Cs */
+    HB_Other_PrivateUse,         /*   Co */
+    HB_Other_NotAssigned,        /*   Cn */
+
+    HB_Letter_Uppercase,         /*   Lu */
+    HB_Letter_Lowercase,         /*   Ll */
+    HB_Letter_Titlecase,         /*   Lt */
+    HB_Letter_Modifier,          /*   Lm */
+    HB_Letter_Other,             /*   Lo */
+
+    HB_Punctuation_Connector,    /*   Pc */
+    HB_Punctuation_Dash,         /*   Pd */
+    HB_Punctuation_Open,         /*   Ps */
+    HB_Punctuation_Close,        /*   Pe */
+    HB_Punctuation_InitialQuote, /*   Pi */
+    HB_Punctuation_FinalQuote,   /*   Pf */
+    HB_Punctuation_Other,        /*   Po */
+
+    HB_Symbol_Math,              /*   Sm */
+    HB_Symbol_Currency,          /*   Sc */
+    HB_Symbol_Modifier,          /*   Sk */
+    HB_Symbol_Other              /*   So */
+} HB_CharCategory;
+
+typedef enum
+{
+    HB_Grapheme_Other, 
+    HB_Grapheme_CR,
+    HB_Grapheme_LF,
+    HB_Grapheme_Control,
+    HB_Grapheme_Extend,
+    HB_Grapheme_L, 
+    HB_Grapheme_V, 
+    HB_Grapheme_T, 
+    HB_Grapheme_LV, 
+    HB_Grapheme_LVT
+} HB_GraphemeClass;
+
+
+typedef enum
+{
+    HB_Word_Other,
+    HB_Word_Format,
+    HB_Word_Katakana,
+    HB_Word_ALetter,
+    HB_Word_MidLetter,
+    HB_Word_MidNum,
+    HB_Word_Numeric,
+    HB_Word_ExtendNumLet
+} HB_WordClass;
+
+
+typedef enum
+{
+    HB_Sentence_Other,
+    HB_Sentence_Sep,
+    HB_Sentence_Format,
+    HB_Sentence_Sp,
+    HB_Sentence_Lower,
+    HB_Sentence_Upper,
+    HB_Sentence_OLetter,
+    HB_Sentence_Numeric,
+    HB_Sentence_ATerm,
+    HB_Sentence_STerm,
+    HB_Sentence_Close
+} HB_SentenceClass;
+
+HB_GraphemeClass HB_GetGraphemeClass(HB_UChar32 ch);
+HB_WordClass HB_GetWordClass(HB_UChar32 ch);
+HB_SentenceClass HB_GetSentenceClass(HB_UChar32 ch);
+HB_LineBreakClass HB_GetLineBreakClass(HB_UChar32 ch);
+
+void HB_GetGraphemeAndLineBreakClass(HB_UChar32 ch, HB_GraphemeClass *grapheme, HB_LineBreakClass *lineBreak);
+void HB_GetUnicodeCharProperties(HB_UChar32 ch, HB_CharCategory *category, int *combiningClass);
+HB_CharCategory HB_GetUnicodeCharCategory(HB_UChar32 ch);
+int HB_GetUnicodeCharCombiningClass(HB_UChar32 ch);
+HB_UChar16 HB_GetMirroredChar(HB_UChar16 ch);
+
+void *HB_Library_Resolve(const char *library, const char *symbol);
+
+void *HB_TextCodecForMib(int mib);
+char *HB_TextCodec_ConvertFromUnicode(void *codec, const HB_UChar16 *unicode, hb_uint32 length, hb_uint32 *outputLength);
+void HB_TextCodec_FreeResult(char *);
+
+HB_END_HEADER
+
+#endif
diff -rupN orginal/scribus/harfbuzz/harfbuzz-freetype.c patched/scribus/harfbuzz/harfbuzz-freetype.c
--- orginal/scribus/harfbuzz/harfbuzz-freetype.c	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/harfbuzz-freetype.c	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,150 @@
+#include <stdint.h>
+
+#include <ft2build.h>
+#include FT_FREETYPE_H
+#include FT_TRUETYPE_TABLES_H
+
+#if 0
+#include <freetype/freetype.h>
+#include <freetype/tttables.h>
+#endif
+
+#include <harfbuzz-shaper.h>
+#include "harfbuzz-unicode.h"
+
+static HB_Bool
+hb_freetype_string_to_glyphs(HB_Font font,
+                             const HB_UChar16 *chars, hb_uint32 len,
+                             HB_Glyph *glyphs, hb_uint32 *numGlyphs,
+                             HB_Bool is_rtl) {
+  FT_Face face = (FT_Face) font->userData;
+  if (len > *numGlyphs)
+    return 0;
+
+  size_t i = 0, j = 0;
+  while (i < len) {
+    const uint32_t cp = utf16_to_code_point(chars, len, &i);
+    glyphs[j++] = FT_Get_Char_Index(face, cp);
+  }
+
+  *numGlyphs = j;
+
+  return 1;
+}
+
+static void
+hb_freetype_advances_get(HB_Font font, const HB_Glyph *glyphs, hb_uint32 len,
+                         HB_Fixed *advances, int flags) {
+  FT_Face face = (FT_Face) font->userData;
+
+  hb_uint32 i;
+  for (i = 0; i < len; ++i) {
+    const FT_Error error = FT_Load_Glyph(face, glyphs[i], FT_LOAD_DEFAULT);
+    if (error) {
+      advances[i] = 0;
+      continue;
+    }
+
+    advances[i] = face->glyph->advance.x;
+  }
+}
+
+static HB_Bool
+hb_freetype_can_render(HB_Font font, const HB_UChar16 *chars, hb_uint32 len) {
+  FT_Face face = (FT_Face)font->userData;
+
+  size_t i = 0;
+  while (i < len) {
+    const uint32_t cp = utf16_to_code_point(chars, len, &i);
+    if (FT_Get_Char_Index(face, cp) == 0)
+      return 0;
+  }
+
+  return 1;
+}
+
+static HB_Error
+hb_freetype_outline_point_get(HB_Font font, HB_Glyph glyph, int flags,
+                              hb_uint32 point, HB_Fixed *xpos, HB_Fixed *ypos,
+                              hb_uint32 *n_points) {
+  HB_Error error = HB_Err_Ok;
+  FT_Face face = (FT_Face) font->userData;
+
+  int load_flags = (flags & HB_ShaperFlag_UseDesignMetrics) ? FT_LOAD_NO_HINTING : FT_LOAD_DEFAULT;
+
+  if ((error = (HB_Error) FT_Load_Glyph(face, glyph, load_flags)))
+    return error;
+
+  if (face->glyph->format != ft_glyph_format_outline)
+    return (HB_Error)HB_Err_Invalid_SubTable;
+
+  *n_points = face->glyph->outline.n_points;
+  if (!(*n_points))
+    return HB_Err_Ok;
+
+  if (point > *n_points)
+    return (HB_Error)HB_Err_Invalid_SubTable;
+
+  *xpos = face->glyph->outline.points[point].x;
+  *ypos = face->glyph->outline.points[point].y;
+
+  return HB_Err_Ok;
+}
+
+static void
+hb_freetype_glyph_metrics_get(HB_Font font, HB_Glyph glyph,
+                              HB_GlyphMetrics *metrics) {
+  FT_Face face = (FT_Face) font->userData;
+
+  const FT_Error error = FT_Load_Glyph(face, glyph, FT_LOAD_DEFAULT);
+  if (error) {
+    metrics->x = metrics->y = metrics->width = metrics->height = 0;
+    metrics->xOffset = metrics->yOffset = 0;
+    return;
+  }
+
+  const FT_Glyph_Metrics *ftmetrics = &face->glyph->metrics;
+  metrics->width = ftmetrics->width;
+  metrics->height = ftmetrics->height;
+  metrics->x = ftmetrics->horiAdvance;
+  metrics->y = 0;  // unclear what this is
+  metrics->xOffset = ftmetrics->horiBearingX;
+  metrics->yOffset = ftmetrics->horiBearingY;
+}
+
+static HB_Fixed
+hb_freetype_font_metric_get(HB_Font font, HB_FontMetric metric) {
+  FT_Face face = (FT_Face) font->userData;
+
+  switch (metric) {
+  case HB_FontAscent:
+    // Note that we aren't scanning the VDMX table which we probably would in
+    // an ideal world.
+    return face->ascender;
+  default:
+    return 0;
+  }
+}
+
+const HB_FontClass hb_freetype_class = {
+  hb_freetype_string_to_glyphs,
+  hb_freetype_advances_get,
+  hb_freetype_can_render,
+  hb_freetype_outline_point_get,
+  hb_freetype_glyph_metrics_get,
+  hb_freetype_font_metric_get,
+};
+
+HB_Error
+hb_freetype_table_sfnt_get(void *voidface, const HB_Tag tag, HB_Byte *buffer, HB_UInt *len) {
+  FT_Face face = (FT_Face) voidface;
+  FT_ULong ftlen = *len;
+
+  if (!FT_IS_SFNT(face))
+    return HB_Err_Invalid_Argument;
+
+  const FT_Error error = FT_Load_Sfnt_Table(face, tag, 0, buffer, &ftlen);
+  *len = ftlen;
+  return (HB_Error) error;
+}
+
diff -rupN orginal/scribus/harfbuzz/harfbuzz-freetype.h patched/scribus/harfbuzz/harfbuzz-freetype.h
--- orginal/scribus/harfbuzz/harfbuzz-freetype.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/harfbuzz-freetype.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,9 @@
+#ifndef HB_FREETYPE_H_
+#define HB_FREETYPE_H_
+
+extern const HB_FontClass hb_freetype_class;
+
+HB_Error hb_freetype_table_sfnt_get(void *voidface, const HB_Tag tag,
+                                    HB_Byte *buffer, HB_UInt *len);
+
+#endif  // HB_FREETYPE_H_
diff -rupN orginal/scribus/harfbuzz/harfbuzz-gdef-private.h patched/scribus/harfbuzz/harfbuzz-gdef-private.h
--- orginal/scribus/harfbuzz/harfbuzz-gdef-private.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/harfbuzz-gdef-private.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 1998-2004  David Turner and Werner Lemberg
+ * Copyright (C) 2006  Behdad Esfahbod
+ *
+ * This is part of HarfBuzz, an OpenType Layout engine library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ */
+
+#ifndef HARFBUZZ_GDEF_PRIVATE_H
+#define HARFBUZZ_GDEF_PRIVATE_H
+
+#include "harfbuzz-impl.h"
+#include "harfbuzz-stream-private.h"
+#include "harfbuzz-buffer-private.h"
+#include "harfbuzz-gdef.h"
+
+HB_BEGIN_HEADER
+
+
+/* Attachment related structures */
+
+struct  HB_AttachPoint_
+{
+  HB_UShort   PointCount;             /* size of the PointIndex array */
+  HB_UShort*  PointIndex;             /* array of contour points      */
+};
+
+/* Ligature Caret related structures */
+
+struct  HB_CaretValueFormat1_
+{
+  HB_Short  Coordinate;               /* x or y value (in design units) */
+};
+
+typedef struct HB_CaretValueFormat1_  HB_CaretValueFormat1;
+
+
+struct  HB_CaretValueFormat2_
+{
+  HB_UShort  CaretValuePoint;         /* contour point index on glyph */
+};
+
+typedef struct HB_CaretValueFormat2_  HB_CaretValueFormat2;
+
+
+struct  HB_CaretValueFormat3_
+{
+  HB_Short    Coordinate;             /* x or y value (in design units) */
+  HB_Device  Device;                 /* Device table for x or y value  */
+};
+
+typedef struct HB_CaretValueFormat3_  HB_CaretValueFormat3;
+
+
+struct  HB_CaretValueFormat4_
+{
+  HB_UShort  IdCaretValue;            /* metric ID */
+};
+
+typedef struct HB_CaretValueFormat4_  HB_CaretValueFormat4;
+
+
+struct  HB_CaretValue_
+{
+  HB_UShort  CaretValueFormat;        /* 1, 2, 3, or 4 */
+
+  union
+  {
+    HB_CaretValueFormat1  cvf1;
+    HB_CaretValueFormat2  cvf2;
+    HB_CaretValueFormat3  cvf3;
+    HB_CaretValueFormat4  cvf4;
+  } cvf;
+};
+
+typedef struct HB_CaretValue_  HB_CaretValue;
+
+
+struct  HB_LigGlyph_
+{
+  HB_Bool          loaded;
+
+  HB_UShort        CaretCount;        /* number of caret values */
+  HB_CaretValue*  CaretValue;        /* array of caret values  */
+};
+
+
+HB_INTERNAL HB_Error
+_HB_GDEF_Add_Glyph_Property( HB_GDEFHeader* gdef,
+				       HB_UShort        glyphID,
+				       HB_UShort        property );
+
+HB_INTERNAL HB_Error
+_HB_GDEF_Check_Property( HB_GDEFHeader* gdef,
+				   HB_GlyphItem    item,
+				   HB_UShort        flags,
+				   HB_UShort*       property );
+
+HB_INTERNAL HB_Error
+_HB_GDEF_LoadMarkAttachClassDef_From_LookupFlags( HB_GDEFHeader* gdef,
+						  HB_Stream      input,
+						  HB_Lookup*     lo,
+						  HB_UShort      num_lookups );
+
+HB_END_HEADER
+
+#endif /* HARFBUZZ_GDEF_PRIVATE_H */
diff -rupN orginal/scribus/harfbuzz/harfbuzz-gdef.c patched/scribus/harfbuzz/harfbuzz-gdef.c
--- orginal/scribus/harfbuzz/harfbuzz-gdef.c	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/harfbuzz-gdef.c	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,1159 @@
+/*
+ * Copyright (C) 1998-2004  David Turner and Werner Lemberg
+ * Copyright (C) 2006  Behdad Esfahbod
+ *
+ * This is part of HarfBuzz, an OpenType Layout engine library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ */
+
+#include "harfbuzz-impl.h"
+#include "harfbuzz-gdef-private.h"
+#include "harfbuzz-open-private.h"
+
+static HB_Error  Load_AttachList( HB_AttachList*  al,
+				  HB_Stream        stream );
+static HB_Error  Load_LigCaretList( HB_LigCaretList*  lcl,
+				    HB_Stream          stream );
+
+static void  Free_AttachList( HB_AttachList*  al);
+static void  Free_LigCaretList( HB_LigCaretList*  lcl);
+
+static void  Free_NewGlyphClasses( HB_GDEFHeader*  gdef);
+
+
+
+/* GDEF glyph classes */
+
+#define UNCLASSIFIED_GLYPH  0
+#define SIMPLE_GLYPH        1
+#define LIGATURE_GLYPH      2
+#define MARK_GLYPH          3
+#define COMPONENT_GLYPH     4
+
+
+
+
+
+
+HB_Error  HB_New_GDEF_Table( HB_GDEFHeader** retptr )
+{
+  HB_Error         error;
+
+  HB_GDEFHeader*  gdef;
+
+  if ( !retptr )
+    return ERR(HB_Err_Invalid_Argument);
+
+  if ( ALLOC( gdef, sizeof( *gdef ) ) )
+    return error;
+
+  gdef->GlyphClassDef.loaded = FALSE;
+  gdef->AttachList.loaded = FALSE;
+  gdef->LigCaretList.loaded = FALSE;
+  gdef->MarkAttachClassDef_offset = 0;
+  gdef->MarkAttachClassDef.loaded = FALSE;
+
+  gdef->LastGlyph = 0;
+  gdef->NewGlyphClasses = NULL;
+
+  *retptr = gdef;
+
+  return HB_Err_Ok;
+}
+
+
+HB_Error  HB_Load_GDEF_Table( HB_Stream stream, 
+			      HB_GDEFHeader** retptr )
+{
+  HB_Error         error;
+  HB_UInt         cur_offset, new_offset, base_offset;
+
+  HB_GDEFHeader*  gdef;
+
+
+  if ( !retptr )
+    return ERR(HB_Err_Invalid_Argument);
+
+  if ( GOTO_Table( TTAG_GDEF ) )
+    return error;
+
+  if (( error = HB_New_GDEF_Table ( &gdef ) ))
+    return error;
+
+  base_offset = FILE_Pos();
+
+  /* skip version */
+
+  if ( FILE_Seek( base_offset + 4L ) ||
+       ACCESS_Frame( 2L ) )
+    goto Fail0;
+
+  new_offset = GET_UShort();
+
+  FORGET_Frame();
+
+  /* all GDEF subtables are optional */
+
+  if ( new_offset )
+  {
+    new_offset += base_offset;
+
+    /* only classes 1-4 are allowed here */
+
+    cur_offset = FILE_Pos();
+    if ( FILE_Seek( new_offset ) ||
+	 ( error = _HB_OPEN_Load_ClassDefinition( &gdef->GlyphClassDef, 5,
+					 stream ) ) != HB_Err_Ok )
+      goto Fail0;
+    (void)FILE_Seek( cur_offset );
+  }
+
+  if ( ACCESS_Frame( 2L ) )
+    goto Fail1;
+
+  new_offset = GET_UShort();
+
+  FORGET_Frame();
+
+  if ( new_offset )
+  {
+    new_offset += base_offset;
+
+    cur_offset = FILE_Pos();
+    if ( FILE_Seek( new_offset ) ||
+	 ( error = Load_AttachList( &gdef->AttachList,
+				    stream ) ) != HB_Err_Ok )
+      goto Fail1;
+    (void)FILE_Seek( cur_offset );
+  }
+
+  if ( ACCESS_Frame( 2L ) )
+    goto Fail2;
+
+  new_offset = GET_UShort();
+
+  FORGET_Frame();
+
+  if ( new_offset )
+  {
+    new_offset += base_offset;
+
+    cur_offset = FILE_Pos();
+    if ( FILE_Seek( new_offset ) ||
+	 ( error = Load_LigCaretList( &gdef->LigCaretList,
+				      stream ) ) != HB_Err_Ok )
+      goto Fail2;
+    (void)FILE_Seek( cur_offset );
+  }
+
+  /* OpenType 1.2 has introduced the `MarkAttachClassDef' field.  We
+     first have to scan the LookupFlag values to find out whether we
+     must load it or not.  Here we only store the offset of the table. */
+
+  if ( ACCESS_Frame( 2L ) )
+    goto Fail3;
+
+  new_offset = GET_UShort();
+
+  FORGET_Frame();
+
+  if ( new_offset )
+    gdef->MarkAttachClassDef_offset = new_offset + base_offset;
+  else
+    gdef->MarkAttachClassDef_offset = 0;
+
+  *retptr = gdef;
+
+  return HB_Err_Ok;
+
+Fail3:
+  Free_LigCaretList( &gdef->LigCaretList );
+  
+Fail2:
+  Free_AttachList( &gdef->AttachList );
+
+Fail1:
+  _HB_OPEN_Free_ClassDefinition( &gdef->GlyphClassDef );
+
+Fail0:
+  FREE( gdef );
+
+  return error;
+}
+
+
+HB_Error  HB_Done_GDEF_Table ( HB_GDEFHeader* gdef ) 
+{  
+  Free_LigCaretList( &gdef->LigCaretList );
+  Free_AttachList( &gdef->AttachList );
+  _HB_OPEN_Free_ClassDefinition( &gdef->GlyphClassDef );
+  _HB_OPEN_Free_ClassDefinition( &gdef->MarkAttachClassDef );
+  
+  Free_NewGlyphClasses( gdef );
+
+  FREE( gdef );
+
+  return HB_Err_Ok;
+}
+
+
+
+
+/*******************************
+ * AttachList related functions
+ *******************************/
+
+
+/* AttachPoint */
+
+static HB_Error  Load_AttachPoint( HB_AttachPoint*  ap,
+				   HB_Stream         stream )
+{
+  HB_Error  error;
+
+  HB_UShort   n, count;
+  HB_UShort*  pi;
+
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  count = ap->PointCount = GET_UShort();
+
+  FORGET_Frame();
+
+  ap->PointIndex = NULL;
+
+  if ( count )
+  {
+    if ( ALLOC_ARRAY( ap->PointIndex, count, HB_UShort ) )
+      return error;
+
+    pi = ap->PointIndex;
+
+    if ( ACCESS_Frame( count * 2L ) )
+    {
+      FREE( pi );
+      return error;
+    }
+
+    for ( n = 0; n < count; n++ )
+      pi[n] = GET_UShort();
+
+    FORGET_Frame();
+  }
+
+  return HB_Err_Ok;
+}
+
+
+static void  Free_AttachPoint( HB_AttachPoint*  ap )
+{
+  FREE( ap->PointIndex );
+}
+
+
+/* AttachList */
+
+static HB_Error  Load_AttachList( HB_AttachList*  al,
+				  HB_Stream        stream )
+{
+  HB_Error  error;
+
+  HB_UShort         n, m, count;
+  HB_UInt          cur_offset, new_offset, base_offset;
+
+  HB_AttachPoint*  ap;
+
+
+  base_offset = FILE_Pos();
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  new_offset = GET_UShort() + base_offset;
+
+  FORGET_Frame();
+
+  cur_offset = FILE_Pos();
+  if ( FILE_Seek( new_offset ) ||
+       ( error = _HB_OPEN_Load_Coverage( &al->Coverage, stream ) ) != HB_Err_Ok )
+    return error;
+  (void)FILE_Seek( cur_offset );
+
+  if ( ACCESS_Frame( 2L ) )
+    goto Fail2;
+
+  count = al->GlyphCount = GET_UShort();
+
+  FORGET_Frame();
+
+  al->AttachPoint = NULL;
+
+  if ( ALLOC_ARRAY( al->AttachPoint, count, HB_AttachPoint ) )
+    goto Fail2;
+
+  ap = al->AttachPoint;
+
+  for ( n = 0; n < count; n++ )
+  {
+    if ( ACCESS_Frame( 2L ) )
+      goto Fail1;
+
+    new_offset = GET_UShort() + base_offset;
+
+    FORGET_Frame();
+
+    cur_offset = FILE_Pos();
+    if ( FILE_Seek( new_offset ) ||
+	 ( error = Load_AttachPoint( &ap[n], stream ) ) != HB_Err_Ok )
+      goto Fail1;
+    (void)FILE_Seek( cur_offset );
+  }
+
+  al->loaded = TRUE;
+
+  return HB_Err_Ok;
+
+Fail1:
+  for ( m = 0; m < n; m++ )
+    Free_AttachPoint( &ap[m] );
+
+  FREE( ap );
+
+Fail2:
+  _HB_OPEN_Free_Coverage( &al->Coverage );
+  return error;
+}
+
+
+static void  Free_AttachList( HB_AttachList*  al)
+{
+  HB_UShort         n, count;
+
+  HB_AttachPoint*  ap;
+
+
+  if ( !al->loaded )
+    return;
+
+  if ( al->AttachPoint )
+  {
+    count = al->GlyphCount;
+    ap    = al->AttachPoint;
+
+    for ( n = 0; n < count; n++ )
+      Free_AttachPoint( &ap[n] );
+
+    FREE( ap );
+  }
+
+  _HB_OPEN_Free_Coverage( &al->Coverage );
+}
+
+
+
+/*********************************
+ * LigCaretList related functions
+ *********************************/
+
+
+/* CaretValueFormat1 */
+/* CaretValueFormat2 */
+/* CaretValueFormat3 */
+/* CaretValueFormat4 */
+
+static HB_Error  Load_CaretValue( HB_CaretValue*  cv,
+				  HB_Stream        stream )
+{
+  HB_Error  error;
+
+  HB_UInt cur_offset, new_offset, base_offset;
+
+
+  base_offset = FILE_Pos();
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  cv->CaretValueFormat = GET_UShort();
+
+  FORGET_Frame();
+
+  switch ( cv->CaretValueFormat )
+  {
+  case 1:
+    if ( ACCESS_Frame( 2L ) )
+      return error;
+
+    cv->cvf.cvf1.Coordinate = GET_Short();
+
+    FORGET_Frame();
+
+    break;
+
+  case 2:
+    if ( ACCESS_Frame( 2L ) )
+      return error;
+
+    cv->cvf.cvf2.CaretValuePoint = GET_UShort();
+
+    FORGET_Frame();
+
+    break;
+
+  case 3:
+    if ( ACCESS_Frame( 4L ) )
+      return error;
+
+    cv->cvf.cvf3.Coordinate = GET_Short();
+
+    new_offset = GET_UShort() + base_offset;
+
+    FORGET_Frame();
+
+    cur_offset = FILE_Pos();
+    if ( FILE_Seek( new_offset ) ||
+	 ( error = _HB_OPEN_Load_Device( &cv->cvf.cvf3.Device,
+				stream ) ) != HB_Err_Ok )
+      return error;
+    (void)FILE_Seek( cur_offset );
+
+    break;
+
+  case 4:
+    if ( ACCESS_Frame( 2L ) )
+      return error;
+
+    cv->cvf.cvf4.IdCaretValue = GET_UShort();
+
+    FORGET_Frame();
+    break;
+
+  default:
+    return ERR(HB_Err_Invalid_SubTable_Format);
+  }
+
+  return HB_Err_Ok;
+}
+
+
+static void  Free_CaretValue( HB_CaretValue*  cv)
+{
+  if ( cv->CaretValueFormat == 3 )
+    _HB_OPEN_Free_Device( &cv->cvf.cvf3.Device );
+}
+
+
+/* LigGlyph */
+
+static HB_Error  Load_LigGlyph( HB_LigGlyph*  lg,
+				HB_Stream      stream )
+{
+  HB_Error  error;
+
+  HB_UShort        n, m, count;
+  HB_UInt         cur_offset, new_offset, base_offset;
+
+  HB_CaretValue*  cv;
+
+
+  base_offset = FILE_Pos();
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  count = lg->CaretCount = GET_UShort();
+
+  FORGET_Frame();
+
+  lg->CaretValue = NULL;
+
+  if ( ALLOC_ARRAY( lg->CaretValue, count, HB_CaretValue ) )
+    return error;
+
+  cv = lg->CaretValue;
+
+  for ( n = 0; n < count; n++ )
+  {
+    if ( ACCESS_Frame( 2L ) )
+      goto Fail;
+
+    new_offset = GET_UShort() + base_offset;
+
+    FORGET_Frame();
+
+    cur_offset = FILE_Pos();
+    if ( FILE_Seek( new_offset ) ||
+	 ( error = Load_CaretValue( &cv[n], stream ) ) != HB_Err_Ok )
+      goto Fail;
+    (void)FILE_Seek( cur_offset );
+  }
+
+  return HB_Err_Ok;
+
+Fail:
+  for ( m = 0; m < n; m++ )
+    Free_CaretValue( &cv[m] );
+
+  FREE( cv );
+  return error;
+}
+
+
+static void  Free_LigGlyph( HB_LigGlyph*  lg)
+{
+  HB_UShort        n, count;
+
+  HB_CaretValue*  cv;
+
+
+  if ( lg->CaretValue )
+  {
+    count = lg->CaretCount;
+    cv    = lg->CaretValue;
+
+    for ( n = 0; n < count; n++ )
+      Free_CaretValue( &cv[n] );
+
+    FREE( cv );
+  }
+}
+
+
+/* LigCaretList */
+
+static HB_Error  Load_LigCaretList( HB_LigCaretList*  lcl,
+				    HB_Stream          stream )
+{
+  HB_Error  error;
+
+  HB_UShort      m, n, count;
+  HB_UInt       cur_offset, new_offset, base_offset;
+
+  HB_LigGlyph*  lg;
+
+
+  base_offset = FILE_Pos();
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  new_offset = GET_UShort() + base_offset;
+
+  FORGET_Frame();
+
+  cur_offset = FILE_Pos();
+  if ( FILE_Seek( new_offset ) ||
+       ( error = _HB_OPEN_Load_Coverage( &lcl->Coverage, stream ) ) != HB_Err_Ok )
+    return error;
+  (void)FILE_Seek( cur_offset );
+
+  if ( ACCESS_Frame( 2L ) )
+    goto Fail2;
+
+  count = lcl->LigGlyphCount = GET_UShort();
+
+  FORGET_Frame();
+
+  lcl->LigGlyph = NULL;
+
+  if ( ALLOC_ARRAY( lcl->LigGlyph, count, HB_LigGlyph ) )
+    goto Fail2;
+
+  lg = lcl->LigGlyph;
+
+  for ( n = 0; n < count; n++ )
+  {
+    if ( ACCESS_Frame( 2L ) )
+      goto Fail1;
+
+    new_offset = GET_UShort() + base_offset;
+
+    FORGET_Frame();
+
+    cur_offset = FILE_Pos();
+    if ( FILE_Seek( new_offset ) ||
+	 ( error = Load_LigGlyph( &lg[n], stream ) ) != HB_Err_Ok )
+      goto Fail1;
+    (void)FILE_Seek( cur_offset );
+  }
+
+  lcl->loaded = TRUE;
+
+  return HB_Err_Ok;
+
+Fail1:
+  for ( m = 0; m < n; m++ )
+    Free_LigGlyph( &lg[m] );
+
+  FREE( lg );
+
+Fail2:
+  _HB_OPEN_Free_Coverage( &lcl->Coverage );
+  return error;
+}
+
+
+static void  Free_LigCaretList( HB_LigCaretList*  lcl )
+{
+  HB_UShort      n, count;
+
+  HB_LigGlyph*  lg;
+
+
+  if ( !lcl->loaded )
+    return;
+
+  if ( lcl->LigGlyph )
+  {
+    count = lcl->LigGlyphCount;
+    lg    = lcl->LigGlyph;
+
+    for ( n = 0; n < count; n++ )
+      Free_LigGlyph( &lg[n] );
+
+    FREE( lg );
+  }
+
+  _HB_OPEN_Free_Coverage( &lcl->Coverage );
+}
+
+
+
+/***********
+ * GDEF API
+ ***********/
+
+
+static HB_UShort  Get_New_Class( HB_GDEFHeader*  gdef,
+				 HB_UShort        glyphID,
+				 HB_UShort        index )
+{
+  HB_UShort              glyph_index, array_index, count;
+  HB_UShort              byte, bits;
+  
+  HB_ClassRangeRecord*  gcrr;
+  HB_UShort**            ngc;
+
+
+  if ( glyphID >= gdef->LastGlyph )
+    return 0;
+
+  count = gdef->GlyphClassDef.cd.cd2.ClassRangeCount;
+  gcrr = gdef->GlyphClassDef.cd.cd2.ClassRangeRecord;
+  ngc  = gdef->NewGlyphClasses;
+
+  if ( index < count && glyphID < gcrr[index].Start )
+  {
+    array_index = index;
+    if ( index == 0 )
+      glyph_index = glyphID;
+    else
+      glyph_index = glyphID - gcrr[index - 1].End - 1;
+  }
+  else
+  {
+    array_index = index + 1;
+    glyph_index = glyphID - gcrr[index].End - 1;
+  }
+
+  byte = ngc[array_index][glyph_index / 4];
+  bits = byte >> ( 16 - ( glyph_index % 4 + 1 ) * 4 );
+
+  return bits & 0x000F;
+}
+
+
+
+HB_Error  HB_GDEF_Get_Glyph_Property( HB_GDEFHeader*  gdef,
+				      HB_UShort        glyphID,
+				      HB_UShort*       property )
+{
+  HB_UShort class = 0, index = 0; /* shut compiler up */
+
+  HB_Error  error;
+
+
+  if ( !gdef || !property )
+    return ERR(HB_Err_Invalid_Argument);
+
+  /* first, we check for mark attach classes */
+
+  if ( gdef->MarkAttachClassDef.loaded )
+  {
+    error = _HB_OPEN_Get_Class( &gdef->MarkAttachClassDef, glyphID, &class, &index );
+    if ( error && error != HB_Err_Not_Covered )
+      return error;
+    if ( !error )
+    {
+      *property = class << 8;
+      return HB_Err_Ok;
+    }
+  }
+
+  error = _HB_OPEN_Get_Class( &gdef->GlyphClassDef, glyphID, &class, &index );
+  if ( error && error != HB_Err_Not_Covered )
+    return error;
+
+  /* if we have a constructed class table, check whether additional
+     values have been assigned                                      */
+
+  if ( error == HB_Err_Not_Covered && gdef->NewGlyphClasses )
+    class = Get_New_Class( gdef, glyphID, index );
+
+  switch ( class )
+  {
+  default:
+  case UNCLASSIFIED_GLYPH:
+    *property = 0;
+    break;
+
+  case SIMPLE_GLYPH:
+    *property = HB_GDEF_BASE_GLYPH;
+    break;
+
+  case LIGATURE_GLYPH:
+    *property = HB_GDEF_LIGATURE;
+    break;
+
+  case MARK_GLYPH:
+    *property = HB_GDEF_MARK;
+    break;
+
+  case COMPONENT_GLYPH:
+    *property = HB_GDEF_COMPONENT;
+    break;
+  }
+
+  return HB_Err_Ok;
+}
+
+
+static HB_Error  Make_ClassRange( HB_ClassDefinition*  cd,
+				  HB_UShort             start,
+				  HB_UShort             end,
+				  HB_UShort             class )
+{
+  HB_Error               error;
+  HB_UShort              index;
+
+  HB_ClassDefFormat2*   cdf2;
+  HB_ClassRangeRecord*  crr;
+
+
+  cdf2 = &cd->cd.cd2;
+
+  if ( REALLOC_ARRAY( cdf2->ClassRangeRecord,
+		      cdf2->ClassRangeCount + 1 ,
+		      HB_ClassRangeRecord ) )
+    return error;
+
+  cdf2->ClassRangeCount++;
+
+  crr   = cdf2->ClassRangeRecord;
+  index = cdf2->ClassRangeCount - 1;
+
+  crr[index].Start = start;
+  crr[index].End   = end;
+  crr[index].Class = class;
+
+  return HB_Err_Ok;
+}
+
+
+
+HB_Error  HB_GDEF_Build_ClassDefinition( HB_GDEFHeader*  gdef,
+					 HB_UShort        num_glyphs,
+					 HB_UShort        glyph_count,
+					 HB_UShort*       glyph_array,
+					 HB_UShort*       class_array )
+{
+  HB_UShort              start, curr_glyph, curr_class;
+  HB_UShort              n, m, count;
+  HB_Error               error;
+
+  HB_ClassDefinition*   gcd;
+  HB_ClassRangeRecord*  gcrr;
+  HB_UShort**            ngc;
+
+
+  if ( !gdef || !glyph_array || !class_array )
+    return ERR(HB_Err_Invalid_Argument);
+
+  gcd = &gdef->GlyphClassDef;
+
+  /* We build a format 2 table */
+
+  gcd->ClassFormat = 2;
+
+  gcd->cd.cd2.ClassRangeCount  = 0;
+  gcd->cd.cd2.ClassRangeRecord = NULL;
+
+  start      = glyph_array[0];
+  curr_class = class_array[0];
+  curr_glyph = start;
+
+  if ( curr_class >= 5 )
+  {
+    error = ERR(HB_Err_Invalid_Argument);
+    goto Fail4;
+  }
+
+  glyph_count--;
+
+  for ( n = 0; n < glyph_count + 1; n++ )
+  {
+    if ( curr_glyph == glyph_array[n] && curr_class == class_array[n] )
+    {
+      if ( n == glyph_count )
+      {
+	if ( ( error = Make_ClassRange( gcd, start,
+					curr_glyph,
+					curr_class) ) != HB_Err_Ok )
+	  goto Fail3;
+      }
+      else
+      {
+	if ( curr_glyph == 0xFFFF )
+	{
+	  error = ERR(HB_Err_Invalid_Argument);
+	  goto Fail3;
+	}
+	else
+	  curr_glyph++;
+      }
+    }
+    else
+    {
+      if ( ( error = Make_ClassRange( gcd, start,
+				      curr_glyph - 1,
+				      curr_class) ) != HB_Err_Ok )
+	goto Fail3;
+
+      if ( curr_glyph > glyph_array[n] )
+      {
+	error = ERR(HB_Err_Invalid_Argument);
+	goto Fail3;
+      }
+
+      start      = glyph_array[n];
+      curr_class = class_array[n];
+      curr_glyph = start;
+
+      if ( curr_class >= 5 )
+      {
+	error = ERR(HB_Err_Invalid_Argument);
+	goto Fail3;
+      }
+
+      if ( n == glyph_count )
+      {
+	if ( ( error = Make_ClassRange( gcd, start,
+					curr_glyph,
+					curr_class) ) != HB_Err_Ok )
+	  goto Fail3;
+      }
+      else
+      {
+	if ( curr_glyph == 0xFFFF )
+	{
+	  error = ERR(HB_Err_Invalid_Argument);
+	  goto Fail3;
+	}
+	else
+	  curr_glyph++;
+      }
+    }
+  }
+
+  /* now prepare the arrays for class values assigned during the lookup
+     process                                                            */
+
+  if ( ALLOC_ARRAY( gdef->NewGlyphClasses,
+		    gcd->cd.cd2.ClassRangeCount + 1, HB_UShort* ) )
+    goto Fail3;
+
+  count = gcd->cd.cd2.ClassRangeCount;
+  gcrr  = gcd->cd.cd2.ClassRangeRecord;
+  ngc   = gdef->NewGlyphClasses;
+
+  /* We allocate arrays for all glyphs not covered by the class range
+     records.  Each element holds four class values.                  */
+
+  if ( count > 0 )
+  {
+      if ( gcrr[0].Start )
+      {
+	if ( ALLOC_ARRAY( ngc[0], ( gcrr[0].Start + 3 ) / 4, HB_UShort ) )
+	  goto Fail2;
+      }
+
+      for ( n = 1; n < count; n++ )
+      {
+	if ( gcrr[n].Start - gcrr[n - 1].End > 1 )
+	  if ( ALLOC_ARRAY( ngc[n],
+			    ( gcrr[n].Start - gcrr[n - 1].End + 2 ) / 4,
+			    HB_UShort ) )
+	    goto Fail1;
+      }
+
+      if ( gcrr[count - 1].End != num_glyphs - 1 )
+      {
+	if ( ALLOC_ARRAY( ngc[count],
+			  ( num_glyphs - gcrr[count - 1].End + 2 ) / 4,
+			  HB_UShort ) )
+	    goto Fail1;
+      }
+  }
+  else if ( num_glyphs > 0 )
+  {
+      if ( ALLOC_ARRAY( ngc[count],
+			( num_glyphs + 3 ) / 4,
+			HB_UShort ) )
+	  goto Fail2;
+  }
+      
+  gdef->LastGlyph = num_glyphs - 1;
+
+  gdef->MarkAttachClassDef_offset = 0L;
+  gdef->MarkAttachClassDef.loaded = FALSE;
+
+  gcd->loaded = TRUE;
+
+  return HB_Err_Ok;
+
+Fail1:
+  for ( m = 0; m < n; m++ )
+    FREE( ngc[m] );
+
+Fail2:
+  FREE( gdef->NewGlyphClasses );
+
+Fail3:
+  FREE( gcd->cd.cd2.ClassRangeRecord );
+
+Fail4:
+  return error;
+}
+
+
+static void  Free_NewGlyphClasses( HB_GDEFHeader*  gdef )
+{
+  HB_UShort**  ngc;
+  HB_UShort    n, count;
+
+
+  if ( gdef->NewGlyphClasses )
+  {
+    count = gdef->GlyphClassDef.cd.cd2.ClassRangeCount + 1;
+    ngc   = gdef->NewGlyphClasses;
+
+    for ( n = 0; n < count; n++ )
+      FREE( ngc[n] );
+
+    FREE( ngc );
+  }
+}
+
+
+HB_INTERNAL HB_Error
+_HB_GDEF_Add_Glyph_Property( HB_GDEFHeader* gdef,
+			      HB_UShort        glyphID,
+			      HB_UShort        property )
+{
+  HB_Error               error;
+  HB_UShort              class, new_class, index = 0; /* shut compiler up */
+  HB_UShort              byte, bits, mask;
+  HB_UShort              array_index, glyph_index, count;
+
+  HB_ClassRangeRecord*  gcrr;
+  HB_UShort**            ngc;
+
+
+  error = _HB_OPEN_Get_Class( &gdef->GlyphClassDef, glyphID, &class, &index );
+  if ( error && error != HB_Err_Not_Covered )
+    return error;
+
+  /* we don't accept glyphs covered in `GlyphClassDef' */
+
+  if ( !error )
+    return HB_Err_Not_Covered;
+
+  switch ( property )
+  {
+  case 0:
+    new_class = UNCLASSIFIED_GLYPH;
+    break;
+
+  case HB_GDEF_BASE_GLYPH:
+    new_class = SIMPLE_GLYPH;
+    break;
+
+  case HB_GDEF_LIGATURE:
+    new_class = LIGATURE_GLYPH;
+    break;
+
+  case HB_GDEF_MARK:
+    new_class = MARK_GLYPH;
+    break;
+
+  case HB_GDEF_COMPONENT:
+    new_class = COMPONENT_GLYPH;
+    break;
+
+  default:
+    return ERR(HB_Err_Invalid_Argument);
+  }
+
+  count = gdef->GlyphClassDef.cd.cd2.ClassRangeCount;
+  gcrr = gdef->GlyphClassDef.cd.cd2.ClassRangeRecord;
+  ngc  = gdef->NewGlyphClasses;
+
+  if ( index < count && glyphID < gcrr[index].Start )
+  {
+    array_index = index;
+    if ( index == 0 )
+      glyph_index = glyphID;
+    else
+      glyph_index = glyphID - gcrr[index - 1].End - 1;
+  }
+  else
+  {
+    array_index = index + 1;
+    glyph_index = glyphID - gcrr[index].End - 1;
+  }
+
+  byte  = ngc[array_index][glyph_index / 4];
+  bits  = byte >> ( 16 - ( glyph_index % 4 + 1 ) * 4 );
+  class = bits & 0x000F;
+
+  /* we don't overwrite existing entries */
+
+  if ( !class )
+  {
+    bits = new_class << ( 16 - ( glyph_index % 4 + 1 ) * 4 );
+    mask = ~( 0x000F << ( 16 - ( glyph_index % 4 + 1 ) * 4 ) );
+
+    ngc[array_index][glyph_index / 4] &= mask;
+    ngc[array_index][glyph_index / 4] |= bits;
+  }
+
+  return HB_Err_Ok;
+}
+
+
+HB_INTERNAL HB_Error
+_HB_GDEF_Check_Property( HB_GDEFHeader* gdef,
+			  HB_GlyphItem    gitem,
+			  HB_UShort        flags,
+			  HB_UShort*       property )
+{
+  HB_Error  error;
+
+  if ( gdef )
+  {
+    HB_UShort basic_glyph_class;
+    HB_UShort desired_attachment_class;
+
+    if ( gitem->gproperties == HB_GLYPH_PROPERTIES_UNKNOWN )
+    {
+      error = HB_GDEF_Get_Glyph_Property( gdef, gitem->gindex, &gitem->gproperties );
+      if ( error )
+	return error;
+    }
+
+    *property = gitem->gproperties;
+
+    /* If the glyph was found in the MarkAttachmentClass table,
+     * then that class value is the high byte of the result,
+     * otherwise the low byte contains the basic type of the glyph
+     * as defined by the GlyphClassDef table.
+     */
+    if ( *property & HB_LOOKUP_FLAG_IGNORE_SPECIAL_MARKS  )
+      basic_glyph_class = HB_GDEF_MARK;
+    else
+      basic_glyph_class = *property;
+
+    /* Return Not_Covered, if, for example, basic_glyph_class
+     * is HB_GDEF_LIGATURE and LookFlags includes HB_LOOKUP_FLAG_IGNORE_LIGATURES
+     */
+    if ( flags & basic_glyph_class )
+      return HB_Err_Not_Covered;
+    
+    /* The high byte of LookupFlags has the meaning
+     * "ignore marks of attachment type different than
+     * the attachment type specified."
+     */
+    desired_attachment_class = flags & HB_LOOKUP_FLAG_IGNORE_SPECIAL_MARKS;
+    if ( desired_attachment_class )
+    {
+      if ( basic_glyph_class == HB_GDEF_MARK &&
+	   *property != desired_attachment_class )
+	return HB_Err_Not_Covered;
+    }
+  } else {
+      *property = 0;
+  }
+
+  return HB_Err_Ok;
+}
+
+HB_INTERNAL HB_Error
+_HB_GDEF_LoadMarkAttachClassDef_From_LookupFlags( HB_GDEFHeader* gdef,
+						  HB_Stream      stream,
+						  HB_Lookup*     lo,
+						  HB_UShort      num_lookups)
+{
+  HB_Error   error = HB_Err_Ok;
+  HB_UShort  i;
+
+  /* We now check the LookupFlags for values larger than 0xFF to find
+     out whether we need to load the `MarkAttachClassDef' field of the
+     GDEF table -- this hack is necessary for OpenType 1.2 tables since
+     the version field of the GDEF table hasn't been incremented.
+
+     For constructed GDEF tables, we only load it if
+     `MarkAttachClassDef_offset' is not zero (nevertheless, a build of
+     a constructed mark attach table is not supported currently).       */
+
+  if ( gdef &&
+       gdef->MarkAttachClassDef_offset && !gdef->MarkAttachClassDef.loaded )
+  {
+    for ( i = 0; i < num_lookups; i++ )
+    {
+
+      if ( lo[i].LookupFlag & HB_LOOKUP_FLAG_IGNORE_SPECIAL_MARKS )
+      {
+	if ( FILE_Seek( gdef->MarkAttachClassDef_offset ) ||
+	     ( error = _HB_OPEN_Load_ClassDefinition( &gdef->MarkAttachClassDef,
+					     256, stream ) ) != HB_Err_Ok )
+	  goto Done;
+
+	break;
+      }
+    }
+  }
+
+Done:
+  return error;
+}
+
+/* END */
diff -rupN orginal/scribus/harfbuzz/harfbuzz-gdef.h patched/scribus/harfbuzz/harfbuzz-gdef.h
--- orginal/scribus/harfbuzz/harfbuzz-gdef.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/harfbuzz-gdef.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,135 @@
+/*
+ * Copyright (C) 1998-2004  David Turner and Werner Lemberg
+ * Copyright (C) 2006  Behdad Esfahbod
+ *
+ * This is part of HarfBuzz, an OpenType Layout engine library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ */
+
+#ifndef HARFBUZZ_GDEF_H
+#define HARFBUZZ_GDEF_H
+
+#include "harfbuzz-open.h"
+#include "harfbuzz-stream.h"
+
+HB_BEGIN_HEADER
+
+/* GDEF glyph properties.  Note that HB_GDEF_COMPONENT has no corresponding
+ * flag in the LookupFlag field.     */
+#define HB_GDEF_BASE_GLYPH  0x0002
+#define HB_GDEF_LIGATURE    0x0004
+#define HB_GDEF_MARK        0x0008
+#define HB_GDEF_COMPONENT   0x0010
+
+
+typedef struct HB_AttachPoint_  HB_AttachPoint;
+
+
+struct  HB_AttachList_
+{
+  HB_Bool           loaded;
+
+  HB_Coverage       Coverage;         /* Coverage table              */
+  HB_UShort         GlyphCount;       /* number of glyphs with
+					 attachments                 */
+  HB_AttachPoint*   AttachPoint;      /* array of AttachPoint tables */
+};
+
+typedef struct HB_AttachList_  HB_AttachList;
+
+typedef struct HB_LigGlyph_  HB_LigGlyph;
+
+struct  HB_LigCaretList_
+{
+  HB_Bool        loaded;
+
+  HB_Coverage    Coverage;            /* Coverage table            */
+  HB_UShort      LigGlyphCount;       /* number of ligature glyphs */
+  HB_LigGlyph*   LigGlyph;            /* array of LigGlyph tables  */
+};
+
+typedef struct HB_LigCaretList_  HB_LigCaretList;
+
+
+
+/* The `NewGlyphClasses' field is not defined in the TTO specification.
+   We use it for fonts with a constructed `GlyphClassDef' structure
+   (i.e., which don't have a GDEF table) to collect glyph classes
+   assigned during the lookup process.  The number of arrays in this
+   pointer array is GlyphClassDef->cd.cd2.ClassRangeCount+1; the nth
+   array then contains the glyph class values of the glyphs not covered
+   by the ClassRangeRecords structures with index n-1 and n.  We store
+   glyph class values for four glyphs in a single array element.
+
+   `LastGlyph' is identical to the number of glyphs minus one in the
+   font; we need it only if `NewGlyphClasses' is not NULL (to have an
+   upper bound for the last array).
+
+   Note that we first store the file offset to the `MarkAttachClassDef'
+   field (which has been introduced in OpenType 1.2) -- since the
+   `Version' field value hasn't been increased to indicate that we have
+   one more field for some obscure reason, we must parse the GSUB table
+   to find out whether class values refer to this table.  Only then we
+   can finally load the MarkAttachClassDef structure if necessary.      */
+
+struct  HB_GDEFHeader_
+{
+  HB_UInt             offset;
+
+  HB_16Dot16             Version;
+
+  HB_ClassDefinition   GlyphClassDef;
+  HB_AttachList        AttachList;
+  HB_LigCaretList      LigCaretList;
+  HB_UInt             MarkAttachClassDef_offset;
+  HB_ClassDefinition   MarkAttachClassDef;        /* new in OT 1.2 */
+
+  HB_UShort            LastGlyph;
+  HB_UShort**          NewGlyphClasses;
+};
+
+typedef struct HB_GDEFHeader_   HB_GDEFHeader;
+typedef struct HB_GDEFHeader_*  HB_GDEF;
+
+
+HB_Error  HB_New_GDEF_Table( HB_GDEFHeader** retptr );
+      
+
+HB_Error  HB_Load_GDEF_Table( HB_Stream       stream,
+			      HB_GDEFHeader** gdef );
+
+
+HB_Error  HB_Done_GDEF_Table ( HB_GDEFHeader* gdef );
+
+
+HB_Error  HB_GDEF_Get_Glyph_Property( HB_GDEFHeader*  gdef,
+				      HB_UShort        glyphID,
+				      HB_UShort*       property );
+
+HB_Error  HB_GDEF_Build_ClassDefinition( HB_GDEFHeader*  gdef,
+					 HB_UShort        num_glyphs,
+					 HB_UShort        glyph_count,
+					 HB_UShort*       glyph_array,
+					 HB_UShort*       class_array );
+
+
+HB_END_HEADER
+
+#endif /* HARFBUZZ_GDEF_H */
diff -rupN orginal/scribus/harfbuzz/harfbuzz-global.h patched/scribus/harfbuzz/harfbuzz-global.h
--- orginal/scribus/harfbuzz/harfbuzz-global.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/harfbuzz-global.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,118 @@
+/*
+ * Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies)
+ * Copyright (C) 2007  Red Hat, Inc.
+ *
+ * This is part of HarfBuzz, an OpenType Layout engine library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ */
+
+#ifndef HARFBUZZ_GLOBAL_H
+#define HARFBUZZ_GLOBAL_H
+
+#include <stdlib.h>
+#include <string.h>
+
+#ifdef __cplusplus
+#define HB_BEGIN_HEADER  extern "C" {
+#define HB_END_HEADER  }
+#else
+#define HB_BEGIN_HEADER  /* nothing */
+#define HB_END_HEADER  /* nothing */
+#endif
+
+HB_BEGIN_HEADER
+
+#ifndef FALSE
+#define FALSE 0
+#endif
+
+#ifndef TRUE
+#define TRUE (!FALSE)
+#endif
+
+#define HB_MAKE_TAG( _x1, _x2, _x3, _x4 ) \
+          ( ( (HB_UInt)_x1 << 24 ) |     \
+            ( (HB_UInt)_x2 << 16 ) |     \
+            ( (HB_UInt)_x3 <<  8 ) |     \
+              (HB_UInt)_x4         )
+
+typedef char hb_int8;
+typedef unsigned char hb_uint8;
+typedef short hb_int16;
+typedef unsigned short hb_uint16;
+typedef int hb_int32;
+typedef unsigned int hb_uint32;
+
+typedef hb_uint8 HB_Bool;
+
+typedef hb_uint8 HB_Byte;
+typedef hb_uint16 HB_UShort;
+typedef hb_uint32 HB_UInt;
+typedef hb_int8 HB_Char;
+typedef hb_int16 HB_Short;
+typedef hb_int32 HB_Int;
+
+typedef hb_uint16 HB_UChar16;
+typedef hb_uint32 HB_UChar32;
+typedef hb_uint32 HB_Glyph;
+typedef hb_int32 HB_Fixed; /* 26.6 */
+
+#define HB_FIXED_CONSTANT(v) ((v) * 64)
+#define HB_FIXED_ROUND(v) (((v)+32) & -64)
+
+typedef hb_int32 HB_16Dot16; /* 16.16 */
+
+typedef void * HB_Pointer;
+typedef hb_uint32 HB_Tag;
+
+typedef enum {
+  /* no error */
+  HB_Err_Ok                           = 0x0000,
+  HB_Err_Not_Covered                  = 0xFFFF,
+
+  /* _hb_err() is called whenever returning the following errors,
+   * and in a couple places for HB_Err_Not_Covered too. */
+
+  /* programmer error */
+  HB_Err_Invalid_Argument             = 0x1A66,
+
+  /* font error */
+  HB_Err_Invalid_SubTable_Format      = 0x157F,
+  HB_Err_Invalid_SubTable             = 0x1570,
+  HB_Err_Read_Error                   = 0x6EAD,
+
+  /* system error */
+  HB_Err_Out_Of_Memory                = 0xDEAD
+} HB_Error;
+
+typedef struct {
+    HB_Fixed x;
+    HB_Fixed y;
+} HB_FixedPoint;
+
+typedef struct HB_Font_ *HB_Font;
+typedef struct HB_StreamRec_ *HB_Stream;
+typedef struct HB_FaceRec_ *HB_Face;
+
+HB_END_HEADER
+
+#endif
diff -rupN orginal/scribus/harfbuzz/harfbuzz-gpos-private.h patched/scribus/harfbuzz/harfbuzz-gpos-private.h
--- orginal/scribus/harfbuzz/harfbuzz-gpos-private.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/harfbuzz-gpos-private.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,712 @@
+/*
+ * Copyright (C) 1998-2004  David Turner and Werner Lemberg
+ * Copyright (C) 2006  Behdad Esfahbod
+ *
+ * This is part of HarfBuzz, an OpenType Layout engine library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ */
+
+#ifndef HARFBUZZ_GPOS_PRIVATE_H
+#define HARFBUZZ_GPOS_PRIVATE_H
+
+#include "harfbuzz-impl.h"
+#include "harfbuzz-stream-private.h"
+#include "harfbuzz-gpos.h"
+
+HB_BEGIN_HEADER
+
+
+/* shared tables */
+
+struct  HB_ValueRecord_
+{
+  HB_Short    XPlacement;             /* horizontal adjustment for
+					 placement                      */
+  HB_Short    YPlacement;             /* vertical adjustment for
+					 placement                      */
+  HB_Short    XAdvance;               /* horizontal adjustment for
+					 advance                        */
+  HB_Short    YAdvance;               /* vertical adjustment for
+					 advance                        */
+  HB_Device  XPlacementDevice;       /* device table for horizontal
+					 placement                      */
+  HB_Device  YPlacementDevice;       /* device table for vertical
+					 placement                      */
+  HB_Device  XAdvanceDevice;         /* device table for horizontal
+					 advance                        */
+  HB_Device  YAdvanceDevice;         /* device table for vertical
+					 advance                        */
+  HB_UShort   XIdPlacement;           /* horizontal placement metric ID */
+  HB_UShort   YIdPlacement;           /* vertical placement metric ID   */
+  HB_UShort   XIdAdvance;             /* horizontal advance metric ID   */
+  HB_UShort   YIdAdvance;             /* vertical advance metric ID     */
+};
+
+typedef struct HB_ValueRecord_  HB_ValueRecord;
+
+
+/* Mask values to scan the value format of the ValueRecord structure.
+ We always expand compressed ValueRecords of the font.              */
+
+#define HB_GPOS_FORMAT_HAVE_X_PLACEMENT         0x0001
+#define HB_GPOS_FORMAT_HAVE_Y_PLACEMENT         0x0002
+#define HB_GPOS_FORMAT_HAVE_X_ADVANCE           0x0004
+#define HB_GPOS_FORMAT_HAVE_Y_ADVANCE           0x0008
+#define HB_GPOS_FORMAT_HAVE_X_PLACEMENT_DEVICE  0x0010
+#define HB_GPOS_FORMAT_HAVE_Y_PLACEMENT_DEVICE  0x0020
+#define HB_GPOS_FORMAT_HAVE_X_ADVANCE_DEVICE    0x0040
+#define HB_GPOS_FORMAT_HAVE_Y_ADVANCE_DEVICE    0x0080
+#define HB_GPOS_FORMAT_HAVE_X_ID_PLACEMENT      0x0100
+#define HB_GPOS_FORMAT_HAVE_Y_ID_PLACEMENT      0x0200
+#define HB_GPOS_FORMAT_HAVE_X_ID_ADVANCE        0x0400
+#define HB_GPOS_FORMAT_HAVE_Y_ID_ADVANCE        0x0800
+
+
+struct  HB_AnchorFormat1_
+{
+  HB_Short   XCoordinate;             /* horizontal value */
+  HB_Short   YCoordinate;             /* vertical value   */
+};
+
+typedef struct HB_AnchorFormat1_  HB_AnchorFormat1;
+
+
+struct  HB_AnchorFormat2_
+{
+  HB_Short   XCoordinate;             /* horizontal value             */
+  HB_Short   YCoordinate;             /* vertical value               */
+  HB_UShort  AnchorPoint;             /* index to glyph contour point */
+};
+
+typedef struct HB_AnchorFormat2_  HB_AnchorFormat2;
+
+
+struct  HB_AnchorFormat3_
+{
+  HB_Short    XCoordinate;            /* horizontal value              */
+  HB_Short    YCoordinate;            /* vertical value                */
+  HB_Device  XDeviceTable;           /* device table for X coordinate */
+  HB_Device  YDeviceTable;           /* device table for Y coordinate */
+};
+
+typedef struct HB_AnchorFormat3_  HB_AnchorFormat3;
+
+
+struct  HB_AnchorFormat4_
+{
+  HB_UShort  XIdAnchor;               /* horizontal metric ID */
+  HB_UShort  YIdAnchor;               /* vertical metric ID   */
+};
+
+typedef struct HB_AnchorFormat4_  HB_AnchorFormat4;
+
+
+struct  HB_Anchor_
+{
+  HB_UShort  PosFormat;               /* 1, 2, 3, or 4 -- 0 indicates
+					 that there is no Anchor table */
+
+  union
+  {
+    HB_AnchorFormat1  af1;
+    HB_AnchorFormat2  af2;
+    HB_AnchorFormat3  af3;
+    HB_AnchorFormat4  af4;
+  } af;
+};
+
+typedef struct HB_Anchor_  HB_Anchor;
+
+
+struct  HB_MarkRecord_
+{
+  HB_UShort   Class;                  /* mark class   */
+  HB_Anchor  MarkAnchor;             /* anchor table */
+};
+
+typedef struct HB_MarkRecord_  HB_MarkRecord;
+
+
+struct  HB_MarkArray_
+{
+  HB_UShort        MarkCount;         /* number of MarkRecord tables */
+  HB_MarkRecord*  MarkRecord;        /* array of MarkRecord tables  */
+};
+
+typedef struct HB_MarkArray_  HB_MarkArray;
+
+
+/* LookupType 1 */
+
+struct  HB_SinglePosFormat1_
+{
+  HB_ValueRecord  Value;             /* ValueRecord for all covered
+					 glyphs                      */
+};
+
+typedef struct HB_SinglePosFormat1_  HB_SinglePosFormat1;
+
+
+struct  HB_SinglePosFormat2_
+{
+  HB_UShort         ValueCount;       /* number of ValueRecord tables */
+  HB_ValueRecord*  Value;            /* array of ValueRecord tables  */
+};
+
+typedef struct HB_SinglePosFormat2_  HB_SinglePosFormat2;
+
+
+struct  HB_SinglePos_
+{
+  HB_UShort     PosFormat;            /* 1 or 2         */
+  HB_Coverage  Coverage;             /* Coverage table */
+
+  HB_UShort     ValueFormat;          /* format of ValueRecord table */
+
+  union
+  {
+    HB_SinglePosFormat1  spf1;
+    HB_SinglePosFormat2  spf2;
+  } spf;
+};
+
+typedef struct HB_SinglePos_  HB_SinglePos;
+
+
+/* LookupType 2 */
+
+struct  HB_PairValueRecord_
+{
+  HB_UShort        SecondGlyph;       /* glyph ID for second glyph  */
+  HB_ValueRecord  Value1;            /* pos. data for first glyph  */
+  HB_ValueRecord  Value2;            /* pos. data for second glyph */
+};
+
+typedef struct HB_PairValueRecord_  HB_PairValueRecord;
+
+
+struct  HB_PairSet_
+{
+  HB_UShort             PairValueCount;
+				      /* number of PairValueRecord tables */
+  HB_PairValueRecord*  PairValueRecord;
+				      /* array of PairValueRecord tables  */
+};
+
+typedef struct HB_PairSet_  HB_PairSet;
+
+
+struct  HB_PairPosFormat1_
+{
+  HB_UShort     PairSetCount;         /* number of PairSet tables    */
+  HB_PairSet*  PairSet;              /* array of PairSet tables     */
+};
+
+typedef struct HB_PairPosFormat1_  HB_PairPosFormat1;
+
+
+struct  HB_Class2Record_
+{
+  HB_ValueRecord  Value1;            /* pos. data for first glyph  */
+  HB_ValueRecord  Value2;            /* pos. data for second glyph */
+};
+
+typedef struct HB_Class2Record_  HB_Class2Record;
+
+
+struct  HB_Class1Record_
+{
+  HB_Class2Record*  Class2Record;    /* array of Class2Record tables */
+};
+
+typedef struct HB_Class1Record_  HB_Class1Record;
+
+
+struct  HB_PairPosFormat2_
+{
+  HB_ClassDefinition  ClassDef1;     /* class def. for first glyph     */
+  HB_ClassDefinition  ClassDef2;     /* class def. for second glyph    */
+  HB_UShort            Class1Count;   /* number of classes in ClassDef1
+					 table                          */
+  HB_UShort            Class2Count;   /* number of classes in ClassDef2
+					 table                          */
+  HB_Class1Record*    Class1Record;  /* array of Class1Record tables   */
+};
+
+typedef struct HB_PairPosFormat2_  HB_PairPosFormat2;
+
+
+struct  HB_PairPos_
+{
+  HB_UShort     PosFormat;            /* 1 or 2         */
+  HB_Coverage  Coverage;             /* Coverage table */
+  HB_UShort     ValueFormat1;         /* format of ValueRecord table
+					 for first glyph             */
+  HB_UShort     ValueFormat2;         /* format of ValueRecord table
+					 for second glyph            */
+
+  union
+  {
+    HB_PairPosFormat1  ppf1;
+    HB_PairPosFormat2  ppf2;
+  } ppf;
+};
+
+typedef struct HB_PairPos_  HB_PairPos;
+
+
+/* LookupType 3 */
+
+struct  HB_EntryExitRecord_
+{
+  HB_Anchor  EntryAnchor;            /* entry Anchor table */
+  HB_Anchor  ExitAnchor;             /* exit Anchor table  */
+};
+
+
+typedef struct HB_EntryExitRecord_  HB_EntryExitRecord;
+
+struct  HB_CursivePos_
+{
+  HB_UShort             PosFormat;    /* always 1                         */
+  HB_Coverage          Coverage;     /* Coverage table                   */
+  HB_UShort             EntryExitCount;
+				      /* number of EntryExitRecord tables */
+  HB_EntryExitRecord*  EntryExitRecord;
+				      /* array of EntryExitRecord tables  */
+};
+
+typedef struct HB_CursivePos_  HB_CursivePos;
+
+
+/* LookupType 4 */
+
+struct  HB_BaseRecord_
+{
+  HB_Anchor*  BaseAnchor;            /* array of base glyph anchor
+					 tables                     */
+};
+
+typedef struct HB_BaseRecord_  HB_BaseRecord;
+
+
+struct  HB_BaseArray_
+{
+  HB_UShort        BaseCount;         /* number of BaseRecord tables */
+  HB_BaseRecord*  BaseRecord;        /* array of BaseRecord tables  */
+};
+
+typedef struct HB_BaseArray_  HB_BaseArray;
+
+
+struct  HB_MarkBasePos_
+{
+  HB_UShort      PosFormat;           /* always 1                  */
+  HB_Coverage   MarkCoverage;        /* mark glyph coverage table */
+  HB_Coverage   BaseCoverage;        /* base glyph coverage table */
+  HB_UShort      ClassCount;          /* number of mark classes    */
+  HB_MarkArray  MarkArray;           /* mark array table          */
+  HB_BaseArray  BaseArray;           /* base array table          */
+};
+
+typedef struct HB_MarkBasePos_  HB_MarkBasePos;
+
+
+/* LookupType 5 */
+
+struct  HB_ComponentRecord_
+{
+  HB_Anchor*  LigatureAnchor;        /* array of ligature glyph anchor
+					 tables                         */
+};
+
+typedef struct HB_ComponentRecord_  HB_ComponentRecord;
+
+
+struct  HB_LigatureAttach_
+{
+  HB_UShort             ComponentCount;
+				      /* number of ComponentRecord tables */
+  HB_ComponentRecord*  ComponentRecord;
+				      /* array of ComponentRecord tables  */
+};
+
+typedef struct HB_LigatureAttach_  HB_LigatureAttach;
+
+
+struct  HB_LigatureArray_
+{
+  HB_UShort            LigatureCount; /* number of LigatureAttach tables */
+  HB_LigatureAttach*  LigatureAttach;
+				      /* array of LigatureAttach tables  */
+};
+
+typedef struct HB_LigatureArray_  HB_LigatureArray;
+
+
+struct  HB_MarkLigPos_
+{
+  HB_UShort          PosFormat;       /* always 1                      */
+  HB_Coverage       MarkCoverage;    /* mark glyph coverage table     */
+  HB_Coverage       LigatureCoverage;
+				      /* ligature glyph coverage table */
+  HB_UShort          ClassCount;      /* number of mark classes        */
+  HB_MarkArray      MarkArray;       /* mark array table              */
+  HB_LigatureArray  LigatureArray;   /* ligature array table          */
+};
+
+typedef struct HB_MarkLigPos_  HB_MarkLigPos;
+
+
+/* LookupType 6 */
+
+struct  HB_Mark2Record_
+{
+  HB_Anchor*  Mark2Anchor;           /* array of mark glyph anchor
+					 tables                     */
+};
+
+typedef struct HB_Mark2Record_  HB_Mark2Record;
+
+
+struct  HB_Mark2Array_
+{
+  HB_UShort         Mark2Count;       /* number of Mark2Record tables */
+  HB_Mark2Record*  Mark2Record;      /* array of Mark2Record tables  */
+};
+
+typedef struct HB_Mark2Array_  HB_Mark2Array;
+
+
+struct  HB_MarkMarkPos_
+{
+  HB_UShort       PosFormat;          /* always 1                         */
+  HB_Coverage    Mark1Coverage;      /* first mark glyph coverage table  */
+  HB_Coverage    Mark2Coverage;      /* second mark glyph coverave table */
+  HB_UShort       ClassCount;         /* number of combining mark classes */
+  HB_MarkArray   Mark1Array;         /* MarkArray table for first mark   */
+  HB_Mark2Array  Mark2Array;         /* MarkArray table for second mark  */
+};
+
+typedef struct HB_MarkMarkPos_  HB_MarkMarkPos;
+
+
+/* needed by both lookup type 7 and 8 */
+
+struct  HB_PosLookupRecord_
+{
+  HB_UShort  SequenceIndex;           /* index into current
+					 glyph sequence               */
+  HB_UShort  LookupListIndex;         /* Lookup to apply to that pos. */
+};
+
+typedef struct HB_PosLookupRecord_  HB_PosLookupRecord;
+
+
+/* LookupType 7 */
+
+struct  HB_PosRule_
+{
+  HB_UShort             GlyphCount;   /* total number of input glyphs     */
+  HB_UShort             PosCount;     /* number of PosLookupRecord tables */
+  HB_UShort*            Input;        /* array of input glyph IDs         */
+  HB_PosLookupRecord*  PosLookupRecord;
+				      /* array of PosLookupRecord tables  */
+};
+
+typedef struct HB_PosRule_  HB_PosRule;
+
+
+struct  HB_PosRuleSet_
+{
+  HB_UShort     PosRuleCount;         /* number of PosRule tables */
+  HB_PosRule*  PosRule;              /* array of PosRule tables  */
+};
+
+typedef struct HB_PosRuleSet_  HB_PosRuleSet;
+
+
+struct  HB_ContextPosFormat1_
+{
+  HB_Coverage     Coverage;          /* Coverage table              */
+  HB_UShort        PosRuleSetCount;   /* number of PosRuleSet tables */
+  HB_PosRuleSet*  PosRuleSet;        /* array of PosRuleSet tables  */
+};
+
+typedef struct HB_ContextPosFormat1_  HB_ContextPosFormat1;
+
+
+struct  HB_PosClassRule_
+{
+  HB_UShort             GlyphCount;   /* total number of context classes  */
+  HB_UShort             PosCount;     /* number of PosLookupRecord tables */
+  HB_UShort*            Class;        /* array of classes                 */
+  HB_PosLookupRecord*  PosLookupRecord;
+				      /* array of PosLookupRecord tables  */
+};
+
+typedef struct HB_PosClassRule_  HB_PosClassRule;
+
+
+struct  HB_PosClassSet_
+{
+  HB_UShort          PosClassRuleCount;
+				      /* number of PosClassRule tables */
+  HB_PosClassRule*  PosClassRule;    /* array of PosClassRule tables  */
+};
+
+typedef struct HB_PosClassSet_  HB_PosClassSet;
+
+
+/* The `MaxContextLength' field is not defined in the TTO specification
+   but simplifies the implementation of this format.  It holds the
+   maximal context length used in the context rules.                    */
+
+struct  HB_ContextPosFormat2_
+{
+  HB_UShort            MaxContextLength;
+				      /* maximal context length       */
+  HB_Coverage         Coverage;      /* Coverage table               */
+  HB_ClassDefinition  ClassDef;      /* ClassDef table               */
+  HB_UShort            PosClassSetCount;
+				      /* number of PosClassSet tables */
+  HB_PosClassSet*     PosClassSet;   /* array of PosClassSet tables  */
+};
+
+typedef struct HB_ContextPosFormat2_  HB_ContextPosFormat2;
+
+
+struct  HB_ContextPosFormat3_
+{
+  HB_UShort             GlyphCount;   /* number of input glyphs           */
+  HB_UShort             PosCount;     /* number of PosLookupRecord tables */
+  HB_Coverage*         Coverage;     /* array of Coverage tables         */
+  HB_PosLookupRecord*  PosLookupRecord;
+				      /* array of PosLookupRecord tables  */
+};
+
+typedef struct HB_ContextPosFormat3_  HB_ContextPosFormat3;
+
+
+struct  HB_ContextPos_
+{
+  HB_UShort  PosFormat;               /* 1, 2, or 3     */
+
+  union
+  {
+    HB_ContextPosFormat1  cpf1;
+    HB_ContextPosFormat2  cpf2;
+    HB_ContextPosFormat3  cpf3;
+  } cpf;
+};
+
+typedef struct HB_ContextPos_  HB_ContextPos;
+
+
+/* LookupType 8 */
+
+struct  HB_ChainPosRule_
+{
+  HB_UShort             BacktrackGlyphCount;
+				      /* total number of backtrack glyphs */
+  HB_UShort*            Backtrack;    /* array of backtrack glyph IDs     */
+  HB_UShort             InputGlyphCount;
+				      /* total number of input glyphs     */
+  HB_UShort*            Input;        /* array of input glyph IDs         */
+  HB_UShort             LookaheadGlyphCount;
+				      /* total number of lookahead glyphs */
+  HB_UShort*            Lookahead;    /* array of lookahead glyph IDs     */
+  HB_UShort             PosCount;     /* number of PosLookupRecords       */
+  HB_PosLookupRecord*  PosLookupRecord;
+				      /* array of PosLookupRecords       */
+};
+
+typedef struct HB_ChainPosRule_  HB_ChainPosRule;
+
+
+struct  HB_ChainPosRuleSet_
+{
+  HB_UShort          ChainPosRuleCount;
+				      /* number of ChainPosRule tables */
+  HB_ChainPosRule*  ChainPosRule;    /* array of ChainPosRule tables  */
+};
+
+typedef struct HB_ChainPosRuleSet_  HB_ChainPosRuleSet;
+
+
+struct  HB_ChainContextPosFormat1_
+{
+  HB_Coverage          Coverage;     /* Coverage table                   */
+  HB_UShort             ChainPosRuleSetCount;
+				      /* number of ChainPosRuleSet tables */
+  HB_ChainPosRuleSet*  ChainPosRuleSet;
+				      /* array of ChainPosRuleSet tables  */
+};
+
+typedef struct HB_ChainContextPosFormat1_  HB_ChainContextPosFormat1;
+
+
+struct  HB_ChainPosClassRule_
+{
+  HB_UShort             BacktrackGlyphCount;
+				      /* total number of backtrack
+					 classes                         */
+  HB_UShort*            Backtrack;    /* array of backtrack classes      */
+  HB_UShort             InputGlyphCount;
+				      /* total number of context classes */
+  HB_UShort*            Input;        /* array of context classes        */
+  HB_UShort             LookaheadGlyphCount;
+				      /* total number of lookahead
+					 classes                         */
+  HB_UShort*            Lookahead;    /* array of lookahead classes      */
+  HB_UShort             PosCount;     /* number of PosLookupRecords      */
+  HB_PosLookupRecord*  PosLookupRecord;
+				      /* array of substitution lookups   */
+};
+
+typedef struct HB_ChainPosClassRule_  HB_ChainPosClassRule;
+
+
+struct  HB_ChainPosClassSet_
+{
+  HB_UShort               ChainPosClassRuleCount;
+				      /* number of ChainPosClassRule
+					 tables                      */
+  HB_ChainPosClassRule*  ChainPosClassRule;
+				      /* array of ChainPosClassRule
+					 tables                      */
+};
+
+typedef struct HB_ChainPosClassSet_  HB_ChainPosClassSet;
+
+
+/* The `MaxXXXLength' fields are not defined in the TTO specification
+   but simplifies the implementation of this format.  It holds the
+   maximal context length used in the specific context rules.         */
+
+struct  HB_ChainContextPosFormat2_
+{
+  HB_Coverage           Coverage;    /* Coverage table             */
+
+  HB_UShort              MaxBacktrackLength;
+				      /* maximal backtrack length   */
+  HB_ClassDefinition    BacktrackClassDef;
+				      /* BacktrackClassDef table    */
+  HB_UShort              MaxInputLength;
+				      /* maximal input length       */
+  HB_ClassDefinition    InputClassDef;
+				      /* InputClassDef table        */
+  HB_UShort              MaxLookaheadLength;
+				      /* maximal lookahead length   */
+  HB_ClassDefinition    LookaheadClassDef;
+				      /* LookaheadClassDef table    */
+
+  HB_UShort              ChainPosClassSetCount;
+				      /* number of ChainPosClassSet
+					 tables                     */
+  HB_ChainPosClassSet*  ChainPosClassSet;
+				      /* array of ChainPosClassSet
+					 tables                     */
+};
+
+typedef struct HB_ChainContextPosFormat2_  HB_ChainContextPosFormat2;
+
+
+struct  HB_ChainContextPosFormat3_
+{
+  HB_UShort             BacktrackGlyphCount;
+				      /* number of backtrack glyphs    */
+  HB_Coverage*         BacktrackCoverage;
+				      /* array of backtrack Coverage
+					 tables                        */
+  HB_UShort             InputGlyphCount;
+				      /* number of input glyphs        */
+  HB_Coverage*         InputCoverage;
+				      /* array of input coverage
+					 tables                        */
+  HB_UShort             LookaheadGlyphCount;
+				      /* number of lookahead glyphs    */
+  HB_Coverage*         LookaheadCoverage;
+				      /* array of lookahead coverage
+					 tables                        */
+  HB_UShort             PosCount;     /* number of PosLookupRecords    */
+  HB_PosLookupRecord*  PosLookupRecord;
+				      /* array of substitution lookups */
+};
+
+typedef struct HB_ChainContextPosFormat3_  HB_ChainContextPosFormat3;
+
+
+struct  HB_ChainContextPos_
+{
+  HB_UShort  PosFormat;             /* 1, 2, or 3 */
+
+  union
+  {
+    HB_ChainContextPosFormat1  ccpf1;
+    HB_ChainContextPosFormat2  ccpf2;
+    HB_ChainContextPosFormat3  ccpf3;
+  } ccpf;
+};
+
+typedef struct HB_ChainContextPos_  HB_ChainContextPos;
+
+
+#if 0
+/* LookupType 10 */
+struct HB_ExtensionPos_
+{
+  HB_UShort      PosFormat;           /* always 1 */
+  HB_UShort      LookuptType;         /* lookup-type of referenced subtable */
+  HB_GPOS_SubTable *subtable;         /* referenced subtable */
+};
+
+typedef struct HB_ExtensionPos_  HB_ExtensionPos;
+#endif
+
+
+union  HB_GPOS_SubTable_
+{
+  HB_SinglePos        single;
+  HB_PairPos          pair;
+  HB_CursivePos       cursive;
+  HB_MarkBasePos      markbase;
+  HB_MarkLigPos       marklig;
+  HB_MarkMarkPos      markmark;
+  HB_ContextPos       context;
+  HB_ChainContextPos  chain;
+};
+
+typedef union HB_GPOS_SubTable_  HB_GPOS_SubTable;
+
+
+
+HB_INTERNAL HB_Error
+_HB_GPOS_Load_SubTable( HB_GPOS_SubTable* st,
+				  HB_Stream     stream,
+				  HB_UShort     lookup_type );
+
+HB_INTERNAL void
+_HB_GPOS_Free_SubTable( HB_GPOS_SubTable* st,
+			      HB_UShort     lookup_type );
+
+HB_END_HEADER
+
+#endif /* HARFBUZZ_GPOS_PRIVATE_H */
diff -rupN orginal/scribus/harfbuzz/harfbuzz-gpos.c patched/scribus/harfbuzz/harfbuzz-gpos.c
--- orginal/scribus/harfbuzz/harfbuzz-gpos.c	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/harfbuzz-gpos.c	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,6055 @@
+/*
+ * Copyright (C) 1998-2004  David Turner and Werner Lemberg
+ * Copyright (C) 2006  Behdad Esfahbod
+ * Copyright (C) 2007  Red Hat, Inc.
+ *
+ * This is part of HarfBuzz, an OpenType Layout engine library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ */
+
+#include "harfbuzz-impl.h"
+#include "harfbuzz-gpos-private.h"
+#include "harfbuzz-open-private.h"
+#include "harfbuzz-gdef-private.h"
+#include "harfbuzz-shaper.h"
+
+struct  GPOS_Instance_
+{
+  HB_GPOSHeader*  gpos;
+  HB_Font          font;
+  HB_Bool          dvi;
+  HB_UShort        load_flags;  /* how the glyph should be loaded */
+  HB_Bool          r2l;
+
+  HB_UShort        last;        /* the last valid glyph -- used
+				   with cursive positioning     */
+  HB_Fixed           anchor_x;    /* the coordinates of the anchor point */
+  HB_Fixed           anchor_y;    /* of the last valid glyph             */
+};
+
+typedef struct GPOS_Instance_  GPOS_Instance;
+
+
+static HB_Error  GPOS_Do_Glyph_Lookup( GPOS_Instance*    gpi,
+				       HB_UShort         lookup_index,
+				       HB_Buffer        buffer,
+				       HB_UShort         context_length,
+				       int               nesting_level );
+
+
+
+/* the client application must replace this with something more
+   meaningful if multiple master fonts are to be supported.     */
+
+static HB_Error  default_mmfunc( HB_Font      font,
+				 HB_UShort    metric_id,
+				 HB_Fixed*      metric_value,
+				 void*        data )
+{
+  HB_UNUSED(font);
+  HB_UNUSED(metric_id);
+  HB_UNUSED(metric_value);
+  HB_UNUSED(data);
+  return ERR(HB_Err_Not_Covered); /* ERR() call intended */
+}
+
+
+
+HB_Error  HB_Load_GPOS_Table( HB_Stream stream, 
+			      HB_GPOSHeader** retptr,
+			      HB_GDEFHeader*  gdef,
+			      HB_Stream       gdefStream )
+{
+  HB_UInt         cur_offset, new_offset, base_offset;
+
+  HB_GPOSHeader*  gpos;
+
+  HB_Error   error;
+
+
+  if ( !retptr )
+    return ERR(HB_Err_Invalid_Argument);
+
+  if ( GOTO_Table( TTAG_GPOS ) )
+    return error;
+
+  base_offset = FILE_Pos();
+
+  if ( ALLOC ( gpos, sizeof( *gpos ) ) )
+    return error;
+
+  gpos->mmfunc = default_mmfunc;
+
+  /* skip version */
+
+  if ( FILE_Seek( base_offset + 4L ) ||
+       ACCESS_Frame( 2L ) )
+    goto Fail4;
+
+  new_offset = GET_UShort() + base_offset;
+
+  FORGET_Frame();
+
+  cur_offset = FILE_Pos();
+  if ( FILE_Seek( new_offset ) ||
+       ( error = _HB_OPEN_Load_ScriptList( &gpos->ScriptList,
+				  stream ) ) != HB_Err_Ok )
+    goto Fail4;
+  (void)FILE_Seek( cur_offset );
+
+  if ( ACCESS_Frame( 2L ) )
+    goto Fail3;
+
+  new_offset = GET_UShort() + base_offset;
+
+  FORGET_Frame();
+
+  cur_offset = FILE_Pos();
+  if ( FILE_Seek( new_offset ) ||
+       ( error = _HB_OPEN_Load_FeatureList( &gpos->FeatureList,
+				   stream ) ) != HB_Err_Ok )
+    goto Fail3;
+  (void)FILE_Seek( cur_offset );
+
+  if ( ACCESS_Frame( 2L ) )
+    goto Fail2;
+
+  new_offset = GET_UShort() + base_offset;
+
+  FORGET_Frame();
+
+  cur_offset = FILE_Pos();
+  if ( FILE_Seek( new_offset ) ||
+       ( error = _HB_OPEN_Load_LookupList( &gpos->LookupList,
+				  stream, HB_Type_GPOS ) ) != HB_Err_Ok )
+    goto Fail2;
+
+  gpos->gdef = gdef;      /* can be NULL */
+
+  if ( ( error =  _HB_GDEF_LoadMarkAttachClassDef_From_LookupFlags( gdef, gdefStream,
+								     gpos->LookupList.Lookup,
+								     gpos->LookupList.LookupCount ) ) )
+    goto Fail1;
+
+  *retptr = gpos;
+
+  return HB_Err_Ok;
+
+Fail1:
+  _HB_OPEN_Free_LookupList( &gpos->LookupList, HB_Type_GPOS );
+
+Fail2:
+  _HB_OPEN_Free_FeatureList( &gpos->FeatureList );
+
+Fail3:
+  _HB_OPEN_Free_ScriptList( &gpos->ScriptList );
+
+Fail4:
+  FREE( gpos );
+
+  return error;
+}
+
+
+HB_Error  HB_Done_GPOS_Table( HB_GPOSHeader* gpos )
+{
+  _HB_OPEN_Free_LookupList( &gpos->LookupList, HB_Type_GPOS );
+  _HB_OPEN_Free_FeatureList( &gpos->FeatureList );
+  _HB_OPEN_Free_ScriptList( &gpos->ScriptList );
+
+  FREE( gpos );
+
+  return HB_Err_Ok;
+}
+
+
+/*****************************
+ * SubTable related functions
+ *****************************/
+
+/* shared tables */
+
+/* ValueRecord */
+
+/* There is a subtle difference in the specs between a `table' and a
+   `record' -- offsets for device tables in ValueRecords are taken from
+   the parent table and not the parent record.                          */
+
+static HB_Error  Load_ValueRecord( HB_ValueRecord*  vr,
+				   HB_UShort         format,
+				   HB_UInt          base_offset,
+				   HB_Stream         stream )
+{
+  HB_Error  error;
+
+  HB_UInt cur_offset, new_offset;
+
+
+  if ( format & HB_GPOS_FORMAT_HAVE_X_PLACEMENT )
+  {
+    if ( ACCESS_Frame( 2L ) )
+      return error;
+
+    vr->XPlacement = GET_Short();
+
+    FORGET_Frame();
+  }
+  else
+    vr->XPlacement = 0;
+
+  if ( format & HB_GPOS_FORMAT_HAVE_Y_PLACEMENT )
+  {
+    if ( ACCESS_Frame( 2L ) )
+      return error;
+
+    vr->YPlacement = GET_Short();
+
+    FORGET_Frame();
+  }
+  else
+    vr->YPlacement = 0;
+
+  if ( format & HB_GPOS_FORMAT_HAVE_X_ADVANCE )
+  {
+    if ( ACCESS_Frame( 2L ) )
+      return error;
+
+    vr->XAdvance = GET_Short();
+
+    FORGET_Frame();
+  }
+  else
+    vr->XAdvance = 0;
+
+  if ( format & HB_GPOS_FORMAT_HAVE_Y_ADVANCE )
+  {
+    if ( ACCESS_Frame( 2L ) )
+      return error;
+
+    vr->YAdvance = GET_Short();
+
+    FORGET_Frame();
+  }
+  else
+    vr->YAdvance = 0;
+
+  if ( format & HB_GPOS_FORMAT_HAVE_X_PLACEMENT_DEVICE )
+  {
+    if ( ACCESS_Frame( 2L ) )
+      return error;
+
+    new_offset = GET_UShort();
+
+    FORGET_Frame();
+
+    if ( new_offset )
+    {
+      new_offset += base_offset;
+
+      cur_offset = FILE_Pos();
+      if ( FILE_Seek( new_offset ) ||
+	   ( error = _HB_OPEN_Load_Device( &vr->XPlacementDevice,
+				  stream ) ) != HB_Err_Ok )
+	return error;
+      (void)FILE_Seek( cur_offset );
+    }
+    else
+      goto empty1;
+  }
+  else
+  {
+  empty1:
+    vr->XPlacementDevice.StartSize  = 0;
+    vr->XPlacementDevice.EndSize    = 0;
+    vr->XPlacementDevice.DeltaValue = NULL;
+  }
+
+  if ( format & HB_GPOS_FORMAT_HAVE_Y_PLACEMENT_DEVICE )
+  {
+    if ( ACCESS_Frame( 2L ) )
+      goto Fail3;
+
+    new_offset = GET_UShort();
+
+    FORGET_Frame();
+
+    if ( new_offset )
+    {
+      new_offset += base_offset;
+
+      cur_offset = FILE_Pos();
+      if ( FILE_Seek( new_offset ) ||
+	   ( error = _HB_OPEN_Load_Device( &vr->YPlacementDevice,
+				  stream ) ) != HB_Err_Ok )
+	goto Fail3;
+      (void)FILE_Seek( cur_offset );
+    }
+    else
+      goto empty2;
+  }
+  else
+  {
+  empty2:
+    vr->YPlacementDevice.StartSize  = 0;
+    vr->YPlacementDevice.EndSize    = 0;
+    vr->YPlacementDevice.DeltaValue = NULL;
+  }
+
+  if ( format & HB_GPOS_FORMAT_HAVE_X_ADVANCE_DEVICE )
+  {
+    if ( ACCESS_Frame( 2L ) )
+      goto Fail2;
+
+    new_offset = GET_UShort();
+
+    FORGET_Frame();
+
+    if ( new_offset )
+    {
+      new_offset += base_offset;
+
+      cur_offset = FILE_Pos();
+      if ( FILE_Seek( new_offset ) ||
+	   ( error = _HB_OPEN_Load_Device( &vr->XAdvanceDevice,
+				  stream ) ) != HB_Err_Ok )
+	goto Fail2;
+      (void)FILE_Seek( cur_offset );
+    }
+    else
+      goto empty3;
+  }
+  else
+  {
+  empty3:
+    vr->XAdvanceDevice.StartSize  = 0;
+    vr->XAdvanceDevice.EndSize    = 0;
+    vr->XAdvanceDevice.DeltaValue = NULL;
+  }
+
+  if ( format & HB_GPOS_FORMAT_HAVE_Y_ADVANCE_DEVICE )
+  {
+    if ( ACCESS_Frame( 2L ) )
+      goto Fail1;
+
+    new_offset = GET_UShort();
+
+    FORGET_Frame();
+
+    if ( new_offset )
+    {
+      new_offset += base_offset;
+
+      cur_offset = FILE_Pos();
+      if ( FILE_Seek( new_offset ) ||
+	   ( error = _HB_OPEN_Load_Device( &vr->YAdvanceDevice,
+				  stream ) ) != HB_Err_Ok )
+	goto Fail1;
+      (void)FILE_Seek( cur_offset );
+    }
+    else
+      goto empty4;
+  }
+  else
+  {
+  empty4:
+    vr->YAdvanceDevice.StartSize  = 0;
+    vr->YAdvanceDevice.EndSize    = 0;
+    vr->YAdvanceDevice.DeltaValue = NULL;
+  }
+
+  if ( format & HB_GPOS_FORMAT_HAVE_X_ID_PLACEMENT )
+  {
+    if ( ACCESS_Frame( 2L ) )
+      goto Fail1;
+
+    vr->XIdPlacement = GET_UShort();
+
+    FORGET_Frame();
+  }
+  else
+    vr->XIdPlacement = 0;
+
+  if ( format & HB_GPOS_FORMAT_HAVE_Y_ID_PLACEMENT )
+  {
+    if ( ACCESS_Frame( 2L ) )
+      goto Fail1;
+
+    vr->YIdPlacement = GET_UShort();
+
+    FORGET_Frame();
+  }
+  else
+    vr->YIdPlacement = 0;
+
+  if ( format & HB_GPOS_FORMAT_HAVE_X_ID_ADVANCE )
+  {
+    if ( ACCESS_Frame( 2L ) )
+      goto Fail1;
+
+    vr->XIdAdvance = GET_UShort();
+
+    FORGET_Frame();
+  }
+  else
+    vr->XIdAdvance = 0;
+
+  if ( format & HB_GPOS_FORMAT_HAVE_Y_ID_ADVANCE )
+  {
+    if ( ACCESS_Frame( 2L ) )
+      goto Fail1;
+
+    vr->YIdAdvance = GET_UShort();
+
+    FORGET_Frame();
+  }
+  else
+    vr->YIdAdvance = 0;
+
+  return HB_Err_Ok;
+
+Fail1:
+  _HB_OPEN_Free_Device( &vr->YAdvanceDevice );
+
+Fail2:
+  _HB_OPEN_Free_Device( &vr->XAdvanceDevice );
+
+Fail3:
+  _HB_OPEN_Free_Device( &vr->YPlacementDevice );
+  return error;
+}
+
+
+static void  Free_ValueRecord( HB_ValueRecord*  vr,
+			       HB_UShort         format )
+{
+  if ( format & HB_GPOS_FORMAT_HAVE_Y_ADVANCE_DEVICE )
+    _HB_OPEN_Free_Device( &vr->YAdvanceDevice );
+  if ( format & HB_GPOS_FORMAT_HAVE_X_ADVANCE_DEVICE )
+    _HB_OPEN_Free_Device( &vr->XAdvanceDevice );
+  if ( format & HB_GPOS_FORMAT_HAVE_Y_PLACEMENT_DEVICE )
+    _HB_OPEN_Free_Device( &vr->YPlacementDevice );
+  if ( format & HB_GPOS_FORMAT_HAVE_X_PLACEMENT_DEVICE )
+    _HB_OPEN_Free_Device( &vr->XPlacementDevice );
+}
+
+
+static HB_Error  Get_ValueRecord( GPOS_Instance*    gpi,
+				  HB_ValueRecord*  vr,
+				  HB_UShort         format,
+				  HB_Position      gd )
+{
+  HB_Fixed           value;
+  HB_Short         pixel_value;
+  HB_Error         error = HB_Err_Ok;
+  HB_GPOSHeader*  gpos = gpi->gpos;
+
+  HB_UShort  x_ppem, y_ppem;
+  HB_16Dot16   x_scale, y_scale;
+
+
+  if ( !format )
+    return HB_Err_Ok;
+
+  x_ppem  = gpi->font->x_ppem;
+  y_ppem  = gpi->font->y_ppem;
+  x_scale = gpi->font->x_scale;
+  y_scale = gpi->font->y_scale;
+
+  /* design units -> fractional pixel */
+
+  if ( format & HB_GPOS_FORMAT_HAVE_X_PLACEMENT )
+    gd->x_pos += x_scale * vr->XPlacement / 0x10000;
+  if ( format & HB_GPOS_FORMAT_HAVE_Y_PLACEMENT )
+    gd->y_pos += y_scale * vr->YPlacement / 0x10000;
+  if ( format & HB_GPOS_FORMAT_HAVE_X_ADVANCE )
+    gd->x_advance += x_scale * vr->XAdvance / 0x10000;
+  if ( format & HB_GPOS_FORMAT_HAVE_Y_ADVANCE )
+    gd->y_advance += y_scale * vr->YAdvance / 0x10000;
+
+  if ( !gpi->dvi )
+  {
+    /* pixel -> fractional pixel */
+
+    if ( format & HB_GPOS_FORMAT_HAVE_X_PLACEMENT_DEVICE )
+    {
+      _HB_OPEN_Get_Device( &vr->XPlacementDevice, x_ppem, &pixel_value );
+      gd->x_pos += pixel_value << 6;
+    }
+    if ( format & HB_GPOS_FORMAT_HAVE_Y_PLACEMENT_DEVICE )
+    {
+      _HB_OPEN_Get_Device( &vr->YPlacementDevice, y_ppem, &pixel_value );
+      gd->y_pos += pixel_value << 6;
+    }
+    if ( format & HB_GPOS_FORMAT_HAVE_X_ADVANCE_DEVICE )
+    {
+      _HB_OPEN_Get_Device( &vr->XAdvanceDevice, x_ppem, &pixel_value );
+      gd->x_advance += pixel_value << 6;
+    }
+    if ( format & HB_GPOS_FORMAT_HAVE_Y_ADVANCE_DEVICE )
+    {
+      _HB_OPEN_Get_Device( &vr->YAdvanceDevice, y_ppem, &pixel_value );
+      gd->y_advance += pixel_value << 6;
+    }
+  }
+
+  /* values returned from mmfunc() are already in fractional pixels */
+
+  if ( format & HB_GPOS_FORMAT_HAVE_X_ID_PLACEMENT )
+  {
+    error = (gpos->mmfunc)( gpi->font, vr->XIdPlacement,
+			    &value, gpos->data );
+    if ( error )
+      return error;
+    gd->x_pos += value;
+  }
+  if ( format & HB_GPOS_FORMAT_HAVE_Y_ID_PLACEMENT )
+  {
+    error = (gpos->mmfunc)( gpi->font, vr->YIdPlacement,
+			    &value, gpos->data );
+    if ( error )
+      return error;
+    gd->y_pos += value;
+  }
+  if ( format & HB_GPOS_FORMAT_HAVE_X_ID_ADVANCE )
+  {
+    error = (gpos->mmfunc)( gpi->font, vr->XIdAdvance,
+			    &value, gpos->data );
+    if ( error )
+      return error;
+    gd->x_advance += value;
+  }
+  if ( format & HB_GPOS_FORMAT_HAVE_Y_ID_ADVANCE )
+  {
+    error = (gpos->mmfunc)( gpi->font, vr->YIdAdvance,
+			    &value, gpos->data );
+    if ( error )
+      return error;
+    gd->y_advance += value;
+  }
+
+  return error;
+}
+
+
+/* AnchorFormat1 */
+/* AnchorFormat2 */
+/* AnchorFormat3 */
+/* AnchorFormat4 */
+
+static HB_Error  Load_Anchor( HB_Anchor*  an,
+			      HB_Stream    stream )
+{
+  HB_Error  error;
+
+  HB_UInt cur_offset, new_offset, base_offset;
+
+
+  base_offset = FILE_Pos();
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  an->PosFormat = GET_UShort();
+
+  FORGET_Frame();
+
+  switch ( an->PosFormat )
+  {
+  case 1:
+    if ( ACCESS_Frame( 4L ) )
+      return error;
+
+    an->af.af1.XCoordinate = GET_Short();
+    an->af.af1.YCoordinate = GET_Short();
+
+    FORGET_Frame();
+    break;
+
+  case 2:
+    if ( ACCESS_Frame( 6L ) )
+      return error;
+
+    an->af.af2.XCoordinate = GET_Short();
+    an->af.af2.YCoordinate = GET_Short();
+    an->af.af2.AnchorPoint = GET_UShort();
+
+    FORGET_Frame();
+    break;
+
+  case 3:
+    if ( ACCESS_Frame( 6L ) )
+      return error;
+
+    an->af.af3.XCoordinate = GET_Short();
+    an->af.af3.YCoordinate = GET_Short();
+
+    new_offset = GET_UShort();
+
+    FORGET_Frame();
+
+    if ( new_offset )
+    {
+      new_offset += base_offset;
+
+      cur_offset = FILE_Pos();
+      if ( FILE_Seek( new_offset ) ||
+	   ( error = _HB_OPEN_Load_Device( &an->af.af3.XDeviceTable,
+				  stream ) ) != HB_Err_Ok )
+	return error;
+      (void)FILE_Seek( cur_offset );
+    }
+    else
+    {
+      an->af.af3.XDeviceTable.StartSize  = 0;
+      an->af.af3.XDeviceTable.EndSize    = 0;
+      an->af.af3.XDeviceTable.DeltaValue = NULL;
+    }
+
+    if ( ACCESS_Frame( 2L ) )
+      goto Fail;
+
+    new_offset = GET_UShort();
+
+    FORGET_Frame();
+
+    if ( new_offset )
+    {
+      new_offset += base_offset;
+
+      cur_offset = FILE_Pos();
+      if ( FILE_Seek( new_offset ) ||
+	   ( error = _HB_OPEN_Load_Device( &an->af.af3.YDeviceTable,
+				  stream ) ) != HB_Err_Ok )
+	goto Fail;
+      (void)FILE_Seek( cur_offset );
+    }
+    else
+    {
+      an->af.af3.YDeviceTable.StartSize  = 0;
+      an->af.af3.YDeviceTable.EndSize    = 0;
+      an->af.af3.YDeviceTable.DeltaValue = NULL;
+    }
+    break;
+
+  case 4:
+    if ( ACCESS_Frame( 4L ) )
+      return error;
+
+    an->af.af4.XIdAnchor = GET_UShort();
+    an->af.af4.YIdAnchor = GET_UShort();
+
+    FORGET_Frame();
+    break;
+
+  default:
+    return ERR(HB_Err_Invalid_SubTable_Format);
+  }
+
+  return HB_Err_Ok;
+
+Fail:
+  _HB_OPEN_Free_Device( &an->af.af3.XDeviceTable );
+  return error;
+}
+
+
+static void  Free_Anchor( HB_Anchor*  an)
+{
+  if ( an->PosFormat == 3 )
+  {
+    _HB_OPEN_Free_Device( &an->af.af3.YDeviceTable );
+    _HB_OPEN_Free_Device( &an->af.af3.XDeviceTable );
+  }
+}
+
+
+static HB_Error  Get_Anchor( GPOS_Instance*   gpi,
+			     HB_Anchor*      an,
+			     HB_UShort        glyph_index,
+			     HB_Fixed*          x_value,
+			     HB_Fixed*          y_value )
+{
+  HB_Error  error = HB_Err_Ok;
+
+  HB_GPOSHeader*  gpos = gpi->gpos;
+  HB_UShort        ap;
+
+  HB_Short         pixel_value;
+
+  HB_UShort        x_ppem, y_ppem;
+  HB_16Dot16         x_scale, y_scale;
+
+
+  x_ppem  = gpi->font->x_ppem;
+  y_ppem  = gpi->font->y_ppem;
+  x_scale = gpi->font->x_scale;
+  y_scale = gpi->font->y_scale;
+
+  switch ( an->PosFormat )
+  {
+  case 0:
+    /* The special case of an empty AnchorTable */
+  default:
+
+    return HB_Err_Not_Covered;
+
+  case 1:
+    *x_value = x_scale * an->af.af1.XCoordinate / 0x10000;
+    *y_value = y_scale * an->af.af1.YCoordinate / 0x10000;
+    break;
+
+  case 2:
+    if ( !gpi->dvi )
+    {
+      hb_uint32 n_points = 0;
+      ap = an->af.af2.AnchorPoint;
+      if (!gpi->font->klass->getPointInOutline)
+          goto no_contour_point;
+      error = gpi->font->klass->getPointInOutline(gpi->font, glyph_index, gpi->load_flags, ap, x_value, y_value, &n_points);
+      if (error)
+          return error;
+      /* if n_points is set to zero, we use the design coordinate value pair.
+       * This can happen e.g. for sbit glyphs. */
+      if (!n_points)
+          goto no_contour_point;
+    }
+    else
+    {
+    no_contour_point:
+      *x_value = x_scale * an->af.af3.XCoordinate / 0x10000;
+      *y_value = y_scale * an->af.af3.YCoordinate / 0x10000;
+    }
+    break;
+
+  case 3:
+    if ( !gpi->dvi )
+    {
+      _HB_OPEN_Get_Device( &an->af.af3.XDeviceTable, x_ppem, &pixel_value );
+      *x_value = pixel_value << 6;
+      _HB_OPEN_Get_Device( &an->af.af3.YDeviceTable, y_ppem, &pixel_value );
+      *y_value = pixel_value << 6;
+    }
+    else
+      *x_value = *y_value = 0;
+
+    *x_value += x_scale * an->af.af3.XCoordinate / 0x10000;
+    *y_value += y_scale * an->af.af3.YCoordinate / 0x10000;
+    break;
+
+  case 4:
+    error = (gpos->mmfunc)( gpi->font, an->af.af4.XIdAnchor,
+			    x_value, gpos->data );
+    if ( error )
+      return error;
+
+    error = (gpos->mmfunc)( gpi->font, an->af.af4.YIdAnchor,
+			    y_value, gpos->data );
+    if ( error )
+      return error;
+    break;
+  }
+
+  return error;
+}
+
+
+/* MarkArray */
+
+static HB_Error  Load_MarkArray ( HB_MarkArray*  ma,
+				  HB_Stream       stream )
+{
+  HB_Error  error;
+
+  HB_UShort        n, m, count;
+  HB_UInt         cur_offset, new_offset, base_offset;
+
+  HB_MarkRecord*  mr;
+
+
+  base_offset = FILE_Pos();
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  count = ma->MarkCount = GET_UShort();
+
+  FORGET_Frame();
+
+  ma->MarkRecord = NULL;
+
+  if ( ALLOC_ARRAY( ma->MarkRecord, count, HB_MarkRecord ) )
+    return error;
+
+  mr = ma->MarkRecord;
+
+  for ( n = 0; n < count; n++ )
+  {
+    if ( ACCESS_Frame( 4L ) )
+      goto Fail;
+
+    mr[n].Class = GET_UShort();
+    new_offset  = GET_UShort() + base_offset;
+
+    FORGET_Frame();
+
+    cur_offset = FILE_Pos();
+    if ( FILE_Seek( new_offset ) ||
+	 ( error = Load_Anchor( &mr[n].MarkAnchor, stream ) ) != HB_Err_Ok )
+      goto Fail;
+    (void)FILE_Seek( cur_offset );
+  }
+
+  return HB_Err_Ok;
+
+Fail:
+  for ( m = 0; m < n; m++ )
+    Free_Anchor( &mr[m].MarkAnchor );
+
+  FREE( mr );
+  return error;
+}
+
+
+static void  Free_MarkArray( HB_MarkArray*  ma )
+{
+  HB_UShort        n, count;
+
+  HB_MarkRecord*  mr;
+
+
+  if ( ma->MarkRecord )
+  {
+    count = ma->MarkCount;
+    mr    = ma->MarkRecord;
+
+    for ( n = 0; n < count; n++ )
+      Free_Anchor( &mr[n].MarkAnchor );
+
+    FREE( mr );
+  }
+}
+
+
+/* LookupType 1 */
+
+/* SinglePosFormat1 */
+/* SinglePosFormat2 */
+
+static HB_Error  Load_SinglePos( HB_GPOS_SubTable* st,
+				 HB_Stream       stream )
+{
+  HB_Error  error;
+  HB_SinglePos*   sp = &st->single;
+
+  HB_UShort         n, m, count, format;
+  HB_UInt          cur_offset, new_offset, base_offset;
+
+  HB_ValueRecord*  vr;
+
+
+  base_offset = FILE_Pos();
+
+  if ( ACCESS_Frame( 6L ) )
+    return error;
+
+  sp->PosFormat = GET_UShort();
+  new_offset    = GET_UShort() + base_offset;
+
+  format = sp->ValueFormat = GET_UShort();
+
+  FORGET_Frame();
+
+  if ( !format )
+    return ERR(HB_Err_Invalid_SubTable);
+
+  cur_offset = FILE_Pos();
+  if ( FILE_Seek( new_offset ) ||
+       ( error = _HB_OPEN_Load_Coverage( &sp->Coverage, stream ) ) != HB_Err_Ok )
+    return error;
+  (void)FILE_Seek( cur_offset );
+
+  switch ( sp->PosFormat )
+  {
+  case 1:
+    error = Load_ValueRecord( &sp->spf.spf1.Value, format,
+			      base_offset, stream );
+    if ( error )
+      goto Fail2;
+    break;
+
+  case 2:
+    if ( ACCESS_Frame( 2L ) )
+      goto Fail2;
+
+    count = sp->spf.spf2.ValueCount = GET_UShort();
+
+    FORGET_Frame();
+
+    sp->spf.spf2.Value = NULL;
+
+    if ( ALLOC_ARRAY( sp->spf.spf2.Value, count, HB_ValueRecord ) )
+      goto Fail2;
+
+    vr = sp->spf.spf2.Value;
+
+    for ( n = 0; n < count; n++ )
+    {
+      error = Load_ValueRecord( &vr[n], format, base_offset, stream );
+      if ( error )
+	goto Fail1;
+    }
+    break;
+
+  default:
+    return ERR(HB_Err_Invalid_SubTable_Format);
+  }
+
+  return HB_Err_Ok;
+
+Fail1:
+  for ( m = 0; m < n; m++ )
+    Free_ValueRecord( &vr[m], format );
+
+  FREE( vr );
+
+Fail2:
+  _HB_OPEN_Free_Coverage( &sp->Coverage );
+  return error;
+}
+
+
+static void  Free_SinglePos( HB_GPOS_SubTable* st )
+{
+  HB_UShort         n, count, format;
+  HB_SinglePos*   sp = &st->single;
+
+  HB_ValueRecord*  v;
+
+
+  format = sp->ValueFormat;
+
+  switch ( sp->PosFormat )
+  {
+  case 1:
+    Free_ValueRecord( &sp->spf.spf1.Value, format );
+    break;
+
+  case 2:
+    if ( sp->spf.spf2.Value )
+    {
+      count = sp->spf.spf2.ValueCount;
+      v     = sp->spf.spf2.Value;
+
+      for ( n = 0; n < count; n++ )
+	Free_ValueRecord( &v[n], format );
+
+      FREE( v );
+    }
+    break;
+  default:
+    break;
+  }
+
+  _HB_OPEN_Free_Coverage( &sp->Coverage );
+}
+
+static HB_Error  Lookup_SinglePos( GPOS_Instance*    gpi,
+				   HB_GPOS_SubTable* st,
+				   HB_Buffer        buffer,
+				   HB_UShort         flags,
+				   HB_UShort         context_length,
+				   int               nesting_level )
+{
+  HB_UShort        index, property;
+  HB_Error         error;
+  HB_GPOSHeader*  gpos = gpi->gpos;
+  HB_SinglePos*   sp = &st->single;
+
+  HB_UNUSED(nesting_level);
+
+  if ( context_length != 0xFFFF && context_length < 1 )
+    return HB_Err_Not_Covered;
+
+  if ( CHECK_Property( gpos->gdef, IN_CURITEM(), flags, &property ) )
+    return error;
+
+  error = _HB_OPEN_Coverage_Index( &sp->Coverage, IN_CURGLYPH(), &index );
+  if ( error )
+    return error;
+
+  switch ( sp->PosFormat )
+  {
+  case 1:
+    error = Get_ValueRecord( gpi, &sp->spf.spf1.Value,
+			     sp->ValueFormat, POSITION( buffer->in_pos ) );
+    if ( error )
+      return error;
+    break;
+
+  case 2:
+    if ( index >= sp->spf.spf2.ValueCount )
+      return ERR(HB_Err_Invalid_SubTable);
+    error = Get_ValueRecord( gpi, &sp->spf.spf2.Value[index],
+			     sp->ValueFormat, POSITION( buffer->in_pos ) );
+    if ( error )
+      return error;
+    break;
+
+  default:
+    return ERR(HB_Err_Invalid_SubTable);
+  }
+
+  (buffer->in_pos)++;
+
+  return HB_Err_Ok;
+}
+
+
+/* LookupType 2 */
+
+/* PairSet */
+
+static HB_Error  Load_PairSet ( HB_PairSet*  ps,
+				HB_UShort     format1,
+				HB_UShort     format2,
+				HB_Stream     stream )
+{
+  HB_Error  error;
+
+  HB_UShort             n, m, count;
+  HB_UInt              base_offset;
+
+  HB_PairValueRecord*  pvr;
+
+
+  base_offset = FILE_Pos();
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  count = ps->PairValueCount = GET_UShort();
+
+  FORGET_Frame();
+
+  ps->PairValueRecord = NULL;
+
+  if ( ALLOC_ARRAY( ps->PairValueRecord, count, HB_PairValueRecord ) )
+    return error;
+
+  pvr = ps->PairValueRecord;
+
+  for ( n = 0; n < count; n++ )
+  {
+    if ( ACCESS_Frame( 2L ) )
+      goto Fail;
+
+    pvr[n].SecondGlyph = GET_UShort();
+
+    FORGET_Frame();
+
+    if ( format1 )
+    {
+      error = Load_ValueRecord( &pvr[n].Value1, format1,
+				base_offset, stream );
+      if ( error )
+	goto Fail;
+    }
+    if ( format2 )
+    {
+      error = Load_ValueRecord( &pvr[n].Value2, format2,
+				base_offset, stream );
+      if ( error )
+      {
+	if ( format1 )
+	  Free_ValueRecord( &pvr[n].Value1, format1 );
+	goto Fail;
+      }
+    }
+  }
+
+  return HB_Err_Ok;
+
+Fail:
+  for ( m = 0; m < n; m++ )
+  {
+    if ( format1 )
+      Free_ValueRecord( &pvr[m].Value1, format1 );
+    if ( format2 )
+      Free_ValueRecord( &pvr[m].Value2, format2 );
+  }
+
+  FREE( pvr );
+  return error;
+}
+
+
+static void  Free_PairSet( HB_PairSet*  ps,
+			   HB_UShort     format1,
+			   HB_UShort     format2 )
+{
+  HB_UShort             n, count;
+
+  HB_PairValueRecord*  pvr;
+
+
+  if ( ps->PairValueRecord )
+  {
+    count = ps->PairValueCount;
+    pvr   = ps->PairValueRecord;
+
+    for ( n = 0; n < count; n++ )
+    {
+      if ( format1 )
+	Free_ValueRecord( &pvr[n].Value1, format1 );
+      if ( format2 )
+	Free_ValueRecord( &pvr[n].Value2, format2 );
+    }
+
+    FREE( pvr );
+  }
+}
+
+
+/* PairPosFormat1 */
+
+static HB_Error  Load_PairPos1( HB_PairPosFormat1*  ppf1,
+				HB_UShort            format1,
+				HB_UShort            format2,
+				HB_Stream            stream )
+{
+  HB_Error  error;
+
+  HB_UShort     n, m, count;
+  HB_UInt      cur_offset, new_offset, base_offset;
+
+  HB_PairSet*  ps;
+
+
+  base_offset = FILE_Pos() - 8L;
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  count = ppf1->PairSetCount = GET_UShort();
+
+  FORGET_Frame();
+
+  ppf1->PairSet = NULL;
+
+  if ( ALLOC_ARRAY( ppf1->PairSet, count, HB_PairSet ) )
+    return error;
+
+  ps = ppf1->PairSet;
+
+  for ( n = 0; n < count; n++ )
+  {
+    if ( ACCESS_Frame( 2L ) )
+      goto Fail;
+
+    new_offset = GET_UShort() + base_offset;
+
+    FORGET_Frame();
+
+    cur_offset = FILE_Pos();
+    if ( FILE_Seek( new_offset ) ||
+	 ( error = Load_PairSet( &ps[n], format1,
+				 format2, stream ) ) != HB_Err_Ok )
+      goto Fail;
+    (void)FILE_Seek( cur_offset );
+  }
+
+  return HB_Err_Ok;
+
+Fail:
+  for ( m = 0; m < n; m++ )
+    Free_PairSet( &ps[m], format1, format2 );
+
+  FREE( ps );
+  return error;
+}
+
+
+static void  Free_PairPos1( HB_PairPosFormat1*  ppf1,
+			    HB_UShort            format1,
+			    HB_UShort            format2 )
+{
+  HB_UShort     n, count;
+
+  HB_PairSet*  ps;
+
+
+  if ( ppf1->PairSet )
+  {
+    count = ppf1->PairSetCount;
+    ps    = ppf1->PairSet;
+
+    for ( n = 0; n < count; n++ )
+      Free_PairSet( &ps[n], format1, format2 );
+
+    FREE( ps );
+  }
+}
+
+
+/* PairPosFormat2 */
+
+static HB_Error  Load_PairPos2( HB_PairPosFormat2*  ppf2,
+				HB_UShort            format1,
+				HB_UShort            format2,
+				HB_Stream            stream )
+{
+  HB_Error  error;
+
+  HB_UShort          m, n, k, count1, count2;
+  HB_UInt           cur_offset, new_offset1, new_offset2, base_offset;
+
+  HB_Class1Record*  c1r;
+  HB_Class2Record*  c2r;
+
+
+  base_offset = FILE_Pos() - 8L;
+
+  if ( ACCESS_Frame( 8L ) )
+    return error;
+
+  new_offset1 = GET_UShort() + base_offset;
+  new_offset2 = GET_UShort() + base_offset;
+
+  /* `Class1Count' and `Class2Count' are the upper limits for class
+     values, thus we read it now to make additional safety checks.  */
+
+  count1 = ppf2->Class1Count = GET_UShort();
+  count2 = ppf2->Class2Count = GET_UShort();
+
+  FORGET_Frame();
+
+  cur_offset = FILE_Pos();
+  if ( FILE_Seek( new_offset1 ) ||
+       ( error = _HB_OPEN_Load_ClassDefinition( &ppf2->ClassDef1, count1,
+				       stream ) ) != HB_Err_Ok )
+    return error;
+  if ( FILE_Seek( new_offset2 ) ||
+       ( error = _HB_OPEN_Load_ClassDefinition( &ppf2->ClassDef2, count2,
+				       stream ) ) != HB_Err_Ok )
+    goto Fail3;
+  (void)FILE_Seek( cur_offset );
+
+  ppf2->Class1Record = NULL;
+
+  if ( ALLOC_ARRAY( ppf2->Class1Record, count1, HB_Class1Record ) )
+    goto Fail2;
+
+  c1r = ppf2->Class1Record;
+
+  for ( m = 0; m < count1; m++ )
+  {
+    c1r[m].Class2Record = NULL;
+
+    if ( ALLOC_ARRAY( c1r[m].Class2Record, count2, HB_Class2Record ) )
+      goto Fail1;
+
+    c2r = c1r[m].Class2Record;
+
+    for ( n = 0; n < count2; n++ )
+    {
+      if ( format1 )
+      {
+	error = Load_ValueRecord( &c2r[n].Value1, format1,
+				  base_offset, stream );
+	if ( error )
+	  goto Fail0;
+      }
+      if ( format2 )
+      {
+	error = Load_ValueRecord( &c2r[n].Value2, format2,
+				  base_offset, stream );
+	if ( error )
+	{
+	  if ( format1 )
+	    Free_ValueRecord( &c2r[n].Value1, format1 );
+	  goto Fail0;
+	}
+      }
+    }
+
+    continue;
+
+  Fail0:
+    for ( k = 0; k < n; k++ )
+    {
+      if ( format1 )
+	Free_ValueRecord( &c2r[k].Value1, format1 );
+      if ( format2 )
+	Free_ValueRecord( &c2r[k].Value2, format2 );
+    }
+    goto Fail1;
+  }
+
+  return HB_Err_Ok;
+
+Fail1:
+  for ( k = 0; k < m; k++ )
+  {
+    c2r = c1r[k].Class2Record;
+
+    for ( n = 0; n < count2; n++ )
+    {
+      if ( format1 )
+	Free_ValueRecord( &c2r[n].Value1, format1 );
+      if ( format2 )
+	Free_ValueRecord( &c2r[n].Value2, format2 );
+    }
+
+    FREE( c2r );
+  }
+
+  FREE( c1r );
+Fail2:
+
+  _HB_OPEN_Free_ClassDefinition( &ppf2->ClassDef2 );
+
+Fail3:
+  _HB_OPEN_Free_ClassDefinition( &ppf2->ClassDef1 );
+  return error;
+}
+
+
+static void  Free_PairPos2( HB_PairPosFormat2*  ppf2,
+			    HB_UShort            format1,
+			    HB_UShort            format2)
+{
+  HB_UShort          m, n, count1, count2;
+
+  HB_Class1Record*  c1r;
+  HB_Class2Record*  c2r;
+
+
+  if ( ppf2->Class1Record )
+  {
+    c1r    = ppf2->Class1Record;
+    count1 = ppf2->Class1Count;
+    count2 = ppf2->Class2Count;
+
+    for ( m = 0; m < count1; m++ )
+    {
+      c2r = c1r[m].Class2Record;
+
+      for ( n = 0; n < count2; n++ )
+      {
+	if ( format1 )
+	  Free_ValueRecord( &c2r[n].Value1, format1 );
+	if ( format2 )
+	  Free_ValueRecord( &c2r[n].Value2, format2 );
+      }
+
+      FREE( c2r );
+    }
+
+    FREE( c1r );
+
+    _HB_OPEN_Free_ClassDefinition( &ppf2->ClassDef2 );
+    _HB_OPEN_Free_ClassDefinition( &ppf2->ClassDef1 );
+  }
+}
+
+
+static HB_Error  Load_PairPos( HB_GPOS_SubTable* st,
+			       HB_Stream     stream )
+{
+  HB_Error  error;
+  HB_PairPos*     pp = &st->pair;
+
+  HB_UShort         format1, format2;
+  HB_UInt          cur_offset, new_offset, base_offset;
+
+
+  base_offset = FILE_Pos();
+
+  if ( ACCESS_Frame( 8L ) )
+    return error;
+
+  pp->PosFormat = GET_UShort();
+  new_offset    = GET_UShort() + base_offset;
+
+  format1 = pp->ValueFormat1 = GET_UShort();
+  format2 = pp->ValueFormat2 = GET_UShort();
+
+  FORGET_Frame();
+
+  cur_offset = FILE_Pos();
+  if ( FILE_Seek( new_offset ) ||
+       ( error = _HB_OPEN_Load_Coverage( &pp->Coverage, stream ) ) != HB_Err_Ok )
+    return error;
+  (void)FILE_Seek( cur_offset );
+
+  switch ( pp->PosFormat )
+  {
+  case 1:
+    error = Load_PairPos1( &pp->ppf.ppf1, format1, format2, stream );
+    if ( error )
+      goto Fail;
+    break;
+
+  case 2:
+    error = Load_PairPos2( &pp->ppf.ppf2, format1, format2, stream );
+    if ( error )
+      goto Fail;
+    break;
+
+  default:
+    return ERR(HB_Err_Invalid_SubTable_Format);
+  }
+
+  return HB_Err_Ok;
+
+Fail:
+  _HB_OPEN_Free_Coverage( &pp->Coverage );
+  return error;
+}
+
+
+static void  Free_PairPos( HB_GPOS_SubTable* st )
+{
+  HB_UShort  format1, format2;
+  HB_PairPos*     pp = &st->pair;
+
+
+  format1 = pp->ValueFormat1;
+  format2 = pp->ValueFormat2;
+
+  switch ( pp->PosFormat )
+  {
+  case 1:
+    Free_PairPos1( &pp->ppf.ppf1, format1, format2 );
+    break;
+
+  case 2:
+    Free_PairPos2( &pp->ppf.ppf2, format1, format2 );
+    break;
+
+  default:
+    break;
+  }
+
+  _HB_OPEN_Free_Coverage( &pp->Coverage );
+}
+
+
+static HB_Error  Lookup_PairPos1( GPOS_Instance*       gpi,
+				  HB_PairPosFormat1*  ppf1,
+				  HB_Buffer           buffer,
+				  HB_UInt              first_pos,
+				  HB_UShort            index,
+				  HB_UShort            format1,
+				  HB_UShort            format2 )
+{
+  HB_Error              error;
+  HB_UShort             numpvr, glyph2;
+
+  HB_PairValueRecord*  pvr;
+
+
+  if ( index >= ppf1->PairSetCount )
+     return ERR(HB_Err_Invalid_SubTable);
+
+  pvr = ppf1->PairSet[index].PairValueRecord;
+  if ( !pvr )
+    return ERR(HB_Err_Invalid_SubTable);
+
+  glyph2 = IN_CURGLYPH();
+
+  for ( numpvr = ppf1->PairSet[index].PairValueCount;
+	numpvr;
+	numpvr--, pvr++ )
+  {
+    if ( glyph2 == pvr->SecondGlyph )
+    {
+      error = Get_ValueRecord( gpi, &pvr->Value1, format1,
+			       POSITION( first_pos ) );
+      if ( error )
+	return error;
+      return Get_ValueRecord( gpi, &pvr->Value2, format2,
+			      POSITION( buffer->in_pos ) );
+    }
+  }
+
+  return HB_Err_Not_Covered;
+}
+
+
+static HB_Error  Lookup_PairPos2( GPOS_Instance*       gpi,
+				  HB_PairPosFormat2*  ppf2,
+				  HB_Buffer           buffer,
+				  HB_UInt              first_pos,
+				  HB_UShort            format1,
+				  HB_UShort            format2 )
+{
+  HB_Error           error;
+  HB_UShort          cl1 = 0, cl2 = 0; /* shut compiler up */
+
+  HB_Class1Record*  c1r;
+  HB_Class2Record*  c2r;
+
+
+  error = _HB_OPEN_Get_Class( &ppf2->ClassDef1, IN_GLYPH( first_pos ),
+		     &cl1, NULL );
+  if ( error && error != HB_Err_Not_Covered )
+    return error;
+  error = _HB_OPEN_Get_Class( &ppf2->ClassDef2, IN_CURGLYPH(),
+		     &cl2, NULL );
+  if ( error && error != HB_Err_Not_Covered )
+    return error;
+
+  c1r = &ppf2->Class1Record[cl1];
+  if ( !c1r )
+    return ERR(HB_Err_Invalid_SubTable);
+  c2r = &c1r->Class2Record[cl2];
+
+  error = Get_ValueRecord( gpi, &c2r->Value1, format1, POSITION( first_pos ) );
+  if ( error )
+    return error;
+  return Get_ValueRecord( gpi, &c2r->Value2, format2, POSITION( buffer->in_pos ) );
+}
+
+
+static HB_Error  Lookup_PairPos( GPOS_Instance*    gpi,
+				 HB_GPOS_SubTable* st,
+				 HB_Buffer        buffer,
+				 HB_UShort         flags,
+				 HB_UShort         context_length,
+				 int               nesting_level )
+{
+  HB_Error         error;
+  HB_UShort        index, property;
+  HB_UInt          first_pos;
+  HB_GPOSHeader*  gpos = gpi->gpos;
+  HB_PairPos*     pp = &st->pair;
+
+  HB_UNUSED(nesting_level);
+
+  if ( buffer->in_pos >= buffer->in_length - 1 )
+    return HB_Err_Not_Covered;           /* Not enough glyphs in stream */
+
+  if ( context_length != 0xFFFF && context_length < 2 )
+    return HB_Err_Not_Covered;
+
+  if ( CHECK_Property( gpos->gdef, IN_CURITEM(), flags, &property ) )
+    return error;
+
+  error = _HB_OPEN_Coverage_Index( &pp->Coverage, IN_CURGLYPH(), &index );
+  if ( error )
+    return error;
+
+  /* second glyph */
+
+  first_pos = buffer->in_pos;
+  (buffer->in_pos)++;
+
+  while ( CHECK_Property( gpos->gdef, IN_CURITEM(),
+			  flags, &property ) )
+  {
+    if ( error && error != HB_Err_Not_Covered )
+      return error;
+
+    if ( buffer->in_pos == buffer->in_length )
+      {
+	buffer->in_pos = first_pos;
+        return HB_Err_Not_Covered;
+      }
+    (buffer->in_pos)++;
+
+  }
+
+  switch ( pp->PosFormat )
+  {
+  case 1:
+    error = Lookup_PairPos1( gpi, &pp->ppf.ppf1, buffer,
+			     first_pos, index,
+			     pp->ValueFormat1, pp->ValueFormat2 );
+    break;
+
+  case 2:
+    error = Lookup_PairPos2( gpi, &pp->ppf.ppf2, buffer, first_pos,
+			     pp->ValueFormat1, pp->ValueFormat2 );
+    break;
+
+  default:
+    return ERR(HB_Err_Invalid_SubTable_Format);
+  }
+
+  /* if we don't have coverage for the second glyph don't skip it for
+     further lookups but reset in_pos back to the first_glyph and let
+     the caller in Do_String_Lookup increment in_pos */
+  if ( error == HB_Err_Not_Covered )
+      buffer->in_pos = first_pos;
+
+  /* adjusting the `next' glyph */
+
+  if ( pp->ValueFormat2 )
+    (buffer->in_pos)++;
+
+  return error;
+}
+
+
+/* LookupType 3 */
+
+/* CursivePosFormat1 */
+
+static HB_Error  Load_CursivePos( HB_GPOS_SubTable* st,
+				  HB_Stream        stream )
+{
+  HB_Error  error;
+  HB_CursivePos*  cp = &st->cursive;
+
+  HB_UShort             n, m, count;
+  HB_UInt              cur_offset, new_offset, base_offset;
+
+  HB_EntryExitRecord*  eer;
+
+
+  base_offset = FILE_Pos();
+
+  if ( ACCESS_Frame( 4L ) )
+    return error;
+
+  cp->PosFormat = GET_UShort();
+  new_offset    = GET_UShort() + base_offset;
+
+  FORGET_Frame();
+
+  cur_offset = FILE_Pos();
+  if ( FILE_Seek( new_offset ) ||
+       ( error = _HB_OPEN_Load_Coverage( &cp->Coverage, stream ) ) != HB_Err_Ok )
+    return error;
+  (void)FILE_Seek( cur_offset );
+
+  if ( ACCESS_Frame( 2L ) )
+    goto Fail2;
+
+  count = cp->EntryExitCount = GET_UShort();
+
+  FORGET_Frame();
+
+  cp->EntryExitRecord = NULL;
+
+  if ( ALLOC_ARRAY( cp->EntryExitRecord, count, HB_EntryExitRecord ) )
+    goto Fail2;
+
+  eer = cp->EntryExitRecord;
+
+  for ( n = 0; n < count; n++ )
+  {
+    HB_UInt entry_offset;
+
+    if ( ACCESS_Frame( 2L ) )
+      return error;
+
+    entry_offset = new_offset = GET_UShort();
+
+    FORGET_Frame();
+
+    if ( new_offset )
+    {
+      new_offset += base_offset;
+
+      cur_offset = FILE_Pos();
+      if ( FILE_Seek( new_offset ) ||
+	   ( error = Load_Anchor( &eer[n].EntryAnchor,
+				  stream ) ) != HB_Err_Ok )
+	goto Fail1;
+      (void)FILE_Seek( cur_offset );
+    }
+    else
+      eer[n].EntryAnchor.PosFormat   = 0;
+
+    if ( ACCESS_Frame( 2L ) )
+      return error;
+
+    new_offset = GET_UShort();
+
+    FORGET_Frame();
+
+    if ( new_offset )
+    {
+      new_offset += base_offset;
+
+      cur_offset = FILE_Pos();
+      if ( FILE_Seek( new_offset ) ||
+	   ( error = Load_Anchor( &eer[n].ExitAnchor,
+				  stream ) ) != HB_Err_Ok )
+      {
+	if ( entry_offset )
+	  Free_Anchor( &eer[n].EntryAnchor );
+	goto Fail1;
+      }
+      (void)FILE_Seek( cur_offset );
+    }
+    else
+      eer[n].ExitAnchor.PosFormat   = 0;
+  }
+
+  return HB_Err_Ok;
+
+Fail1:
+  for ( m = 0; m < n; m++ )
+  {
+    Free_Anchor( &eer[m].EntryAnchor );
+    Free_Anchor( &eer[m].ExitAnchor );
+  }
+
+  FREE( eer );
+
+Fail2:
+  _HB_OPEN_Free_Coverage( &cp->Coverage );
+  return error;
+}
+
+
+static void  Free_CursivePos( HB_GPOS_SubTable* st )
+{
+  HB_UShort             n, count;
+  HB_CursivePos*  cp = &st->cursive;
+
+  HB_EntryExitRecord*  eer;
+
+
+  if ( cp->EntryExitRecord )
+  {
+    count = cp->EntryExitCount;
+    eer   = cp->EntryExitRecord;
+
+    for ( n = 0; n < count; n++ )
+    {
+      Free_Anchor( &eer[n].EntryAnchor );
+      Free_Anchor( &eer[n].ExitAnchor );
+    }
+
+    FREE( eer );
+  }
+
+  _HB_OPEN_Free_Coverage( &cp->Coverage );
+}
+
+
+static HB_Error  Lookup_CursivePos( GPOS_Instance*    gpi,
+				    HB_GPOS_SubTable* st,
+				    HB_Buffer        buffer,
+				    HB_UShort         flags,
+				    HB_UShort         context_length,
+				    int               nesting_level )
+{
+  HB_UShort        index, property;
+  HB_Error         error;
+  HB_GPOSHeader*  gpos = gpi->gpos;
+  HB_CursivePos*  cp = &st->cursive;
+
+  HB_EntryExitRecord*  eer;
+  HB_Fixed                entry_x, entry_y;
+  HB_Fixed                exit_x, exit_y;
+
+  HB_UNUSED(nesting_level);
+
+  if ( context_length != 0xFFFF && context_length < 1 )
+  {
+    gpi->last = 0xFFFF;
+    return HB_Err_Not_Covered;
+  }
+
+  /* Glyphs not having the right GDEF properties will be ignored, i.e.,
+     gpi->last won't be reset (contrary to user defined properties). */
+
+  if ( CHECK_Property( gpos->gdef, IN_CURITEM(), flags, &property ) )
+    return error;
+
+  /* We don't handle mark glyphs here.  According to Andrei, this isn't
+     possible, but who knows...                                         */
+
+  if ( property == HB_GDEF_MARK )
+  {
+    gpi->last = 0xFFFF;
+    return HB_Err_Not_Covered;
+  }
+
+  error = _HB_OPEN_Coverage_Index( &cp->Coverage, IN_CURGLYPH(), &index );
+  if ( error )
+  {
+    gpi->last = 0xFFFF;
+    return error;
+  }
+
+  if ( index >= cp->EntryExitCount )
+    return ERR(HB_Err_Invalid_SubTable);
+
+  eer = &cp->EntryExitRecord[index];
+
+  /* Now comes the messiest part of the whole OpenType
+     specification.  At first glance, cursive connections seem easy
+     to understand, but there are pitfalls!  The reason is that
+     the specs don't mention how to compute the advance values
+     resp. glyph offsets.  I was told it would be an omission, to
+     be fixed in the next OpenType version...  Again many thanks to
+     Andrei Burago <andreib@microsoft.com> for clarifications.
+
+     Consider the following example:
+
+		      |  xadv1    |
+		       +---------+
+		       |         |
+		 +-----+--+ 1    |
+		 |     | .|      |
+		 |    0+--+------+
+		 |   2    |
+		 |        |
+		0+--------+
+		|  xadv2   |
+
+       glyph1: advance width = 12
+	       anchor point = (3,1)
+
+       glyph2: advance width = 11
+	       anchor point = (9,4)
+
+       LSB is 1 for both glyphs (so the boxes drawn above are glyph
+       bboxes).  Writing direction is R2L; `0' denotes the glyph's
+       coordinate origin.
+
+     Now the surprising part: The advance width of the *left* glyph
+     (resp. of the *bottom* glyph) will be modified, no matter
+     whether the writing direction is L2R or R2L (resp. T2B or
+     B2T)!  This assymetry is caused by the fact that the glyph's
+     coordinate origin is always the lower left corner for all
+     writing directions.
+
+     Continuing the above example, we can compute the new
+     (horizontal) advance width of glyph2 as
+
+       9 - 3 = 6  ,
+
+     and the new vertical offset of glyph2 as
+
+       1 - 4 = -3  .
+
+
+     Vertical writing direction is far more complicated:
+
+     a) Assuming that we recompute the advance height of the lower glyph:
+
+				  --
+		       +---------+
+	      --       |         |
+		 +-----+--+ 1    | yadv1
+		 |     | .|      |
+	   yadv2 |    0+--+------+        -- BSB1  --
+		 |   2    |       --      --        y_offset
+		 |        |
+   BSB2 --      0+--------+                        --
+	--    --
+
+       glyph1: advance height = 6
+	       anchor point = (3,1)
+
+       glyph2: advance height = 7
+	       anchor point = (9,4)
+
+       TSB is 1 for both glyphs; writing direction is T2B.
+
+
+	 BSB1     = yadv1 - (TSB1 + ymax1)
+	 BSB2     = yadv2 - (TSB2 + ymax2)
+	 y_offset = y2 - y1
+
+       vertical advance width of glyph2
+	 = y_offset + BSB2 - BSB1
+	 = (y2 - y1) + (yadv2 - (TSB2 + ymax2)) - (yadv1 - (TSB1 + ymax1))
+	 = y2 - y1 + yadv2 - TSB2 - ymax2 - (yadv1 - TSB1 - ymax1)
+	 = y2 - y1 + yadv2 - TSB2 - ymax2 - yadv1 + TSB1 + ymax1
+
+
+     b) Assuming that we recompute the advance height of the upper glyph:
+
+				  --      --
+		       +---------+        -- TSB1
+	--    --       |         |
+   TSB2 --       +-----+--+ 1    | yadv1   ymax1
+		 |     | .|      |
+	   yadv2 |    0+--+------+        --       --
+    ymax2        |   2    |       --                y_offset
+		 |        |
+	--      0+--------+                        --
+	      --
+
+       glyph1: advance height = 6
+	       anchor point = (3,1)
+
+       glyph2: advance height = 7
+	       anchor point = (9,4)
+
+       TSB is 1 for both glyphs; writing direction is T2B.
+
+       y_offset = y2 - y1
+
+       vertical advance width of glyph2
+	 = TSB1 + ymax1 + y_offset - (TSB2 + ymax2)
+	 = TSB1 + ymax1 + y2 - y1 - TSB2 - ymax2
+
+
+     Comparing a) with b) shows that b) is easier to compute.  I'll wait
+     for a reply from Andrei to see what should really be implemented...
+
+     Since horizontal advance widths or vertical advance heights
+     can be used alone but not together, no ambiguity occurs.        */
+
+  if ( gpi->last == 0xFFFF )
+    goto end;
+
+  /* Get_Anchor() returns HB_Err_Not_Covered if there is no anchor
+     table.                                                         */
+
+  error = Get_Anchor( gpi, &eer->EntryAnchor, IN_CURGLYPH(),
+		      &entry_x, &entry_y );
+  if ( error == HB_Err_Not_Covered )
+    goto end;
+  if ( error )
+    return error;
+
+  if ( gpi->r2l )
+  {
+    POSITION( buffer->in_pos )->x_advance   = entry_x - gpi->anchor_x;
+    POSITION( buffer->in_pos )->new_advance = TRUE;
+  }
+  else
+  {
+    POSITION( gpi->last )->x_advance   = gpi->anchor_x - entry_x;
+    POSITION( gpi->last )->new_advance = TRUE;
+  }
+
+  if ( flags & HB_LOOKUP_FLAG_RIGHT_TO_LEFT )
+  {
+    POSITION( gpi->last )->cursive_chain = gpi->last - buffer->in_pos;
+    POSITION( gpi->last )->y_pos = entry_y - gpi->anchor_y;
+  }
+  else
+  {
+    POSITION( buffer->in_pos )->cursive_chain = buffer->in_pos - gpi->last;
+    POSITION( buffer->in_pos )->y_pos = gpi->anchor_y - entry_y;
+  }
+
+end:
+  error = Get_Anchor( gpi, &eer->ExitAnchor, IN_CURGLYPH(),
+		      &exit_x, &exit_y );
+  if ( error == HB_Err_Not_Covered )
+    gpi->last = 0xFFFF;
+  else
+  {
+    gpi->last     = buffer->in_pos;
+    gpi->anchor_x = exit_x;
+    gpi->anchor_y = exit_y;
+  }
+  if ( error )
+    return error;
+
+  (buffer->in_pos)++;
+
+  return HB_Err_Ok;
+}
+
+
+/* LookupType 4 */
+
+/* BaseArray */
+
+static HB_Error  Load_BaseArray( HB_BaseArray*  ba,
+				 HB_UShort       num_classes,
+				 HB_Stream       stream )
+{
+  HB_Error  error;
+
+  HB_UShort       m, n, count;
+  HB_UInt         cur_offset, new_offset, base_offset;
+
+  HB_BaseRecord  *br;
+  HB_Anchor      *ban, *bans;
+
+
+  base_offset = FILE_Pos();
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  count = ba->BaseCount = GET_UShort();
+
+  FORGET_Frame();
+
+  ba->BaseRecord = NULL;
+
+  if ( ALLOC_ARRAY( ba->BaseRecord, count, HB_BaseRecord ) )
+    return error;
+
+  br = ba->BaseRecord;
+
+  bans = NULL;
+
+  if ( ALLOC_ARRAY( bans, count * num_classes, HB_Anchor ) )
+    goto Fail;
+
+  for ( m = 0; m < count; m++ )
+  {
+    br[m].BaseAnchor = NULL;
+
+    ban = br[m].BaseAnchor = bans + m * num_classes;
+
+    for ( n = 0; n < num_classes; n++ )
+    {
+      if ( ACCESS_Frame( 2L ) )
+	goto Fail;
+
+      new_offset = GET_UShort() + base_offset;
+
+      FORGET_Frame();
+
+      if (new_offset == base_offset) {
+	/* XXX
+	 * Doulos SIL Regular is buggy and has zero offsets here.
+	 * Skip it
+	 */
+	ban[n].PosFormat = 0;
+	continue;
+      }
+
+      cur_offset = FILE_Pos();
+      if ( FILE_Seek( new_offset ) ||
+	   ( error = Load_Anchor( &ban[n], stream ) ) != HB_Err_Ok )
+	goto Fail;
+      (void)FILE_Seek( cur_offset );
+    }
+  }
+
+  return HB_Err_Ok;
+
+Fail:
+  FREE( bans );
+  FREE( br );
+  return error;
+}
+
+
+static void  Free_BaseArray( HB_BaseArray*  ba,
+			     HB_UShort       num_classes )
+{
+  HB_BaseRecord  *br;
+  HB_Anchor      *bans;
+
+  if ( ba->BaseRecord )
+  {
+    br    = ba->BaseRecord;
+
+    if ( ba->BaseCount )
+    {
+      HB_UShort i, count;
+      count = num_classes * ba->BaseCount;
+      bans = br[0].BaseAnchor;
+      for (i = 0; i < count; i++)
+        Free_Anchor (&bans[i]);
+      FREE( bans );
+    }
+
+    FREE( br );
+  }
+}
+
+
+/* MarkBasePosFormat1 */
+
+static HB_Error  Load_MarkBasePos( HB_GPOS_SubTable* st,
+				   HB_Stream         stream )
+{
+  HB_Error  error;
+  HB_MarkBasePos* mbp = &st->markbase;
+
+  HB_UInt  cur_offset, new_offset, base_offset;
+
+
+  base_offset = FILE_Pos();
+
+  if ( ACCESS_Frame( 4L ) )
+    return error;
+
+  mbp->PosFormat = GET_UShort();
+  new_offset     = GET_UShort() + base_offset;
+
+  FORGET_Frame();
+
+  if (mbp->PosFormat != 1)
+    return ERR(HB_Err_Invalid_SubTable_Format);
+
+  cur_offset = FILE_Pos();
+  if ( FILE_Seek( new_offset ) ||
+       ( error = _HB_OPEN_Load_Coverage( &mbp->MarkCoverage, stream ) ) != HB_Err_Ok )
+    return error;
+  (void)FILE_Seek( cur_offset );
+
+  if ( ACCESS_Frame( 2L ) )
+    goto Fail3;
+
+  new_offset = GET_UShort() + base_offset;
+
+  FORGET_Frame();
+
+  cur_offset = FILE_Pos();
+  if ( FILE_Seek( new_offset ) ||
+       ( error = _HB_OPEN_Load_Coverage( &mbp->BaseCoverage, stream ) ) != HB_Err_Ok )
+    goto Fail3;
+  (void)FILE_Seek( cur_offset );
+
+  if ( ACCESS_Frame( 4L ) )
+    goto Fail2;
+
+  mbp->ClassCount = GET_UShort();
+  new_offset      = GET_UShort() + base_offset;
+
+  FORGET_Frame();
+
+  cur_offset = FILE_Pos();
+  if ( FILE_Seek( new_offset ) ||
+       ( error = Load_MarkArray( &mbp->MarkArray, stream ) ) != HB_Err_Ok )
+    goto Fail2;
+  (void)FILE_Seek( cur_offset );
+
+  if ( ACCESS_Frame( 2L ) )
+    goto Fail1;
+
+  new_offset = GET_UShort() + base_offset;
+
+  FORGET_Frame();
+
+  cur_offset = FILE_Pos();
+  if ( FILE_Seek( new_offset ) ||
+       ( error = Load_BaseArray( &mbp->BaseArray, mbp->ClassCount,
+				 stream ) ) != HB_Err_Ok )
+    goto Fail1;
+
+  return HB_Err_Ok;
+
+Fail1:
+  Free_MarkArray( &mbp->MarkArray );
+
+Fail2:
+  _HB_OPEN_Free_Coverage( &mbp->BaseCoverage );
+
+Fail3:
+  _HB_OPEN_Free_Coverage( &mbp->MarkCoverage );
+  return error;
+}
+
+
+static void  Free_MarkBasePos( HB_GPOS_SubTable* st )
+{
+  HB_MarkBasePos* mbp = &st->markbase;
+
+  Free_BaseArray( &mbp->BaseArray, mbp->ClassCount );
+  Free_MarkArray( &mbp->MarkArray );
+  _HB_OPEN_Free_Coverage( &mbp->BaseCoverage );
+  _HB_OPEN_Free_Coverage( &mbp->MarkCoverage );
+}
+
+
+static HB_Error  Lookup_MarkBasePos( GPOS_Instance*    gpi,
+				     HB_GPOS_SubTable* st,
+				     HB_Buffer        buffer,
+				     HB_UShort         flags,
+				     HB_UShort         context_length,
+				     int               nesting_level )
+{
+  HB_UShort        i, j, mark_index, base_index, property, class;
+  HB_Fixed           x_mark_value, y_mark_value, x_base_value, y_base_value;
+  HB_Error         error;
+  HB_GPOSHeader*  gpos = gpi->gpos;
+  HB_MarkBasePos* mbp = &st->markbase;
+
+  HB_MarkArray*   ma;
+  HB_BaseArray*   ba;
+  HB_BaseRecord*  br;
+  HB_Anchor*      mark_anchor;
+  HB_Anchor*      base_anchor;
+
+  HB_Position     o;
+
+  HB_UNUSED(nesting_level);
+
+  if ( context_length != 0xFFFF && context_length < 1 )
+    return HB_Err_Not_Covered;
+
+  if ( flags & HB_LOOKUP_FLAG_IGNORE_BASE_GLYPHS )
+    return HB_Err_Not_Covered;
+
+  if ( CHECK_Property( gpos->gdef, IN_CURITEM(),
+		       flags, &property ) )
+    return error;
+
+  error = _HB_OPEN_Coverage_Index( &mbp->MarkCoverage, IN_CURGLYPH(),
+			  &mark_index );
+  if ( error )
+    return error;
+
+  /* now we search backwards for a non-mark glyph */
+
+  i = 1;
+  j = buffer->in_pos - 1;
+
+  while ( i <= buffer->in_pos )
+  {
+    error = HB_GDEF_Get_Glyph_Property( gpos->gdef, IN_GLYPH( j ),
+					&property );
+    if ( error )
+      return error;
+
+    if ( !( property == HB_GDEF_MARK || property & HB_LOOKUP_FLAG_IGNORE_SPECIAL_MARKS ) )
+      break;
+
+    i++;
+    j--;
+  }
+
+  /* The following assertion is too strong -- at least for mangal.ttf. */
+#if 0
+  if ( property != HB_GDEF_BASE_GLYPH )
+    return HB_Err_Not_Covered;
+#endif
+
+  if ( i > buffer->in_pos )
+    return HB_Err_Not_Covered;
+
+  error = _HB_OPEN_Coverage_Index( &mbp->BaseCoverage, IN_GLYPH( j ),
+			  &base_index );
+  if ( error )
+    return error;
+
+  ma = &mbp->MarkArray;
+
+  if ( mark_index >= ma->MarkCount )
+    return ERR(HB_Err_Invalid_SubTable);
+
+  class       = ma->MarkRecord[mark_index].Class;
+  mark_anchor = &ma->MarkRecord[mark_index].MarkAnchor;
+
+  if ( class >= mbp->ClassCount )
+    return ERR(HB_Err_Invalid_SubTable);
+
+  ba = &mbp->BaseArray;
+
+  if ( base_index >= ba->BaseCount )
+    return ERR(HB_Err_Invalid_SubTable);
+
+  br          = &ba->BaseRecord[base_index];
+  base_anchor = &br->BaseAnchor[class];
+
+  error = Get_Anchor( gpi, mark_anchor, IN_CURGLYPH(),
+		      &x_mark_value, &y_mark_value );
+  if ( error )
+    return error;
+
+  error = Get_Anchor( gpi, base_anchor, IN_GLYPH( j ),
+		      &x_base_value, &y_base_value );
+  if ( error )
+    return error;
+
+  /* anchor points are not cumulative */
+
+  o = POSITION( buffer->in_pos );
+
+  o->x_pos     = x_base_value - x_mark_value;
+  o->y_pos     = y_base_value - y_mark_value;
+  o->x_advance = 0;
+  o->y_advance = 0;
+  o->back      = i;
+
+  (buffer->in_pos)++;
+
+  return HB_Err_Ok;
+}
+
+
+/* LookupType 5 */
+
+/* LigatureAttach */
+
+static HB_Error  Load_LigatureAttach( HB_LigatureAttach*  lat,
+				      HB_UShort            num_classes,
+				      HB_Stream            stream )
+{
+  HB_Error  error;
+
+  HB_UShort             m, n, k, count;
+  HB_UInt              cur_offset, new_offset, base_offset;
+
+  HB_ComponentRecord*  cr;
+  HB_Anchor*           lan;
+
+
+  base_offset = FILE_Pos();
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  count = lat->ComponentCount = GET_UShort();
+
+  FORGET_Frame();
+
+  lat->ComponentRecord = NULL;
+
+  if ( ALLOC_ARRAY( lat->ComponentRecord, count, HB_ComponentRecord ) )
+    return error;
+
+  cr = lat->ComponentRecord;
+
+  for ( m = 0; m < count; m++ )
+  {
+    cr[m].LigatureAnchor = NULL;
+
+    if ( ALLOC_ARRAY( cr[m].LigatureAnchor, num_classes, HB_Anchor ) )
+      goto Fail;
+
+    lan = cr[m].LigatureAnchor;
+
+    for ( n = 0; n < num_classes; n++ )
+    {
+      if ( ACCESS_Frame( 2L ) )
+	goto Fail0;
+
+      new_offset = GET_UShort();
+
+      FORGET_Frame();
+
+      if ( new_offset )
+      {
+	new_offset += base_offset;
+
+	cur_offset = FILE_Pos();
+	if ( FILE_Seek( new_offset ) ||
+	     ( error = Load_Anchor( &lan[n], stream ) ) != HB_Err_Ok )
+	  goto Fail0;
+	(void)FILE_Seek( cur_offset );
+      }
+      else
+	lan[n].PosFormat = 0;
+    }
+
+    continue;
+  Fail0:
+    for ( k = 0; k < n; k++ )
+      Free_Anchor( &lan[k] );
+    goto Fail;
+  }
+
+  return HB_Err_Ok;
+
+Fail:
+  for ( k = 0; k < m; k++ )
+  {
+    lan = cr[k].LigatureAnchor;
+
+    for ( n = 0; n < num_classes; n++ )
+      Free_Anchor( &lan[n] );
+
+    FREE( lan );
+  }
+
+  FREE( cr );
+  return error;
+}
+
+
+static void  Free_LigatureAttach( HB_LigatureAttach*  lat,
+				  HB_UShort            num_classes )
+{
+  HB_UShort        m, n, count;
+
+  HB_ComponentRecord*  cr;
+  HB_Anchor*           lan;
+
+
+  if ( lat->ComponentRecord )
+  {
+    count = lat->ComponentCount;
+    cr    = lat->ComponentRecord;
+
+    for ( m = 0; m < count; m++ )
+    {
+      lan = cr[m].LigatureAnchor;
+
+      for ( n = 0; n < num_classes; n++ )
+	Free_Anchor( &lan[n] );
+
+      FREE( lan );
+    }
+
+    FREE( cr );
+  }
+}
+
+
+/* LigatureArray */
+
+static HB_Error  Load_LigatureArray( HB_LigatureArray*  la,
+				     HB_UShort           num_classes,
+				     HB_Stream           stream )
+{
+  HB_Error  error;
+
+  HB_UShort            n, m, count;
+  HB_UInt             cur_offset, new_offset, base_offset;
+
+  HB_LigatureAttach*  lat;
+
+
+  base_offset = FILE_Pos();
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  count = la->LigatureCount = GET_UShort();
+
+  FORGET_Frame();
+
+  la->LigatureAttach = NULL;
+
+  if ( ALLOC_ARRAY( la->LigatureAttach, count, HB_LigatureAttach ) )
+    return error;
+
+  lat = la->LigatureAttach;
+
+  for ( n = 0; n < count; n++ )
+  {
+    if ( ACCESS_Frame( 2L ) )
+      goto Fail;
+
+    new_offset = GET_UShort() + base_offset;
+
+    FORGET_Frame();
+
+    cur_offset = FILE_Pos();
+    if ( FILE_Seek( new_offset ) ||
+	 ( error = Load_LigatureAttach( &lat[n], num_classes,
+					stream ) ) != HB_Err_Ok )
+      goto Fail;
+    (void)FILE_Seek( cur_offset );
+  }
+
+  return HB_Err_Ok;
+
+Fail:
+  for ( m = 0; m < n; m++ )
+    Free_LigatureAttach( &lat[m], num_classes );
+
+  FREE( lat );
+  return error;
+}
+
+
+static void  Free_LigatureArray( HB_LigatureArray*  la,
+				 HB_UShort           num_classes )
+{
+  HB_UShort            n, count;
+
+  HB_LigatureAttach*  lat;
+
+
+  if ( la->LigatureAttach )
+  {
+    count = la->LigatureCount;
+    lat   = la->LigatureAttach;
+
+    for ( n = 0; n < count; n++ )
+      Free_LigatureAttach( &lat[n], num_classes );
+
+    FREE( lat );
+  }
+}
+
+
+/* MarkLigPosFormat1 */
+
+static HB_Error  Load_MarkLigPos( HB_GPOS_SubTable* st,
+				  HB_Stream        stream )
+{
+  HB_Error  error;
+  HB_MarkLigPos*  mlp = &st->marklig;
+
+  HB_UInt  cur_offset, new_offset, base_offset;
+
+
+  base_offset = FILE_Pos();
+
+  if ( ACCESS_Frame( 4L ) )
+    return error;
+
+  mlp->PosFormat = GET_UShort();
+  new_offset     = GET_UShort() + base_offset;
+
+  FORGET_Frame();
+
+  cur_offset = FILE_Pos();
+  if ( FILE_Seek( new_offset ) ||
+       ( error = _HB_OPEN_Load_Coverage( &mlp->MarkCoverage, stream ) ) != HB_Err_Ok )
+    return error;
+  (void)FILE_Seek( cur_offset );
+
+  if ( ACCESS_Frame( 2L ) )
+    goto Fail3;
+
+  new_offset = GET_UShort() + base_offset;
+
+  FORGET_Frame();
+
+  cur_offset = FILE_Pos();
+  if ( FILE_Seek( new_offset ) ||
+       ( error = _HB_OPEN_Load_Coverage( &mlp->LigatureCoverage,
+				stream ) ) != HB_Err_Ok )
+    goto Fail3;
+  (void)FILE_Seek( cur_offset );
+
+  if ( ACCESS_Frame( 4L ) )
+    goto Fail2;
+
+  mlp->ClassCount = GET_UShort();
+  new_offset      = GET_UShort() + base_offset;
+
+  FORGET_Frame();
+
+  cur_offset = FILE_Pos();
+  if ( FILE_Seek( new_offset ) ||
+       ( error = Load_MarkArray( &mlp->MarkArray, stream ) ) != HB_Err_Ok )
+    goto Fail2;
+  (void)FILE_Seek( cur_offset );
+
+  if ( ACCESS_Frame( 2L ) )
+    goto Fail1;
+
+  new_offset = GET_UShort() + base_offset;
+
+  FORGET_Frame();
+
+  cur_offset = FILE_Pos();
+  if ( FILE_Seek( new_offset ) ||
+       ( error = Load_LigatureArray( &mlp->LigatureArray, mlp->ClassCount,
+				     stream ) ) != HB_Err_Ok )
+    goto Fail1;
+
+  return HB_Err_Ok;
+
+Fail1:
+  Free_MarkArray( &mlp->MarkArray );
+
+Fail2:
+  _HB_OPEN_Free_Coverage( &mlp->LigatureCoverage );
+
+Fail3:
+  _HB_OPEN_Free_Coverage( &mlp->MarkCoverage );
+  return error;
+}
+
+
+static void  Free_MarkLigPos( HB_GPOS_SubTable* st)
+{
+  HB_MarkLigPos*  mlp = &st->marklig;
+
+  Free_LigatureArray( &mlp->LigatureArray, mlp->ClassCount );
+  Free_MarkArray( &mlp->MarkArray );
+  _HB_OPEN_Free_Coverage( &mlp->LigatureCoverage );
+  _HB_OPEN_Free_Coverage( &mlp->MarkCoverage );
+}
+
+
+static HB_Error  Lookup_MarkLigPos( GPOS_Instance*    gpi,
+				    HB_GPOS_SubTable* st,
+				    HB_Buffer        buffer,
+				    HB_UShort         flags,
+				    HB_UShort         context_length,
+				    int               nesting_level )
+{
+  HB_UShort        i, j, mark_index, lig_index, property, class;
+  HB_UShort        mark_glyph;
+  HB_Fixed           x_mark_value, y_mark_value, x_lig_value, y_lig_value;
+  HB_Error         error;
+  HB_GPOSHeader*  gpos = gpi->gpos;
+  HB_MarkLigPos*  mlp = &st->marklig;
+
+  HB_MarkArray*        ma;
+  HB_LigatureArray*    la;
+  HB_LigatureAttach*   lat;
+  HB_ComponentRecord*  cr;
+  HB_UShort             comp_index;
+  HB_Anchor*           mark_anchor;
+  HB_Anchor*           lig_anchor;
+
+  HB_Position    o;
+
+  HB_UNUSED(nesting_level);
+
+  if ( context_length != 0xFFFF && context_length < 1 )
+    return HB_Err_Not_Covered;
+
+  if ( flags & HB_LOOKUP_FLAG_IGNORE_LIGATURES )
+    return HB_Err_Not_Covered;
+
+  mark_glyph = IN_CURGLYPH();
+
+  if ( CHECK_Property( gpos->gdef, IN_CURITEM(), flags, &property ) )
+    return error;
+
+  error = _HB_OPEN_Coverage_Index( &mlp->MarkCoverage, mark_glyph, &mark_index );
+  if ( error )
+    return error;
+
+  /* now we search backwards for a non-mark glyph */
+
+  i = 1;
+  j = buffer->in_pos - 1;
+
+  while ( i <= buffer->in_pos )
+  {
+    error = HB_GDEF_Get_Glyph_Property( gpos->gdef, IN_GLYPH( j ),
+					&property );
+    if ( error )
+      return error;
+
+    if ( !( property == HB_GDEF_MARK || property & HB_LOOKUP_FLAG_IGNORE_SPECIAL_MARKS ) )
+      break;
+
+    i++;
+    j--;
+  }
+
+  /* Similar to Lookup_MarkBasePos(), I suspect that this assertion is
+     too strong, thus it is commented out.                             */
+#if 0
+  if ( property != HB_GDEF_LIGATURE )
+    return HB_Err_Not_Covered;
+#endif
+
+  if ( i > buffer->in_pos )
+    return HB_Err_Not_Covered;
+
+  error = _HB_OPEN_Coverage_Index( &mlp->LigatureCoverage, IN_GLYPH( j ),
+			  &lig_index );
+  if ( error )
+    return error;
+
+  ma = &mlp->MarkArray;
+
+  if ( mark_index >= ma->MarkCount )
+    return ERR(HB_Err_Invalid_SubTable);
+
+  class       = ma->MarkRecord[mark_index].Class;
+  mark_anchor = &ma->MarkRecord[mark_index].MarkAnchor;
+
+  if ( class >= mlp->ClassCount )
+    return ERR(HB_Err_Invalid_SubTable);
+
+  la = &mlp->LigatureArray;
+
+  if ( lig_index >= la->LigatureCount )
+    return ERR(HB_Err_Invalid_SubTable);
+
+  lat = &la->LigatureAttach[lig_index];
+
+  /* We must now check whether the ligature ID of the current mark glyph
+     is identical to the ligature ID of the found ligature.  If yes, we
+     can directly use the component index.  If not, we attach the mark
+     glyph to the last component of the ligature.                        */
+
+  if ( IN_LIGID( j ) == IN_LIGID( buffer->in_pos) )
+  {
+    comp_index = IN_COMPONENT( buffer->in_pos );
+    if ( comp_index >= lat->ComponentCount )
+      return HB_Err_Not_Covered;
+  }
+  else
+    comp_index = lat->ComponentCount - 1;
+
+  cr         = &lat->ComponentRecord[comp_index];
+  lig_anchor = &cr->LigatureAnchor[class];
+
+  error = Get_Anchor( gpi, mark_anchor, IN_CURGLYPH(),
+		      &x_mark_value, &y_mark_value );
+  if ( error )
+    return error;
+  error = Get_Anchor( gpi, lig_anchor, IN_GLYPH( j ),
+		      &x_lig_value, &y_lig_value );
+  if ( error )
+    return error;
+
+  /* anchor points are not cumulative */
+
+  o = POSITION( buffer->in_pos );
+
+  o->x_pos     = x_lig_value - x_mark_value;
+  o->y_pos     = y_lig_value - y_mark_value;
+  o->x_advance = 0;
+  o->y_advance = 0;
+  o->back      = i;
+
+  (buffer->in_pos)++;
+
+  return HB_Err_Ok;
+}
+
+
+/* LookupType 6 */
+
+/* Mark2Array */
+
+static HB_Error  Load_Mark2Array( HB_Mark2Array*  m2a,
+				  HB_UShort        num_classes,
+				  HB_Stream        stream )
+{
+  HB_Error  error;
+
+  HB_UShort        m, n, count;
+  HB_UInt          cur_offset, new_offset, base_offset;
+
+  HB_Mark2Record  *m2r;
+  HB_Anchor       *m2an, *m2ans;
+
+
+  base_offset = FILE_Pos();
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  count = m2a->Mark2Count = GET_UShort();
+
+  FORGET_Frame();
+
+  m2a->Mark2Record = NULL;
+
+  if ( ALLOC_ARRAY( m2a->Mark2Record, count, HB_Mark2Record ) )
+    return error;
+
+  m2r = m2a->Mark2Record;
+
+  m2ans = NULL;
+
+  if ( ALLOC_ARRAY( m2ans, count * num_classes, HB_Anchor ) )
+    goto Fail;
+
+  for ( m = 0; m < count; m++ )
+  {
+    m2an = m2r[m].Mark2Anchor = m2ans + m * num_classes;
+
+    for ( n = 0; n < num_classes; n++ )
+    {
+      if ( ACCESS_Frame( 2L ) )
+	goto Fail;
+
+      new_offset = GET_UShort() + base_offset;
+
+      FORGET_Frame();
+
+      if (new_offset == base_offset) {
+        /* Anchor table not provided.  Skip loading.
+	 * Some versions of FreeSans hit this. */
+        m2an[n].PosFormat = 0;
+	continue;
+      }
+
+      cur_offset = FILE_Pos();
+      if ( FILE_Seek( new_offset ) ||
+	   ( error = Load_Anchor( &m2an[n], stream ) ) != HB_Err_Ok )
+	goto Fail;
+      (void)FILE_Seek( cur_offset );
+    }
+  }
+
+  return HB_Err_Ok;
+
+Fail:
+  FREE( m2ans );
+  FREE( m2r );
+  return error;
+}
+
+
+static void  Free_Mark2Array( HB_Mark2Array*  m2a,
+			      HB_UShort        num_classes )
+{
+  HB_Mark2Record  *m2r;
+  HB_Anchor       *m2ans;
+
+  HB_UNUSED(num_classes);
+
+  if ( m2a->Mark2Record )
+  {
+    m2r   = m2a->Mark2Record;
+
+    if ( m2a->Mark2Count )
+    {
+      m2ans = m2r[0].Mark2Anchor;
+      FREE( m2ans );
+    }
+
+    FREE( m2r );
+  }
+}
+
+
+/* MarkMarkPosFormat1 */
+
+static HB_Error  Load_MarkMarkPos( HB_GPOS_SubTable* st,
+				   HB_Stream         stream )
+{
+  HB_Error  error;
+  HB_MarkMarkPos* mmp = &st->markmark;
+
+  HB_UInt  cur_offset, new_offset, base_offset;
+
+
+  base_offset = FILE_Pos();
+
+  if ( ACCESS_Frame( 4L ) )
+    return error;
+
+  mmp->PosFormat = GET_UShort();
+  new_offset     = GET_UShort() + base_offset;
+
+  FORGET_Frame();
+
+  cur_offset = FILE_Pos();
+  if ( FILE_Seek( new_offset ) ||
+       ( error = _HB_OPEN_Load_Coverage( &mmp->Mark1Coverage,
+				stream ) ) != HB_Err_Ok )
+    return error;
+  (void)FILE_Seek( cur_offset );
+
+  if ( ACCESS_Frame( 2L ) )
+    goto Fail3;
+
+  new_offset = GET_UShort() + base_offset;
+
+  FORGET_Frame();
+
+  cur_offset = FILE_Pos();
+  if ( FILE_Seek( new_offset ) ||
+       ( error = _HB_OPEN_Load_Coverage( &mmp->Mark2Coverage,
+				stream ) ) != HB_Err_Ok )
+    goto Fail3;
+  (void)FILE_Seek( cur_offset );
+
+  if ( ACCESS_Frame( 4L ) )
+    goto Fail2;
+
+  mmp->ClassCount = GET_UShort();
+  new_offset      = GET_UShort() + base_offset;
+
+  FORGET_Frame();
+
+  cur_offset = FILE_Pos();
+  if ( FILE_Seek( new_offset ) ||
+       ( error = Load_MarkArray( &mmp->Mark1Array, stream ) ) != HB_Err_Ok )
+    goto Fail2;
+  (void)FILE_Seek( cur_offset );
+
+  if ( ACCESS_Frame( 2L ) )
+    goto Fail1;
+
+  new_offset = GET_UShort() + base_offset;
+
+  FORGET_Frame();
+
+  cur_offset = FILE_Pos();
+  if ( FILE_Seek( new_offset ) ||
+       ( error = Load_Mark2Array( &mmp->Mark2Array, mmp->ClassCount,
+				  stream ) ) != HB_Err_Ok )
+    goto Fail1;
+
+  return HB_Err_Ok;
+
+Fail1:
+  Free_MarkArray( &mmp->Mark1Array );
+
+Fail2:
+  _HB_OPEN_Free_Coverage( &mmp->Mark2Coverage );
+
+Fail3:
+  _HB_OPEN_Free_Coverage( &mmp->Mark1Coverage );
+  return error;
+}
+
+
+static void  Free_MarkMarkPos( HB_GPOS_SubTable* st)
+{
+  HB_MarkMarkPos* mmp = &st->markmark;
+
+  Free_Mark2Array( &mmp->Mark2Array, mmp->ClassCount );
+  Free_MarkArray( &mmp->Mark1Array );
+  _HB_OPEN_Free_Coverage( &mmp->Mark2Coverage );
+  _HB_OPEN_Free_Coverage( &mmp->Mark1Coverage );
+}
+
+
+static HB_Error  Lookup_MarkMarkPos( GPOS_Instance*    gpi,
+				     HB_GPOS_SubTable* st,
+				     HB_Buffer        buffer,
+				     HB_UShort         flags,
+				     HB_UShort         context_length,
+				     int               nesting_level )
+{
+  HB_UShort        i, j, mark1_index, mark2_index, property, class;
+  HB_Fixed           x_mark1_value, y_mark1_value,
+		   x_mark2_value, y_mark2_value;
+  HB_Error         error;
+  HB_GPOSHeader*  gpos = gpi->gpos;
+  HB_MarkMarkPos* mmp = &st->markmark;
+
+  HB_MarkArray*    ma1;
+  HB_Mark2Array*   ma2;
+  HB_Mark2Record*  m2r;
+  HB_Anchor*       mark1_anchor;
+  HB_Anchor*       mark2_anchor;
+
+  HB_Position    o;
+
+  HB_UNUSED(nesting_level);
+
+  if ( context_length != 0xFFFF && context_length < 1 )
+    return HB_Err_Not_Covered;
+
+  if ( flags & HB_LOOKUP_FLAG_IGNORE_MARKS )
+    return HB_Err_Not_Covered;
+
+  if ( CHECK_Property( gpos->gdef, IN_CURITEM(),
+		       flags, &property ) )
+    return error;
+
+  error = _HB_OPEN_Coverage_Index( &mmp->Mark1Coverage, IN_CURGLYPH(),
+			  &mark1_index );
+  if ( error )
+    return error;
+
+  /* now we search backwards for a suitable mark glyph until a non-mark
+     glyph                                                */
+
+  if ( buffer->in_pos == 0 )
+    return HB_Err_Not_Covered;
+
+  i = 1;
+  j = buffer->in_pos - 1;
+  while ( i <= buffer->in_pos )
+  {
+    error = HB_GDEF_Get_Glyph_Property( gpos->gdef, IN_GLYPH( j ),
+					&property );
+    if ( error )
+      return error;
+
+    if ( !( property == HB_GDEF_MARK || property & HB_LOOKUP_FLAG_IGNORE_SPECIAL_MARKS ) )
+      return HB_Err_Not_Covered;
+
+    if ( flags & HB_LOOKUP_FLAG_IGNORE_SPECIAL_MARKS )
+    {
+      if ( property == (flags & 0xFF00) )
+        break;
+    }
+    else
+      break;
+
+    i++;
+    j--;
+  }
+
+  error = _HB_OPEN_Coverage_Index( &mmp->Mark2Coverage, IN_GLYPH( j ),
+			  &mark2_index );
+  if ( error )
+    return error;
+
+  ma1 = &mmp->Mark1Array;
+
+  if ( mark1_index >= ma1->MarkCount )
+    return ERR(HB_Err_Invalid_SubTable);
+
+  class        = ma1->MarkRecord[mark1_index].Class;
+  mark1_anchor = &ma1->MarkRecord[mark1_index].MarkAnchor;
+
+  if ( class >= mmp->ClassCount )
+    return ERR(HB_Err_Invalid_SubTable);
+
+  ma2 = &mmp->Mark2Array;
+
+  if ( mark2_index >= ma2->Mark2Count )
+    return ERR(HB_Err_Invalid_SubTable);
+
+  m2r          = &ma2->Mark2Record[mark2_index];
+  mark2_anchor = &m2r->Mark2Anchor[class];
+
+  error = Get_Anchor( gpi, mark1_anchor, IN_CURGLYPH(),
+		      &x_mark1_value, &y_mark1_value );
+  if ( error )
+    return error;
+  error = Get_Anchor( gpi, mark2_anchor, IN_GLYPH( j ),
+		      &x_mark2_value, &y_mark2_value );
+  if ( error )
+    return error;
+
+  /* anchor points are not cumulative */
+
+  o = POSITION( buffer->in_pos );
+
+  o->x_pos     = x_mark2_value - x_mark1_value;
+  o->y_pos     = y_mark2_value - y_mark1_value;
+  o->x_advance = 0;
+  o->y_advance = 0;
+  o->back      = 1;
+
+  (buffer->in_pos)++;
+
+  return HB_Err_Ok;
+}
+
+
+/* Do the actual positioning for a context positioning (either format
+   7 or 8).  This is only called after we've determined that the stream
+   matches the subrule.                                                 */
+
+static HB_Error  Do_ContextPos( GPOS_Instance*        gpi,
+				HB_UShort             GlyphCount,
+				HB_UShort             PosCount,
+				HB_PosLookupRecord*  pos,
+				HB_Buffer            buffer,
+				int                   nesting_level )
+{
+  HB_Error  error;
+  HB_UInt   i, old_pos;
+
+
+  i = 0;
+
+  while ( i < GlyphCount )
+  {
+    if ( PosCount && i == pos->SequenceIndex )
+    {
+      old_pos = buffer->in_pos;
+
+      /* Do a positioning */
+
+      error = GPOS_Do_Glyph_Lookup( gpi, pos->LookupListIndex, buffer,
+				    GlyphCount, nesting_level );
+
+      if ( error )
+	return error;
+
+      pos++;
+      PosCount--;
+      i += buffer->in_pos - old_pos;
+    }
+    else
+    {
+      i++;
+      (buffer->in_pos)++;
+    }
+  }
+
+  return HB_Err_Ok;
+}
+
+
+/* LookupType 7 */
+
+/* PosRule */
+
+static HB_Error  Load_PosRule( HB_PosRule*  pr,
+			       HB_Stream     stream )
+{
+  HB_Error  error;
+
+  HB_UShort             n, count;
+  HB_UShort*            i;
+
+  HB_PosLookupRecord*  plr;
+
+
+  if ( ACCESS_Frame( 4L ) )
+    return error;
+
+  pr->GlyphCount = GET_UShort();
+  pr->PosCount   = GET_UShort();
+
+  FORGET_Frame();
+
+  pr->Input = NULL;
+
+  count = pr->GlyphCount - 1;         /* only GlyphCount - 1 elements */
+
+  if ( ALLOC_ARRAY( pr->Input, count, HB_UShort ) )
+    return error;
+
+  i = pr->Input;
+
+  if ( ACCESS_Frame( count * 2L ) )
+    goto Fail2;
+
+  for ( n = 0; n < count; n++ )
+    i[n] = GET_UShort();
+
+  FORGET_Frame();
+
+  pr->PosLookupRecord = NULL;
+
+  count = pr->PosCount;
+
+  if ( ALLOC_ARRAY( pr->PosLookupRecord, count, HB_PosLookupRecord ) )
+    goto Fail2;
+
+  plr = pr->PosLookupRecord;
+
+  if ( ACCESS_Frame( count * 4L ) )
+    goto Fail1;
+
+  for ( n = 0; n < count; n++ )
+  {
+    plr[n].SequenceIndex   = GET_UShort();
+    plr[n].LookupListIndex = GET_UShort();
+  }
+
+  FORGET_Frame();
+
+  return HB_Err_Ok;
+
+Fail1:
+  FREE( plr );
+
+Fail2:
+  FREE( i );
+  return error;
+}
+
+
+static void  Free_PosRule( HB_PosRule*  pr )
+{
+  FREE( pr->PosLookupRecord );
+  FREE( pr->Input );
+}
+
+
+/* PosRuleSet */
+
+static HB_Error  Load_PosRuleSet( HB_PosRuleSet*  prs,
+				  HB_Stream        stream )
+{
+  HB_Error  error;
+
+  HB_UShort     n, m, count;
+  HB_UInt      cur_offset, new_offset, base_offset;
+
+  HB_PosRule*  pr;
+
+
+  base_offset = FILE_Pos();
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  count = prs->PosRuleCount = GET_UShort();
+
+  FORGET_Frame();
+
+  prs->PosRule = NULL;
+
+  if ( ALLOC_ARRAY( prs->PosRule, count, HB_PosRule ) )
+    return error;
+
+  pr = prs->PosRule;
+
+  for ( n = 0; n < count; n++ )
+  {
+    if ( ACCESS_Frame( 2L ) )
+      goto Fail;
+
+    new_offset = GET_UShort() + base_offset;
+
+    FORGET_Frame();
+
+    cur_offset = FILE_Pos();
+    if ( FILE_Seek( new_offset ) ||
+	 ( error = Load_PosRule( &pr[n], stream ) ) != HB_Err_Ok )
+      goto Fail;
+    (void)FILE_Seek( cur_offset );
+  }
+
+  return HB_Err_Ok;
+
+Fail:
+  for ( m = 0; m < n; m++ )
+    Free_PosRule( &pr[m] );
+
+  FREE( pr );
+  return error;
+}
+
+
+static void  Free_PosRuleSet( HB_PosRuleSet*  prs )
+{
+  HB_UShort     n, count;
+
+  HB_PosRule*  pr;
+
+
+  if ( prs->PosRule )
+  {
+    count = prs->PosRuleCount;
+    pr    = prs->PosRule;
+
+    for ( n = 0; n < count; n++ )
+      Free_PosRule( &pr[n] );
+
+    FREE( pr );
+  }
+}
+
+
+/* ContextPosFormat1 */
+
+static HB_Error  Load_ContextPos1( HB_ContextPosFormat1*  cpf1,
+				   HB_Stream               stream )
+{
+  HB_Error  error;
+
+  HB_UShort        n, m, count;
+  HB_UInt         cur_offset, new_offset, base_offset;
+
+  HB_PosRuleSet*  prs;
+
+
+  base_offset = FILE_Pos() - 2L;
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  new_offset = GET_UShort() + base_offset;
+
+  FORGET_Frame();
+
+  cur_offset = FILE_Pos();
+  if ( FILE_Seek( new_offset ) ||
+       ( error = _HB_OPEN_Load_Coverage( &cpf1->Coverage, stream ) ) != HB_Err_Ok )
+    return error;
+  (void)FILE_Seek( cur_offset );
+
+  if ( ACCESS_Frame( 2L ) )
+    goto Fail2;
+
+  count = cpf1->PosRuleSetCount = GET_UShort();
+
+  FORGET_Frame();
+
+  cpf1->PosRuleSet = NULL;
+
+  if ( ALLOC_ARRAY( cpf1->PosRuleSet, count, HB_PosRuleSet ) )
+    goto Fail2;
+
+  prs = cpf1->PosRuleSet;
+
+  for ( n = 0; n < count; n++ )
+  {
+    if ( ACCESS_Frame( 2L ) )
+      goto Fail1;
+
+    new_offset = GET_UShort() + base_offset;
+
+    FORGET_Frame();
+
+    cur_offset = FILE_Pos();
+    if ( FILE_Seek( new_offset ) ||
+	 ( error = Load_PosRuleSet( &prs[n], stream ) ) != HB_Err_Ok )
+      goto Fail1;
+    (void)FILE_Seek( cur_offset );
+  }
+
+  return HB_Err_Ok;
+
+Fail1:
+  for ( m = 0; m < n; m++ )
+    Free_PosRuleSet( &prs[m] );
+
+  FREE( prs );
+
+Fail2:
+  _HB_OPEN_Free_Coverage( &cpf1->Coverage );
+  return error;
+}
+
+
+static void  Free_ContextPos1( HB_ContextPosFormat1*  cpf1 )
+{
+  HB_UShort        n, count;
+
+  HB_PosRuleSet*  prs;
+
+
+  if ( cpf1->PosRuleSet )
+  {
+    count = cpf1->PosRuleSetCount;
+    prs   = cpf1->PosRuleSet;
+
+    for ( n = 0; n < count; n++ )
+      Free_PosRuleSet( &prs[n] );
+
+    FREE( prs );
+  }
+
+  _HB_OPEN_Free_Coverage( &cpf1->Coverage );
+}
+
+
+/* PosClassRule */
+
+static HB_Error  Load_PosClassRule( HB_ContextPosFormat2*  cpf2,
+				    HB_PosClassRule*       pcr,
+				    HB_Stream               stream )
+{
+  HB_Error  error;
+
+  HB_UShort             n, count;
+
+  HB_UShort*            c;
+  HB_PosLookupRecord*  plr;
+
+
+  if ( ACCESS_Frame( 4L ) )
+    return error;
+
+  pcr->GlyphCount = GET_UShort();
+  pcr->PosCount   = GET_UShort();
+
+  FORGET_Frame();
+
+  if ( pcr->GlyphCount > cpf2->MaxContextLength )
+    cpf2->MaxContextLength = pcr->GlyphCount;
+
+  pcr->Class = NULL;
+
+  count = pcr->GlyphCount - 1;        /* only GlyphCount - 1 elements */
+
+  if ( ALLOC_ARRAY( pcr->Class, count, HB_UShort ) )
+    return error;
+
+  c = pcr->Class;
+
+  if ( ACCESS_Frame( count * 2L ) )
+    goto Fail2;
+
+  for ( n = 0; n < count; n++ )
+    c[n] = GET_UShort();
+
+  FORGET_Frame();
+
+  pcr->PosLookupRecord = NULL;
+
+  count = pcr->PosCount;
+
+  if ( ALLOC_ARRAY( pcr->PosLookupRecord, count, HB_PosLookupRecord ) )
+    goto Fail2;
+
+  plr = pcr->PosLookupRecord;
+
+  if ( ACCESS_Frame( count * 4L ) )
+    goto Fail1;
+
+  for ( n = 0; n < count; n++ )
+  {
+    plr[n].SequenceIndex   = GET_UShort();
+    plr[n].LookupListIndex = GET_UShort();
+  }
+
+  FORGET_Frame();
+
+  return HB_Err_Ok;
+
+Fail1:
+  FREE( plr );
+
+Fail2:
+  FREE( c );
+  return error;
+}
+
+
+static void  Free_PosClassRule( HB_PosClassRule*  pcr )
+{
+  FREE( pcr->PosLookupRecord );
+  FREE( pcr->Class );
+}
+
+
+/* PosClassSet */
+
+static HB_Error  Load_PosClassSet( HB_ContextPosFormat2*  cpf2,
+				   HB_PosClassSet*        pcs,
+				   HB_Stream               stream )
+{
+  HB_Error  error;
+
+  HB_UShort          n, m, count;
+  HB_UInt           cur_offset, new_offset, base_offset;
+
+  HB_PosClassRule*  pcr;
+
+
+  base_offset = FILE_Pos();
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  count = pcs->PosClassRuleCount = GET_UShort();
+
+  FORGET_Frame();
+
+  pcs->PosClassRule = NULL;
+
+  if ( ALLOC_ARRAY( pcs->PosClassRule, count, HB_PosClassRule ) )
+    return error;
+
+  pcr = pcs->PosClassRule;
+
+  for ( n = 0; n < count; n++ )
+  {
+    if ( ACCESS_Frame( 2L ) )
+      goto Fail;
+
+    new_offset = GET_UShort() + base_offset;
+
+    FORGET_Frame();
+
+    cur_offset = FILE_Pos();
+    if ( FILE_Seek( new_offset ) ||
+	 ( error = Load_PosClassRule( cpf2, &pcr[n],
+				      stream ) ) != HB_Err_Ok )
+      goto Fail;
+    (void)FILE_Seek( cur_offset );
+  }
+
+  return HB_Err_Ok;
+
+Fail:
+  for ( m = 0; m < n; m++ )
+    Free_PosClassRule( &pcr[m] );
+
+  FREE( pcr );
+  return error;
+}
+
+
+static void  Free_PosClassSet( HB_PosClassSet*  pcs )
+{
+  HB_UShort          n, count;
+
+  HB_PosClassRule*  pcr;
+
+
+  if ( pcs->PosClassRule )
+  {
+    count = pcs->PosClassRuleCount;
+    pcr   = pcs->PosClassRule;
+
+    for ( n = 0; n < count; n++ )
+      Free_PosClassRule( &pcr[n] );
+
+    FREE( pcr );
+  }
+}
+
+
+/* ContextPosFormat2 */
+
+static HB_Error  Load_ContextPos2( HB_ContextPosFormat2*  cpf2,
+				   HB_Stream               stream )
+{
+  HB_Error  error;
+
+  HB_UShort         n, m, count;
+  HB_UInt          cur_offset, new_offset, base_offset;
+
+  HB_PosClassSet*  pcs;
+
+
+  base_offset = FILE_Pos() - 2;
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  new_offset = GET_UShort() + base_offset;
+
+  FORGET_Frame();
+
+  cur_offset = FILE_Pos();
+  if ( FILE_Seek( new_offset ) ||
+       ( error = _HB_OPEN_Load_Coverage( &cpf2->Coverage, stream ) ) != HB_Err_Ok )
+    return error;
+  (void)FILE_Seek( cur_offset );
+
+  if ( ACCESS_Frame( 4L ) )
+    goto Fail3;
+
+  new_offset = GET_UShort() + base_offset;
+
+  /* `PosClassSetCount' is the upper limit for class values, thus we
+     read it now to make an additional safety check.                 */
+
+  count = cpf2->PosClassSetCount = GET_UShort();
+
+  FORGET_Frame();
+
+  cur_offset = FILE_Pos();
+  if ( FILE_Seek( new_offset ) ||
+       ( error = _HB_OPEN_Load_ClassDefinition( &cpf2->ClassDef, count,
+				       stream ) ) != HB_Err_Ok )
+    goto Fail3;
+  (void)FILE_Seek( cur_offset );
+
+  cpf2->PosClassSet      = NULL;
+  cpf2->MaxContextLength = 0;
+
+  if ( ALLOC_ARRAY( cpf2->PosClassSet, count, HB_PosClassSet ) )
+    goto Fail2;
+
+  pcs = cpf2->PosClassSet;
+
+  for ( n = 0; n < count; n++ )
+  {
+    if ( ACCESS_Frame( 2L ) )
+      goto Fail1;
+
+    new_offset = GET_UShort() + base_offset;
+
+    FORGET_Frame();
+
+    if ( new_offset != base_offset )      /* not a NULL offset */
+    {
+      cur_offset = FILE_Pos();
+      if ( FILE_Seek( new_offset ) ||
+	   ( error = Load_PosClassSet( cpf2, &pcs[n],
+				       stream ) ) != HB_Err_Ok )
+	goto Fail1;
+      (void)FILE_Seek( cur_offset );
+    }
+    else
+    {
+      /* we create a PosClassSet table with no entries */
+
+      cpf2->PosClassSet[n].PosClassRuleCount = 0;
+      cpf2->PosClassSet[n].PosClassRule      = NULL;
+    }
+  }
+
+  return HB_Err_Ok;
+
+Fail1:
+  for ( m = 0; m < n; n++ )
+    Free_PosClassSet( &pcs[m] );
+
+  FREE( pcs );
+
+Fail2:
+  _HB_OPEN_Free_ClassDefinition( &cpf2->ClassDef );
+
+Fail3:
+  _HB_OPEN_Free_Coverage( &cpf2->Coverage );
+  return error;
+}
+
+
+static void  Free_ContextPos2( HB_ContextPosFormat2*  cpf2 )
+{
+  HB_UShort         n, count;
+
+  HB_PosClassSet*  pcs;
+
+
+  if ( cpf2->PosClassSet )
+  {
+    count = cpf2->PosClassSetCount;
+    pcs   = cpf2->PosClassSet;
+
+    for ( n = 0; n < count; n++ )
+      Free_PosClassSet( &pcs[n] );
+
+    FREE( pcs );
+  }
+
+  _HB_OPEN_Free_ClassDefinition( &cpf2->ClassDef );
+  _HB_OPEN_Free_Coverage( &cpf2->Coverage );
+}
+
+
+/* ContextPosFormat3 */
+
+static HB_Error  Load_ContextPos3( HB_ContextPosFormat3*  cpf3,
+				   HB_Stream               stream )
+{
+  HB_Error  error;
+
+  HB_UShort             n, count;
+  HB_UInt              cur_offset, new_offset, base_offset;
+
+  HB_Coverage*         c;
+  HB_PosLookupRecord*  plr;
+
+
+  base_offset = FILE_Pos() - 2L;
+
+  if ( ACCESS_Frame( 4L ) )
+    return error;
+
+  cpf3->GlyphCount = GET_UShort();
+  cpf3->PosCount   = GET_UShort();
+
+  FORGET_Frame();
+
+  cpf3->Coverage = NULL;
+
+  count = cpf3->GlyphCount;
+
+  if ( ALLOC_ARRAY( cpf3->Coverage, count, HB_Coverage ) )
+    return error;
+
+  c = cpf3->Coverage;
+
+  for ( n = 0; n < count; n++ )
+  {
+    if ( ACCESS_Frame( 2L ) )
+      goto Fail2;
+
+    new_offset = GET_UShort() + base_offset;
+
+    FORGET_Frame();
+
+    cur_offset = FILE_Pos();
+    if ( FILE_Seek( new_offset ) ||
+	 ( error = _HB_OPEN_Load_Coverage( &c[n], stream ) ) != HB_Err_Ok )
+      goto Fail2;
+    (void)FILE_Seek( cur_offset );
+  }
+
+  cpf3->PosLookupRecord = NULL;
+
+  count = cpf3->PosCount;
+
+  if ( ALLOC_ARRAY( cpf3->PosLookupRecord, count, HB_PosLookupRecord ) )
+    goto Fail2;
+
+  plr = cpf3->PosLookupRecord;
+
+  if ( ACCESS_Frame( count * 4L ) )
+    goto Fail1;
+
+  for ( n = 0; n < count; n++ )
+  {
+    plr[n].SequenceIndex   = GET_UShort();
+    plr[n].LookupListIndex = GET_UShort();
+  }
+
+  FORGET_Frame();
+
+  return HB_Err_Ok;
+
+Fail1:
+  FREE( plr );
+
+Fail2:
+  for ( n = 0; n < count; n++ )
+    _HB_OPEN_Free_Coverage( &c[n] );
+
+  FREE( c );
+  return error;
+}
+
+
+static void  Free_ContextPos3( HB_ContextPosFormat3*  cpf3 )
+{
+  HB_UShort      n, count;
+
+  HB_Coverage*  c;
+
+
+  FREE( cpf3->PosLookupRecord );
+
+  if ( cpf3->Coverage )
+  {
+    count = cpf3->GlyphCount;
+    c     = cpf3->Coverage;
+
+    for ( n = 0; n < count; n++ )
+      _HB_OPEN_Free_Coverage( &c[n] );
+
+    FREE( c );
+  }
+}
+
+
+/* ContextPos */
+
+static HB_Error  Load_ContextPos( HB_GPOS_SubTable* st,
+				  HB_Stream        stream )
+{
+  HB_Error  error;
+  HB_ContextPos*   cp = &st->context;
+
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  cp->PosFormat = GET_UShort();
+
+  FORGET_Frame();
+
+  switch ( cp->PosFormat )
+  {
+  case 1:
+    return Load_ContextPos1( &cp->cpf.cpf1, stream );
+
+  case 2:
+    return Load_ContextPos2( &cp->cpf.cpf2, stream );
+
+  case 3:
+    return Load_ContextPos3( &cp->cpf.cpf3, stream );
+
+  default:
+    return ERR(HB_Err_Invalid_SubTable_Format);
+  }
+
+  return HB_Err_Ok;               /* never reached */
+}
+
+
+static void  Free_ContextPos( HB_GPOS_SubTable* st )
+{
+  HB_ContextPos*   cp = &st->context;
+
+  switch ( cp->PosFormat )
+  {
+  case 1:  Free_ContextPos1( &cp->cpf.cpf1 ); break;
+  case 2:  Free_ContextPos2( &cp->cpf.cpf2 ); break;
+  case 3:  Free_ContextPos3( &cp->cpf.cpf3 ); break;
+  default:					      break;
+  }
+}
+
+
+static HB_Error  Lookup_ContextPos1( GPOS_Instance*          gpi,
+				     HB_ContextPosFormat1*  cpf1,
+				     HB_Buffer              buffer,
+				     HB_UShort               flags,
+				     HB_UShort               context_length,
+				     int                     nesting_level )
+{
+  HB_UShort        index, property;
+  HB_UShort        i, j, k, numpr;
+  HB_Error         error;
+  HB_GPOSHeader*  gpos = gpi->gpos;
+
+  HB_PosRule*     pr;
+  HB_GDEFHeader*  gdef;
+
+
+  gdef = gpos->gdef;
+
+  if ( CHECK_Property( gdef, IN_CURITEM(), flags, &property ) )
+    return error;
+
+  error = _HB_OPEN_Coverage_Index( &cpf1->Coverage, IN_CURGLYPH(), &index );
+  if ( error )
+    return error;
+
+  pr    = cpf1->PosRuleSet[index].PosRule;
+  numpr = cpf1->PosRuleSet[index].PosRuleCount;
+
+  for ( k = 0; k < numpr; k++ )
+  {
+    if ( context_length != 0xFFFF && context_length < pr[k].GlyphCount )
+      goto next_posrule;
+
+    if ( buffer->in_pos + pr[k].GlyphCount > buffer->in_length )
+      goto next_posrule;                       /* context is too long */
+
+    for ( i = 1, j = buffer->in_pos + 1; i < pr[k].GlyphCount; i++, j++ )
+    {
+      while ( CHECK_Property( gdef, IN_ITEM( j ), flags, &property ) )
+      {
+	if ( error && error != HB_Err_Not_Covered )
+	  return error;
+
+	if ( j + pr[k].GlyphCount - i == (HB_Int)buffer->in_length )
+	  goto next_posrule;
+	j++;
+      }
+
+      if ( IN_GLYPH( j ) != pr[k].Input[i - 1] )
+	goto next_posrule;
+    }
+
+    return Do_ContextPos( gpi, pr[k].GlyphCount,
+			  pr[k].PosCount, pr[k].PosLookupRecord,
+			  buffer,
+			  nesting_level );
+
+    next_posrule:
+      ;
+  }
+
+  return HB_Err_Not_Covered;
+}
+
+
+static HB_Error  Lookup_ContextPos2( GPOS_Instance*          gpi,
+				     HB_ContextPosFormat2*  cpf2,
+				     HB_Buffer              buffer,
+				     HB_UShort               flags,
+				     HB_UShort               context_length,
+				     int                     nesting_level )
+{
+  HB_UShort          index, property;
+  HB_Error           error;
+  HB_UShort          i, j, k, known_classes;
+
+  HB_UShort*         classes;
+  HB_UShort*         cl;
+  HB_GPOSHeader*    gpos = gpi->gpos;
+
+  HB_PosClassSet*   pcs;
+  HB_PosClassRule*  pr;
+  HB_GDEFHeader*    gdef;
+
+
+  gdef = gpos->gdef;
+
+  if ( CHECK_Property( gdef, IN_CURITEM(), flags, &property ) )
+    return error;
+
+  /* Note: The coverage table in format 2 doesn't give an index into
+	   anything.  It just lets us know whether or not we need to
+	   do any lookup at all.                                     */
+
+  error = _HB_OPEN_Coverage_Index( &cpf2->Coverage, IN_CURGLYPH(), &index );
+  if ( error )
+    return error;
+
+  if (cpf2->MaxContextLength < 1)
+    return HB_Err_Not_Covered;
+
+  if ( ALLOC_ARRAY( classes, cpf2->MaxContextLength, HB_UShort ) )
+    return error;
+
+  error = _HB_OPEN_Get_Class( &cpf2->ClassDef, IN_CURGLYPH(),
+		     &classes[0], NULL );
+  if ( error && error != HB_Err_Not_Covered )
+    goto End;
+  known_classes = 0;
+
+  pcs = &cpf2->PosClassSet[classes[0]];
+  if ( !pcs )
+  {
+    error = ERR(HB_Err_Invalid_SubTable);
+    goto End;
+  }
+
+  for ( k = 0; k < pcs->PosClassRuleCount; k++ )
+  {
+    pr = &pcs->PosClassRule[k];
+
+    if ( context_length != 0xFFFF && context_length < pr->GlyphCount )
+      goto next_posclassrule;
+
+    if ( buffer->in_pos + pr->GlyphCount > buffer->in_length )
+      goto next_posclassrule;                /* context is too long */
+
+    cl   = pr->Class;
+
+    /* Start at 1 because [0] is implied */
+
+    for ( i = 1, j = buffer->in_pos + 1; i < pr->GlyphCount; i++, j++ )
+    {
+      while ( CHECK_Property( gdef, IN_ITEM( j ), flags, &property ) )
+      {
+	if ( error && error != HB_Err_Not_Covered )
+	  goto End;
+
+	if ( j + pr->GlyphCount - i == (HB_Int)buffer->in_length )
+	  goto next_posclassrule;
+	j++;
+      }
+
+      if ( i > known_classes )
+      {
+	/* Keeps us from having to do this for each rule */
+
+	error = _HB_OPEN_Get_Class( &cpf2->ClassDef, IN_GLYPH( j ), &classes[i], NULL );
+	if ( error && error != HB_Err_Not_Covered )
+	  goto End;
+	known_classes = i;
+      }
+
+      if ( cl[i - 1] != classes[i] )
+	goto next_posclassrule;
+    }
+
+    error = Do_ContextPos( gpi, pr->GlyphCount,
+			   pr->PosCount, pr->PosLookupRecord,
+			   buffer,
+			   nesting_level );
+    goto End;
+
+  next_posclassrule:
+    ;
+  }
+
+  error = HB_Err_Not_Covered;
+
+End:
+  FREE( classes );
+  return error;
+}
+
+
+static HB_Error  Lookup_ContextPos3( GPOS_Instance*          gpi,
+				     HB_ContextPosFormat3*  cpf3,
+				     HB_Buffer              buffer,
+				     HB_UShort               flags,
+				     HB_UShort               context_length,
+				     int                     nesting_level )
+{
+  HB_Error         error;
+  HB_UShort        index, i, j, property;
+  HB_GPOSHeader*  gpos = gpi->gpos;
+
+  HB_Coverage*    c;
+  HB_GDEFHeader*  gdef;
+
+
+  gdef = gpos->gdef;
+
+  if ( CHECK_Property( gdef, IN_CURITEM(), flags, &property ) )
+    return error;
+
+  if ( context_length != 0xFFFF && context_length < cpf3->GlyphCount )
+    return HB_Err_Not_Covered;
+
+  if ( buffer->in_pos + cpf3->GlyphCount > buffer->in_length )
+    return HB_Err_Not_Covered;         /* context is too long */
+
+  c    = cpf3->Coverage;
+
+  for ( i = 1, j = 1; i < cpf3->GlyphCount; i++, j++ )
+  {
+    while ( CHECK_Property( gdef, IN_ITEM( j ), flags, &property ) )
+    {
+      if ( error && error != HB_Err_Not_Covered )
+	return error;
+
+      if ( j + cpf3->GlyphCount - i == (HB_Int)buffer->in_length )
+	return HB_Err_Not_Covered;
+      j++;
+    }
+
+    error = _HB_OPEN_Coverage_Index( &c[i], IN_GLYPH( j ), &index );
+    if ( error )
+      return error;
+  }
+
+  return Do_ContextPos( gpi, cpf3->GlyphCount,
+			cpf3->PosCount, cpf3->PosLookupRecord,
+			buffer,
+			nesting_level );
+}
+
+
+static HB_Error  Lookup_ContextPos( GPOS_Instance*    gpi,
+				    HB_GPOS_SubTable* st,
+				    HB_Buffer        buffer,
+				    HB_UShort         flags,
+				    HB_UShort         context_length,
+				    int               nesting_level )
+{
+  HB_ContextPos*   cp = &st->context;
+
+  switch ( cp->PosFormat )
+  {
+  case 1:
+    return Lookup_ContextPos1( gpi, &cp->cpf.cpf1, buffer,
+			       flags, context_length, nesting_level );
+
+  case 2:
+    return Lookup_ContextPos2( gpi, &cp->cpf.cpf2, buffer,
+			       flags, context_length, nesting_level );
+
+  case 3:
+    return Lookup_ContextPos3( gpi, &cp->cpf.cpf3, buffer,
+			       flags, context_length, nesting_level );
+
+  default:
+    return ERR(HB_Err_Invalid_SubTable_Format);
+  }
+
+  return HB_Err_Ok;               /* never reached */
+}
+
+
+/* LookupType 8 */
+
+/* ChainPosRule */
+
+static HB_Error  Load_ChainPosRule( HB_ChainPosRule*  cpr,
+				    HB_Stream          stream )
+{
+  HB_Error  error;
+
+  HB_UShort             n, count;
+  HB_UShort*            b;
+  HB_UShort*            i;
+  HB_UShort*            l;
+
+  HB_PosLookupRecord*  plr;
+
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  cpr->BacktrackGlyphCount = GET_UShort();
+
+  FORGET_Frame();
+
+  cpr->Backtrack = NULL;
+
+  count = cpr->BacktrackGlyphCount;
+
+  if ( ALLOC_ARRAY( cpr->Backtrack, count, HB_UShort ) )
+    return error;
+
+  b = cpr->Backtrack;
+
+  if ( ACCESS_Frame( count * 2L ) )
+    goto Fail4;
+
+  for ( n = 0; n < count; n++ )
+    b[n] = GET_UShort();
+
+  FORGET_Frame();
+
+  if ( ACCESS_Frame( 2L ) )
+    goto Fail4;
+
+  cpr->InputGlyphCount = GET_UShort();
+
+  FORGET_Frame();
+
+  cpr->Input = NULL;
+
+  count = cpr->InputGlyphCount - 1;  /* only InputGlyphCount - 1 elements */
+
+  if ( ALLOC_ARRAY( cpr->Input, count, HB_UShort ) )
+    goto Fail4;
+
+  i = cpr->Input;
+
+  if ( ACCESS_Frame( count * 2L ) )
+    goto Fail3;
+
+  for ( n = 0; n < count; n++ )
+    i[n] = GET_UShort();
+
+  FORGET_Frame();
+
+  if ( ACCESS_Frame( 2L ) )
+    goto Fail3;
+
+  cpr->LookaheadGlyphCount = GET_UShort();
+
+  FORGET_Frame();
+
+  cpr->Lookahead = NULL;
+
+  count = cpr->LookaheadGlyphCount;
+
+  if ( ALLOC_ARRAY( cpr->Lookahead, count, HB_UShort ) )
+    goto Fail3;
+
+  l = cpr->Lookahead;
+
+  if ( ACCESS_Frame( count * 2L ) )
+    goto Fail2;
+
+  for ( n = 0; n < count; n++ )
+    l[n] = GET_UShort();
+
+  FORGET_Frame();
+
+  if ( ACCESS_Frame( 2L ) )
+    goto Fail2;
+
+  cpr->PosCount = GET_UShort();
+
+  FORGET_Frame();
+
+  cpr->PosLookupRecord = NULL;
+
+  count = cpr->PosCount;
+
+  if ( ALLOC_ARRAY( cpr->PosLookupRecord, count, HB_PosLookupRecord ) )
+    goto Fail2;
+
+  plr = cpr->PosLookupRecord;
+
+  if ( ACCESS_Frame( count * 4L ) )
+    goto Fail1;
+
+  for ( n = 0; n < count; n++ )
+  {
+    plr[n].SequenceIndex   = GET_UShort();
+    plr[n].LookupListIndex = GET_UShort();
+  }
+
+  FORGET_Frame();
+
+  return HB_Err_Ok;
+
+Fail1:
+  FREE( plr );
+
+Fail2:
+  FREE( l );
+
+Fail3:
+  FREE( i );
+
+Fail4:
+  FREE( b );
+  return error;
+}
+
+
+static void  Free_ChainPosRule( HB_ChainPosRule*  cpr )
+{
+  FREE( cpr->PosLookupRecord );
+  FREE( cpr->Lookahead );
+  FREE( cpr->Input );
+  FREE( cpr->Backtrack );
+}
+
+
+/* ChainPosRuleSet */
+
+static HB_Error  Load_ChainPosRuleSet( HB_ChainPosRuleSet*  cprs,
+				       HB_Stream             stream )
+{
+  HB_Error  error;
+
+  HB_UShort          n, m, count;
+  HB_UInt           cur_offset, new_offset, base_offset;
+
+  HB_ChainPosRule*  cpr;
+
+
+  base_offset = FILE_Pos();
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  count = cprs->ChainPosRuleCount = GET_UShort();
+
+  FORGET_Frame();
+
+  cprs->ChainPosRule = NULL;
+
+  if ( ALLOC_ARRAY( cprs->ChainPosRule, count, HB_ChainPosRule ) )
+    return error;
+
+  cpr = cprs->ChainPosRule;
+
+  for ( n = 0; n < count; n++ )
+  {
+    if ( ACCESS_Frame( 2L ) )
+      goto Fail;
+
+    new_offset = GET_UShort() + base_offset;
+
+    FORGET_Frame();
+
+    cur_offset = FILE_Pos();
+    if ( FILE_Seek( new_offset ) ||
+	 ( error = Load_ChainPosRule( &cpr[n], stream ) ) != HB_Err_Ok )
+      goto Fail;
+    (void)FILE_Seek( cur_offset );
+  }
+
+  return HB_Err_Ok;
+
+Fail:
+  for ( m = 0; m < n; m++ )
+    Free_ChainPosRule( &cpr[m] );
+
+  FREE( cpr );
+  return error;
+}
+
+
+static void  Free_ChainPosRuleSet( HB_ChainPosRuleSet*  cprs )
+{
+  HB_UShort          n, count;
+
+  HB_ChainPosRule*  cpr;
+
+
+  if ( cprs->ChainPosRule )
+  {
+    count = cprs->ChainPosRuleCount;
+    cpr   = cprs->ChainPosRule;
+
+    for ( n = 0; n < count; n++ )
+      Free_ChainPosRule( &cpr[n] );
+
+    FREE( cpr );
+  }
+}
+
+
+/* ChainContextPosFormat1 */
+
+static HB_Error  Load_ChainContextPos1( HB_ChainContextPosFormat1*  ccpf1,
+					HB_Stream                    stream )
+{
+  HB_Error  error;
+
+  HB_UShort             n, m, count;
+  HB_UInt              cur_offset, new_offset, base_offset;
+
+  HB_ChainPosRuleSet*  cprs;
+
+
+  base_offset = FILE_Pos() - 2L;
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  new_offset = GET_UShort() + base_offset;
+
+  FORGET_Frame();
+
+  cur_offset = FILE_Pos();
+  if ( FILE_Seek( new_offset ) ||
+       ( error = _HB_OPEN_Load_Coverage( &ccpf1->Coverage, stream ) ) != HB_Err_Ok )
+    return error;
+  (void)FILE_Seek( cur_offset );
+
+  if ( ACCESS_Frame( 2L ) )
+    goto Fail2;
+
+  count = ccpf1->ChainPosRuleSetCount = GET_UShort();
+
+  FORGET_Frame();
+
+  ccpf1->ChainPosRuleSet = NULL;
+
+  if ( ALLOC_ARRAY( ccpf1->ChainPosRuleSet, count, HB_ChainPosRuleSet ) )
+    goto Fail2;
+
+  cprs = ccpf1->ChainPosRuleSet;
+
+  for ( n = 0; n < count; n++ )
+  {
+    if ( ACCESS_Frame( 2L ) )
+      goto Fail1;
+
+    new_offset = GET_UShort() + base_offset;
+
+    FORGET_Frame();
+
+    cur_offset = FILE_Pos();
+    if ( FILE_Seek( new_offset ) ||
+	 ( error = Load_ChainPosRuleSet( &cprs[n], stream ) ) != HB_Err_Ok )
+      goto Fail1;
+    (void)FILE_Seek( cur_offset );
+  }
+
+  return HB_Err_Ok;
+
+Fail1:
+  for ( m = 0; m < n; m++ )
+    Free_ChainPosRuleSet( &cprs[m] );
+
+  FREE( cprs );
+
+Fail2:
+  _HB_OPEN_Free_Coverage( &ccpf1->Coverage );
+  return error;
+}
+
+
+static void  Free_ChainContextPos1( HB_ChainContextPosFormat1*  ccpf1 )
+{
+  HB_UShort             n, count;
+
+  HB_ChainPosRuleSet*  cprs;
+
+
+  if ( ccpf1->ChainPosRuleSet )
+  {
+    count = ccpf1->ChainPosRuleSetCount;
+    cprs  = ccpf1->ChainPosRuleSet;
+
+    for ( n = 0; n < count; n++ )
+      Free_ChainPosRuleSet( &cprs[n] );
+
+    FREE( cprs );
+  }
+
+  _HB_OPEN_Free_Coverage( &ccpf1->Coverage );
+}
+
+
+/* ChainPosClassRule */
+
+static HB_Error  Load_ChainPosClassRule(
+		   HB_ChainContextPosFormat2*  ccpf2,
+		   HB_ChainPosClassRule*       cpcr,
+		   HB_Stream                    stream )
+{
+  HB_Error  error;
+
+  HB_UShort             n, count;
+
+  HB_UShort*            b;
+  HB_UShort*            i;
+  HB_UShort*            l;
+  HB_PosLookupRecord*  plr;
+
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  cpcr->BacktrackGlyphCount = GET_UShort();
+
+  FORGET_Frame();
+
+  if ( cpcr->BacktrackGlyphCount > ccpf2->MaxBacktrackLength )
+    ccpf2->MaxBacktrackLength = cpcr->BacktrackGlyphCount;
+
+  cpcr->Backtrack = NULL;
+
+  count = cpcr->BacktrackGlyphCount;
+
+  if ( ALLOC_ARRAY( cpcr->Backtrack, count, HB_UShort ) )
+    return error;
+
+  b = cpcr->Backtrack;
+
+  if ( ACCESS_Frame( count * 2L ) )
+    goto Fail4;
+
+  for ( n = 0; n < count; n++ )
+    b[n] = GET_UShort();
+
+  FORGET_Frame();
+
+  if ( ACCESS_Frame( 2L ) )
+    goto Fail4;
+
+  cpcr->InputGlyphCount = GET_UShort();
+
+  if ( cpcr->InputGlyphCount > ccpf2->MaxInputLength )
+    ccpf2->MaxInputLength = cpcr->InputGlyphCount;
+
+  FORGET_Frame();
+
+  cpcr->Input = NULL;
+
+  count = cpcr->InputGlyphCount - 1; /* only InputGlyphCount - 1 elements */
+
+  if ( ALLOC_ARRAY( cpcr->Input, count, HB_UShort ) )
+    goto Fail4;
+
+  i = cpcr->Input;
+
+  if ( ACCESS_Frame( count * 2L ) )
+    goto Fail3;
+
+  for ( n = 0; n < count; n++ )
+    i[n] = GET_UShort();
+
+  FORGET_Frame();
+
+  if ( ACCESS_Frame( 2L ) )
+    goto Fail3;
+
+  cpcr->LookaheadGlyphCount = GET_UShort();
+
+  FORGET_Frame();
+
+  if ( cpcr->LookaheadGlyphCount > ccpf2->MaxLookaheadLength )
+    ccpf2->MaxLookaheadLength = cpcr->LookaheadGlyphCount;
+
+  cpcr->Lookahead = NULL;
+
+  count = cpcr->LookaheadGlyphCount;
+
+  if ( ALLOC_ARRAY( cpcr->Lookahead, count, HB_UShort ) )
+    goto Fail3;
+
+  l = cpcr->Lookahead;
+
+  if ( ACCESS_Frame( count * 2L ) )
+    goto Fail2;
+
+  for ( n = 0; n < count; n++ )
+    l[n] = GET_UShort();
+
+  FORGET_Frame();
+
+  if ( ACCESS_Frame( 2L ) )
+    goto Fail2;
+
+  cpcr->PosCount = GET_UShort();
+
+  FORGET_Frame();
+
+  cpcr->PosLookupRecord = NULL;
+
+  count = cpcr->PosCount;
+
+  if ( ALLOC_ARRAY( cpcr->PosLookupRecord, count, HB_PosLookupRecord ) )
+    goto Fail2;
+
+  plr = cpcr->PosLookupRecord;
+
+  if ( ACCESS_Frame( count * 4L ) )
+    goto Fail1;
+
+  for ( n = 0; n < count; n++ )
+  {
+    plr[n].SequenceIndex   = GET_UShort();
+    plr[n].LookupListIndex = GET_UShort();
+  }
+
+  FORGET_Frame();
+
+  return HB_Err_Ok;
+
+Fail1:
+  FREE( plr );
+
+Fail2:
+  FREE( l );
+
+Fail3:
+  FREE( i );
+
+Fail4:
+  FREE( b );
+  return error;
+}
+
+
+static void  Free_ChainPosClassRule( HB_ChainPosClassRule*  cpcr )
+{
+  FREE( cpcr->PosLookupRecord );
+  FREE( cpcr->Lookahead );
+  FREE( cpcr->Input );
+  FREE( cpcr->Backtrack );
+}
+
+
+/* PosClassSet */
+
+static HB_Error  Load_ChainPosClassSet(
+		   HB_ChainContextPosFormat2*  ccpf2,
+		   HB_ChainPosClassSet*        cpcs,
+		   HB_Stream                    stream )
+{
+  HB_Error  error;
+
+  HB_UShort               n, m, count;
+  HB_UInt                cur_offset, new_offset, base_offset;
+
+  HB_ChainPosClassRule*  cpcr;
+
+
+  base_offset = FILE_Pos();
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  count = cpcs->ChainPosClassRuleCount = GET_UShort();
+
+  FORGET_Frame();
+
+  cpcs->ChainPosClassRule = NULL;
+
+  if ( ALLOC_ARRAY( cpcs->ChainPosClassRule, count,
+		    HB_ChainPosClassRule ) )
+    return error;
+
+  cpcr = cpcs->ChainPosClassRule;
+
+  for ( n = 0; n < count; n++ )
+  {
+    if ( ACCESS_Frame( 2L ) )
+      goto Fail;
+
+    new_offset = GET_UShort() + base_offset;
+
+    FORGET_Frame();
+
+    cur_offset = FILE_Pos();
+    if ( FILE_Seek( new_offset ) ||
+	 ( error = Load_ChainPosClassRule( ccpf2, &cpcr[n],
+					   stream ) ) != HB_Err_Ok )
+      goto Fail;
+    (void)FILE_Seek( cur_offset );
+  }
+
+  return HB_Err_Ok;
+
+Fail:
+  for ( m = 0; m < n; m++ )
+    Free_ChainPosClassRule( &cpcr[m] );
+
+  FREE( cpcr );
+  return error;
+}
+
+
+static void  Free_ChainPosClassSet( HB_ChainPosClassSet*  cpcs )
+{
+  HB_UShort               n, count;
+
+  HB_ChainPosClassRule*  cpcr;
+
+
+  if ( cpcs->ChainPosClassRule )
+  {
+    count = cpcs->ChainPosClassRuleCount;
+    cpcr  = cpcs->ChainPosClassRule;
+
+    for ( n = 0; n < count; n++ )
+      Free_ChainPosClassRule( &cpcr[n] );
+
+    FREE( cpcr );
+  }
+}
+
+
+/* ChainContextPosFormat2 */
+
+static HB_Error  Load_ChainContextPos2( HB_ChainContextPosFormat2*  ccpf2,
+					HB_Stream                    stream )
+{
+  HB_Error  error;
+
+  HB_UShort              n, m, count;
+  HB_UInt               cur_offset, new_offset, base_offset;
+  HB_UInt               backtrack_offset, input_offset, lookahead_offset;
+
+  HB_ChainPosClassSet*  cpcs;
+
+
+  base_offset = FILE_Pos() - 2;
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  new_offset = GET_UShort() + base_offset;
+
+  FORGET_Frame();
+
+  cur_offset = FILE_Pos();
+  if ( FILE_Seek( new_offset ) ||
+       ( error = _HB_OPEN_Load_Coverage( &ccpf2->Coverage, stream ) ) != HB_Err_Ok )
+    return error;
+  (void)FILE_Seek( cur_offset );
+
+  if ( ACCESS_Frame( 8L ) )
+    goto Fail5;
+
+  backtrack_offset = GET_UShort();
+  input_offset     = GET_UShort();
+  lookahead_offset = GET_UShort();
+
+  /* `ChainPosClassSetCount' is the upper limit for input class values,
+     thus we read it now to make an additional safety check. No limit
+     is known or needed for the other two class definitions          */
+
+  count = ccpf2->ChainPosClassSetCount = GET_UShort();
+
+  FORGET_Frame();
+
+  if ( ( error = _HB_OPEN_Load_EmptyOrClassDefinition( &ccpf2->BacktrackClassDef, 65535,
+						       backtrack_offset, base_offset,
+						       stream ) ) != HB_Err_Ok )
+    goto Fail5;
+  if ( ( error = _HB_OPEN_Load_EmptyOrClassDefinition( &ccpf2->InputClassDef, count,
+						       input_offset, base_offset,
+						       stream ) ) != HB_Err_Ok )
+    goto Fail4;
+  if ( ( error = _HB_OPEN_Load_EmptyOrClassDefinition( &ccpf2->LookaheadClassDef, 65535,
+						       lookahead_offset, base_offset,
+						       stream ) ) != HB_Err_Ok )
+    goto Fail3;
+
+  ccpf2->ChainPosClassSet   = NULL;
+  ccpf2->MaxBacktrackLength = 0;
+  ccpf2->MaxInputLength     = 0;
+  ccpf2->MaxLookaheadLength = 0;
+
+  if ( ALLOC_ARRAY( ccpf2->ChainPosClassSet, count, HB_ChainPosClassSet ) )
+    goto Fail2;
+
+  cpcs = ccpf2->ChainPosClassSet;
+
+  for ( n = 0; n < count; n++ )
+  {
+    if ( ACCESS_Frame( 2L ) )
+      goto Fail1;
+
+    new_offset = GET_UShort() + base_offset;
+
+    FORGET_Frame();
+
+    if ( new_offset != base_offset )      /* not a NULL offset */
+    {
+      cur_offset = FILE_Pos();
+      if ( FILE_Seek( new_offset ) ||
+	   ( error = Load_ChainPosClassSet( ccpf2, &cpcs[n],
+					    stream ) ) != HB_Err_Ok )
+	goto Fail1;
+      (void)FILE_Seek( cur_offset );
+    }
+    else
+    {
+      /* we create a ChainPosClassSet table with no entries */
+
+      ccpf2->ChainPosClassSet[n].ChainPosClassRuleCount = 0;
+      ccpf2->ChainPosClassSet[n].ChainPosClassRule      = NULL;
+    }
+  }
+
+  return HB_Err_Ok;
+
+Fail1:
+  for ( m = 0; m < n; m++ )
+    Free_ChainPosClassSet( &cpcs[m] );
+
+  FREE( cpcs );
+
+Fail2:
+  _HB_OPEN_Free_ClassDefinition( &ccpf2->LookaheadClassDef );
+
+Fail3:
+  _HB_OPEN_Free_ClassDefinition( &ccpf2->InputClassDef );
+
+Fail4:
+  _HB_OPEN_Free_ClassDefinition( &ccpf2->BacktrackClassDef );
+
+Fail5:
+  _HB_OPEN_Free_Coverage( &ccpf2->Coverage );
+  return error;
+}
+
+
+static void  Free_ChainContextPos2( HB_ChainContextPosFormat2*  ccpf2 )
+{
+  HB_UShort              n, count;
+
+  HB_ChainPosClassSet*  cpcs;
+
+
+  if ( ccpf2->ChainPosClassSet )
+  {
+    count = ccpf2->ChainPosClassSetCount;
+    cpcs  = ccpf2->ChainPosClassSet;
+
+    for ( n = 0; n < count; n++ )
+      Free_ChainPosClassSet( &cpcs[n] );
+
+    FREE( cpcs );
+  }
+
+  _HB_OPEN_Free_ClassDefinition( &ccpf2->LookaheadClassDef );
+  _HB_OPEN_Free_ClassDefinition( &ccpf2->InputClassDef );
+  _HB_OPEN_Free_ClassDefinition( &ccpf2->BacktrackClassDef );
+
+  _HB_OPEN_Free_Coverage( &ccpf2->Coverage );
+}
+
+
+/* ChainContextPosFormat3 */
+
+static HB_Error  Load_ChainContextPos3( HB_ChainContextPosFormat3*  ccpf3,
+					HB_Stream                    stream )
+{
+  HB_Error  error;
+
+  HB_UShort             n, nb, ni, nl, m, count;
+  HB_UShort             backtrack_count, input_count, lookahead_count;
+  HB_UInt              cur_offset, new_offset, base_offset;
+
+  HB_Coverage*         b;
+  HB_Coverage*         i;
+  HB_Coverage*         l;
+  HB_PosLookupRecord*  plr;
+
+
+  base_offset = FILE_Pos() - 2L;
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  ccpf3->BacktrackGlyphCount = GET_UShort();
+
+  FORGET_Frame();
+
+  ccpf3->BacktrackCoverage = NULL;
+
+  backtrack_count = ccpf3->BacktrackGlyphCount;
+
+  if ( ALLOC_ARRAY( ccpf3->BacktrackCoverage, backtrack_count,
+		    HB_Coverage ) )
+    return error;
+
+  b = ccpf3->BacktrackCoverage;
+
+  for ( nb = 0; nb < backtrack_count; nb++ )
+  {
+    if ( ACCESS_Frame( 2L ) )
+      goto Fail4;
+
+    new_offset = GET_UShort() + base_offset;
+
+    FORGET_Frame();
+
+    cur_offset = FILE_Pos();
+    if ( FILE_Seek( new_offset ) ||
+	 ( error = _HB_OPEN_Load_Coverage( &b[nb], stream ) ) != HB_Err_Ok )
+      goto Fail4;
+    (void)FILE_Seek( cur_offset );
+  }
+
+  if ( ACCESS_Frame( 2L ) )
+    goto Fail4;
+
+  ccpf3->InputGlyphCount = GET_UShort();
+
+  FORGET_Frame();
+
+  ccpf3->InputCoverage = NULL;
+
+  input_count = ccpf3->InputGlyphCount;
+
+  if ( ALLOC_ARRAY( ccpf3->InputCoverage, input_count, HB_Coverage ) )
+    goto Fail4;
+
+  i = ccpf3->InputCoverage;
+
+  for ( ni = 0; ni < input_count; ni++ )
+  {
+    if ( ACCESS_Frame( 2L ) )
+      goto Fail3;
+
+    new_offset = GET_UShort() + base_offset;
+
+    FORGET_Frame();
+
+    cur_offset = FILE_Pos();
+    if ( FILE_Seek( new_offset ) ||
+	 ( error = _HB_OPEN_Load_Coverage( &i[ni], stream ) ) != HB_Err_Ok )
+      goto Fail3;
+    (void)FILE_Seek( cur_offset );
+  }
+
+  if ( ACCESS_Frame( 2L ) )
+    goto Fail3;
+
+  ccpf3->LookaheadGlyphCount = GET_UShort();
+
+  FORGET_Frame();
+
+  ccpf3->LookaheadCoverage = NULL;
+
+  lookahead_count = ccpf3->LookaheadGlyphCount;
+
+  if ( ALLOC_ARRAY( ccpf3->LookaheadCoverage, lookahead_count,
+		    HB_Coverage ) )
+    goto Fail3;
+
+  l = ccpf3->LookaheadCoverage;
+
+  for ( nl = 0; nl < lookahead_count; nl++ )
+  {
+    if ( ACCESS_Frame( 2L ) )
+      goto Fail2;
+
+    new_offset = GET_UShort() + base_offset;
+
+    FORGET_Frame();
+
+    cur_offset = FILE_Pos();
+    if ( FILE_Seek( new_offset ) ||
+	 ( error = _HB_OPEN_Load_Coverage( &l[nl], stream ) ) != HB_Err_Ok )
+      goto Fail2;
+    (void)FILE_Seek( cur_offset );
+  }
+
+  if ( ACCESS_Frame( 2L ) )
+    goto Fail2;
+
+  ccpf3->PosCount = GET_UShort();
+
+  FORGET_Frame();
+
+  ccpf3->PosLookupRecord = NULL;
+
+  count = ccpf3->PosCount;
+
+  if ( ALLOC_ARRAY( ccpf3->PosLookupRecord, count, HB_PosLookupRecord ) )
+    goto Fail2;
+
+  plr = ccpf3->PosLookupRecord;
+
+  if ( ACCESS_Frame( count * 4L ) )
+    goto Fail1;
+
+  for ( n = 0; n < count; n++ )
+  {
+    plr[n].SequenceIndex   = GET_UShort();
+    plr[n].LookupListIndex = GET_UShort();
+  }
+
+  FORGET_Frame();
+
+  return HB_Err_Ok;
+
+Fail1:
+  FREE( plr );
+
+Fail2:
+  for ( m = 0; m < nl; m++ )
+    _HB_OPEN_Free_Coverage( &l[m] );
+
+  FREE( l );
+
+Fail3:
+  for ( m = 0; m < ni; m++ )
+    _HB_OPEN_Free_Coverage( &i[m] );
+
+  FREE( i );
+
+Fail4:
+  for ( m = 0; m < nb; m++ )
+    _HB_OPEN_Free_Coverage( &b[m] );
+
+  FREE( b );
+  return error;
+}
+
+
+static void  Free_ChainContextPos3( HB_ChainContextPosFormat3*  ccpf3 )
+{
+  HB_UShort      n, count;
+
+  HB_Coverage*  c;
+
+
+  FREE( ccpf3->PosLookupRecord );
+
+  if ( ccpf3->LookaheadCoverage )
+  {
+    count = ccpf3->LookaheadGlyphCount;
+    c     = ccpf3->LookaheadCoverage;
+
+    for ( n = 0; n < count; n++ )
+      _HB_OPEN_Free_Coverage( &c[n] );
+
+    FREE( c );
+  }
+
+  if ( ccpf3->InputCoverage )
+  {
+    count = ccpf3->InputGlyphCount;
+    c     = ccpf3->InputCoverage;
+
+    for ( n = 0; n < count; n++ )
+      _HB_OPEN_Free_Coverage( &c[n] );
+
+    FREE( c );
+  }
+
+  if ( ccpf3->BacktrackCoverage )
+  {
+    count = ccpf3->BacktrackGlyphCount;
+    c     = ccpf3->BacktrackCoverage;
+
+    for ( n = 0; n < count; n++ )
+      _HB_OPEN_Free_Coverage( &c[n] );
+
+    FREE( c );
+  }
+}
+
+
+/* ChainContextPos */
+
+static HB_Error  Load_ChainContextPos( HB_GPOS_SubTable* st,
+				       HB_Stream             stream )
+{
+  HB_Error  error;
+  HB_ChainContextPos*  ccp = &st->chain;
+
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  ccp->PosFormat = GET_UShort();
+
+  FORGET_Frame();
+
+  switch ( ccp->PosFormat )
+  {
+  case 1:
+    return Load_ChainContextPos1( &ccp->ccpf.ccpf1, stream );
+
+  case 2:
+    return Load_ChainContextPos2( &ccp->ccpf.ccpf2, stream );
+
+  case 3:
+    return Load_ChainContextPos3( &ccp->ccpf.ccpf3, stream );
+
+  default:
+    return ERR(HB_Err_Invalid_SubTable_Format);
+  }
+
+  return HB_Err_Ok;               /* never reached */
+}
+
+
+static void  Free_ChainContextPos( HB_GPOS_SubTable* st )
+{
+  HB_ChainContextPos*  ccp = &st->chain;
+
+  switch ( ccp->PosFormat )
+  {
+  case 1:  Free_ChainContextPos1( &ccp->ccpf.ccpf1 ); break;
+  case 2:  Free_ChainContextPos2( &ccp->ccpf.ccpf2 ); break;
+  case 3:  Free_ChainContextPos3( &ccp->ccpf.ccpf3 ); break;
+  default:						      break;
+  }
+}
+
+
+static HB_Error  Lookup_ChainContextPos1(
+		   GPOS_Instance*               gpi,
+		   HB_ChainContextPosFormat1*  ccpf1,
+		   HB_Buffer                   buffer,
+		   HB_UShort                    flags,
+		   HB_UShort                    context_length,
+		   int                          nesting_level )
+{
+  HB_UShort          index, property;
+  HB_UShort          i, j, k, num_cpr;
+  HB_UShort          bgc, igc, lgc;
+  HB_Error           error;
+  HB_GPOSHeader*    gpos = gpi->gpos;
+
+  HB_ChainPosRule*  cpr;
+  HB_ChainPosRule   curr_cpr;
+  HB_GDEFHeader*    gdef;
+
+
+  gdef = gpos->gdef;
+
+  if ( CHECK_Property( gdef, IN_CURITEM(), flags, &property ) )
+    return error;
+
+  error = _HB_OPEN_Coverage_Index( &ccpf1->Coverage, IN_CURGLYPH(), &index );
+  if ( error )
+    return error;
+
+  cpr     = ccpf1->ChainPosRuleSet[index].ChainPosRule;
+  num_cpr = ccpf1->ChainPosRuleSet[index].ChainPosRuleCount;
+
+  for ( k = 0; k < num_cpr; k++ )
+  {
+    curr_cpr = cpr[k];
+    bgc      = curr_cpr.BacktrackGlyphCount;
+    igc      = curr_cpr.InputGlyphCount;
+    lgc      = curr_cpr.LookaheadGlyphCount;
+
+    if ( context_length != 0xFFFF && context_length < igc )
+      goto next_chainposrule;
+
+    /* check whether context is too long; it is a first guess only */
+
+    if ( bgc > buffer->in_pos || buffer->in_pos + igc + lgc > buffer->in_length )
+      goto next_chainposrule;
+
+    if ( bgc )
+    {
+      /* Since we don't know in advance the number of glyphs to inspect,
+	 we search backwards for matches in the backtrack glyph array    */
+
+      for ( i = 0, j = buffer->in_pos - 1; i < bgc; i++, j-- )
+      {
+	while ( CHECK_Property( gdef, IN_ITEM( j ), flags, &property ) )
+	{
+	  if ( error && error != HB_Err_Not_Covered )
+	    return error;
+
+	  if ( j + 1 == bgc - i )
+	    goto next_chainposrule;
+	  j--;
+	}
+
+	/* In OpenType 1.3, it is undefined whether the offsets of
+	   backtrack glyphs is in logical order or not.  Version 1.4
+	   will clarify this:
+
+	     Logical order -      a  b  c  d  e  f  g  h  i  j
+					      i
+	     Input offsets -                  0  1
+	     Backtrack offsets -  3  2  1  0
+	     Lookahead offsets -                    0  1  2  3           */
+
+	if ( IN_GLYPH( j ) != curr_cpr.Backtrack[i] )
+	  goto next_chainposrule;
+      }
+    }
+
+    /* Start at 1 because [0] is implied */
+
+    for ( i = 1, j = buffer->in_pos + 1; i < igc; i++, j++ )
+    {
+      while ( CHECK_Property( gdef, IN_ITEM( j ), flags, &property ) )
+      {
+	if ( error && error != HB_Err_Not_Covered )
+	  return error;
+
+	if ( j + igc - i + lgc == (HB_Int)buffer->in_length )
+	  goto next_chainposrule;
+	j++;
+      }
+
+      if ( IN_GLYPH( j ) != curr_cpr.Input[i - 1] )
+	goto next_chainposrule;
+    }
+
+    /* we are starting to check for lookahead glyphs right after the
+       last context glyph                                            */
+
+    for ( i = 0; i < lgc; i++, j++ )
+    {
+      while ( CHECK_Property( gdef, IN_ITEM( j ), flags, &property ) )
+      {
+	if ( error && error != HB_Err_Not_Covered )
+	  return error;
+
+	if ( j + lgc - i == (HB_Int)buffer->in_length )
+	  goto next_chainposrule;
+	j++;
+      }
+
+      if ( IN_GLYPH( j ) != curr_cpr.Lookahead[i] )
+	goto next_chainposrule;
+    }
+
+    return Do_ContextPos( gpi, igc,
+			  curr_cpr.PosCount,
+			  curr_cpr.PosLookupRecord,
+			  buffer,
+			  nesting_level );
+
+  next_chainposrule:
+    ;
+  }
+
+  return HB_Err_Not_Covered;
+}
+
+
+static HB_Error  Lookup_ChainContextPos2(
+		   GPOS_Instance*               gpi,
+		   HB_ChainContextPosFormat2*  ccpf2,
+		   HB_Buffer                   buffer,
+		   HB_UShort                    flags,
+		   HB_UShort                    context_length,
+		   int                          nesting_level )
+{
+  HB_UShort              index, property;
+  HB_Error               error;
+  HB_UShort              i, j, k;
+  HB_UShort              bgc, igc, lgc;
+  HB_UShort              known_backtrack_classes,
+			 known_input_classes,
+			 known_lookahead_classes;
+
+  HB_UShort*             backtrack_classes;
+  HB_UShort*             input_classes;
+  HB_UShort*             lookahead_classes;
+
+  HB_UShort*             bc;
+  HB_UShort*             ic;
+  HB_UShort*             lc;
+  HB_GPOSHeader*        gpos = gpi->gpos;
+
+  HB_ChainPosClassSet*  cpcs;
+  HB_ChainPosClassRule  cpcr;
+  HB_GDEFHeader*        gdef;
+
+
+  gdef = gpos->gdef;
+
+  if ( CHECK_Property( gdef, IN_CURITEM(), flags, &property ) )
+    return error;
+
+  /* Note: The coverage table in format 2 doesn't give an index into
+	   anything.  It just lets us know whether or not we need to
+	   do any lookup at all.                                     */
+
+  error = _HB_OPEN_Coverage_Index( &ccpf2->Coverage, IN_CURGLYPH(), &index );
+  if ( error )
+    return error;
+
+  if ( ALLOC_ARRAY( backtrack_classes, ccpf2->MaxBacktrackLength, HB_UShort ) )
+    return error;
+  known_backtrack_classes = 0;
+
+  if (ccpf2->MaxInputLength < 1)
+    return HB_Err_Not_Covered;
+
+  if ( ALLOC_ARRAY( input_classes, ccpf2->MaxInputLength, HB_UShort ) )
+    goto End3;
+  known_input_classes = 1;
+
+  if ( ALLOC_ARRAY( lookahead_classes, ccpf2->MaxLookaheadLength, HB_UShort ) )
+    goto End2;
+  known_lookahead_classes = 0;
+
+  error = _HB_OPEN_Get_Class( &ccpf2->InputClassDef, IN_CURGLYPH(),
+		     &input_classes[0], NULL );
+  if ( error && error != HB_Err_Not_Covered )
+    goto End1;
+
+  cpcs = &ccpf2->ChainPosClassSet[input_classes[0]];
+  if ( !cpcs )
+  {
+    error = ERR(HB_Err_Invalid_SubTable);
+    goto End1;
+  }
+
+  for ( k = 0; k < cpcs->ChainPosClassRuleCount; k++ )
+  {
+    cpcr = cpcs->ChainPosClassRule[k];
+    bgc  = cpcr.BacktrackGlyphCount;
+    igc  = cpcr.InputGlyphCount;
+    lgc  = cpcr.LookaheadGlyphCount;
+
+    if ( context_length != 0xFFFF && context_length < igc )
+      goto next_chainposclassrule;
+
+    /* check whether context is too long; it is a first guess only */
+
+    if ( bgc > buffer->in_pos || buffer->in_pos + igc + lgc > buffer->in_length )
+      goto next_chainposclassrule;
+
+    if ( bgc )
+    {
+      /* Since we don't know in advance the number of glyphs to inspect,
+	 we search backwards for matches in the backtrack glyph array.
+	 Note that `known_backtrack_classes' starts at index 0.         */
+
+      bc       = cpcr.Backtrack;
+
+      for ( i = 0, j = buffer->in_pos - 1; i < bgc; i++, j-- )
+      {
+	while ( CHECK_Property( gdef, IN_ITEM( j ), flags, &property ) )
+	{
+	  if ( error && error != HB_Err_Not_Covered )
+	    goto End1;
+
+	  if ( j + 1 == bgc - i )
+	    goto next_chainposclassrule;
+	  j++;
+	}
+
+	if ( i >= known_backtrack_classes )
+	{
+	  /* Keeps us from having to do this for each rule */
+
+	  error = _HB_OPEN_Get_Class( &ccpf2->BacktrackClassDef, IN_GLYPH( j ),
+			     &backtrack_classes[i], NULL );
+	  if ( error && error != HB_Err_Not_Covered )
+	    goto End1;
+	  known_backtrack_classes = i;
+	}
+
+	if ( bc[i] != backtrack_classes[i] )
+	  goto next_chainposclassrule;
+      }
+    }
+
+    ic       = cpcr.Input;
+
+    /* Start at 1 because [0] is implied */
+
+    for ( i = 1, j = buffer->in_pos + 1; i < igc; i++, j++ )
+    {
+      while ( CHECK_Property( gdef, IN_ITEM( j ), flags, &property ) )
+      {
+	if ( error && error != HB_Err_Not_Covered )
+	  goto End1;
+
+	if ( j + igc - i + lgc == (HB_Int)buffer->in_length )
+	  goto next_chainposclassrule;
+	j++;
+      }
+
+      if ( i >= known_input_classes )
+      {
+	error = _HB_OPEN_Get_Class( &ccpf2->InputClassDef, IN_GLYPH( j ),
+			   &input_classes[i], NULL );
+	if ( error && error != HB_Err_Not_Covered )
+	  goto End1;
+	known_input_classes = i;
+      }
+
+      if ( ic[i - 1] != input_classes[i] )
+	goto next_chainposclassrule;
+    }
+
+    /* we are starting to check for lookahead glyphs right after the
+       last context glyph                                            */
+
+    lc       = cpcr.Lookahead;
+
+    for ( i = 0; i < lgc; i++, j++ )
+    {
+      while ( CHECK_Property( gdef, IN_ITEM( j ), flags, &property ) )
+      {
+	if ( error && error != HB_Err_Not_Covered )
+	  goto End1;
+
+	if ( j + lgc - i == (HB_Int)buffer->in_length )
+	  goto next_chainposclassrule;
+	j++;
+      }
+
+      if ( i >= known_lookahead_classes )
+      {
+	error = _HB_OPEN_Get_Class( &ccpf2->LookaheadClassDef, IN_GLYPH( j ),
+			   &lookahead_classes[i], NULL );
+	if ( error && error != HB_Err_Not_Covered )
+	  goto End1;
+	known_lookahead_classes = i;
+      }
+
+      if ( lc[i] != lookahead_classes[i] )
+	goto next_chainposclassrule;
+    }
+
+    error = Do_ContextPos( gpi, igc,
+			   cpcr.PosCount,
+			   cpcr.PosLookupRecord,
+			   buffer,
+			   nesting_level );
+    goto End1;
+
+  next_chainposclassrule:
+    ;
+  }
+
+  error = HB_Err_Not_Covered;
+
+End1:
+  FREE( lookahead_classes );
+
+End2:
+  FREE( input_classes );
+
+End3:
+  FREE( backtrack_classes );
+  return error;
+}
+
+
+static HB_Error  Lookup_ChainContextPos3(
+		   GPOS_Instance*               gpi,
+		   HB_ChainContextPosFormat3*  ccpf3,
+		   HB_Buffer                   buffer,
+		   HB_UShort                    flags,
+		   HB_UShort                    context_length,
+		   int                          nesting_level )
+{
+  HB_UShort        index, i, j, property;
+  HB_UShort        bgc, igc, lgc;
+  HB_Error         error;
+  HB_GPOSHeader*  gpos = gpi->gpos;
+
+  HB_Coverage*    bc;
+  HB_Coverage*    ic;
+  HB_Coverage*    lc;
+  HB_GDEFHeader*  gdef;
+
+
+  gdef = gpos->gdef;
+
+  if ( CHECK_Property( gdef, IN_CURITEM(), flags, &property ) )
+    return error;
+
+  bgc = ccpf3->BacktrackGlyphCount;
+  igc = ccpf3->InputGlyphCount;
+  lgc = ccpf3->LookaheadGlyphCount;
+
+  if ( context_length != 0xFFFF && context_length < igc )
+    return HB_Err_Not_Covered;
+
+  /* check whether context is too long; it is a first guess only */
+
+  if ( bgc > buffer->in_pos || buffer->in_pos + igc + lgc > buffer->in_length )
+    return HB_Err_Not_Covered;
+
+  if ( bgc )
+  {
+    /* Since we don't know in advance the number of glyphs to inspect,
+       we search backwards for matches in the backtrack glyph array    */
+
+    bc       = ccpf3->BacktrackCoverage;
+
+    for ( i = 0, j = buffer->in_pos - 1; i < bgc; i++, j-- )
+    {
+      while ( CHECK_Property( gdef, IN_ITEM( j ), flags, &property ) )
+      {
+	if ( error && error != HB_Err_Not_Covered )
+	  return error;
+
+	if ( j + 1 == bgc - i )
+	  return HB_Err_Not_Covered;
+	j--;
+      }
+
+      error = _HB_OPEN_Coverage_Index( &bc[i], IN_GLYPH( j ), &index );
+      if ( error )
+	return error;
+    }
+  }
+
+  ic       = ccpf3->InputCoverage;
+
+  for ( i = 0, j = buffer->in_pos; i < igc; i++, j++ )
+  {
+    /* We already called CHECK_Property for IN_GLYPH ( buffer->in_pos ) */
+    while ( j > buffer->in_pos && CHECK_Property( gdef, IN_ITEM( j ), flags, &property ) )
+    {
+      if ( error && error != HB_Err_Not_Covered )
+	return error;
+
+      if ( j + igc - i + lgc == (HB_Int)buffer->in_length )
+	return HB_Err_Not_Covered;
+      j++;
+    }
+
+    error = _HB_OPEN_Coverage_Index( &ic[i], IN_GLYPH( j ), &index );
+    if ( error )
+      return error;
+  }
+
+  /* we are starting to check for lookahead glyphs right after the
+     last context glyph                                            */
+
+  lc       = ccpf3->LookaheadCoverage;
+
+  for ( i = 0; i < lgc; i++, j++ )
+  {
+    while ( CHECK_Property( gdef, IN_ITEM( j ), flags, &property ) )
+    {
+      if ( error && error != HB_Err_Not_Covered )
+	return error;
+
+      if ( j + lgc - i == (HB_Int)buffer->in_length )
+	return HB_Err_Not_Covered;
+      j++;
+    }
+
+    error = _HB_OPEN_Coverage_Index( &lc[i], IN_GLYPH( j ), &index );
+    if ( error )
+      return error;
+  }
+
+  return Do_ContextPos( gpi, igc,
+			ccpf3->PosCount,
+			ccpf3->PosLookupRecord,
+			buffer,
+			nesting_level );
+}
+
+
+static HB_Error  Lookup_ChainContextPos(
+		   GPOS_Instance*        gpi,
+		   HB_GPOS_SubTable* st,
+		   HB_Buffer            buffer,
+		   HB_UShort             flags,
+		   HB_UShort             context_length,
+		   int                   nesting_level )
+{
+  HB_ChainContextPos*  ccp = &st->chain;
+
+  switch ( ccp->PosFormat )
+  {
+  case 1:
+    return Lookup_ChainContextPos1( gpi, &ccp->ccpf.ccpf1, buffer,
+				    flags, context_length,
+				    nesting_level );
+
+  case 2:
+    return Lookup_ChainContextPos2( gpi, &ccp->ccpf.ccpf2, buffer,
+				    flags, context_length,
+				    nesting_level );
+
+  case 3:
+    return Lookup_ChainContextPos3( gpi, &ccp->ccpf.ccpf3, buffer,
+				    flags, context_length,
+				    nesting_level );
+
+  default:
+    return ERR(HB_Err_Invalid_SubTable_Format);
+  }
+
+  return HB_Err_Ok;               /* never reached */
+}
+
+
+
+/***********
+ * GPOS API
+ ***********/
+
+
+
+HB_Error  HB_GPOS_Select_Script( HB_GPOSHeader*  gpos,
+				 HB_UInt         script_tag,
+				 HB_UShort*       script_index )
+{
+  HB_UShort          n;
+
+  HB_ScriptList*    sl;
+  HB_ScriptRecord*  sr;
+
+
+  if ( !gpos || !script_index )
+    return ERR(HB_Err_Invalid_Argument);
+
+  sl = &gpos->ScriptList;
+  sr = sl->ScriptRecord;
+
+  for ( n = 0; n < sl->ScriptCount; n++ )
+    if ( script_tag == sr[n].ScriptTag )
+    {
+      *script_index = n;
+
+      return HB_Err_Ok;
+    }
+
+  return HB_Err_Not_Covered;
+}
+
+
+
+HB_Error  HB_GPOS_Select_Language( HB_GPOSHeader*  gpos,
+				   HB_UInt         language_tag,
+				   HB_UShort        script_index,
+				   HB_UShort*       language_index,
+				   HB_UShort*       req_feature_index )
+{
+  HB_UShort           n;
+
+  HB_ScriptList*     sl;
+  HB_ScriptRecord*   sr;
+  HB_ScriptTable*         s;
+  HB_LangSysRecord*  lsr;
+
+
+  if ( !gpos || !language_index || !req_feature_index )
+    return ERR(HB_Err_Invalid_Argument);
+
+  sl = &gpos->ScriptList;
+  sr = sl->ScriptRecord;
+
+  if ( script_index >= sl->ScriptCount )
+    return ERR(HB_Err_Invalid_Argument);
+
+  s   = &sr[script_index].Script;
+  lsr = s->LangSysRecord;
+
+  for ( n = 0; n < s->LangSysCount; n++ )
+    if ( language_tag == lsr[n].LangSysTag )
+    {
+      *language_index = n;
+      *req_feature_index = lsr[n].LangSys.ReqFeatureIndex;
+
+      return HB_Err_Ok;
+    }
+
+  return HB_Err_Not_Covered;
+}
+
+
+/* selecting 0xFFFF for language_index asks for the values of the
+   default language (DefaultLangSys)                              */
+
+
+HB_Error  HB_GPOS_Select_Feature( HB_GPOSHeader*  gpos,
+				  HB_UInt         feature_tag,
+				  HB_UShort        script_index,
+				  HB_UShort        language_index,
+				  HB_UShort*       feature_index )
+{
+  HB_UShort           n;
+
+  HB_ScriptList*     sl;
+  HB_ScriptRecord*   sr;
+  HB_ScriptTable*         s;
+  HB_LangSysRecord*  lsr;
+  HB_LangSys*        ls;
+  HB_UShort*          fi;
+
+  HB_FeatureList*    fl;
+  HB_FeatureRecord*  fr;
+
+
+  if ( !gpos || !feature_index )
+    return ERR(HB_Err_Invalid_Argument);
+
+  sl = &gpos->ScriptList;
+  sr = sl->ScriptRecord;
+
+  fl = &gpos->FeatureList;
+  fr = fl->FeatureRecord;
+
+  if ( script_index >= sl->ScriptCount )
+    return ERR(HB_Err_Invalid_Argument);
+
+  s   = &sr[script_index].Script;
+  lsr = s->LangSysRecord;
+
+  if ( language_index == 0xFFFF )
+    ls = &s->DefaultLangSys;
+  else
+  {
+    if ( language_index >= s->LangSysCount )
+      return ERR(HB_Err_Invalid_Argument);
+
+    ls = &lsr[language_index].LangSys;
+  }
+
+  fi = ls->FeatureIndex;
+
+  for ( n = 0; n < ls->FeatureCount; n++ )
+  {
+    if ( fi[n] >= fl->FeatureCount )
+      return ERR(HB_Err_Invalid_SubTable_Format);
+
+    if ( feature_tag == fr[fi[n]].FeatureTag )
+    {
+      *feature_index = fi[n];
+
+      return HB_Err_Ok;
+    }
+  }
+
+  return HB_Err_Not_Covered;
+}
+
+
+/* The next three functions return a null-terminated list */
+
+
+HB_Error  HB_GPOS_Query_Scripts( HB_GPOSHeader*  gpos,
+				 HB_UInt**       script_tag_list )
+{
+  HB_Error           error;
+  HB_UShort          n;
+  HB_UInt*          stl;
+
+  HB_ScriptList*    sl;
+  HB_ScriptRecord*  sr;
+
+
+  if ( !gpos || !script_tag_list )
+    return ERR(HB_Err_Invalid_Argument);
+
+  sl = &gpos->ScriptList;
+  sr = sl->ScriptRecord;
+
+  if ( ALLOC_ARRAY( stl, sl->ScriptCount + 1, HB_UInt ) )
+    return error;
+
+  for ( n = 0; n < sl->ScriptCount; n++ )
+    stl[n] = sr[n].ScriptTag;
+  stl[n] = 0;
+
+  *script_tag_list = stl;
+
+  return HB_Err_Ok;
+}
+
+
+
+HB_Error  HB_GPOS_Query_Languages( HB_GPOSHeader*  gpos,
+				   HB_UShort        script_index,
+				   HB_UInt**       language_tag_list )
+{
+  HB_Error            error;
+  HB_UShort           n;
+  HB_UInt*           ltl;
+
+  HB_ScriptList*     sl;
+  HB_ScriptRecord*   sr;
+  HB_ScriptTable*    s;
+  HB_LangSysRecord*  lsr;
+
+
+  if ( !gpos || !language_tag_list )
+    return ERR(HB_Err_Invalid_Argument);
+
+  sl = &gpos->ScriptList;
+  sr = sl->ScriptRecord;
+
+  if ( script_index >= sl->ScriptCount )
+    return ERR(HB_Err_Invalid_Argument);
+
+  s   = &sr[script_index].Script;
+  lsr = s->LangSysRecord;
+
+  if ( ALLOC_ARRAY( ltl, s->LangSysCount + 1, HB_UInt ) )
+    return error;
+
+  for ( n = 0; n < s->LangSysCount; n++ )
+    ltl[n] = lsr[n].LangSysTag;
+  ltl[n] = 0;
+
+  *language_tag_list = ltl;
+
+  return HB_Err_Ok;
+}
+
+
+/* selecting 0xFFFF for language_index asks for the values of the
+   default language (DefaultLangSys)                              */
+
+
+HB_Error  HB_GPOS_Query_Features( HB_GPOSHeader*  gpos,
+				  HB_UShort        script_index,
+				  HB_UShort        language_index,
+				  HB_UInt**       feature_tag_list )
+{
+  HB_UShort           n;
+  HB_Error            error;
+  HB_UInt*           ftl;
+
+  HB_ScriptList*     sl;
+  HB_ScriptRecord*   sr;
+  HB_ScriptTable*    s;
+  HB_LangSysRecord*  lsr;
+  HB_LangSys*        ls;
+  HB_UShort*          fi;
+
+  HB_FeatureList*    fl;
+  HB_FeatureRecord*  fr;
+
+
+  if ( !gpos || !feature_tag_list )
+    return ERR(HB_Err_Invalid_Argument);
+
+  sl = &gpos->ScriptList;
+  sr = sl->ScriptRecord;
+
+  fl = &gpos->FeatureList;
+  fr = fl->FeatureRecord;
+
+  if ( script_index >= sl->ScriptCount )
+    return ERR(HB_Err_Invalid_Argument);
+
+  s   = &sr[script_index].Script;
+  lsr = s->LangSysRecord;
+
+  if ( language_index == 0xFFFF )
+    ls = &s->DefaultLangSys;
+  else
+  {
+    if ( language_index >= s->LangSysCount )
+      return ERR(HB_Err_Invalid_Argument);
+
+    ls = &lsr[language_index].LangSys;
+  }
+
+  fi = ls->FeatureIndex;
+
+  if ( ALLOC_ARRAY( ftl, ls->FeatureCount + 1, HB_UInt ) )
+    return error;
+
+  for ( n = 0; n < ls->FeatureCount; n++ )
+  {
+    if ( fi[n] >= fl->FeatureCount )
+    {
+      FREE( ftl );
+      return ERR(HB_Err_Invalid_SubTable_Format);
+    }
+    ftl[n] = fr[fi[n]].FeatureTag;
+  }
+  ftl[n] = 0;
+
+  *feature_tag_list = ftl;
+
+  return HB_Err_Ok;
+}
+
+
+/* Do an individual subtable lookup.  Returns HB_Err_Ok if positioning
+   has been done, or HB_Err_Not_Covered if not.                        */
+static HB_Error  GPOS_Do_Glyph_Lookup( GPOS_Instance*    gpi,
+				       HB_UShort         lookup_index,
+				       HB_Buffer        buffer,
+				       HB_UShort         context_length,
+				       int               nesting_level )
+{
+  HB_Error             error = HB_Err_Not_Covered;
+  HB_UShort            i, flags, lookup_count;
+  HB_GPOSHeader*       gpos = gpi->gpos;
+  HB_Lookup*           lo;
+  int		       lookup_type;
+
+
+  nesting_level++;
+
+  if ( nesting_level > HB_MAX_NESTING_LEVEL )
+    return ERR(HB_Err_Not_Covered); /* ERR() call intended */
+
+  lookup_count = gpos->LookupList.LookupCount;
+  if (lookup_index >= lookup_count)
+    return error;
+
+  lo    = &gpos->LookupList.Lookup[lookup_index];
+  flags = lo->LookupFlag;
+  lookup_type = lo->LookupType;
+
+  for ( i = 0; i < lo->SubTableCount; i++ )
+  {
+    HB_GPOS_SubTable *st = &lo->SubTable[i].st.gpos;
+
+    switch (lookup_type) {
+      case HB_GPOS_LOOKUP_SINGLE:
+        error = Lookup_SinglePos	( gpi, st, buffer, flags, context_length, nesting_level ); break;
+      case HB_GPOS_LOOKUP_PAIR:
+	error = Lookup_PairPos		( gpi, st, buffer, flags, context_length, nesting_level ); break;
+      case HB_GPOS_LOOKUP_CURSIVE:
+	error = Lookup_CursivePos	( gpi, st, buffer, flags, context_length, nesting_level ); break;
+      case HB_GPOS_LOOKUP_MARKBASE:
+	error = Lookup_MarkBasePos	( gpi, st, buffer, flags, context_length, nesting_level ); break;
+      case HB_GPOS_LOOKUP_MARKLIG:
+	error = Lookup_MarkLigPos	( gpi, st, buffer, flags, context_length, nesting_level ); break;
+      case HB_GPOS_LOOKUP_MARKMARK:
+	error = Lookup_MarkMarkPos	( gpi, st, buffer, flags, context_length, nesting_level ); break;
+      case HB_GPOS_LOOKUP_CONTEXT:
+	error = Lookup_ContextPos	( gpi, st, buffer, flags, context_length, nesting_level ); break;
+      case HB_GPOS_LOOKUP_CHAIN:
+	error = Lookup_ChainContextPos	( gpi, st, buffer, flags, context_length, nesting_level ); break;
+    /*case HB_GPOS_LOOKUP_EXTENSION:
+	error = Lookup_ExtensionPos	( gpi, st, buffer, flags, context_length, nesting_level ); break;*/
+      default:
+	error = HB_Err_Not_Covered;
+    }
+
+    /* Check whether we have a successful positioning or an error other
+       than HB_Err_Not_Covered                                         */
+    if ( error != HB_Err_Not_Covered )
+      return error;
+  }
+
+  return HB_Err_Not_Covered;
+}
+
+
+HB_INTERNAL HB_Error
+_HB_GPOS_Load_SubTable( HB_GPOS_SubTable* st,
+			HB_Stream         stream,
+			HB_UShort         lookup_type )
+{
+  switch ( lookup_type ) {
+    case HB_GPOS_LOOKUP_SINGLE:		return Load_SinglePos		( st, stream );
+    case HB_GPOS_LOOKUP_PAIR:		return Load_PairPos		( st, stream );
+    case HB_GPOS_LOOKUP_CURSIVE:	return Load_CursivePos		( st, stream );
+    case HB_GPOS_LOOKUP_MARKBASE:	return Load_MarkBasePos		( st, stream );
+    case HB_GPOS_LOOKUP_MARKLIG:	return Load_MarkLigPos		( st, stream );
+    case HB_GPOS_LOOKUP_MARKMARK:	return Load_MarkMarkPos		( st, stream );
+    case HB_GPOS_LOOKUP_CONTEXT:	return Load_ContextPos		( st, stream );
+    case HB_GPOS_LOOKUP_CHAIN:		return Load_ChainContextPos	( st, stream );
+  /*case HB_GPOS_LOOKUP_EXTENSION:	return Load_ExtensionPos	( st, stream );*/
+    default:				return ERR(HB_Err_Invalid_SubTable_Format);
+  }
+}
+
+
+HB_INTERNAL void
+_HB_GPOS_Free_SubTable( HB_GPOS_SubTable* st,
+			HB_UShort         lookup_type )
+{
+  switch ( lookup_type ) {
+    case HB_GPOS_LOOKUP_SINGLE:		Free_SinglePos		( st ); return;
+    case HB_GPOS_LOOKUP_PAIR:		Free_PairPos		( st ); return;
+    case HB_GPOS_LOOKUP_CURSIVE:	Free_CursivePos		( st ); return;
+    case HB_GPOS_LOOKUP_MARKBASE:	Free_MarkBasePos	( st ); return;
+    case HB_GPOS_LOOKUP_MARKLIG:	Free_MarkLigPos		( st ); return;
+    case HB_GPOS_LOOKUP_MARKMARK:	Free_MarkMarkPos	( st ); return;
+    case HB_GPOS_LOOKUP_CONTEXT:	Free_ContextPos		( st ); return;
+    case HB_GPOS_LOOKUP_CHAIN:		Free_ChainContextPos	( st ); return;
+  /*case HB_GPOS_LOOKUP_EXTENSION:	Free_ExtensionPos	( st ); return;*/
+    default:									return;
+  }
+}
+
+
+/* apply one lookup to the input string object */
+
+static HB_Error  GPOS_Do_String_Lookup( GPOS_Instance*    gpi,
+				   HB_UShort         lookup_index,
+				   HB_Buffer        buffer )
+{
+  HB_Error         error, retError = HB_Err_Not_Covered;
+  HB_GPOSHeader*  gpos = gpi->gpos;
+
+  HB_UInt*  properties = gpos->LookupList.Properties;
+
+  const int       nesting_level = 0;
+  /* 0xFFFF indicates that we don't have a context length yet */
+  const HB_UShort context_length = 0xFFFF;
+
+
+  gpi->last  = 0xFFFF;     /* no last valid glyph for cursive pos. */
+
+  buffer->in_pos = 0;
+  while ( buffer->in_pos < buffer->in_length )
+  {
+    if ( ~IN_PROPERTIES( buffer->in_pos ) & properties[lookup_index] )
+    {
+      /* Note that the connection between mark and base glyphs hold
+	 exactly one (string) lookup.  For example, it would be possible
+	 that in the first lookup, mark glyph X is attached to base
+	 glyph A, and in the next lookup it is attached to base glyph B.
+	 It is up to the font designer to provide meaningful lookups and
+	 lookup order.                                                   */
+
+      error = GPOS_Do_Glyph_Lookup( gpi, lookup_index, buffer, context_length, nesting_level );
+      if ( error && error != HB_Err_Not_Covered )
+	return error;
+    }
+    else
+    {
+      /* Contrary to properties defined in GDEF, user-defined properties
+	 will always stop a possible cursive positioning.                */
+      gpi->last = 0xFFFF;
+
+      error = HB_Err_Not_Covered;
+    }
+
+    if ( error == HB_Err_Not_Covered )
+      (buffer->in_pos)++;
+    else
+      retError = error;
+  }
+
+  return retError;
+}
+
+
+static HB_Error  Position_CursiveChain ( HB_Buffer     buffer )
+{
+  HB_UInt   i, j;
+  HB_Position positions = buffer->positions;
+
+  /* First handle all left-to-right connections */
+  for (j = 0; j < buffer->in_length; j++)
+  {
+    if (positions[j].cursive_chain > 0)
+      positions[j].y_pos += positions[j - positions[j].cursive_chain].y_pos;
+  }
+
+  /* Then handle all right-to-left connections */
+  for (i = buffer->in_length; i > 0; i--)
+  {
+    j = i - 1;
+
+    if (positions[j].cursive_chain < 0)
+      positions[j].y_pos += positions[j - positions[j].cursive_chain].y_pos;
+  }
+
+  return HB_Err_Ok;
+}
+
+
+HB_Error  HB_GPOS_Add_Feature( HB_GPOSHeader*  gpos,
+			       HB_UShort        feature_index,
+			       HB_UInt          property )
+{
+  HB_UShort    i;
+
+  HB_Feature  feature;
+  HB_UInt*     properties;
+  HB_UShort*   index;
+  HB_UShort    lookup_count;
+
+  /* Each feature can only be added once */
+
+  if ( !gpos ||
+       feature_index >= gpos->FeatureList.FeatureCount ||
+       gpos->FeatureList.ApplyCount == gpos->FeatureList.FeatureCount )
+    return ERR(HB_Err_Invalid_Argument);
+
+  gpos->FeatureList.ApplyOrder[gpos->FeatureList.ApplyCount++] = feature_index;
+
+  properties = gpos->LookupList.Properties;
+
+  feature = gpos->FeatureList.FeatureRecord[feature_index].Feature;
+  index   = feature.LookupListIndex;
+  lookup_count = gpos->LookupList.LookupCount;
+
+  for ( i = 0; i < feature.LookupListCount; i++ )
+  {
+    HB_UShort lookup_index = index[i];
+    if (lookup_index < lookup_count)
+      properties[lookup_index] |= property;
+  }
+
+  return HB_Err_Ok;
+}
+
+
+
+HB_Error  HB_GPOS_Clear_Features( HB_GPOSHeader*  gpos )
+{
+  HB_UShort i;
+
+  HB_UInt*  properties;
+
+
+  if ( !gpos )
+    return ERR(HB_Err_Invalid_Argument);
+
+  gpos->FeatureList.ApplyCount = 0;
+
+  properties = gpos->LookupList.Properties;
+
+  for ( i = 0; i < gpos->LookupList.LookupCount; i++ )
+    properties[i] = 0;
+
+  return HB_Err_Ok;
+}
+
+
+
+HB_Error  HB_GPOS_Register_MM_Function( HB_GPOSHeader*  gpos,
+					HB_MMFunction   mmfunc,
+					void*            data )
+{
+  if ( !gpos )
+    return ERR(HB_Err_Invalid_Argument);
+
+  gpos->mmfunc = mmfunc;
+  gpos->data   = data;
+
+  return HB_Err_Ok;
+}
+
+/* If `dvi' is TRUE, glyph contour points for anchor points and device
+   tables are ignored -- you will get device independent values.         */
+
+
+HB_Error  HB_GPOS_Apply_String( HB_Font            font,
+				HB_GPOSHeader*    gpos,
+				HB_UShort          load_flags,
+				HB_Buffer         buffer,
+				HB_Bool            dvi,
+				HB_Bool            r2l )
+{
+  HB_Error       error, retError = HB_Err_Not_Covered;
+  GPOS_Instance  gpi;
+  int            i, j, lookup_count, num_features;
+
+  if ( !font || !gpos || !buffer )
+    return ERR(HB_Err_Invalid_Argument);
+
+  if ( buffer->in_length == 0 )
+    return HB_Err_Not_Covered;
+
+  gpi.font       = font;
+  gpi.gpos       = gpos;
+  gpi.load_flags = load_flags;
+  gpi.r2l        = r2l;
+  gpi.dvi        = dvi;
+
+  lookup_count = gpos->LookupList.LookupCount;
+  num_features = gpos->FeatureList.ApplyCount;
+
+  if ( num_features )
+    {
+      error = _hb_buffer_clear_positions( buffer );
+      if ( error )
+	return error;
+    }
+
+  for ( i = 0; i < num_features; i++ )
+  {
+    HB_UShort  feature_index = gpos->FeatureList.ApplyOrder[i];
+    HB_Feature feature = gpos->FeatureList.FeatureRecord[feature_index].Feature;
+
+    for ( j = 0; j < feature.LookupListCount; j++ )
+    {
+      HB_UShort lookup_index = feature.LookupListIndex[j];
+
+      /* Skip nonexistant lookups */
+      if (lookup_index >= lookup_count)
+       continue;
+
+      error = GPOS_Do_String_Lookup( &gpi, lookup_index, buffer );
+      if ( error )
+      {
+	if ( error != HB_Err_Not_Covered )
+	  return error;
+      }
+      else
+	retError = error;
+    }
+  }
+
+  if ( num_features )
+    {
+  error = Position_CursiveChain ( buffer );
+  if ( error )
+    return error;
+    }
+
+  return retError;
+}
+
+/* END */
diff -rupN orginal/scribus/harfbuzz/harfbuzz-gpos.h patched/scribus/harfbuzz/harfbuzz-gpos.h
--- orginal/scribus/harfbuzz/harfbuzz-gpos.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/harfbuzz-gpos.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,149 @@
+/*
+ * Copyright (C) 1998-2004  David Turner and Werner Lemberg
+ * Copyright (C) 2006  Behdad Esfahbod
+ *
+ * This is part of HarfBuzz, an OpenType Layout engine library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ */
+
+#ifndef HARFBUZZ_GPOS_H
+#define HARFBUZZ_GPOS_H
+
+#include "harfbuzz-gdef.h"
+#include "harfbuzz-buffer.h"
+
+HB_BEGIN_HEADER
+
+
+/* Lookup types for glyph positioning */
+
+#define HB_GPOS_LOOKUP_SINGLE     1
+#define HB_GPOS_LOOKUP_PAIR       2
+#define HB_GPOS_LOOKUP_CURSIVE    3
+#define HB_GPOS_LOOKUP_MARKBASE   4
+#define HB_GPOS_LOOKUP_MARKLIG    5
+#define HB_GPOS_LOOKUP_MARKMARK   6
+#define HB_GPOS_LOOKUP_CONTEXT    7
+#define HB_GPOS_LOOKUP_CHAIN      8
+#define HB_GPOS_LOOKUP_EXTENSION  9
+
+/* A pointer to a function which accesses the PostScript interpreter.
+   Multiple Master fonts need this interface to convert a metric ID
+   (as stored in an OpenType font version 1.2 or higher) `metric_id'
+   into a metric value (returned in `metric_value').
+
+   `data' points to the user-defined structure specified during a
+   call to HB_GPOS_Register_MM_Function().
+
+   `metric_value' must be returned as a scaled value (but shouldn't
+   be rounded).                                                       */
+
+typedef HB_Error  (*HB_MMFunction)(HB_Font       font,
+				    HB_UShort    metric_id,
+				    HB_Fixed*      metric_value,
+				    void*        data );
+
+
+struct  HB_GPOSHeader_
+{
+  HB_16Dot16           Version;
+
+  HB_ScriptList     ScriptList;
+  HB_FeatureList    FeatureList;
+  HB_LookupList     LookupList;
+
+  HB_GDEFHeader*    gdef;
+
+  /* this is OpenType 1.2 -- Multiple Master fonts need this
+     callback function to get various metric values from the
+     PostScript interpreter.                                 */
+
+  HB_MMFunction     mmfunc;
+  void*              data;
+};
+
+typedef struct HB_GPOSHeader_  HB_GPOSHeader;
+typedef HB_GPOSHeader* HB_GPOS;
+
+
+HB_Error  HB_Load_GPOS_Table( HB_Stream stream, 
+                              HB_GPOSHeader** gpos,
+			      HB_GDEFHeader*  gdef,
+                              HB_Stream       gdefStream );
+
+
+HB_Error  HB_Done_GPOS_Table( HB_GPOSHeader* gpos );
+
+
+HB_Error  HB_GPOS_Select_Script( HB_GPOSHeader*  gpos,
+				 HB_UInt         script_tag,
+				 HB_UShort*       script_index );
+
+HB_Error  HB_GPOS_Select_Language( HB_GPOSHeader*  gpos,
+				   HB_UInt         language_tag,
+				   HB_UShort        script_index,
+				   HB_UShort*       language_index,
+				   HB_UShort*       req_feature_index );
+
+HB_Error  HB_GPOS_Select_Feature( HB_GPOSHeader*  gpos,
+				  HB_UInt         feature_tag,
+				  HB_UShort        script_index,
+				  HB_UShort        language_index,
+				  HB_UShort*       feature_index );
+
+
+HB_Error  HB_GPOS_Query_Scripts( HB_GPOSHeader*  gpos,
+				 HB_UInt**       script_tag_list );
+
+HB_Error  HB_GPOS_Query_Languages( HB_GPOSHeader*  gpos,
+				   HB_UShort        script_index,
+				   HB_UInt**       language_tag_list );
+
+HB_Error  HB_GPOS_Query_Features( HB_GPOSHeader*  gpos,
+				  HB_UShort        script_index,
+				  HB_UShort        language_index,
+				  HB_UInt**       feature_tag_list );
+
+
+HB_Error  HB_GPOS_Add_Feature( HB_GPOSHeader*  gpos,
+			       HB_UShort        feature_index,
+			       HB_UInt          property );
+
+HB_Error  HB_GPOS_Clear_Features( HB_GPOSHeader*  gpos );
+
+
+HB_Error  HB_GPOS_Register_MM_Function( HB_GPOSHeader*  gpos,
+					HB_MMFunction   mmfunc,
+					void*            data );
+
+/* If `dvi' is TRUE, glyph contour points for anchor points and device
+   tables are ignored -- you will get device independent values.         */
+
+
+HB_Error  HB_GPOS_Apply_String( HB_Font           font,
+				HB_GPOSHeader*   gpos,
+				HB_UShort         load_flags,
+				HB_Buffer        buffer,
+				HB_Bool           dvi,
+				HB_Bool           r2l );
+
+HB_END_HEADER
+
+#endif /* HARFBUZZ_GPOS_H */
diff -rupN orginal/scribus/harfbuzz/harfbuzz-gsub-private.h patched/scribus/harfbuzz/harfbuzz-gsub-private.h
--- orginal/scribus/harfbuzz/harfbuzz-gsub-private.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/harfbuzz-gsub-private.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,476 @@
+/*
+ * Copyright (C) 1998-2004  David Turner and Werner Lemberg
+ * Copyright (C) 2006  Behdad Esfahbod
+ *
+ * This is part of HarfBuzz, an OpenType Layout engine library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ */
+
+#ifndef HARFBUZZ_GSUB_PRIVATE_H
+#define HARFBUZZ_GSUB_PRIVATE_H
+
+#include "harfbuzz-impl.h"
+#include "harfbuzz-stream-private.h"
+#include "harfbuzz-gsub.h"
+
+HB_BEGIN_HEADER
+
+
+typedef union HB_GSUB_SubTable_  HB_GSUB_SubTable;
+
+/* LookupType 1 */
+
+struct  HB_SingleSubstFormat1_
+{
+  HB_Short  DeltaGlyphID;             /* constant added to get
+					 substitution glyph index */
+};
+
+typedef struct HB_SingleSubstFormat1_  HB_SingleSubstFormat1;
+
+
+struct  HB_SingleSubstFormat2_
+{
+  HB_UShort   GlyphCount;             /* number of glyph IDs in
+					 Substitute array              */
+  HB_UShort*  Substitute;             /* array of substitute glyph IDs */
+};
+
+typedef struct HB_SingleSubstFormat2_  HB_SingleSubstFormat2;
+
+
+struct  HB_SingleSubst_
+{
+  HB_UShort     SubstFormat;          /* 1 or 2         */
+  HB_Coverage  Coverage;             /* Coverage table */
+
+  union
+  {
+    HB_SingleSubstFormat1  ssf1;
+    HB_SingleSubstFormat2  ssf2;
+  } ssf;
+};
+
+typedef struct HB_SingleSubst_  HB_SingleSubst;
+
+
+/* LookupType 2 */
+
+struct  HB_Sequence_
+{
+  HB_UShort   GlyphCount;             /* number of glyph IDs in the
+					 Substitute array           */
+  HB_UShort*  Substitute;             /* string of glyph IDs to
+					 substitute                 */
+};
+
+typedef struct HB_Sequence_  HB_Sequence;
+
+
+struct  HB_MultipleSubst_
+{
+  HB_UShort      SubstFormat;         /* always 1                  */
+  HB_Coverage   Coverage;            /* Coverage table            */
+  HB_UShort      SequenceCount;       /* number of Sequence tables */
+  HB_Sequence*  Sequence;            /* array of Sequence tables  */
+};
+
+typedef struct HB_MultipleSubst_  HB_MultipleSubst;
+
+
+/* LookupType 3 */
+
+struct  HB_AlternateSet_
+{
+  HB_UShort   GlyphCount;             /* number of glyph IDs in the
+					 Alternate array              */
+  HB_UShort*  Alternate;              /* array of alternate glyph IDs */
+};
+
+typedef struct HB_AlternateSet_  HB_AlternateSet;
+
+
+struct  HB_AlternateSubst_
+{
+  HB_UShort          SubstFormat;     /* always 1                      */
+  HB_Coverage       Coverage;        /* Coverage table                */
+  HB_UShort          AlternateSetCount;
+				      /* number of AlternateSet tables */
+  HB_AlternateSet*  AlternateSet;    /* array of AlternateSet tables  */
+};
+
+typedef struct HB_AlternateSubst_  HB_AlternateSubst;
+
+
+/* LookupType 4 */
+
+struct  HB_Ligature_
+{
+  HB_UShort   LigGlyph;               /* glyphID of ligature
+					 to substitute                    */
+  HB_UShort   ComponentCount;         /* number of components in ligature */
+  HB_UShort*  Component;              /* array of component glyph IDs     */
+};
+
+typedef struct HB_Ligature_  HB_Ligature;
+
+
+struct  HB_LigatureSet_
+{
+  HB_UShort      LigatureCount;       /* number of Ligature tables */
+  HB_Ligature*  Ligature;            /* array of Ligature tables  */
+};
+
+typedef struct HB_LigatureSet_  HB_LigatureSet;
+
+
+struct  HB_LigatureSubst_
+{
+  HB_UShort         SubstFormat;      /* always 1                     */
+  HB_Coverage      Coverage;         /* Coverage table               */
+  HB_UShort         LigatureSetCount; /* number of LigatureSet tables */
+  HB_LigatureSet*  LigatureSet;      /* array of LigatureSet tables  */
+};
+
+typedef struct HB_LigatureSubst_  HB_LigatureSubst;
+
+
+/* needed by both lookup type 5 and 6 */
+
+struct  HB_SubstLookupRecord_
+{
+  HB_UShort  SequenceIndex;           /* index into current
+					 glyph sequence               */
+  HB_UShort  LookupListIndex;         /* Lookup to apply to that pos. */
+};
+
+typedef struct HB_SubstLookupRecord_  HB_SubstLookupRecord;
+
+
+/* LookupType 5 */
+
+struct  HB_SubRule_
+{
+  HB_UShort               GlyphCount; /* total number of input glyphs */
+  HB_UShort               SubstCount; /* number of SubstLookupRecord
+					 tables                       */
+  HB_UShort*              Input;      /* array of input glyph IDs     */
+  HB_SubstLookupRecord*  SubstLookupRecord;
+				      /* array of SubstLookupRecord
+					 tables                       */
+};
+
+typedef struct HB_SubRule_  HB_SubRule;
+
+
+struct  HB_SubRuleSet_
+{
+  HB_UShort     SubRuleCount;         /* number of SubRule tables */
+  HB_SubRule*  SubRule;              /* array of SubRule tables  */
+};
+
+typedef struct HB_SubRuleSet_  HB_SubRuleSet;
+
+
+struct  HB_ContextSubstFormat1_
+{
+  HB_Coverage     Coverage;          /* Coverage table              */
+  HB_UShort        SubRuleSetCount;   /* number of SubRuleSet tables */
+  HB_SubRuleSet*  SubRuleSet;        /* array of SubRuleSet tables  */
+};
+
+typedef struct HB_ContextSubstFormat1_  HB_ContextSubstFormat1;
+
+
+struct  HB_SubClassRule_
+{
+  HB_UShort               GlyphCount; /* total number of context classes */
+  HB_UShort               SubstCount; /* number of SubstLookupRecord
+					 tables                          */
+  HB_UShort*              Class;      /* array of classes                */
+  HB_SubstLookupRecord*  SubstLookupRecord;
+				      /* array of SubstLookupRecord
+					 tables                          */
+};
+
+typedef struct HB_SubClassRule_  HB_SubClassRule;
+
+
+struct  HB_SubClassSet_
+{
+  HB_UShort          SubClassRuleCount;
+				      /* number of SubClassRule tables */
+  HB_SubClassRule*  SubClassRule;    /* array of SubClassRule tables  */
+};
+
+typedef struct HB_SubClassSet_  HB_SubClassSet;
+
+
+/* The `MaxContextLength' field is not defined in the TTO specification
+   but simplifies the implementation of this format.  It holds the
+   maximal context length used in the context rules.                    */
+
+struct  HB_ContextSubstFormat2_
+{
+  HB_UShort            MaxContextLength;
+				      /* maximal context length       */
+  HB_Coverage         Coverage;      /* Coverage table               */
+  HB_ClassDefinition  ClassDef;      /* ClassDef table               */
+  HB_UShort            SubClassSetCount;
+				      /* number of SubClassSet tables */
+  HB_SubClassSet*     SubClassSet;   /* array of SubClassSet tables  */
+};
+
+typedef struct HB_ContextSubstFormat2_  HB_ContextSubstFormat2;
+
+
+struct  HB_ContextSubstFormat3_
+{
+  HB_UShort               GlyphCount; /* number of input glyphs        */
+  HB_UShort               SubstCount; /* number of SubstLookupRecords  */
+  HB_Coverage*           Coverage;   /* array of Coverage tables      */
+  HB_SubstLookupRecord*  SubstLookupRecord;
+				      /* array of substitution lookups */
+};
+
+typedef struct HB_ContextSubstFormat3_  HB_ContextSubstFormat3;
+
+
+struct  HB_ContextSubst_
+{
+  HB_UShort  SubstFormat;             /* 1, 2, or 3 */
+
+  union
+  {
+    HB_ContextSubstFormat1  csf1;
+    HB_ContextSubstFormat2  csf2;
+    HB_ContextSubstFormat3  csf3;
+  } csf;
+};
+
+typedef struct HB_ContextSubst_  HB_ContextSubst;
+
+
+/* LookupType 6 */
+
+struct  HB_ChainSubRule_
+{
+  HB_UShort               BacktrackGlyphCount;
+				      /* total number of backtrack glyphs */
+  HB_UShort*              Backtrack;  /* array of backtrack glyph IDs     */
+  HB_UShort               InputGlyphCount;
+				      /* total number of input glyphs     */
+  HB_UShort*              Input;      /* array of input glyph IDs         */
+  HB_UShort               LookaheadGlyphCount;
+				      /* total number of lookahead glyphs */
+  HB_UShort*              Lookahead;  /* array of lookahead glyph IDs     */
+  HB_UShort               SubstCount; /* number of SubstLookupRecords     */
+  HB_SubstLookupRecord*  SubstLookupRecord;
+				      /* array of SubstLookupRecords      */
+};
+
+typedef struct HB_ChainSubRule_  HB_ChainSubRule;
+
+
+struct  HB_ChainSubRuleSet_
+{
+  HB_UShort          ChainSubRuleCount;
+				      /* number of ChainSubRule tables */
+  HB_ChainSubRule*  ChainSubRule;    /* array of ChainSubRule tables  */
+};
+
+typedef struct HB_ChainSubRuleSet_  HB_ChainSubRuleSet;
+
+
+struct  HB_ChainContextSubstFormat1_
+{
+  HB_Coverage          Coverage;     /* Coverage table                   */
+  HB_UShort             ChainSubRuleSetCount;
+				      /* number of ChainSubRuleSet tables */
+  HB_ChainSubRuleSet*  ChainSubRuleSet;
+				      /* array of ChainSubRuleSet tables  */
+};
+
+typedef struct HB_ChainContextSubstFormat1_  HB_ChainContextSubstFormat1;
+
+
+struct  HB_ChainSubClassRule_
+{
+  HB_UShort               BacktrackGlyphCount;
+				      /* total number of backtrack
+					 classes                         */
+  HB_UShort*              Backtrack;  /* array of backtrack classes      */
+  HB_UShort               InputGlyphCount;
+				      /* total number of context classes */
+  HB_UShort*              Input;      /* array of context classes        */
+  HB_UShort               LookaheadGlyphCount;
+				      /* total number of lookahead
+					 classes                         */
+  HB_UShort*              Lookahead;  /* array of lookahead classes      */
+  HB_UShort               SubstCount; /* number of SubstLookupRecords    */
+  HB_SubstLookupRecord*  SubstLookupRecord;
+				      /* array of substitution lookups   */
+};
+
+typedef struct HB_ChainSubClassRule_  HB_ChainSubClassRule;
+
+
+struct  HB_ChainSubClassSet_
+{
+  HB_UShort               ChainSubClassRuleCount;
+				      /* number of ChainSubClassRule
+					 tables                      */
+  HB_ChainSubClassRule*  ChainSubClassRule;
+				      /* array of ChainSubClassRule
+					 tables                      */
+};
+
+typedef struct HB_ChainSubClassSet_  HB_ChainSubClassSet;
+
+
+/* The `MaxXXXLength' fields are not defined in the TTO specification
+   but simplifies the implementation of this format.  It holds the
+   maximal context length used in the specific context rules.         */
+
+struct  HB_ChainContextSubstFormat2_
+{
+  HB_Coverage           Coverage;    /* Coverage table             */
+
+  HB_UShort              MaxBacktrackLength;
+				      /* maximal backtrack length   */
+  HB_ClassDefinition    BacktrackClassDef;
+				      /* BacktrackClassDef table    */
+  HB_UShort              MaxInputLength;
+				      /* maximal input length       */
+  HB_ClassDefinition    InputClassDef;
+				      /* InputClassDef table        */
+  HB_UShort              MaxLookaheadLength;
+				      /* maximal lookahead length   */
+  HB_ClassDefinition    LookaheadClassDef;
+				      /* LookaheadClassDef table    */
+
+  HB_UShort              ChainSubClassSetCount;
+				      /* number of ChainSubClassSet
+					 tables                     */
+  HB_ChainSubClassSet*  ChainSubClassSet;
+				      /* array of ChainSubClassSet
+					 tables                     */
+};
+
+typedef struct HB_ChainContextSubstFormat2_  HB_ChainContextSubstFormat2;
+
+
+struct  HB_ChainContextSubstFormat3_
+{
+  HB_UShort               BacktrackGlyphCount;
+				      /* number of backtrack glyphs    */
+  HB_Coverage*           BacktrackCoverage;
+				      /* array of backtrack Coverage
+					 tables                        */
+  HB_UShort               InputGlyphCount;
+				      /* number of input glyphs        */
+  HB_Coverage*           InputCoverage;
+				      /* array of input coverage
+					 tables                        */
+  HB_UShort               LookaheadGlyphCount;
+				      /* number of lookahead glyphs    */
+  HB_Coverage*           LookaheadCoverage;
+				      /* array of lookahead coverage
+					 tables                        */
+  HB_UShort               SubstCount; /* number of SubstLookupRecords  */
+  HB_SubstLookupRecord*  SubstLookupRecord;
+				      /* array of substitution lookups */
+};
+
+typedef struct HB_ChainContextSubstFormat3_  HB_ChainContextSubstFormat3;
+
+
+struct  HB_ChainContextSubst_
+{
+  HB_UShort  SubstFormat;             /* 1, 2, or 3 */
+
+  union
+  {
+    HB_ChainContextSubstFormat1  ccsf1;
+    HB_ChainContextSubstFormat2  ccsf2;
+    HB_ChainContextSubstFormat3  ccsf3;
+  } ccsf;
+};
+
+typedef struct HB_ChainContextSubst_  HB_ChainContextSubst;
+
+
+#if 0
+/* LookupType 7 */
+struct HB_ExtensionSubst_
+{
+  HB_UShort      SubstFormat;         /* always 1 */
+  HB_UShort      LookuptType;         /* lookup-type of referenced subtable */
+  HB_GSUB_SubTable *subtable;         /* referenced subtable */
+};
+
+typedef struct HB_ExtensionSubst_  HB_ExtensionSubst;
+#endif
+
+
+/* LookupType 8 */
+struct HB_ReverseChainContextSubst_
+{
+  HB_UShort      SubstFormat;         /* always 1 */
+  HB_Coverage   Coverage;	        /* coverage table for input glyphs */
+  HB_UShort      BacktrackGlyphCount; /* number of backtrack glyphs      */
+  HB_Coverage*  BacktrackCoverage;   /* array of backtrack Coverage
+					 tables                          */
+  HB_UShort      LookaheadGlyphCount; /* number of lookahead glyphs      */
+  HB_Coverage*  LookaheadCoverage;   /* array of lookahead Coverage
+					 tables                          */
+  HB_UShort      GlyphCount;          /* number of Glyph IDs             */
+  HB_UShort*     Substitute;          /* array of substitute Glyph ID    */
+};
+
+typedef struct HB_ReverseChainContextSubst_  HB_ReverseChainContextSubst;
+
+
+union  HB_GSUB_SubTable_
+{
+  HB_SingleSubst              single;
+  HB_MultipleSubst            multiple;
+  HB_AlternateSubst           alternate;
+  HB_LigatureSubst            ligature;
+  HB_ContextSubst             context;
+  HB_ChainContextSubst        chain;
+  HB_ReverseChainContextSubst reverse;
+};
+
+
+
+
+HB_INTERNAL HB_Error
+_HB_GSUB_Load_SubTable( HB_GSUB_SubTable* st,
+				  HB_Stream     stream,
+				  HB_UShort     lookup_type );
+
+HB_INTERNAL void
+_HB_GSUB_Free_SubTable( HB_GSUB_SubTable* st,
+			      HB_UShort     lookup_type );
+
+HB_END_HEADER
+
+#endif /* HARFBUZZ_GSUB_PRIVATE_H */
diff -rupN orginal/scribus/harfbuzz/harfbuzz-gsub.c patched/scribus/harfbuzz/harfbuzz-gsub.c
--- orginal/scribus/harfbuzz/harfbuzz-gsub.c	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/harfbuzz-gsub.c	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,4329 @@
+/*
+ * Copyright (C) 1998-2004  David Turner and Werner Lemberg
+ * Copyright (C) 2006  Behdad Esfahbod
+ * Copyright (C) 2007  Red Hat, Inc.
+ *
+ * This is part of HarfBuzz, an OpenType Layout engine library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ */
+
+#include "harfbuzz-impl.h"
+#include "harfbuzz-gsub-private.h"
+#include "harfbuzz-open-private.h"
+#include "harfbuzz-gdef-private.h"
+
+static HB_Error  GSUB_Do_Glyph_Lookup( HB_GSUBHeader*   gsub,
+				       HB_UShort         lookup_index,
+				       HB_Buffer        buffer,
+				       HB_UShort         context_length,
+				       int               nesting_level );
+
+
+
+/**********************
+ * Auxiliary functions
+ **********************/
+
+
+
+HB_Error  HB_Load_GSUB_Table( HB_Stream stream,
+			      HB_GSUBHeader** retptr,
+			      HB_GDEFHeader*  gdef,
+                              HB_Stream       gdefStream )
+{
+  HB_Error         error;
+  HB_UInt         cur_offset, new_offset, base_offset;
+
+  HB_GSUBHeader*  gsub;
+
+  if ( !retptr )
+    return ERR(HB_Err_Invalid_Argument);
+
+  if ( GOTO_Table( TTAG_GSUB ) )
+    return error;
+
+  base_offset = FILE_Pos();
+
+  if ( ALLOC ( gsub, sizeof( *gsub ) ) ) 
+      return error;
+  
+
+  /* skip version */
+
+  if ( FILE_Seek( base_offset + 4L ) ||
+       ACCESS_Frame( 2L ) )
+    goto Fail4;
+
+  new_offset = GET_UShort() + base_offset;
+
+  FORGET_Frame();
+
+  cur_offset = FILE_Pos();
+  if ( FILE_Seek( new_offset ) ||
+       ( error = _HB_OPEN_Load_ScriptList( &gsub->ScriptList,
+				  stream ) ) != HB_Err_Ok )
+    goto Fail4;
+  (void)FILE_Seek( cur_offset );
+
+  if ( ACCESS_Frame( 2L ) )
+    goto Fail3;
+
+  new_offset = GET_UShort() + base_offset;
+
+  FORGET_Frame();
+
+  cur_offset = FILE_Pos();
+  if ( FILE_Seek( new_offset ) ||
+       ( error = _HB_OPEN_Load_FeatureList( &gsub->FeatureList,
+				   stream ) ) != HB_Err_Ok )
+    goto Fail3;
+  (void)FILE_Seek( cur_offset );
+
+  if ( ACCESS_Frame( 2L ) )
+    goto Fail2;
+
+  new_offset = GET_UShort() + base_offset;
+
+  FORGET_Frame();
+
+  cur_offset = FILE_Pos();
+  if ( FILE_Seek( new_offset ) ||
+       ( error = _HB_OPEN_Load_LookupList( &gsub->LookupList,
+				  stream, HB_Type_GSUB ) ) != HB_Err_Ok )
+    goto Fail2;
+
+  gsub->gdef = gdef;      /* can be NULL */
+
+  if ( ( error =  _HB_GDEF_LoadMarkAttachClassDef_From_LookupFlags( gdef, gdefStream,
+								     gsub->LookupList.Lookup,
+								     gsub->LookupList.LookupCount ) ) )
+    goto Fail1;
+
+  *retptr = gsub;
+
+  return HB_Err_Ok;
+
+Fail1:
+  _HB_OPEN_Free_LookupList( &gsub->LookupList, HB_Type_GSUB );
+
+Fail2:
+  _HB_OPEN_Free_FeatureList( &gsub->FeatureList );
+
+Fail3:
+  _HB_OPEN_Free_ScriptList( &gsub->ScriptList );
+
+Fail4:
+  FREE ( gsub );
+
+
+  return error;
+}
+
+
+HB_Error   HB_Done_GSUB_Table( HB_GSUBHeader* gsub )
+{
+  _HB_OPEN_Free_LookupList( &gsub->LookupList, HB_Type_GSUB );
+  _HB_OPEN_Free_FeatureList( &gsub->FeatureList );
+  _HB_OPEN_Free_ScriptList( &gsub->ScriptList );
+
+  FREE( gsub );
+
+  return HB_Err_Ok;
+}
+
+/*****************************
+ * SubTable related functions
+ *****************************/
+
+
+/* LookupType 1 */
+
+/* SingleSubstFormat1 */
+/* SingleSubstFormat2 */
+
+static HB_Error  Load_SingleSubst( HB_GSUB_SubTable* st,
+				   HB_Stream         stream )
+{
+  HB_Error error;
+  HB_SingleSubst*  ss = &st->single;
+
+  HB_UShort n, count;
+  HB_UInt cur_offset, new_offset, base_offset;
+
+  HB_UShort*  s;
+
+
+  base_offset = FILE_Pos();
+
+  if ( ACCESS_Frame( 4L ) )
+    return error;
+
+  ss->SubstFormat = GET_UShort();
+  new_offset      = GET_UShort() + base_offset;
+
+  FORGET_Frame();
+
+  cur_offset = FILE_Pos();
+  if ( FILE_Seek( new_offset ) ||
+       ( error = _HB_OPEN_Load_Coverage( &ss->Coverage, stream ) ) != HB_Err_Ok )
+    return error;
+  (void)FILE_Seek( cur_offset );
+
+  switch ( ss->SubstFormat )
+  {
+  case 1:
+    if ( ACCESS_Frame( 2L ) )
+      goto Fail2;
+
+    ss->ssf.ssf1.DeltaGlyphID = GET_UShort();
+
+    FORGET_Frame();
+
+    break;
+
+  case 2:
+    if ( ACCESS_Frame( 2L ) )
+      goto Fail2;
+
+    count = ss->ssf.ssf2.GlyphCount = GET_UShort();
+
+    FORGET_Frame();
+
+    ss->ssf.ssf2.Substitute = NULL;
+
+    if ( ALLOC_ARRAY( ss->ssf.ssf2.Substitute, count, HB_UShort ) )
+      goto Fail2;
+
+    s = ss->ssf.ssf2.Substitute;
+
+    if ( ACCESS_Frame( count * 2L ) )
+      goto Fail1;
+
+    for ( n = 0; n < count; n++ )
+      s[n] = GET_UShort();
+
+    FORGET_Frame();
+
+    break;
+
+  default:
+    return ERR(HB_Err_Invalid_SubTable_Format);
+  }
+
+  return HB_Err_Ok;
+
+Fail1:
+  FREE( s );
+
+Fail2:
+  _HB_OPEN_Free_Coverage( &ss->Coverage );
+  return error;
+}
+
+
+static void  Free_SingleSubst( HB_GSUB_SubTable* st )
+{
+  HB_SingleSubst*  ss = &st->single;
+
+  switch ( ss->SubstFormat )
+  {
+  case 1:
+    break;
+
+  case 2:
+    FREE( ss->ssf.ssf2.Substitute );
+    break;
+
+  default:
+    break;
+  }
+
+  _HB_OPEN_Free_Coverage( &ss->Coverage );
+}
+
+
+static HB_Error  Lookup_SingleSubst( HB_GSUBHeader*   gsub,
+				     HB_GSUB_SubTable* st,
+				     HB_Buffer        buffer,
+				     HB_UShort         flags,
+				     HB_UShort         context_length,
+				     int               nesting_level )
+{
+  HB_UShort index, value, property;
+  HB_Error  error;
+  HB_SingleSubst*  ss = &st->single;
+  HB_GDEFHeader*   gdef = gsub->gdef;
+
+  HB_UNUSED(nesting_level);
+
+  if ( context_length != 0xFFFF && context_length < 1 )
+    return HB_Err_Not_Covered;
+
+  if ( CHECK_Property( gdef, IN_CURITEM(), flags, &property ) )
+    return error;
+
+  error = _HB_OPEN_Coverage_Index( &ss->Coverage, IN_CURGLYPH(), &index );
+  if ( error )
+    return error;
+
+  switch ( ss->SubstFormat )
+  {
+  case 1:
+    value = ( IN_CURGLYPH() + ss->ssf.ssf1.DeltaGlyphID ) & 0xFFFF;
+    if ( REPLACE_Glyph( buffer, value, nesting_level ) )
+      return error;
+    break;
+
+  case 2:
+    if ( index >= ss->ssf.ssf2.GlyphCount )
+      return ERR(HB_Err_Invalid_SubTable);
+    value = ss->ssf.ssf2.Substitute[index];
+    if ( REPLACE_Glyph( buffer, value, nesting_level ) )
+      return error;
+    break;
+
+  default:
+    return ERR(HB_Err_Invalid_SubTable);
+  }
+
+  if ( gdef && gdef->NewGlyphClasses )
+  {
+    /* we inherit the old glyph class to the substituted glyph */
+
+    error = _HB_GDEF_Add_Glyph_Property( gdef, value, property );
+    if ( error && error != HB_Err_Not_Covered )
+      return error;
+  }
+
+  return HB_Err_Ok;
+}
+
+
+/* LookupType 2 */
+
+/* Sequence */
+
+static HB_Error  Load_Sequence( HB_Sequence*  s,
+				HB_Stream      stream )
+{
+  HB_Error error;
+
+  HB_UShort n, count;
+  HB_UShort*  sub;
+
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  count = s->GlyphCount = GET_UShort();
+
+  FORGET_Frame();
+
+  s->Substitute = NULL;
+
+  if ( count )
+  {
+    if ( ALLOC_ARRAY( s->Substitute, count, HB_UShort ) )
+      return error;
+
+    sub = s->Substitute;
+
+    if ( ACCESS_Frame( count * 2L ) )
+    {
+      FREE( sub );
+      return error;
+    }
+
+    for ( n = 0; n < count; n++ )
+      sub[n] = GET_UShort();
+
+    FORGET_Frame();
+  }
+
+  return HB_Err_Ok;
+}
+
+
+static void  Free_Sequence( HB_Sequence*  s )
+{
+  FREE( s->Substitute );
+}
+
+
+/* MultipleSubstFormat1 */
+
+static HB_Error  Load_MultipleSubst( HB_GSUB_SubTable* st,
+				     HB_Stream         stream )
+{
+  HB_Error error;
+  HB_MultipleSubst*  ms = &st->multiple;
+
+  HB_UShort      n = 0, m, count;
+  HB_UInt       cur_offset, new_offset, base_offset;
+
+  HB_Sequence*  s;
+
+
+  base_offset = FILE_Pos();
+
+  if ( ACCESS_Frame( 4L ) )
+    return error;
+
+  ms->SubstFormat = GET_UShort();             /* should be 1 */
+  new_offset      = GET_UShort() + base_offset;
+
+  FORGET_Frame();
+
+  cur_offset = FILE_Pos();
+  if ( FILE_Seek( new_offset ) ||
+       ( error = _HB_OPEN_Load_Coverage( &ms->Coverage, stream ) ) != HB_Err_Ok )
+    return error;
+  (void)FILE_Seek( cur_offset );
+
+  if ( ACCESS_Frame( 2L ) )
+    goto Fail2;
+
+  count = ms->SequenceCount = GET_UShort();
+
+  FORGET_Frame();
+
+  ms->Sequence = NULL;
+
+  if ( ALLOC_ARRAY( ms->Sequence, count, HB_Sequence ) )
+    goto Fail2;
+
+  s = ms->Sequence;
+
+  for ( n = 0; n < count; n++ )
+  {
+    if ( ACCESS_Frame( 2L ) )
+      goto Fail1;
+
+    new_offset = GET_UShort() + base_offset;
+
+    FORGET_Frame();
+
+    cur_offset = FILE_Pos();
+    if ( FILE_Seek( new_offset ) ||
+	 ( error = Load_Sequence( &s[n], stream ) ) != HB_Err_Ok )
+      goto Fail1;
+    (void)FILE_Seek( cur_offset );
+  }
+
+  return HB_Err_Ok;
+
+Fail1:
+  for ( m = 0; m < n; m++ )
+    Free_Sequence( &s[m] );
+
+  FREE( s );
+
+Fail2:
+  _HB_OPEN_Free_Coverage( &ms->Coverage );
+  return error;
+}
+
+
+static void  Free_MultipleSubst( HB_GSUB_SubTable* st )
+{
+  HB_UShort      n, count;
+  HB_MultipleSubst*  ms = &st->multiple;
+
+  HB_Sequence*  s;
+
+
+  if ( ms->Sequence )
+  {
+    count = ms->SequenceCount;
+    s     = ms->Sequence;
+
+    for ( n = 0; n < count; n++ )
+      Free_Sequence( &s[n] );
+
+    FREE( s );
+  }
+
+  _HB_OPEN_Free_Coverage( &ms->Coverage );
+}
+
+
+static HB_Error  Lookup_MultipleSubst( HB_GSUBHeader*    gsub,
+				       HB_GSUB_SubTable* st,
+				       HB_Buffer         buffer,
+				       HB_UShort          flags,
+				       HB_UShort          context_length,
+				       int                nesting_level )
+{
+  HB_Error  error;
+  HB_UShort index, property, n, count;
+  HB_UShort*s;
+  HB_MultipleSubst*  ms = &st->multiple;
+  HB_GDEFHeader*     gdef = gsub->gdef;
+
+  HB_UNUSED(nesting_level);
+
+  if ( context_length != 0xFFFF && context_length < 1 )
+    return HB_Err_Not_Covered;
+
+  if ( CHECK_Property( gdef, IN_CURITEM(), flags, &property ) )
+    return error;
+
+  error = _HB_OPEN_Coverage_Index( &ms->Coverage, IN_CURGLYPH(), &index );
+  if ( error )
+    return error;
+
+  if ( index >= ms->SequenceCount )
+    return ERR(HB_Err_Invalid_SubTable);
+
+  count = ms->Sequence[index].GlyphCount;
+  s     = ms->Sequence[index].Substitute;
+
+  if ( ADD_String( buffer, 1, count, s, 0xFFFF, 0xFFFF ) )
+    return error;
+
+  if ( gdef && gdef->NewGlyphClasses )
+  {
+    /* this is a guess only ... */
+
+    if ( property == HB_GDEF_LIGATURE )
+      property = HB_GDEF_BASE_GLYPH;
+
+    for ( n = 0; n < count; n++ )
+    {
+      error = _HB_GDEF_Add_Glyph_Property( gdef, s[n], property );
+      if ( error && error != HB_Err_Not_Covered )
+	return error;
+    }
+  }
+
+  return HB_Err_Ok;
+}
+
+
+/* LookupType 3 */
+
+/* AlternateSet */
+
+static HB_Error  Load_AlternateSet( HB_AlternateSet*  as,
+				    HB_Stream          stream )
+{
+  HB_Error error;
+
+  HB_UShort n, count;
+  HB_UShort*  a;
+
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  count = as->GlyphCount = GET_UShort();
+
+  FORGET_Frame();
+
+  as->Alternate = NULL;
+
+  if ( ALLOC_ARRAY( as->Alternate, count, HB_UShort ) )
+    return error;
+
+  a = as->Alternate;
+
+  if ( ACCESS_Frame( count * 2L ) )
+  {
+    FREE( a );
+    return error;
+  }
+
+  for ( n = 0; n < count; n++ )
+    a[n] = GET_UShort();
+
+  FORGET_Frame();
+
+  return HB_Err_Ok;
+}
+
+
+static void  Free_AlternateSet( HB_AlternateSet*  as )
+{
+  FREE( as->Alternate );
+}
+
+
+/* AlternateSubstFormat1 */
+
+static HB_Error  Load_AlternateSubst( HB_GSUB_SubTable* st,
+				      HB_Stream         stream )
+{
+  HB_Error error;
+  HB_AlternateSubst* as = &st->alternate;
+
+  HB_UShort          n = 0, m, count;
+  HB_UInt           cur_offset, new_offset, base_offset;
+
+  HB_AlternateSet*  aset;
+
+
+  base_offset = FILE_Pos();
+
+  if ( ACCESS_Frame( 4L ) )
+    return error;
+
+  as->SubstFormat = GET_UShort();             /* should be 1 */
+  new_offset      = GET_UShort() + base_offset;
+
+  FORGET_Frame();
+
+  cur_offset = FILE_Pos();
+  if ( FILE_Seek( new_offset ) ||
+       ( error = _HB_OPEN_Load_Coverage( &as->Coverage, stream ) ) != HB_Err_Ok )
+    return error;
+  (void)FILE_Seek( cur_offset );
+
+  if ( ACCESS_Frame( 2L ) )
+    goto Fail2;
+
+  count = as->AlternateSetCount = GET_UShort();
+
+  FORGET_Frame();
+
+  as->AlternateSet = NULL;
+
+  if ( ALLOC_ARRAY( as->AlternateSet, count, HB_AlternateSet ) )
+    goto Fail2;
+
+  aset = as->AlternateSet;
+
+  for ( n = 0; n < count; n++ )
+  {
+    if ( ACCESS_Frame( 2L ) )
+      goto Fail1;
+
+    new_offset = GET_UShort() + base_offset;
+
+    FORGET_Frame();
+
+    cur_offset = FILE_Pos();
+    if ( FILE_Seek( new_offset ) ||
+	 ( error = Load_AlternateSet( &aset[n], stream ) ) != HB_Err_Ok )
+      goto Fail1;
+    (void)FILE_Seek( cur_offset );
+  }
+
+  return HB_Err_Ok;
+
+Fail1:
+  for ( m = 0; m < n; m++ )
+    Free_AlternateSet( &aset[m] );
+
+  FREE( aset );
+
+Fail2:
+  _HB_OPEN_Free_Coverage( &as->Coverage );
+  return error;
+}
+
+
+static void  Free_AlternateSubst( HB_GSUB_SubTable* st )
+{
+  HB_UShort          n, count;
+  HB_AlternateSubst* as = &st->alternate;
+
+  HB_AlternateSet*  aset;
+
+
+  if ( as->AlternateSet )
+  {
+    count = as->AlternateSetCount;
+    aset  = as->AlternateSet;
+
+    for ( n = 0; n < count; n++ )
+      Free_AlternateSet( &aset[n] );
+
+    FREE( aset );
+  }
+
+  _HB_OPEN_Free_Coverage( &as->Coverage );
+}
+
+
+static HB_Error  Lookup_AlternateSubst( HB_GSUBHeader*    gsub,
+					HB_GSUB_SubTable* st,
+					HB_Buffer         buffer,
+					HB_UShort          flags,
+					HB_UShort          context_length,
+					int                nesting_level )
+{
+  HB_Error          error;
+  HB_UShort         index, value, alt_index, property;
+  HB_AlternateSubst* as = &st->alternate;
+  HB_GDEFHeader*     gdef = gsub->gdef;
+  HB_AlternateSet  aset;
+
+  HB_UNUSED(nesting_level);
+
+  if ( context_length != 0xFFFF && context_length < 1 )
+    return HB_Err_Not_Covered;
+
+  if ( CHECK_Property( gdef, IN_CURITEM(), flags, &property ) )
+    return error;
+
+  error = _HB_OPEN_Coverage_Index( &as->Coverage, IN_CURGLYPH(), &index );
+  if ( error )
+    return error;
+
+  aset = as->AlternateSet[index];
+
+  /* we use a user-defined callback function to get the alternate index */
+
+  if ( gsub->altfunc )
+    alt_index = (gsub->altfunc)( buffer->out_pos, IN_CURGLYPH(),
+				 aset.GlyphCount, aset.Alternate,
+				 gsub->data );
+  else
+    alt_index = 0;
+
+  value = aset.Alternate[alt_index];
+  if ( REPLACE_Glyph( buffer, value, nesting_level ) )
+    return error;
+
+  if ( gdef && gdef->NewGlyphClasses )
+  {
+    /* we inherit the old glyph class to the substituted glyph */
+
+    error = _HB_GDEF_Add_Glyph_Property( gdef, value, property );
+    if ( error && error != HB_Err_Not_Covered )
+      return error;
+  }
+
+  return HB_Err_Ok;
+}
+
+
+/* LookupType 4 */
+
+/* Ligature */
+
+static HB_Error  Load_Ligature( HB_Ligature*  l,
+				HB_Stream      stream )
+{
+  HB_Error error;
+
+  HB_UShort n, count;
+  HB_UShort*  c;
+
+
+  if ( ACCESS_Frame( 4L ) )
+    return error;
+
+  l->LigGlyph       = GET_UShort();
+  l->ComponentCount = GET_UShort();
+
+  FORGET_Frame();
+
+  l->Component = NULL;
+
+  count = l->ComponentCount - 1;      /* only ComponentCount - 1 elements */
+
+  if ( ALLOC_ARRAY( l->Component, count, HB_UShort ) )
+    return error;
+
+  c = l->Component;
+
+  if ( ACCESS_Frame( count * 2L ) )
+  {
+    FREE( c );
+    return error;
+  }
+
+  for ( n = 0; n < count; n++ )
+    c[n] = GET_UShort();
+
+  FORGET_Frame();
+
+  return HB_Err_Ok;
+}
+
+
+static void  Free_Ligature( HB_Ligature*  l )
+{
+  FREE( l->Component );
+}
+
+
+/* LigatureSet */
+
+static HB_Error  Load_LigatureSet( HB_LigatureSet*  ls,
+				   HB_Stream         stream )
+{
+  HB_Error error;
+
+  HB_UShort      n = 0, m, count;
+  HB_UInt       cur_offset, new_offset, base_offset;
+
+  HB_Ligature*  l;
+
+
+  base_offset = FILE_Pos();
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  count = ls->LigatureCount = GET_UShort();
+
+  FORGET_Frame();
+
+  ls->Ligature = NULL;
+
+  if ( ALLOC_ARRAY( ls->Ligature, count, HB_Ligature ) )
+    return error;
+
+  l = ls->Ligature;
+
+  for ( n = 0; n < count; n++ )
+  {
+    if ( ACCESS_Frame( 2L ) )
+      goto Fail;
+
+    new_offset = GET_UShort() + base_offset;
+
+    FORGET_Frame();
+
+    cur_offset = FILE_Pos();
+    if ( FILE_Seek( new_offset ) ||
+	 ( error = Load_Ligature( &l[n], stream ) ) != HB_Err_Ok )
+      goto Fail;
+    (void)FILE_Seek( cur_offset );
+  }
+
+  return HB_Err_Ok;
+
+Fail:
+  for ( m = 0; m < n; m++ )
+    Free_Ligature( &l[m] );
+
+  FREE( l );
+  return error;
+}
+
+
+static void  Free_LigatureSet( HB_LigatureSet*  ls )
+{
+  HB_UShort      n, count;
+
+  HB_Ligature*  l;
+
+
+  if ( ls->Ligature )
+  {
+    count = ls->LigatureCount;
+    l     = ls->Ligature;
+
+    for ( n = 0; n < count; n++ )
+      Free_Ligature( &l[n] );
+
+    FREE( l );
+  }
+}
+
+
+/* LigatureSubstFormat1 */
+
+static HB_Error  Load_LigatureSubst( HB_GSUB_SubTable* st,
+				     HB_Stream         stream )
+{
+  HB_Error error;
+  HB_LigatureSubst*  ls = &st->ligature;
+
+  HB_UShort         n = 0, m, count;
+  HB_UInt          cur_offset, new_offset, base_offset;
+
+  HB_LigatureSet*  lset;
+
+
+  base_offset = FILE_Pos();
+
+  if ( ACCESS_Frame( 4L ) )
+    return error;
+
+  ls->SubstFormat = GET_UShort();             /* should be 1 */
+  new_offset      = GET_UShort() + base_offset;
+
+  FORGET_Frame();
+
+  cur_offset = FILE_Pos();
+  if ( FILE_Seek( new_offset ) ||
+       ( error = _HB_OPEN_Load_Coverage( &ls->Coverage, stream ) ) != HB_Err_Ok )
+    return error;
+  (void)FILE_Seek( cur_offset );
+
+  if ( ACCESS_Frame( 2L ) )
+    goto Fail2;
+
+  count = ls->LigatureSetCount = GET_UShort();
+
+  FORGET_Frame();
+
+  ls->LigatureSet = NULL;
+
+  if ( ALLOC_ARRAY( ls->LigatureSet, count, HB_LigatureSet ) )
+    goto Fail2;
+
+  lset = ls->LigatureSet;
+
+  for ( n = 0; n < count; n++ )
+  {
+    if ( ACCESS_Frame( 2L ) )
+      goto Fail1;
+
+    new_offset = GET_UShort() + base_offset;
+
+    FORGET_Frame();
+
+    cur_offset = FILE_Pos();
+    if ( FILE_Seek( new_offset ) ||
+	 ( error = Load_LigatureSet( &lset[n], stream ) ) != HB_Err_Ok )
+      goto Fail1;
+    (void)FILE_Seek( cur_offset );
+  }
+
+  return HB_Err_Ok;
+
+Fail1:
+  for ( m = 0; m < n; m++ )
+    Free_LigatureSet( &lset[m] );
+
+  FREE( lset );
+
+Fail2:
+  _HB_OPEN_Free_Coverage( &ls->Coverage );
+  return error;
+}
+
+
+static void  Free_LigatureSubst( HB_GSUB_SubTable* st )
+{
+  HB_UShort         n, count;
+  HB_LigatureSubst*  ls = &st->ligature;
+
+  HB_LigatureSet*  lset;
+
+
+  if ( ls->LigatureSet )
+  {
+    count = ls->LigatureSetCount;
+    lset  = ls->LigatureSet;
+
+    for ( n = 0; n < count; n++ )
+      Free_LigatureSet( &lset[n] );
+
+    FREE( lset );
+  }
+
+  _HB_OPEN_Free_Coverage( &ls->Coverage );
+}
+
+
+static HB_Error  Lookup_LigatureSubst( HB_GSUBHeader*    gsub,
+				       HB_GSUB_SubTable* st,
+				       HB_Buffer         buffer,
+				       HB_UShort          flags,
+				       HB_UShort          context_length,
+				       int                nesting_level )
+{
+  HB_UShort      index, property;
+  HB_Error       error;
+  HB_UShort      numlig, i, j, is_mark, first_is_mark = FALSE;
+  HB_UShort*     c;
+  HB_LigatureSubst*  ls = &st->ligature;
+  HB_GDEFHeader*     gdef = gsub->gdef;
+
+  HB_Ligature*  lig;
+
+  HB_UNUSED(nesting_level);
+
+  if ( CHECK_Property( gdef, IN_CURITEM(), flags, &property ) )
+    return error;
+
+  if ( property == HB_GDEF_MARK || property & HB_LOOKUP_FLAG_IGNORE_SPECIAL_MARKS )
+    first_is_mark = TRUE;
+
+  error = _HB_OPEN_Coverage_Index( &ls->Coverage, IN_CURGLYPH(), &index );
+  if ( error )
+    return error;
+
+  if ( index >= ls->LigatureSetCount )
+     return ERR(HB_Err_Invalid_SubTable);
+
+  lig = ls->LigatureSet[index].Ligature;
+
+  for ( numlig = ls->LigatureSet[index].LigatureCount;
+	numlig;
+	numlig--, lig++ )
+  {
+    if ( buffer->in_pos + lig->ComponentCount > buffer->in_length )
+      goto next_ligature;               /* Not enough glyphs in input */
+
+    c    = lig->Component;
+
+    is_mark = first_is_mark;
+
+    if ( context_length != 0xFFFF && context_length < lig->ComponentCount )
+      break;
+
+    for ( i = 1, j = buffer->in_pos + 1; i < lig->ComponentCount; i++, j++ )
+    {
+      while ( CHECK_Property( gdef, IN_ITEM( j ), flags, &property ) )
+      {
+	if ( error && error != HB_Err_Not_Covered )
+	  return error;
+
+	if ( j + lig->ComponentCount - i == (HB_Int)buffer->in_length )
+	  goto next_ligature;
+	j++;
+      }
+
+      if ( !( property == HB_GDEF_MARK || property & HB_LOOKUP_FLAG_IGNORE_SPECIAL_MARKS ) )
+	is_mark = FALSE;
+
+      if ( IN_GLYPH( j ) != c[i - 1] )
+	goto next_ligature;
+    }
+
+    if ( gdef && gdef->NewGlyphClasses )
+    {
+      /* this is just a guess ... */
+
+      error = _HB_GDEF_Add_Glyph_Property( gdef, lig->LigGlyph,
+				  is_mark ? HB_GDEF_MARK : HB_GDEF_LIGATURE );
+      if ( error && error != HB_Err_Not_Covered )
+	return error;
+    }
+
+    if ( j == buffer->in_pos + i ) /* No input glyphs skipped */
+    {
+      /* We don't use a new ligature ID if there are no skipped
+	 glyphs and the ligature already has an ID.             */
+
+      if ( IN_LIGID( buffer->in_pos ) )
+      {
+	if ( ADD_String( buffer, i, 1, &lig->LigGlyph,
+			0xFFFF, 0xFFFF ) )
+	  return error;
+      }
+      else
+      {
+	HB_UShort ligID = _hb_buffer_allocate_ligid( buffer );
+	if ( ADD_String( buffer, i, 1, &lig->LigGlyph,
+			0xFFFF, ligID ) )
+	  return error;
+      }
+    }
+    else
+    {
+      HB_UShort ligID = _hb_buffer_allocate_ligid( buffer );
+      if ( ADD_Glyph( buffer, lig->LigGlyph, 0xFFFF, ligID ) )
+	return error;
+
+      /* Now we must do a second loop to copy the skipped glyphs to
+	 `out' and assign component values to it.  We start with the
+	 glyph after the first component.  Glyphs between component
+	 i and i+1 belong to component i.  Together with the ligID
+	 value it is later possible to check whether a specific
+	 component value really belongs to a given ligature.         */
+
+      for ( i = 0; i < lig->ComponentCount - 1; i++ )
+      {
+	while ( CHECK_Property( gdef, IN_CURITEM(),
+				flags, &property ) )
+	  if ( ADD_Glyph( buffer, IN_CURGLYPH(), i, ligID ) )
+	    return error;
+
+	(buffer->in_pos)++;
+      }
+    }
+
+    return HB_Err_Ok;
+
+  next_ligature:
+    ;
+  }
+
+  return HB_Err_Not_Covered;
+}
+
+
+/* Do the actual substitution for a context substitution (either format
+   5 or 6).  This is only called after we've determined that the input
+   matches the subrule.                                                 */
+
+static HB_Error  Do_ContextSubst( HB_GSUBHeader*        gsub,
+				  HB_UShort              GlyphCount,
+				  HB_UShort              SubstCount,
+				  HB_SubstLookupRecord* subst,
+				  HB_Buffer             buffer,
+				  int                    nesting_level )
+{
+  HB_Error  error;
+  HB_UInt   i, old_pos;
+
+
+  i = 0;
+
+  while ( i < GlyphCount )
+  {
+    if ( SubstCount && i == subst->SequenceIndex )
+    {
+      old_pos = buffer->in_pos;
+
+      /* Do a substitution */
+
+      error = GSUB_Do_Glyph_Lookup( gsub, subst->LookupListIndex, buffer,
+				    GlyphCount, nesting_level );
+
+      subst++;
+      SubstCount--;
+      i += buffer->in_pos - old_pos;
+
+      if ( error == HB_Err_Not_Covered )
+      {
+	if ( COPY_Glyph( buffer ) )
+	  return error;
+	i++;
+      }
+      else if ( error )
+	return error;
+    }
+    else
+    {
+      /* No substitution for this index */
+
+      if ( COPY_Glyph( buffer ) )
+	return error;
+      i++;
+    }
+  }
+
+  return HB_Err_Ok;
+}
+
+
+/* LookupType 5 */
+
+/* SubRule */
+
+static HB_Error  Load_SubRule( HB_SubRule*  sr,
+			       HB_Stream     stream )
+{
+  HB_Error error;
+
+  HB_UShort               n, count;
+  HB_UShort*              i;
+
+  HB_SubstLookupRecord*  slr;
+
+
+  if ( ACCESS_Frame( 4L ) )
+    return error;
+
+  sr->GlyphCount = GET_UShort();
+  sr->SubstCount = GET_UShort();
+
+  FORGET_Frame();
+
+  sr->Input = NULL;
+
+  count = sr->GlyphCount - 1;         /* only GlyphCount - 1 elements */
+
+  if ( ALLOC_ARRAY( sr->Input, count, HB_UShort ) )
+    return error;
+
+  i = sr->Input;
+
+  if ( ACCESS_Frame( count * 2L ) )
+    goto Fail2;
+
+  for ( n = 0; n < count; n++ )
+    i[n] = GET_UShort();
+
+  FORGET_Frame();
+
+  sr->SubstLookupRecord = NULL;
+
+  count = sr->SubstCount;
+
+  if ( ALLOC_ARRAY( sr->SubstLookupRecord, count, HB_SubstLookupRecord ) )
+    goto Fail2;
+
+  slr = sr->SubstLookupRecord;
+
+  if ( ACCESS_Frame( count * 4L ) )
+    goto Fail1;
+
+  for ( n = 0; n < count; n++ )
+  {
+    slr[n].SequenceIndex   = GET_UShort();
+    slr[n].LookupListIndex = GET_UShort();
+  }
+
+  FORGET_Frame();
+
+  return HB_Err_Ok;
+
+Fail1:
+  FREE( slr );
+
+Fail2:
+  FREE( i );
+  return error;
+}
+
+
+static void  Free_SubRule( HB_SubRule*  sr )
+{
+  FREE( sr->SubstLookupRecord );
+  FREE( sr->Input );
+}
+
+
+/* SubRuleSet */
+
+static HB_Error  Load_SubRuleSet( HB_SubRuleSet*  srs,
+				  HB_Stream        stream )
+{
+  HB_Error error;
+
+  HB_UShort     n = 0, m, count;
+  HB_UInt      cur_offset, new_offset, base_offset;
+
+  HB_SubRule*  sr;
+
+
+  base_offset = FILE_Pos();
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  count = srs->SubRuleCount = GET_UShort();
+
+  FORGET_Frame();
+
+  srs->SubRule = NULL;
+
+  if ( ALLOC_ARRAY( srs->SubRule, count, HB_SubRule ) )
+    return error;
+
+  sr = srs->SubRule;
+
+  for ( n = 0; n < count; n++ )
+  {
+    if ( ACCESS_Frame( 2L ) )
+      goto Fail;
+
+    new_offset = GET_UShort() + base_offset;
+
+    FORGET_Frame();
+
+    cur_offset = FILE_Pos();
+    if ( FILE_Seek( new_offset ) ||
+	 ( error = Load_SubRule( &sr[n], stream ) ) != HB_Err_Ok )
+      goto Fail;
+    (void)FILE_Seek( cur_offset );
+  }
+
+  return HB_Err_Ok;
+
+Fail:
+  for ( m = 0; m < n; m++ )
+    Free_SubRule( &sr[m] );
+
+  FREE( sr );
+  return error;
+}
+
+
+static void  Free_SubRuleSet( HB_SubRuleSet*  srs )
+{
+  HB_UShort     n, count;
+
+  HB_SubRule*  sr;
+
+
+  if ( srs->SubRule )
+  {
+    count = srs->SubRuleCount;
+    sr    = srs->SubRule;
+
+    for ( n = 0; n < count; n++ )
+      Free_SubRule( &sr[n] );
+
+    FREE( sr );
+  }
+}
+
+
+/* ContextSubstFormat1 */
+
+static HB_Error  Load_ContextSubst1( HB_ContextSubstFormat1*  csf1,
+				     HB_Stream                 stream )
+{
+  HB_Error error;
+
+  HB_UShort        n = 0, m, count;
+  HB_UInt         cur_offset, new_offset, base_offset;
+
+  HB_SubRuleSet*  srs;
+
+
+  base_offset = FILE_Pos() - 2L;
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  new_offset = GET_UShort() + base_offset;
+
+  FORGET_Frame();
+
+  cur_offset = FILE_Pos();
+  if ( FILE_Seek( new_offset ) ||
+       ( error = _HB_OPEN_Load_Coverage( &csf1->Coverage, stream ) ) != HB_Err_Ok )
+    return error;
+  (void)FILE_Seek( cur_offset );
+
+  if ( ACCESS_Frame( 2L ) )
+    goto Fail2;
+
+  count = csf1->SubRuleSetCount = GET_UShort();
+
+  FORGET_Frame();
+
+  csf1->SubRuleSet = NULL;
+
+  if ( ALLOC_ARRAY( csf1->SubRuleSet, count, HB_SubRuleSet ) )
+    goto Fail2;
+
+  srs = csf1->SubRuleSet;
+
+  for ( n = 0; n < count; n++ )
+  {
+    if ( ACCESS_Frame( 2L ) )
+      goto Fail1;
+
+    new_offset = GET_UShort() + base_offset;
+
+    FORGET_Frame();
+
+    cur_offset = FILE_Pos();
+    if ( FILE_Seek( new_offset ) ||
+	 ( error = Load_SubRuleSet( &srs[n], stream ) ) != HB_Err_Ok )
+      goto Fail1;
+    (void)FILE_Seek( cur_offset );
+  }
+
+  return HB_Err_Ok;
+
+Fail1:
+  for ( m = 0; m < n; m++ )
+    Free_SubRuleSet( &srs[m] );
+
+  FREE( srs );
+
+Fail2:
+  _HB_OPEN_Free_Coverage( &csf1->Coverage );
+  return error;
+}
+
+
+static void  Free_ContextSubst1( HB_ContextSubstFormat1* csf1 )
+{
+  HB_UShort        n, count;
+
+  HB_SubRuleSet*  srs;
+
+
+  if ( csf1->SubRuleSet )
+  {
+    count = csf1->SubRuleSetCount;
+    srs   = csf1->SubRuleSet;
+
+    for ( n = 0; n < count; n++ )
+      Free_SubRuleSet( &srs[n] );
+
+    FREE( srs );
+  }
+
+  _HB_OPEN_Free_Coverage( &csf1->Coverage );
+}
+
+
+/* SubClassRule */
+
+static HB_Error  Load_SubClassRule( HB_ContextSubstFormat2*  csf2,
+				    HB_SubClassRule*         scr,
+				    HB_Stream                 stream )
+{
+  HB_Error error;
+
+  HB_UShort               n, count;
+
+  HB_UShort*              c;
+  HB_SubstLookupRecord*  slr;
+
+
+  if ( ACCESS_Frame( 4L ) )
+    return error;
+
+  scr->GlyphCount = GET_UShort();
+  scr->SubstCount = GET_UShort();
+
+  if ( scr->GlyphCount > csf2->MaxContextLength )
+    csf2->MaxContextLength = scr->GlyphCount;
+
+  FORGET_Frame();
+
+  scr->Class = NULL;
+
+  count = scr->GlyphCount - 1;        /* only GlyphCount - 1 elements */
+
+  if ( ALLOC_ARRAY( scr->Class, count, HB_UShort ) )
+    return error;
+
+  c = scr->Class;
+
+  if ( ACCESS_Frame( count * 2L ) )
+    goto Fail2;
+
+  for ( n = 0; n < count; n++ )
+    c[n] = GET_UShort();
+
+  FORGET_Frame();
+
+  scr->SubstLookupRecord = NULL;
+
+  count = scr->SubstCount;
+
+  if ( ALLOC_ARRAY( scr->SubstLookupRecord, count, HB_SubstLookupRecord ) )
+    goto Fail2;
+
+  slr = scr->SubstLookupRecord;
+
+  if ( ACCESS_Frame( count * 4L ) )
+    goto Fail1;
+
+  for ( n = 0; n < count; n++ )
+  {
+    slr[n].SequenceIndex   = GET_UShort();
+    slr[n].LookupListIndex = GET_UShort();
+  }
+
+  FORGET_Frame();
+
+  return HB_Err_Ok;
+
+Fail1:
+  FREE( slr );
+
+Fail2:
+  FREE( c );
+  return error;
+}
+
+
+static void  Free_SubClassRule( HB_SubClassRule*  scr )
+{
+  FREE( scr->SubstLookupRecord );
+  FREE( scr->Class );
+}
+
+
+/* SubClassSet */
+
+static HB_Error  Load_SubClassSet( HB_ContextSubstFormat2*  csf2,
+				   HB_SubClassSet*          scs,
+				   HB_Stream                 stream )
+{
+  HB_Error error;
+
+  HB_UShort          n = 0, m, count;
+  HB_UInt           cur_offset, new_offset, base_offset;
+
+  HB_SubClassRule*  scr;
+
+
+  base_offset = FILE_Pos();
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  count = scs->SubClassRuleCount = GET_UShort();
+
+  FORGET_Frame();
+
+  scs->SubClassRule = NULL;
+
+  if ( ALLOC_ARRAY( scs->SubClassRule, count, HB_SubClassRule ) )
+    return error;
+
+  scr = scs->SubClassRule;
+
+  for ( n = 0; n < count; n++ )
+  {
+    if ( ACCESS_Frame( 2L ) )
+      goto Fail;
+
+    new_offset = GET_UShort() + base_offset;
+
+    FORGET_Frame();
+
+    cur_offset = FILE_Pos();
+    if ( FILE_Seek( new_offset ) ||
+	 ( error = Load_SubClassRule( csf2, &scr[n],
+				      stream ) ) != HB_Err_Ok )
+      goto Fail;
+    (void)FILE_Seek( cur_offset );
+  }
+
+  return HB_Err_Ok;
+
+Fail:
+  for ( m = 0; m < n; m++ )
+    Free_SubClassRule( &scr[m] );
+
+  FREE( scr );
+  return error;
+}
+
+
+static void  Free_SubClassSet( HB_SubClassSet*  scs )
+{
+  HB_UShort          n, count;
+
+  HB_SubClassRule*  scr;
+
+
+  if ( scs->SubClassRule )
+  {
+    count = scs->SubClassRuleCount;
+    scr   = scs->SubClassRule;
+
+    for ( n = 0; n < count; n++ )
+      Free_SubClassRule( &scr[n] );
+
+    FREE( scr );
+  }
+}
+
+
+/* ContextSubstFormat2 */
+
+static HB_Error  Load_ContextSubst2( HB_ContextSubstFormat2*  csf2,
+				     HB_Stream                 stream )
+{
+  HB_Error error;
+
+  HB_UShort         n = 0, m, count;
+  HB_UInt          cur_offset, new_offset, base_offset;
+
+  HB_SubClassSet*  scs;
+
+
+  base_offset = FILE_Pos() - 2;
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  new_offset = GET_UShort() + base_offset;
+
+  FORGET_Frame();
+
+  cur_offset = FILE_Pos();
+  if ( FILE_Seek( new_offset ) ||
+       ( error = _HB_OPEN_Load_Coverage( &csf2->Coverage, stream ) ) != HB_Err_Ok )
+    return error;
+  (void)FILE_Seek( cur_offset );
+
+  if ( ACCESS_Frame( 4L ) )
+    goto Fail3;
+
+  new_offset = GET_UShort() + base_offset;
+
+  /* `SubClassSetCount' is the upper limit for class values, thus we
+     read it now to make an additional safety check.                 */
+
+  count = csf2->SubClassSetCount = GET_UShort();
+
+  FORGET_Frame();
+
+  cur_offset = FILE_Pos();
+  if ( FILE_Seek( new_offset ) ||
+       ( error = _HB_OPEN_Load_ClassDefinition( &csf2->ClassDef, count,
+				       stream ) ) != HB_Err_Ok )
+    goto Fail3;
+  (void)FILE_Seek( cur_offset );
+
+  csf2->SubClassSet      = NULL;
+  csf2->MaxContextLength = 0;
+
+  if ( ALLOC_ARRAY( csf2->SubClassSet, count, HB_SubClassSet ) )
+    goto Fail2;
+
+  scs = csf2->SubClassSet;
+
+  for ( n = 0; n < count; n++ )
+  {
+    if ( ACCESS_Frame( 2L ) )
+      goto Fail1;
+
+    new_offset = GET_UShort() + base_offset;
+
+    FORGET_Frame();
+
+    if ( new_offset != base_offset )      /* not a NULL offset */
+    {
+      cur_offset = FILE_Pos();
+      if ( FILE_Seek( new_offset ) ||
+	   ( error = Load_SubClassSet( csf2, &scs[n],
+				       stream ) ) != HB_Err_Ok )
+	goto Fail1;
+      (void)FILE_Seek( cur_offset );
+    }
+    else
+    {
+      /* we create a SubClassSet table with no entries */
+
+      csf2->SubClassSet[n].SubClassRuleCount = 0;
+      csf2->SubClassSet[n].SubClassRule      = NULL;
+    }
+  }
+
+  return HB_Err_Ok;
+
+Fail1:
+  for ( m = 0; m < n; m++ )
+    Free_SubClassSet( &scs[m] );
+
+  FREE( scs );
+
+Fail2:
+  _HB_OPEN_Free_ClassDefinition( &csf2->ClassDef );
+
+Fail3:
+  _HB_OPEN_Free_Coverage( &csf2->Coverage );
+  return error;
+}
+
+
+static void  Free_ContextSubst2( HB_ContextSubstFormat2*  csf2 )
+{
+  HB_UShort         n, count;
+
+  HB_SubClassSet*  scs;
+
+
+  if ( csf2->SubClassSet )
+  {
+    count = csf2->SubClassSetCount;
+    scs   = csf2->SubClassSet;
+
+    for ( n = 0; n < count; n++ )
+      Free_SubClassSet( &scs[n] );
+
+    FREE( scs );
+  }
+
+  _HB_OPEN_Free_ClassDefinition( &csf2->ClassDef );
+  _HB_OPEN_Free_Coverage( &csf2->Coverage );
+}
+
+
+/* ContextSubstFormat3 */
+
+static HB_Error  Load_ContextSubst3( HB_ContextSubstFormat3*  csf3,
+				     HB_Stream                 stream )
+{
+  HB_Error error;
+
+  HB_UShort               n = 0, m, count;
+  HB_UInt                cur_offset, new_offset, base_offset;
+
+  HB_Coverage*           c;
+  HB_SubstLookupRecord*  slr;
+
+
+  base_offset = FILE_Pos() - 2L;
+
+  if ( ACCESS_Frame( 4L ) )
+    return error;
+
+  csf3->GlyphCount = GET_UShort();
+  csf3->SubstCount = GET_UShort();
+
+  FORGET_Frame();
+
+  csf3->Coverage = NULL;
+
+  count = csf3->GlyphCount;
+
+  if ( ALLOC_ARRAY( csf3->Coverage, count, HB_Coverage ) )
+    return error;
+
+  c = csf3->Coverage;
+
+  for ( n = 0; n < count; n++ )
+  {
+    if ( ACCESS_Frame( 2L ) )
+      goto Fail2;
+
+    new_offset = GET_UShort() + base_offset;
+
+    FORGET_Frame();
+
+    cur_offset = FILE_Pos();
+    if ( FILE_Seek( new_offset ) ||
+	 ( error = _HB_OPEN_Load_Coverage( &c[n], stream ) ) != HB_Err_Ok )
+      goto Fail2;
+    (void)FILE_Seek( cur_offset );
+  }
+
+  csf3->SubstLookupRecord = NULL;
+
+  count = csf3->SubstCount;
+
+  if ( ALLOC_ARRAY( csf3->SubstLookupRecord, count,
+		    HB_SubstLookupRecord ) )
+    goto Fail2;
+
+  slr = csf3->SubstLookupRecord;
+
+  if ( ACCESS_Frame( count * 4L ) )
+    goto Fail1;
+
+  for ( n = 0; n < count; n++ )
+  {
+    slr[n].SequenceIndex   = GET_UShort();
+    slr[n].LookupListIndex = GET_UShort();
+  }
+
+  FORGET_Frame();
+
+  return HB_Err_Ok;
+
+Fail1:
+  FREE( slr );
+
+Fail2:
+  for ( m = 0; m < n; m++ )
+    _HB_OPEN_Free_Coverage( &c[m] );
+
+  FREE( c );
+  return error;
+}
+
+
+static void  Free_ContextSubst3( HB_ContextSubstFormat3*  csf3 )
+{
+  HB_UShort      n, count;
+
+  HB_Coverage*  c;
+
+
+  FREE( csf3->SubstLookupRecord );
+
+  if ( csf3->Coverage )
+  {
+    count = csf3->GlyphCount;
+    c     = csf3->Coverage;
+
+    for ( n = 0; n < count; n++ )
+      _HB_OPEN_Free_Coverage( &c[n] );
+
+    FREE( c );
+  }
+}
+
+
+/* ContextSubst */
+
+static HB_Error  Load_ContextSubst( HB_GSUB_SubTable* st,
+				    HB_Stream         stream )
+{
+  HB_Error error;
+  HB_ContextSubst*  cs = &st->context;
+
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  cs->SubstFormat = GET_UShort();
+
+  FORGET_Frame();
+
+  switch ( cs->SubstFormat )
+  {
+  case 1:  return Load_ContextSubst1( &cs->csf.csf1, stream );
+  case 2:  return Load_ContextSubst2( &cs->csf.csf2, stream );
+  case 3:  return Load_ContextSubst3( &cs->csf.csf3, stream );
+  default: return ERR(HB_Err_Invalid_SubTable_Format);
+  }
+
+  return HB_Err_Ok;               /* never reached */
+}
+
+
+static void  Free_ContextSubst( HB_GSUB_SubTable* st )
+{
+  HB_ContextSubst*  cs = &st->context;
+
+  switch ( cs->SubstFormat )
+  {
+  case 1:  Free_ContextSubst1( &cs->csf.csf1 ); break;
+  case 2:  Free_ContextSubst2( &cs->csf.csf2 ); break;
+  case 3:  Free_ContextSubst3( &cs->csf.csf3 ); break;
+  default:						break;
+  }
+}
+
+
+static HB_Error  Lookup_ContextSubst1( HB_GSUBHeader*          gsub,
+				       HB_ContextSubstFormat1* csf1,
+				       HB_Buffer               buffer,
+				       HB_UShort                flags,
+				       HB_UShort                context_length,
+				       int                      nesting_level )
+{
+  HB_UShort        index, property;
+  HB_UShort        i, j, k, numsr;
+  HB_Error         error;
+
+  HB_SubRule*     sr;
+  HB_GDEFHeader*  gdef;
+
+
+  gdef = gsub->gdef;
+
+  if ( CHECK_Property( gdef, IN_CURITEM(), flags, &property ) )
+    return error;
+
+  error = _HB_OPEN_Coverage_Index( &csf1->Coverage, IN_CURGLYPH(), &index );
+  if ( error )
+    return error;
+
+  sr    = csf1->SubRuleSet[index].SubRule;
+  numsr = csf1->SubRuleSet[index].SubRuleCount;
+
+  for ( k = 0; k < numsr; k++ )
+  {
+    if ( context_length != 0xFFFF && context_length < sr[k].GlyphCount )
+      goto next_subrule;
+
+    if ( buffer->in_pos + sr[k].GlyphCount > buffer->in_length )
+      goto next_subrule;                        /* context is too long */
+
+    for ( i = 1, j = buffer->in_pos + 1; i < sr[k].GlyphCount; i++, j++ )
+    {
+      while ( CHECK_Property( gdef, IN_ITEM( j ), flags, &property ) )
+      {
+	if ( error && error != HB_Err_Not_Covered )
+	  return error;
+
+	if ( j + sr[k].GlyphCount - i == (HB_Int)buffer->in_length )
+	  goto next_subrule;
+	j++;
+      }
+
+      if ( IN_GLYPH( j ) != sr[k].Input[i - 1] )
+	goto next_subrule;
+    }
+
+    return Do_ContextSubst( gsub, sr[k].GlyphCount,
+			    sr[k].SubstCount, sr[k].SubstLookupRecord,
+			    buffer,
+			    nesting_level );
+  next_subrule:
+    ;
+  }
+
+  return HB_Err_Not_Covered;
+}
+
+
+static HB_Error  Lookup_ContextSubst2( HB_GSUBHeader*          gsub,
+				       HB_ContextSubstFormat2* csf2,
+				       HB_Buffer               buffer,
+				       HB_UShort                flags,
+				       HB_UShort                context_length,
+				       int                      nesting_level )
+{
+  HB_UShort          index, property;
+  HB_Error           error;
+  HB_UShort          i, j, k, known_classes;
+
+  HB_UShort*         classes;
+  HB_UShort*         cl;
+
+  HB_SubClassSet*   scs;
+  HB_SubClassRule*  sr;
+  HB_GDEFHeader*    gdef;
+
+
+  gdef = gsub->gdef;
+
+  if ( CHECK_Property( gdef, IN_CURITEM(), flags, &property ) )
+    return error;
+
+  /* Note: The coverage table in format 2 doesn't give an index into
+	   anything.  It just lets us know whether or not we need to
+	   do any lookup at all.                                     */
+
+  error = _HB_OPEN_Coverage_Index( &csf2->Coverage, IN_CURGLYPH(), &index );
+  if ( error )
+    return error;
+
+  if (csf2->MaxContextLength < 1)
+    return HB_Err_Not_Covered;
+
+  if ( ALLOC_ARRAY( classes, csf2->MaxContextLength, HB_UShort ) )
+    return error;
+
+  error = _HB_OPEN_Get_Class( &csf2->ClassDef, IN_CURGLYPH(),
+		     &classes[0], NULL );
+  if ( error && error != HB_Err_Not_Covered )
+    goto End;
+  known_classes = 0;
+
+  scs = &csf2->SubClassSet[classes[0]];
+  if ( !scs )
+  {
+    error = ERR(HB_Err_Invalid_SubTable);
+    goto End;
+  }
+
+  for ( k = 0; k < scs->SubClassRuleCount; k++ )
+  {
+    sr  = &scs->SubClassRule[k];
+
+    if ( context_length != 0xFFFF && context_length < sr->GlyphCount )
+      goto next_subclassrule;
+
+    if ( buffer->in_pos + sr->GlyphCount > buffer->in_length )
+      goto next_subclassrule;                      /* context is too long */
+
+    cl   = sr->Class;
+
+    /* Start at 1 because [0] is implied */
+
+    for ( i = 1, j = buffer->in_pos + 1; i < sr->GlyphCount; i++, j++ )
+    {
+      while ( CHECK_Property( gdef, IN_ITEM( j ), flags, &property ) )
+      {
+	if ( error && error != HB_Err_Not_Covered )
+	  goto End;
+
+	if ( j + sr->GlyphCount - i < (HB_Int)buffer->in_length )
+	  goto next_subclassrule;
+	j++;
+      }
+
+      if ( i > known_classes )
+      {
+	/* Keeps us from having to do this for each rule */
+
+	error = _HB_OPEN_Get_Class( &csf2->ClassDef, IN_GLYPH( j ), &classes[i], NULL );
+	if ( error && error != HB_Err_Not_Covered )
+	  goto End;
+	known_classes = i;
+      }
+
+      if ( cl[i - 1] != classes[i] )
+	goto next_subclassrule;
+    }
+
+    error = Do_ContextSubst( gsub, sr->GlyphCount,
+			     sr->SubstCount, sr->SubstLookupRecord,
+			     buffer,
+			     nesting_level );
+    goto End;
+
+  next_subclassrule:
+    ;
+  }
+
+  error = HB_Err_Not_Covered;
+
+End:
+  FREE( classes );
+  return error;
+}
+
+
+static HB_Error  Lookup_ContextSubst3( HB_GSUBHeader*          gsub,
+				       HB_ContextSubstFormat3* csf3,
+				       HB_Buffer               buffer,
+				       HB_UShort                flags,
+				       HB_UShort                context_length,
+				       int                      nesting_level )
+{
+  HB_Error         error;
+  HB_UShort        index, i, j, property;
+
+  HB_Coverage*    c;
+  HB_GDEFHeader*  gdef;
+
+
+  gdef = gsub->gdef;
+
+  if ( CHECK_Property( gdef, IN_CURITEM(), flags, &property ) )
+    return error;
+
+  if ( context_length != 0xFFFF && context_length < csf3->GlyphCount )
+    return HB_Err_Not_Covered;
+
+  if ( buffer->in_pos + csf3->GlyphCount > buffer->in_length )
+    return HB_Err_Not_Covered;         /* context is too long */
+
+  c    = csf3->Coverage;
+
+  for ( i = 1, j = buffer->in_pos + 1; i < csf3->GlyphCount; i++, j++ )
+  {
+    while ( CHECK_Property( gdef, IN_ITEM( j ), flags, &property ) )
+    {
+      if ( error && error != HB_Err_Not_Covered )
+	return error;
+
+      if ( j + csf3->GlyphCount - i == (HB_Int)buffer->in_length )
+	return HB_Err_Not_Covered;
+      j++;
+    }
+
+    error = _HB_OPEN_Coverage_Index( &c[i], IN_GLYPH( j ), &index );
+    if ( error )
+      return error;
+  }
+
+  return Do_ContextSubst( gsub, csf3->GlyphCount,
+			  csf3->SubstCount, csf3->SubstLookupRecord,
+			  buffer,
+			  nesting_level );
+}
+
+
+static HB_Error  Lookup_ContextSubst( HB_GSUBHeader*    gsub,
+				      HB_GSUB_SubTable* st,
+				      HB_Buffer         buffer,
+				      HB_UShort          flags,
+				      HB_UShort          context_length,
+				      int                nesting_level )
+{
+  HB_ContextSubst*  cs = &st->context;
+
+  switch ( cs->SubstFormat )
+  {
+  case 1:  return Lookup_ContextSubst1( gsub, &cs->csf.csf1, buffer, flags, context_length, nesting_level );
+  case 2:  return Lookup_ContextSubst2( gsub, &cs->csf.csf2, buffer, flags, context_length, nesting_level );
+  case 3:  return Lookup_ContextSubst3( gsub, &cs->csf.csf3, buffer, flags, context_length, nesting_level );
+  default: return ERR(HB_Err_Invalid_SubTable_Format);
+  }
+
+  return HB_Err_Ok;               /* never reached */
+}
+
+
+/* LookupType 6 */
+
+/* ChainSubRule */
+
+static HB_Error  Load_ChainSubRule( HB_ChainSubRule*  csr,
+				    HB_Stream          stream )
+{
+  HB_Error error;
+
+  HB_UShort               n, count;
+  HB_UShort*              b;
+  HB_UShort*              i;
+  HB_UShort*              l;
+
+  HB_SubstLookupRecord*  slr;
+
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  csr->BacktrackGlyphCount = GET_UShort();
+
+  FORGET_Frame();
+
+  csr->Backtrack = NULL;
+
+  count = csr->BacktrackGlyphCount;
+
+  if ( ALLOC_ARRAY( csr->Backtrack, count, HB_UShort ) )
+    return error;
+
+  b = csr->Backtrack;
+
+  if ( ACCESS_Frame( count * 2L ) )
+    goto Fail4;
+
+  for ( n = 0; n < count; n++ )
+    b[n] = GET_UShort();
+
+  FORGET_Frame();
+
+  if ( ACCESS_Frame( 2L ) )
+    goto Fail4;
+
+  csr->InputGlyphCount = GET_UShort();
+
+  FORGET_Frame();
+
+  csr->Input = NULL;
+
+  count = csr->InputGlyphCount - 1;  /* only InputGlyphCount - 1 elements */
+
+  if ( ALLOC_ARRAY( csr->Input, count, HB_UShort ) )
+    goto Fail4;
+
+  i = csr->Input;
+
+  if ( ACCESS_Frame( count * 2L ) )
+    goto Fail3;
+
+  for ( n = 0; n < count; n++ )
+    i[n] = GET_UShort();
+
+  FORGET_Frame();
+
+  if ( ACCESS_Frame( 2L ) )
+    goto Fail3;
+
+  csr->LookaheadGlyphCount = GET_UShort();
+
+  FORGET_Frame();
+
+  csr->Lookahead = NULL;
+
+  count = csr->LookaheadGlyphCount;
+
+  if ( ALLOC_ARRAY( csr->Lookahead, count, HB_UShort ) )
+    goto Fail3;
+
+  l = csr->Lookahead;
+
+  if ( ACCESS_Frame( count * 2L ) )
+    goto Fail2;
+
+  for ( n = 0; n < count; n++ )
+    l[n] = GET_UShort();
+
+  FORGET_Frame();
+
+  if ( ACCESS_Frame( 2L ) )
+    goto Fail2;
+
+  csr->SubstCount = GET_UShort();
+
+  FORGET_Frame();
+
+  csr->SubstLookupRecord = NULL;
+
+  count = csr->SubstCount;
+
+  if ( ALLOC_ARRAY( csr->SubstLookupRecord, count, HB_SubstLookupRecord ) )
+    goto Fail2;
+
+  slr = csr->SubstLookupRecord;
+
+  if ( ACCESS_Frame( count * 4L ) )
+    goto Fail1;
+
+  for ( n = 0; n < count; n++ )
+  {
+    slr[n].SequenceIndex   = GET_UShort();
+    slr[n].LookupListIndex = GET_UShort();
+  }
+
+  FORGET_Frame();
+
+  return HB_Err_Ok;
+
+Fail1:
+  FREE( slr );
+
+Fail2:
+  FREE( l );
+
+Fail3:
+  FREE( i );
+
+Fail4:
+  FREE( b );
+  return error;
+}
+
+
+static void  Free_ChainSubRule( HB_ChainSubRule*  csr )
+{
+  FREE( csr->SubstLookupRecord );
+  FREE( csr->Lookahead );
+  FREE( csr->Input );
+  FREE( csr->Backtrack );
+}
+
+
+/* ChainSubRuleSet */
+
+static HB_Error  Load_ChainSubRuleSet( HB_ChainSubRuleSet*  csrs,
+				       HB_Stream             stream )
+{
+  HB_Error error;
+
+  HB_UShort          n = 0, m, count;
+  HB_UInt           cur_offset, new_offset, base_offset;
+
+  HB_ChainSubRule*  csr;
+
+
+  base_offset = FILE_Pos();
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  count = csrs->ChainSubRuleCount = GET_UShort();
+
+  FORGET_Frame();
+
+  csrs->ChainSubRule = NULL;
+
+  if ( ALLOC_ARRAY( csrs->ChainSubRule, count, HB_ChainSubRule ) )
+    return error;
+
+  csr = csrs->ChainSubRule;
+
+  for ( n = 0; n < count; n++ )
+  {
+    if ( ACCESS_Frame( 2L ) )
+      goto Fail;
+
+    new_offset = GET_UShort() + base_offset;
+
+    FORGET_Frame();
+
+    cur_offset = FILE_Pos();
+    if ( FILE_Seek( new_offset ) ||
+	 ( error = Load_ChainSubRule( &csr[n], stream ) ) != HB_Err_Ok )
+      goto Fail;
+    (void)FILE_Seek( cur_offset );
+  }
+
+  return HB_Err_Ok;
+
+Fail:
+  for ( m = 0; m < n; m++ )
+    Free_ChainSubRule( &csr[m] );
+
+  FREE( csr );
+  return error;
+}
+
+
+static void  Free_ChainSubRuleSet( HB_ChainSubRuleSet*  csrs )
+{
+  HB_UShort          n, count;
+
+  HB_ChainSubRule*  csr;
+
+
+  if ( csrs->ChainSubRule )
+  {
+    count = csrs->ChainSubRuleCount;
+    csr   = csrs->ChainSubRule;
+
+    for ( n = 0; n < count; n++ )
+      Free_ChainSubRule( &csr[n] );
+
+    FREE( csr );
+  }
+}
+
+
+/* ChainContextSubstFormat1 */
+
+static HB_Error  Load_ChainContextSubst1(
+		   HB_ChainContextSubstFormat1*  ccsf1,
+		   HB_Stream                      stream )
+{
+  HB_Error error;
+
+  HB_UShort             n = 0, m, count;
+  HB_UInt              cur_offset, new_offset, base_offset;
+
+  HB_ChainSubRuleSet*  csrs;
+
+
+  base_offset = FILE_Pos() - 2L;
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  new_offset = GET_UShort() + base_offset;
+
+  FORGET_Frame();
+
+  cur_offset = FILE_Pos();
+  if ( FILE_Seek( new_offset ) ||
+       ( error = _HB_OPEN_Load_Coverage( &ccsf1->Coverage, stream ) ) != HB_Err_Ok )
+    return error;
+  (void)FILE_Seek( cur_offset );
+
+  if ( ACCESS_Frame( 2L ) )
+    goto Fail2;
+
+  count = ccsf1->ChainSubRuleSetCount = GET_UShort();
+
+  FORGET_Frame();
+
+  ccsf1->ChainSubRuleSet = NULL;
+
+  if ( ALLOC_ARRAY( ccsf1->ChainSubRuleSet, count, HB_ChainSubRuleSet ) )
+    goto Fail2;
+
+  csrs = ccsf1->ChainSubRuleSet;
+
+  for ( n = 0; n < count; n++ )
+  {
+    if ( ACCESS_Frame( 2L ) )
+      goto Fail1;
+
+    new_offset = GET_UShort() + base_offset;
+
+    FORGET_Frame();
+
+    cur_offset = FILE_Pos();
+    if ( FILE_Seek( new_offset ) ||
+	 ( error = Load_ChainSubRuleSet( &csrs[n], stream ) ) != HB_Err_Ok )
+      goto Fail1;
+    (void)FILE_Seek( cur_offset );
+  }
+
+  return HB_Err_Ok;
+
+Fail1:
+  for ( m = 0; m < n; m++ )
+    Free_ChainSubRuleSet( &csrs[m] );
+
+  FREE( csrs );
+
+Fail2:
+  _HB_OPEN_Free_Coverage( &ccsf1->Coverage );
+  return error;
+}
+
+
+static void  Free_ChainContextSubst1( HB_ChainContextSubstFormat1*  ccsf1 )
+{
+  HB_UShort             n, count;
+
+  HB_ChainSubRuleSet*  csrs;
+
+
+  if ( ccsf1->ChainSubRuleSet )
+  {
+    count = ccsf1->ChainSubRuleSetCount;
+    csrs  = ccsf1->ChainSubRuleSet;
+
+    for ( n = 0; n < count; n++ )
+      Free_ChainSubRuleSet( &csrs[n] );
+
+    FREE( csrs );
+  }
+
+  _HB_OPEN_Free_Coverage( &ccsf1->Coverage );
+}
+
+
+/* ChainSubClassRule */
+
+static HB_Error  Load_ChainSubClassRule(
+		   HB_ChainContextSubstFormat2*  ccsf2,
+		   HB_ChainSubClassRule*         cscr,
+		   HB_Stream                      stream )
+{
+  HB_Error error;
+
+  HB_UShort               n, count;
+
+  HB_UShort*              b;
+  HB_UShort*              i;
+  HB_UShort*              l;
+  HB_SubstLookupRecord*  slr;
+
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  cscr->BacktrackGlyphCount = GET_UShort();
+
+  FORGET_Frame();
+
+  if ( cscr->BacktrackGlyphCount > ccsf2->MaxBacktrackLength )
+    ccsf2->MaxBacktrackLength = cscr->BacktrackGlyphCount;
+
+  cscr->Backtrack = NULL;
+
+  count = cscr->BacktrackGlyphCount;
+
+  if ( ALLOC_ARRAY( cscr->Backtrack, count, HB_UShort ) )
+    return error;
+
+  b = cscr->Backtrack;
+
+  if ( ACCESS_Frame( count * 2L ) )
+    goto Fail4;
+
+  for ( n = 0; n < count; n++ )
+    b[n] = GET_UShort();
+
+  FORGET_Frame();
+
+  if ( ACCESS_Frame( 2L ) )
+    goto Fail4;
+
+  cscr->InputGlyphCount = GET_UShort();
+
+  FORGET_Frame();
+
+  if ( cscr->InputGlyphCount > ccsf2->MaxInputLength )
+    ccsf2->MaxInputLength = cscr->InputGlyphCount;
+
+  cscr->Input = NULL;
+
+  count = cscr->InputGlyphCount - 1; /* only InputGlyphCount - 1 elements */
+
+  if ( ALLOC_ARRAY( cscr->Input, count, HB_UShort ) )
+    goto Fail4;
+
+  i = cscr->Input;
+
+  if ( ACCESS_Frame( count * 2L ) )
+    goto Fail3;
+
+  for ( n = 0; n < count; n++ )
+    i[n] = GET_UShort();
+
+  FORGET_Frame();
+
+  if ( ACCESS_Frame( 2L ) )
+    goto Fail3;
+
+  cscr->LookaheadGlyphCount = GET_UShort();
+
+  FORGET_Frame();
+
+  if ( cscr->LookaheadGlyphCount > ccsf2->MaxLookaheadLength )
+    ccsf2->MaxLookaheadLength = cscr->LookaheadGlyphCount;
+
+  cscr->Lookahead = NULL;
+
+  count = cscr->LookaheadGlyphCount;
+
+  if ( ALLOC_ARRAY( cscr->Lookahead, count, HB_UShort ) )
+    goto Fail3;
+
+  l = cscr->Lookahead;
+
+  if ( ACCESS_Frame( count * 2L ) )
+    goto Fail2;
+
+  for ( n = 0; n < count; n++ )
+    l[n] = GET_UShort();
+
+  FORGET_Frame();
+
+  if ( ACCESS_Frame( 2L ) )
+    goto Fail2;
+
+  cscr->SubstCount = GET_UShort();
+
+  FORGET_Frame();
+
+  cscr->SubstLookupRecord = NULL;
+
+  count = cscr->SubstCount;
+
+  if ( ALLOC_ARRAY( cscr->SubstLookupRecord, count,
+		    HB_SubstLookupRecord ) )
+    goto Fail2;
+
+  slr = cscr->SubstLookupRecord;
+
+  if ( ACCESS_Frame( count * 4L ) )
+    goto Fail1;
+
+  for ( n = 0; n < count; n++ )
+  {
+    slr[n].SequenceIndex   = GET_UShort();
+    slr[n].LookupListIndex = GET_UShort();
+  }
+
+  FORGET_Frame();
+
+  return HB_Err_Ok;
+
+Fail1:
+  FREE( slr );
+
+Fail2:
+  FREE( l );
+
+Fail3:
+  FREE( i );
+
+Fail4:
+  FREE( b );
+  return error;
+}
+
+
+static void  Free_ChainSubClassRule( HB_ChainSubClassRule*  cscr )
+{
+  FREE( cscr->SubstLookupRecord );
+  FREE( cscr->Lookahead );
+  FREE( cscr->Input );
+  FREE( cscr->Backtrack );
+}
+
+
+/* SubClassSet */
+
+static HB_Error  Load_ChainSubClassSet(
+		   HB_ChainContextSubstFormat2*  ccsf2,
+		   HB_ChainSubClassSet*          cscs,
+		   HB_Stream                      stream )
+{
+  HB_Error error;
+
+  HB_UShort               n = 0, m, count;
+  HB_UInt                cur_offset, new_offset, base_offset;
+
+  HB_ChainSubClassRule*  cscr;
+
+
+  base_offset = FILE_Pos();
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  count = cscs->ChainSubClassRuleCount = GET_UShort();
+
+  FORGET_Frame();
+
+  cscs->ChainSubClassRule = NULL;
+
+  if ( ALLOC_ARRAY( cscs->ChainSubClassRule, count,
+		    HB_ChainSubClassRule ) )
+    return error;
+
+  cscr = cscs->ChainSubClassRule;
+
+  for ( n = 0; n < count; n++ )
+  {
+    if ( ACCESS_Frame( 2L ) )
+      goto Fail;
+
+    new_offset = GET_UShort() + base_offset;
+
+    FORGET_Frame();
+
+    cur_offset = FILE_Pos();
+    if ( FILE_Seek( new_offset ) ||
+	 ( error = Load_ChainSubClassRule( ccsf2, &cscr[n],
+					   stream ) ) != HB_Err_Ok )
+      goto Fail;
+    (void)FILE_Seek( cur_offset );
+  }
+
+  return HB_Err_Ok;
+
+Fail:
+  for ( m = 0; m < n; m++ )
+    Free_ChainSubClassRule( &cscr[m] );
+
+  FREE( cscr );
+  return error;
+}
+
+
+static void  Free_ChainSubClassSet( HB_ChainSubClassSet*  cscs )
+{
+  HB_UShort               n, count;
+
+  HB_ChainSubClassRule*  cscr;
+
+
+  if ( cscs->ChainSubClassRule )
+  {
+    count = cscs->ChainSubClassRuleCount;
+    cscr  = cscs->ChainSubClassRule;
+
+    for ( n = 0; n < count; n++ )
+      Free_ChainSubClassRule( &cscr[n] );
+
+    FREE( cscr );
+  }
+}
+
+
+/* ChainContextSubstFormat2 */
+
+static HB_Error  Load_ChainContextSubst2(
+		   HB_ChainContextSubstFormat2*  ccsf2,
+		   HB_Stream                      stream )
+{
+  HB_Error error;
+
+  HB_UShort              n = 0, m, count;
+  HB_UInt               cur_offset, new_offset, base_offset;
+  HB_UInt               backtrack_offset, input_offset, lookahead_offset;
+
+  HB_ChainSubClassSet*  cscs;
+
+
+  base_offset = FILE_Pos() - 2;
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  new_offset = GET_UShort() + base_offset;
+
+  FORGET_Frame();
+
+  cur_offset = FILE_Pos();
+  if ( FILE_Seek( new_offset ) ||
+       ( error = _HB_OPEN_Load_Coverage( &ccsf2->Coverage, stream ) ) != HB_Err_Ok )
+    return error;
+  (void)FILE_Seek( cur_offset );
+
+  if ( ACCESS_Frame( 8L ) )
+    goto Fail5;
+
+  backtrack_offset = GET_UShort();
+  input_offset     = GET_UShort();
+  lookahead_offset = GET_UShort();
+
+  /* `ChainSubClassSetCount' is the upper limit for input class values,
+     thus we read it now to make an additional safety check. No limit
+     is known or needed for the other two class definitions          */
+
+  count = ccsf2->ChainSubClassSetCount = GET_UShort();
+
+  FORGET_Frame();
+
+  if ( ( error = _HB_OPEN_Load_EmptyOrClassDefinition( &ccsf2->BacktrackClassDef, 65535,
+						       backtrack_offset, base_offset,
+						       stream ) ) != HB_Err_Ok )
+      goto Fail5;
+
+  if ( ( error = _HB_OPEN_Load_EmptyOrClassDefinition( &ccsf2->InputClassDef, count,
+						       input_offset, base_offset,
+						       stream ) ) != HB_Err_Ok )
+      goto Fail4;
+  if ( ( error = _HB_OPEN_Load_EmptyOrClassDefinition( &ccsf2->LookaheadClassDef, 65535,
+						       lookahead_offset, base_offset,
+						       stream ) ) != HB_Err_Ok )
+    goto Fail3;
+
+  ccsf2->ChainSubClassSet   = NULL;
+  ccsf2->MaxBacktrackLength = 0;
+  ccsf2->MaxInputLength     = 0;
+  ccsf2->MaxLookaheadLength = 0;
+
+  if ( ALLOC_ARRAY( ccsf2->ChainSubClassSet, count, HB_ChainSubClassSet ) )
+    goto Fail2;
+
+  cscs = ccsf2->ChainSubClassSet;
+
+  for ( n = 0; n < count; n++ )
+  {
+    if ( ACCESS_Frame( 2L ) )
+      goto Fail1;
+
+    new_offset = GET_UShort() + base_offset;
+
+    FORGET_Frame();
+
+    if ( new_offset != base_offset )      /* not a NULL offset */
+    {
+      cur_offset = FILE_Pos();
+      if ( FILE_Seek( new_offset ) ||
+	   ( error = Load_ChainSubClassSet( ccsf2, &cscs[n],
+					    stream ) ) != HB_Err_Ok )
+	goto Fail1;
+      (void)FILE_Seek( cur_offset );
+    }
+    else
+    {
+      /* we create a ChainSubClassSet table with no entries */
+
+      ccsf2->ChainSubClassSet[n].ChainSubClassRuleCount = 0;
+      ccsf2->ChainSubClassSet[n].ChainSubClassRule      = NULL;
+    }
+  }
+
+  return HB_Err_Ok;
+
+Fail1:
+  for ( m = 0; m < n; m++ )
+    Free_ChainSubClassSet( &cscs[m] );
+
+  FREE( cscs );
+
+Fail2:
+  _HB_OPEN_Free_ClassDefinition( &ccsf2->LookaheadClassDef );
+
+Fail3:
+  _HB_OPEN_Free_ClassDefinition( &ccsf2->InputClassDef );
+
+Fail4:
+  _HB_OPEN_Free_ClassDefinition( &ccsf2->BacktrackClassDef );
+
+Fail5:
+  _HB_OPEN_Free_Coverage( &ccsf2->Coverage );
+  return error;
+}
+
+
+static void  Free_ChainContextSubst2( HB_ChainContextSubstFormat2*  ccsf2 )
+{
+  HB_UShort              n, count;
+
+  HB_ChainSubClassSet*  cscs;
+
+
+  if ( ccsf2->ChainSubClassSet )
+  {
+    count = ccsf2->ChainSubClassSetCount;
+    cscs  = ccsf2->ChainSubClassSet;
+
+    for ( n = 0; n < count; n++ )
+      Free_ChainSubClassSet( &cscs[n] );
+
+    FREE( cscs );
+  }
+
+  _HB_OPEN_Free_ClassDefinition( &ccsf2->LookaheadClassDef );
+  _HB_OPEN_Free_ClassDefinition( &ccsf2->InputClassDef );
+  _HB_OPEN_Free_ClassDefinition( &ccsf2->BacktrackClassDef );
+
+  _HB_OPEN_Free_Coverage( &ccsf2->Coverage );
+}
+
+
+/* ChainContextSubstFormat3 */
+
+static HB_Error  Load_ChainContextSubst3(
+		   HB_ChainContextSubstFormat3*  ccsf3,
+		   HB_Stream                      stream )
+{
+  HB_Error error;
+
+  HB_UShort               n, nb = 0, ni =0, nl = 0, m, count;
+  HB_UShort               backtrack_count, input_count, lookahead_count;
+  HB_UInt                cur_offset, new_offset, base_offset;
+
+  HB_Coverage*           b;
+  HB_Coverage*           i;
+  HB_Coverage*           l;
+  HB_SubstLookupRecord*  slr;
+
+
+  base_offset = FILE_Pos() - 2L;
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  ccsf3->BacktrackGlyphCount = GET_UShort();
+
+  FORGET_Frame();
+
+  ccsf3->BacktrackCoverage = NULL;
+
+  backtrack_count = ccsf3->BacktrackGlyphCount;
+
+  if ( ALLOC_ARRAY( ccsf3->BacktrackCoverage, backtrack_count,
+		    HB_Coverage ) )
+    return error;
+
+  b = ccsf3->BacktrackCoverage;
+
+  for ( nb = 0; nb < backtrack_count; nb++ )
+  {
+    if ( ACCESS_Frame( 2L ) )
+      goto Fail4;
+
+    new_offset = GET_UShort() + base_offset;
+
+    FORGET_Frame();
+
+    cur_offset = FILE_Pos();
+    if ( FILE_Seek( new_offset ) ||
+	 ( error = _HB_OPEN_Load_Coverage( &b[nb], stream ) ) != HB_Err_Ok )
+      goto Fail4;
+    (void)FILE_Seek( cur_offset );
+  }
+
+  if ( ACCESS_Frame( 2L ) )
+    goto Fail4;
+
+  ccsf3->InputGlyphCount = GET_UShort();
+
+  FORGET_Frame();
+
+  ccsf3->InputCoverage = NULL;
+
+  input_count = ccsf3->InputGlyphCount;
+
+  if ( ALLOC_ARRAY( ccsf3->InputCoverage, input_count, HB_Coverage ) )
+    goto Fail4;
+
+  i = ccsf3->InputCoverage;
+
+  for ( ni = 0; ni < input_count; ni++ )
+  {
+    if ( ACCESS_Frame( 2L ) )
+      goto Fail3;
+
+    new_offset = GET_UShort() + base_offset;
+
+    FORGET_Frame();
+
+    cur_offset = FILE_Pos();
+    if ( FILE_Seek( new_offset ) ||
+	 ( error = _HB_OPEN_Load_Coverage( &i[ni], stream ) ) != HB_Err_Ok )
+      goto Fail3;
+    (void)FILE_Seek( cur_offset );
+  }
+
+  if ( ACCESS_Frame( 2L ) )
+    goto Fail3;
+
+  ccsf3->LookaheadGlyphCount = GET_UShort();
+
+  FORGET_Frame();
+
+  ccsf3->LookaheadCoverage = NULL;
+
+  lookahead_count = ccsf3->LookaheadGlyphCount;
+
+  if ( ALLOC_ARRAY( ccsf3->LookaheadCoverage, lookahead_count,
+		    HB_Coverage ) )
+    goto Fail3;
+
+  l = ccsf3->LookaheadCoverage;
+
+  for ( nl = 0; nl < lookahead_count; nl++ )
+  {
+    if ( ACCESS_Frame( 2L ) )
+      goto Fail2;
+
+    new_offset = GET_UShort() + base_offset;
+
+    FORGET_Frame();
+
+    cur_offset = FILE_Pos();
+    if ( FILE_Seek( new_offset ) ||
+	 ( error = _HB_OPEN_Load_Coverage( &l[nl], stream ) ) != HB_Err_Ok )
+      goto Fail2;
+    (void)FILE_Seek( cur_offset );
+  }
+
+  if ( ACCESS_Frame( 2L ) )
+    goto Fail2;
+
+  ccsf3->SubstCount = GET_UShort();
+
+  FORGET_Frame();
+
+  ccsf3->SubstLookupRecord = NULL;
+
+  count = ccsf3->SubstCount;
+
+  if ( ALLOC_ARRAY( ccsf3->SubstLookupRecord, count,
+		    HB_SubstLookupRecord ) )
+    goto Fail2;
+
+  slr = ccsf3->SubstLookupRecord;
+
+  if ( ACCESS_Frame( count * 4L ) )
+    goto Fail1;
+
+  for ( n = 0; n < count; n++ )
+  {
+    slr[n].SequenceIndex   = GET_UShort();
+    slr[n].LookupListIndex = GET_UShort();
+  }
+
+  FORGET_Frame();
+
+  return HB_Err_Ok;
+
+Fail1:
+  FREE( slr );
+
+Fail2:
+  for ( m = 0; m < nl; m++ )
+    _HB_OPEN_Free_Coverage( &l[m] );
+
+  FREE( l );
+
+Fail3:
+  for ( m = 0; m < ni; m++ )
+    _HB_OPEN_Free_Coverage( &i[m] );
+
+  FREE( i );
+
+Fail4:
+  for ( m = 0; m < nb; m++ )
+    _HB_OPEN_Free_Coverage( &b[m] );
+
+  FREE( b );
+  return error;
+}
+
+
+static void  Free_ChainContextSubst3( HB_ChainContextSubstFormat3*  ccsf3 )
+{
+  HB_UShort      n, count;
+
+  HB_Coverage*  c;
+
+
+  FREE( ccsf3->SubstLookupRecord );
+
+  if ( ccsf3->LookaheadCoverage )
+  {
+    count = ccsf3->LookaheadGlyphCount;
+    c     = ccsf3->LookaheadCoverage;
+
+    for ( n = 0; n < count; n++ )
+      _HB_OPEN_Free_Coverage( &c[n] );
+
+    FREE( c );
+  }
+
+  if ( ccsf3->InputCoverage )
+  {
+    count = ccsf3->InputGlyphCount;
+    c     = ccsf3->InputCoverage;
+
+    for ( n = 0; n < count; n++ )
+      _HB_OPEN_Free_Coverage( &c[n] );
+
+    FREE( c );
+  }
+
+  if ( ccsf3->BacktrackCoverage )
+  {
+    count = ccsf3->BacktrackGlyphCount;
+    c     = ccsf3->BacktrackCoverage;
+
+    for ( n = 0; n < count; n++ )
+      _HB_OPEN_Free_Coverage( &c[n] );
+
+    FREE( c );
+  }
+}
+
+
+/* ChainContextSubst */
+
+static HB_Error  Load_ChainContextSubst( HB_GSUB_SubTable* st,
+					 HB_Stream         stream )
+{
+  HB_Error error;
+  HB_ChainContextSubst*  ccs = &st->chain;
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  ccs->SubstFormat = GET_UShort();
+
+  FORGET_Frame();
+
+  switch ( ccs->SubstFormat ) {
+    case 1:  return Load_ChainContextSubst1( &ccs->ccsf.ccsf1, stream );
+    case 2:  return Load_ChainContextSubst2( &ccs->ccsf.ccsf2, stream );
+    case 3:  return Load_ChainContextSubst3( &ccs->ccsf.ccsf3, stream );
+    default: return ERR(HB_Err_Invalid_SubTable_Format);
+  }
+
+  return HB_Err_Ok;               /* never reached */
+}
+
+
+static void  Free_ChainContextSubst( HB_GSUB_SubTable* st )
+{
+  HB_ChainContextSubst*  ccs = &st->chain;
+
+  switch ( ccs->SubstFormat ) {
+    case 1:  Free_ChainContextSubst1( &ccs->ccsf.ccsf1 ); break;
+    case 2:  Free_ChainContextSubst2( &ccs->ccsf.ccsf2 ); break;
+    case 3:  Free_ChainContextSubst3( &ccs->ccsf.ccsf3 ); break;
+    default:							  break;
+  }
+}
+
+
+static HB_Error  Lookup_ChainContextSubst1( HB_GSUBHeader*               gsub,
+					    HB_ChainContextSubstFormat1* ccsf1,
+					    HB_Buffer                    buffer,
+					    HB_UShort                     flags,
+					    HB_UShort                     context_length,
+					    int                           nesting_level )
+{
+  HB_UShort          index, property;
+  HB_UShort          i, j, k, num_csr;
+  HB_UShort          bgc, igc, lgc;
+  HB_Error           error;
+
+  HB_ChainSubRule*  csr;
+  HB_ChainSubRule   curr_csr;
+  HB_GDEFHeader*    gdef;
+
+
+  gdef = gsub->gdef;
+
+  if ( CHECK_Property( gdef, IN_CURITEM(), flags, &property ) )
+    return error;
+
+  error = _HB_OPEN_Coverage_Index( &ccsf1->Coverage, IN_CURGLYPH(), &index );
+  if ( error )
+    return error;
+
+  csr     = ccsf1->ChainSubRuleSet[index].ChainSubRule;
+  num_csr = ccsf1->ChainSubRuleSet[index].ChainSubRuleCount;
+
+  for ( k = 0; k < num_csr; k++ )
+  {
+    curr_csr = csr[k];
+    bgc      = curr_csr.BacktrackGlyphCount;
+    igc      = curr_csr.InputGlyphCount;
+    lgc      = curr_csr.LookaheadGlyphCount;
+
+    if ( context_length != 0xFFFF && context_length < igc )
+      goto next_chainsubrule;
+
+    /* check whether context is too long; it is a first guess only */
+
+    if ( bgc > buffer->out_pos || buffer->in_pos + igc + lgc > buffer->in_length )
+      goto next_chainsubrule;
+
+    if ( bgc )
+    {
+      /* since we don't know in advance the number of glyphs to inspect,
+	 we search backwards for matches in the backtrack glyph array    */
+
+      for ( i = 0, j = buffer->out_pos - 1; i < bgc; i++, j-- )
+      {
+	while ( CHECK_Property( gdef, OUT_ITEM( j ), flags, &property ) )
+	{
+	  if ( error && error != HB_Err_Not_Covered )
+	    return error;
+
+	  if ( j + 1 == bgc - i )
+	    goto next_chainsubrule;
+	  j--;
+	}
+
+	/* In OpenType 1.3, it is undefined whether the offsets of
+	   backtrack glyphs is in logical order or not.  Version 1.4
+	   will clarify this:
+
+	     Logical order -      a  b  c  d  e  f  g  h  i  j
+					      i
+	     Input offsets -                  0  1
+	     Backtrack offsets -  3  2  1  0
+	     Lookahead offsets -                    0  1  2  3           */
+
+	if ( OUT_GLYPH( j ) != curr_csr.Backtrack[i] )
+	  goto next_chainsubrule;
+      }
+    }
+
+    /* Start at 1 because [0] is implied */
+
+    for ( i = 1, j = buffer->in_pos + 1; i < igc; i++, j++ )
+    {
+      while ( CHECK_Property( gdef, IN_ITEM( j ), flags, &property ) )
+      {
+	if ( error && error != HB_Err_Not_Covered )
+	  return error;
+
+	if ( j + igc - i + lgc == (HB_Int)buffer->in_length )
+	  goto next_chainsubrule;
+	j++;
+      }
+
+      if ( IN_GLYPH( j ) != curr_csr.Input[i - 1] )
+	  goto next_chainsubrule;
+    }
+
+    /* we are starting to check for lookahead glyphs right after the
+       last context glyph                                            */
+
+    for ( i = 0; i < lgc; i++, j++ )
+    {
+      while ( CHECK_Property( gdef, IN_ITEM( j ), flags, &property ) )
+      {
+	if ( error && error != HB_Err_Not_Covered )
+	  return error;
+
+	if ( j + lgc - i == (HB_Int)buffer->in_length )
+	  goto next_chainsubrule;
+	j++;
+      }
+
+      if ( IN_GLYPH( j ) != curr_csr.Lookahead[i] )
+	goto next_chainsubrule;
+    }
+
+    return Do_ContextSubst( gsub, igc,
+			    curr_csr.SubstCount,
+			    curr_csr.SubstLookupRecord,
+			    buffer,
+			    nesting_level );
+
+  next_chainsubrule:
+    ;
+  }
+
+  return HB_Err_Not_Covered;
+}
+
+
+static HB_Error  Lookup_ChainContextSubst2( HB_GSUBHeader*               gsub,
+					    HB_ChainContextSubstFormat2* ccsf2,
+					    HB_Buffer                    buffer,
+					    HB_UShort                     flags,
+					    HB_UShort                     context_length,
+					    int                           nesting_level )
+{
+  HB_UShort              index, property;
+  HB_Error               error;
+  HB_UShort              i, j, k;
+  HB_UShort              bgc, igc, lgc;
+  HB_UShort              known_backtrack_classes,
+			 known_input_classes,
+			 known_lookahead_classes;
+
+  HB_UShort*             backtrack_classes;
+  HB_UShort*             input_classes;
+  HB_UShort*             lookahead_classes;
+
+  HB_UShort*             bc;
+  HB_UShort*             ic;
+  HB_UShort*             lc;
+
+  HB_ChainSubClassSet*  cscs;
+  HB_ChainSubClassRule  ccsr;
+  HB_GDEFHeader*        gdef;
+
+
+  gdef = gsub->gdef;
+
+  if ( CHECK_Property( gdef, IN_CURITEM(), flags, &property ) )
+    return error;
+
+  /* Note: The coverage table in format 2 doesn't give an index into
+	   anything.  It just lets us know whether or not we need to
+	   do any lookup at all.                                     */
+
+  error = _HB_OPEN_Coverage_Index( &ccsf2->Coverage, IN_CURGLYPH(), &index );
+  if ( error )
+    return error;
+
+  if ( ALLOC_ARRAY( backtrack_classes, ccsf2->MaxBacktrackLength, HB_UShort ) )
+    return error;
+  known_backtrack_classes = 0;
+
+  if (ccsf2->MaxInputLength < 1)
+    return HB_Err_Not_Covered;
+
+  if ( ALLOC_ARRAY( input_classes, ccsf2->MaxInputLength, HB_UShort ) )
+    goto End3;
+  known_input_classes = 1;
+
+  if ( ALLOC_ARRAY( lookahead_classes, ccsf2->MaxLookaheadLength, HB_UShort ) )
+    goto End2;
+  known_lookahead_classes = 0;
+
+  error = _HB_OPEN_Get_Class( &ccsf2->InputClassDef, IN_CURGLYPH(),
+		     &input_classes[0], NULL );
+  if ( error && error != HB_Err_Not_Covered )
+    goto End1;
+
+  cscs = &ccsf2->ChainSubClassSet[input_classes[0]];
+  if ( !cscs )
+  {
+    error = ERR(HB_Err_Invalid_SubTable);
+    goto End1;
+  }
+
+  for ( k = 0; k < cscs->ChainSubClassRuleCount; k++ )
+  {
+    ccsr = cscs->ChainSubClassRule[k];
+    bgc  = ccsr.BacktrackGlyphCount;
+    igc  = ccsr.InputGlyphCount;
+    lgc  = ccsr.LookaheadGlyphCount;
+
+    if ( context_length != 0xFFFF && context_length < igc )
+      goto next_chainsubclassrule;
+
+    /* check whether context is too long; it is a first guess only */
+
+    if ( bgc > buffer->out_pos || buffer->in_pos + igc + lgc > buffer->in_length )
+      goto next_chainsubclassrule;
+
+    if ( bgc )
+    {
+      /* Since we don't know in advance the number of glyphs to inspect,
+	 we search backwards for matches in the backtrack glyph array.
+	 Note that `known_backtrack_classes' starts at index 0.         */
+
+      bc       = ccsr.Backtrack;
+
+      for ( i = 0, j = buffer->out_pos - 1; i < bgc; i++, j-- )
+      {
+	while ( CHECK_Property( gdef, OUT_ITEM( j ), flags, &property ) )
+	{
+	  if ( error && error != HB_Err_Not_Covered )
+	    goto End1;
+
+	  if ( j + 1 == bgc - i )
+	    goto next_chainsubclassrule;
+	  j--;
+	}
+
+	if ( i >= known_backtrack_classes )
+	{
+	  /* Keeps us from having to do this for each rule */
+
+	  error = _HB_OPEN_Get_Class( &ccsf2->BacktrackClassDef, OUT_GLYPH( j ),
+			     &backtrack_classes[i], NULL );
+	  if ( error && error != HB_Err_Not_Covered )
+	    goto End1;
+	  known_backtrack_classes = i;
+	}
+
+	if ( bc[i] != backtrack_classes[i] )
+	  goto next_chainsubclassrule;
+      }
+    }
+
+    ic       = ccsr.Input;
+
+    /* Start at 1 because [0] is implied */
+
+    for ( i = 1, j = buffer->in_pos + 1; i < igc; i++, j++ )
+    {
+      while ( CHECK_Property( gdef, IN_ITEM( j ), flags, &property ) )
+      {
+	if ( error && error != HB_Err_Not_Covered )
+	  goto End1;
+
+	if ( j + igc - i + lgc == (HB_Int)buffer->in_length )
+	  goto next_chainsubclassrule;
+	j++;
+      }
+
+      if ( i >= known_input_classes )
+      {
+	error = _HB_OPEN_Get_Class( &ccsf2->InputClassDef, IN_GLYPH( j ),
+			   &input_classes[i], NULL );
+	if ( error && error != HB_Err_Not_Covered )
+	  goto End1;
+	known_input_classes = i;
+      }
+
+      if ( ic[i - 1] != input_classes[i] )
+	goto next_chainsubclassrule;
+    }
+
+    /* we are starting to check for lookahead glyphs right after the
+       last context glyph                                            */
+
+    lc       = ccsr.Lookahead;
+
+    for ( i = 0; i < lgc; i++, j++ )
+    {
+      while ( CHECK_Property( gdef, IN_ITEM( j ), flags, &property ) )
+      {
+	if ( error && error != HB_Err_Not_Covered )
+	  goto End1;
+
+	if ( j + lgc - i == (HB_Int)buffer->in_length )
+	  goto next_chainsubclassrule;
+	j++;
+      }
+
+      if ( i >= known_lookahead_classes )
+      {
+	error = _HB_OPEN_Get_Class( &ccsf2->LookaheadClassDef, IN_GLYPH( j ),
+			   &lookahead_classes[i], NULL );
+	if ( error && error != HB_Err_Not_Covered )
+	  goto End1;
+	known_lookahead_classes = i;
+      }
+
+      if ( lc[i] != lookahead_classes[i] )
+	goto next_chainsubclassrule;
+    }
+
+    error = Do_ContextSubst( gsub, igc,
+			     ccsr.SubstCount,
+			     ccsr.SubstLookupRecord,
+			     buffer,
+			     nesting_level );
+    goto End1;
+
+  next_chainsubclassrule:
+    ;
+  }
+
+  error = HB_Err_Not_Covered;
+
+End1:
+  FREE( lookahead_classes );
+
+End2:
+  FREE( input_classes );
+
+End3:
+  FREE( backtrack_classes );
+  return error;
+}
+
+
+static HB_Error  Lookup_ChainContextSubst3( HB_GSUBHeader*               gsub,
+					    HB_ChainContextSubstFormat3* ccsf3,
+					    HB_Buffer                    buffer,
+					    HB_UShort                     flags,
+					    HB_UShort                     context_length,
+					    int                           nesting_level )
+{
+  HB_UShort        index, i, j, property;
+  HB_UShort        bgc, igc, lgc;
+  HB_Error         error;
+
+  HB_Coverage*    bc;
+  HB_Coverage*    ic;
+  HB_Coverage*    lc;
+  HB_GDEFHeader*  gdef;
+
+
+  gdef = gsub->gdef;
+
+  if ( CHECK_Property( gdef, IN_CURITEM(), flags, &property ) )
+    return error;
+
+  bgc = ccsf3->BacktrackGlyphCount;
+  igc = ccsf3->InputGlyphCount;
+  lgc = ccsf3->LookaheadGlyphCount;
+
+  if ( context_length != 0xFFFF && context_length < igc )
+    return HB_Err_Not_Covered;
+
+  /* check whether context is too long; it is a first guess only */
+
+  if ( bgc > buffer->out_pos || buffer->in_pos + igc + lgc > buffer->in_length )
+    return HB_Err_Not_Covered;
+
+  if ( bgc )
+  {
+    /* Since we don't know in advance the number of glyphs to inspect,
+       we search backwards for matches in the backtrack glyph array    */
+
+    bc       = ccsf3->BacktrackCoverage;
+
+    for ( i = 0, j = buffer->out_pos - 1; i < bgc; i++, j-- )
+    {
+      while ( CHECK_Property( gdef, OUT_ITEM( j ), flags, &property ) )
+      {
+	if ( error && error != HB_Err_Not_Covered )
+	  return error;
+
+	if ( j + 1 == bgc - i )
+	  return HB_Err_Not_Covered;
+	j--;
+      }
+
+      error = _HB_OPEN_Coverage_Index( &bc[i], OUT_GLYPH( j ), &index );
+      if ( error )
+	return error;
+    }
+  }
+
+  ic       = ccsf3->InputCoverage;
+
+  for ( i = 0, j = buffer->in_pos; i < igc; i++, j++ )
+  {
+    /* We already called CHECK_Property for IN_GLYPH( buffer->in_pos ) */
+    while ( j > buffer->in_pos && CHECK_Property( gdef, IN_ITEM( j ), flags, &property ) )
+    {
+      if ( error && error != HB_Err_Not_Covered )
+	return error;
+
+      if ( j + igc - i + lgc == (HB_Int)buffer->in_length )
+	return HB_Err_Not_Covered;
+      j++;
+    }
+
+    error = _HB_OPEN_Coverage_Index( &ic[i], IN_GLYPH( j ), &index );
+    if ( error )
+      return error;
+  }
+
+  /* we are starting for lookahead glyphs right after the last context
+     glyph                                                             */
+
+  lc       = ccsf3->LookaheadCoverage;
+
+  for ( i = 0; i < lgc; i++, j++ )
+  {
+    while ( CHECK_Property( gdef, IN_ITEM( j ), flags, &property ) )
+    {
+      if ( error && error != HB_Err_Not_Covered )
+	return error;
+
+      if ( j + lgc - i == (HB_Int)buffer->in_length )
+	return HB_Err_Not_Covered;
+      j++;
+    }
+
+    error = _HB_OPEN_Coverage_Index( &lc[i], IN_GLYPH( j ), &index );
+    if ( error )
+      return error;
+  }
+
+  return Do_ContextSubst( gsub, igc,
+			  ccsf3->SubstCount,
+			  ccsf3->SubstLookupRecord,
+			  buffer,
+			  nesting_level );
+}
+
+
+static HB_Error  Lookup_ChainContextSubst( HB_GSUBHeader*    gsub,
+					   HB_GSUB_SubTable* st,
+					   HB_Buffer         buffer,
+					   HB_UShort          flags,
+					   HB_UShort          context_length,
+					   int                nesting_level )
+{
+  HB_ChainContextSubst*  ccs = &st->chain;
+
+  switch ( ccs->SubstFormat ) {
+    case 1:  return Lookup_ChainContextSubst1( gsub, &ccs->ccsf.ccsf1, buffer, flags, context_length, nesting_level );
+    case 2:  return Lookup_ChainContextSubst2( gsub, &ccs->ccsf.ccsf2, buffer, flags, context_length, nesting_level );
+    case 3:  return Lookup_ChainContextSubst3( gsub, &ccs->ccsf.ccsf3, buffer, flags, context_length, nesting_level );
+    default: return ERR(HB_Err_Invalid_SubTable_Format);
+  }
+}
+
+
+static HB_Error  Load_ReverseChainContextSubst( HB_GSUB_SubTable* st,
+					        HB_Stream         stream )
+{
+  HB_Error error;
+  HB_ReverseChainContextSubst*  rccs = &st->reverse;
+
+  HB_UShort               m, count;
+
+  HB_UShort               nb = 0, nl = 0, n;
+  HB_UShort               backtrack_count, lookahead_count;
+  HB_UInt                cur_offset, new_offset, base_offset;
+
+  HB_Coverage*           b;
+  HB_Coverage*           l;
+  HB_UShort*              sub;
+
+  base_offset = FILE_Pos();
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  rccs->SubstFormat = GET_UShort();
+
+  if ( rccs->SubstFormat != 1 )
+    return ERR(HB_Err_Invalid_SubTable_Format);
+
+  FORGET_Frame();
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  new_offset = GET_UShort() + base_offset;
+
+  FORGET_Frame();
+
+  cur_offset = FILE_Pos();
+  if ( FILE_Seek( new_offset ) ||
+       ( error = _HB_OPEN_Load_Coverage( &rccs->Coverage, stream ) ) != HB_Err_Ok )
+    return error;
+  (void)FILE_Seek( cur_offset );
+
+
+  if ( ACCESS_Frame( 2L ) )
+    goto Fail4;
+
+  rccs->BacktrackGlyphCount = GET_UShort();
+
+  FORGET_Frame();
+
+  rccs->BacktrackCoverage = NULL;
+
+  backtrack_count = rccs->BacktrackGlyphCount;
+
+  if ( ALLOC_ARRAY( rccs->BacktrackCoverage, backtrack_count,
+		    HB_Coverage ) )
+    goto Fail4;
+
+  b = rccs->BacktrackCoverage;
+
+  for ( nb = 0; nb < backtrack_count; nb++ )
+  {
+    if ( ACCESS_Frame( 2L ) )
+      goto Fail3;
+
+    new_offset = GET_UShort() + base_offset;
+
+    FORGET_Frame();
+
+    cur_offset = FILE_Pos();
+    if ( FILE_Seek( new_offset ) ||
+	 ( error = _HB_OPEN_Load_Coverage( &b[nb], stream ) ) != HB_Err_Ok )
+      goto Fail3;
+    (void)FILE_Seek( cur_offset );
+  }
+
+
+  if ( ACCESS_Frame( 2L ) )
+    goto Fail3;
+
+  rccs->LookaheadGlyphCount = GET_UShort();
+
+  FORGET_Frame();
+
+  rccs->LookaheadCoverage = NULL;
+
+  lookahead_count = rccs->LookaheadGlyphCount;
+
+  if ( ALLOC_ARRAY( rccs->LookaheadCoverage, lookahead_count,
+		    HB_Coverage ) )
+    goto Fail3;
+
+  l = rccs->LookaheadCoverage;
+
+  for ( nl = 0; nl < lookahead_count; nl++ )
+  {
+    if ( ACCESS_Frame( 2L ) )
+      goto Fail2;
+
+    new_offset = GET_UShort() + base_offset;
+
+    FORGET_Frame();
+
+    cur_offset = FILE_Pos();
+    if ( FILE_Seek( new_offset ) ||
+	 ( error = _HB_OPEN_Load_Coverage( &l[nl], stream ) ) != HB_Err_Ok )
+      goto Fail2;
+    (void)FILE_Seek( cur_offset );
+  }
+
+  if ( ACCESS_Frame( 2L ) )
+    goto Fail2;
+
+  rccs->GlyphCount = GET_UShort();
+
+  FORGET_Frame();
+
+  rccs->Substitute = NULL;
+
+  count = rccs->GlyphCount;
+
+  if ( ALLOC_ARRAY( rccs->Substitute, count,
+		    HB_UShort ) )
+    goto Fail2;
+
+  sub = rccs->Substitute;
+
+  if ( ACCESS_Frame( count * 2L ) )
+    goto Fail1;
+
+  for ( n = 0; n < count; n++ )
+    sub[n] = GET_UShort();
+
+  FORGET_Frame();
+
+  return HB_Err_Ok;
+
+Fail1:
+  FREE( sub );
+
+Fail2:
+  for ( m = 0; m < nl; m++ )
+    _HB_OPEN_Free_Coverage( &l[m] );
+
+  FREE( l );
+
+Fail3:
+  for ( m = 0; m < nb; m++ )
+    _HB_OPEN_Free_Coverage( &b[m] );
+
+  FREE( b );
+
+Fail4:
+  _HB_OPEN_Free_Coverage( &rccs->Coverage );
+  return error;
+}
+
+
+static void  Free_ReverseChainContextSubst( HB_GSUB_SubTable* st )
+{
+  HB_UShort      n, count;
+  HB_ReverseChainContextSubst*  rccs = &st->reverse;
+
+  HB_Coverage*  c;
+
+  _HB_OPEN_Free_Coverage( &rccs->Coverage );
+
+  if ( rccs->LookaheadCoverage )
+  {
+    count = rccs->LookaheadGlyphCount;
+    c     = rccs->LookaheadCoverage;
+
+    for ( n = 0; n < count; n++ )
+      _HB_OPEN_Free_Coverage( &c[n] );
+
+    FREE( c );
+  }
+
+  if ( rccs->BacktrackCoverage )
+  {
+    count = rccs->BacktrackGlyphCount;
+    c     = rccs->BacktrackCoverage;
+
+    for ( n = 0; n < count; n++ )
+      _HB_OPEN_Free_Coverage( &c[n] );
+
+    FREE( c );
+  }
+
+  FREE ( rccs->Substitute );
+}
+
+
+static HB_Error  Lookup_ReverseChainContextSubst( HB_GSUBHeader*    gsub,
+						  HB_GSUB_SubTable* st,
+						  HB_Buffer         buffer,
+						  HB_UShort          flags,
+						  HB_UShort         context_length,
+						  int               nesting_level )
+{
+  HB_UShort        index, input_index, i, j, property;
+  HB_UShort        bgc, lgc;
+  HB_Error         error;
+
+  HB_ReverseChainContextSubst*  rccs = &st->reverse;
+  HB_Coverage*    bc;
+  HB_Coverage*    lc;
+  HB_GDEFHeader*  gdef;
+
+  if ( nesting_level != 1 || context_length != 0xFFFF )
+    return HB_Err_Not_Covered;
+
+  gdef = gsub->gdef;
+
+  if ( CHECK_Property( gdef, IN_CURITEM(), flags, &property ) )
+    return error;
+
+  bgc = rccs->BacktrackGlyphCount;
+  lgc = rccs->LookaheadGlyphCount;
+
+  /* check whether context is too long; it is a first guess only */
+
+  if ( bgc > buffer->in_pos || buffer->in_pos + 1 + lgc > buffer->in_length )
+    return HB_Err_Not_Covered;
+
+  if ( bgc )
+  {
+    /* Since we don't know in advance the number of glyphs to inspect,
+       we search backwards for matches in the backtrack glyph array    */
+
+    bc       = rccs->BacktrackCoverage;
+
+    for ( i = 0, j = buffer->in_pos - 1; i < bgc; i++, j-- )
+    {
+      while ( CHECK_Property( gdef, IN_ITEM( j ), flags, &property ) )
+      {
+	if ( error && error != HB_Err_Not_Covered )
+	  return error;
+
+	if ( j + 1 == bgc - i )
+	  return HB_Err_Not_Covered;
+	j--;
+      }
+
+      error = _HB_OPEN_Coverage_Index( &bc[i], IN_GLYPH( j ), &index );
+      if ( error )
+	return error;
+    }
+  }
+
+  j = buffer->in_pos;
+
+  error = _HB_OPEN_Coverage_Index( &rccs->Coverage, IN_GLYPH( j ), &input_index );
+  if ( error )
+      return error;
+
+  lc       = rccs->LookaheadCoverage;
+
+  for ( i = 0, j = buffer->in_pos + 1; i < lgc; i++, j++ )
+  {
+    while ( CHECK_Property( gdef, IN_ITEM( j ), flags, &property ) )
+    {
+      if ( error && error != HB_Err_Not_Covered )
+	return error;
+
+      if ( j + lgc - i == (HB_Int)buffer->in_length )
+	return HB_Err_Not_Covered;
+      j++;
+    }
+
+    error = _HB_OPEN_Coverage_Index( &lc[i], IN_GLYPH( j ), &index );
+    if ( error )
+      return error;
+  }
+
+  IN_CURGLYPH() = rccs->Substitute[input_index];
+  buffer->in_pos--; /* Reverse! */
+
+  return error;
+}
+
+
+
+/***********
+ * GSUB API
+ ***********/
+
+
+
+HB_Error  HB_GSUB_Select_Script( HB_GSUBHeader*  gsub,
+				 HB_UInt         script_tag,
+				 HB_UShort*       script_index )
+{
+  HB_UShort          n;
+
+  HB_ScriptList*    sl;
+  HB_ScriptRecord*  sr;
+
+
+  if ( !gsub || !script_index )
+    return ERR(HB_Err_Invalid_Argument);
+
+  sl = &gsub->ScriptList;
+  sr = sl->ScriptRecord;
+
+  for ( n = 0; n < sl->ScriptCount; n++ )
+    if ( script_tag == sr[n].ScriptTag )
+    {
+      *script_index = n;
+
+      return HB_Err_Ok;
+    }
+
+  return HB_Err_Not_Covered;
+}
+
+
+
+HB_Error  HB_GSUB_Select_Language( HB_GSUBHeader*  gsub,
+				   HB_UInt         language_tag,
+				   HB_UShort        script_index,
+				   HB_UShort*       language_index,
+				   HB_UShort*       req_feature_index )
+{
+  HB_UShort           n;
+
+  HB_ScriptList*     sl;
+  HB_ScriptRecord*   sr;
+  HB_ScriptTable*    s;
+  HB_LangSysRecord*  lsr;
+
+
+  if ( !gsub || !language_index || !req_feature_index )
+    return ERR(HB_Err_Invalid_Argument);
+
+  sl = &gsub->ScriptList;
+  sr = sl->ScriptRecord;
+
+  if ( script_index >= sl->ScriptCount )
+    return ERR(HB_Err_Invalid_Argument);
+
+  s   = &sr[script_index].Script;
+  lsr = s->LangSysRecord;
+
+  for ( n = 0; n < s->LangSysCount; n++ )
+    if ( language_tag == lsr[n].LangSysTag )
+    {
+      *language_index = n;
+      *req_feature_index = lsr[n].LangSys.ReqFeatureIndex;
+
+      return HB_Err_Ok;
+    }
+
+  return HB_Err_Not_Covered;
+}
+
+
+/* selecting 0xFFFF for language_index asks for the values of the
+   default language (DefaultLangSys)                              */
+
+
+HB_Error  HB_GSUB_Select_Feature( HB_GSUBHeader*  gsub,
+				  HB_UInt         feature_tag,
+				  HB_UShort        script_index,
+				  HB_UShort        language_index,
+				  HB_UShort*       feature_index )
+{
+  HB_UShort           n;
+
+  HB_ScriptList*     sl;
+  HB_ScriptRecord*   sr;
+  HB_ScriptTable*    s;
+  HB_LangSysRecord*  lsr;
+  HB_LangSys*        ls;
+  HB_UShort*          fi;
+
+  HB_FeatureList*    fl;
+  HB_FeatureRecord*  fr;
+
+
+  if ( !gsub || !feature_index )
+    return ERR(HB_Err_Invalid_Argument);
+
+  sl = &gsub->ScriptList;
+  sr = sl->ScriptRecord;
+
+  fl = &gsub->FeatureList;
+  fr = fl->FeatureRecord;
+
+  if ( script_index >= sl->ScriptCount )
+    return ERR(HB_Err_Invalid_Argument);
+
+  s   = &sr[script_index].Script;
+  lsr = s->LangSysRecord;
+
+  if ( language_index == 0xFFFF )
+    ls = &s->DefaultLangSys;
+  else
+  {
+    if ( language_index >= s->LangSysCount )
+      return ERR(HB_Err_Invalid_Argument);
+
+    ls = &lsr[language_index].LangSys;
+  }
+
+  fi = ls->FeatureIndex;
+
+  for ( n = 0; n < ls->FeatureCount; n++ )
+  {
+    if ( fi[n] >= fl->FeatureCount )
+      return ERR(HB_Err_Invalid_SubTable_Format);
+
+    if ( feature_tag == fr[fi[n]].FeatureTag )
+    {
+      *feature_index = fi[n];
+
+      return HB_Err_Ok;
+    }
+  }
+
+  return HB_Err_Not_Covered;
+}
+
+
+/* The next three functions return a null-terminated list */
+
+
+HB_Error  HB_GSUB_Query_Scripts( HB_GSUBHeader*  gsub,
+				 HB_UInt**       script_tag_list )
+{
+  HB_UShort          n;
+  HB_Error           error;
+  HB_UInt*          stl;
+
+  HB_ScriptList*    sl;
+  HB_ScriptRecord*  sr;
+
+
+  if ( !gsub || !script_tag_list )
+    return ERR(HB_Err_Invalid_Argument);
+
+  sl = &gsub->ScriptList;
+  sr = sl->ScriptRecord;
+
+  if ( ALLOC_ARRAY( stl, sl->ScriptCount + 1, HB_UInt ) )
+    return error;
+
+  for ( n = 0; n < sl->ScriptCount; n++ )
+    stl[n] = sr[n].ScriptTag;
+  stl[n] = 0;
+
+  *script_tag_list = stl;
+
+  return HB_Err_Ok;
+}
+
+
+
+HB_Error  HB_GSUB_Query_Languages( HB_GSUBHeader*  gsub,
+				   HB_UShort        script_index,
+				   HB_UInt**       language_tag_list )
+{
+  HB_UShort           n;
+  HB_Error            error;
+  HB_UInt*           ltl;
+
+  HB_ScriptList*     sl;
+  HB_ScriptRecord*   sr;
+  HB_ScriptTable*    s;
+  HB_LangSysRecord*  lsr;
+
+
+  if ( !gsub || !language_tag_list )
+    return ERR(HB_Err_Invalid_Argument);
+
+  sl = &gsub->ScriptList;
+  sr = sl->ScriptRecord;
+
+  if ( script_index >= sl->ScriptCount )
+    return ERR(HB_Err_Invalid_Argument);
+
+  s   = &sr[script_index].Script;
+  lsr = s->LangSysRecord;
+
+  if ( ALLOC_ARRAY( ltl, s->LangSysCount + 1, HB_UInt ) )
+    return error;
+
+  for ( n = 0; n < s->LangSysCount; n++ )
+    ltl[n] = lsr[n].LangSysTag;
+  ltl[n] = 0;
+
+  *language_tag_list = ltl;
+
+  return HB_Err_Ok;
+}
+
+
+/* selecting 0xFFFF for language_index asks for the values of the
+   default language (DefaultLangSys)                              */
+
+
+HB_Error  HB_GSUB_Query_Features( HB_GSUBHeader*  gsub,
+				  HB_UShort        script_index,
+				  HB_UShort        language_index,
+				  HB_UInt**       feature_tag_list )
+{
+  HB_UShort           n;
+  HB_Error            error;
+  HB_UInt*           ftl;
+
+  HB_ScriptList*     sl;
+  HB_ScriptRecord*   sr;
+  HB_ScriptTable*    s;
+  HB_LangSysRecord*  lsr;
+  HB_LangSys*        ls;
+  HB_UShort*          fi;
+
+  HB_FeatureList*    fl;
+  HB_FeatureRecord*  fr;
+
+
+  if ( !gsub || !feature_tag_list )
+    return ERR(HB_Err_Invalid_Argument);
+
+  sl = &gsub->ScriptList;
+  sr = sl->ScriptRecord;
+
+  fl = &gsub->FeatureList;
+  fr = fl->FeatureRecord;
+
+  if ( script_index >= sl->ScriptCount )
+    return ERR(HB_Err_Invalid_Argument);
+
+  s   = &sr[script_index].Script;
+  lsr = s->LangSysRecord;
+
+  if ( language_index == 0xFFFF )
+    ls = &s->DefaultLangSys;
+  else
+  {
+    if ( language_index >= s->LangSysCount )
+      return ERR(HB_Err_Invalid_Argument);
+
+    ls = &lsr[language_index].LangSys;
+  }
+
+  fi = ls->FeatureIndex;
+
+  if ( ALLOC_ARRAY( ftl, ls->FeatureCount + 1, HB_UInt ) )
+    return error;
+
+  for ( n = 0; n < ls->FeatureCount; n++ )
+  {
+    if ( fi[n] >= fl->FeatureCount )
+    {
+      FREE( ftl );
+      return ERR(HB_Err_Invalid_SubTable_Format);
+    }
+    ftl[n] = fr[fi[n]].FeatureTag;
+  }
+  ftl[n] = 0;
+
+  *feature_tag_list = ftl;
+
+  return HB_Err_Ok;
+}
+
+
+/* Do an individual subtable lookup.  Returns HB_Err_Ok if substitution
+   has been done, or HB_Err_Not_Covered if not.                        */
+static HB_Error  GSUB_Do_Glyph_Lookup( HB_GSUBHeader* gsub,
+				       HB_UShort       lookup_index,
+				       HB_Buffer      buffer,
+				       HB_UShort       context_length,
+				       int             nesting_level )
+{
+  HB_Error               error = HB_Err_Not_Covered;
+  HB_UShort              i, flags, lookup_count;
+  HB_Lookup*             lo;
+  int                    lookup_type;
+
+  nesting_level++;
+
+  if ( nesting_level > HB_MAX_NESTING_LEVEL )
+    return ERR(HB_Err_Not_Covered); /* ERR() call intended */
+
+  lookup_count = gsub->LookupList.LookupCount;
+  if (lookup_index >= lookup_count)
+    return error;
+
+  lo    = &gsub->LookupList.Lookup[lookup_index];
+  flags = lo->LookupFlag;
+  lookup_type = lo->LookupType;
+
+  for ( i = 0; i < lo->SubTableCount; i++ )
+  {
+    HB_GSUB_SubTable *st = &lo->SubTable[i].st.gsub;
+
+    switch (lookup_type) {
+      case HB_GSUB_LOOKUP_SINGLE:
+	error = Lookup_SingleSubst		( gsub, st, buffer, flags, context_length, nesting_level ); break;
+      case HB_GSUB_LOOKUP_MULTIPLE:
+	error = Lookup_MultipleSubst		( gsub, st, buffer, flags, context_length, nesting_level ); break;
+      case HB_GSUB_LOOKUP_ALTERNATE:
+	error = Lookup_AlternateSubst		( gsub, st, buffer, flags, context_length, nesting_level ); break;
+      case HB_GSUB_LOOKUP_LIGATURE:
+	error = Lookup_LigatureSubst		( gsub, st, buffer, flags, context_length, nesting_level ); break;
+      case HB_GSUB_LOOKUP_CONTEXT:
+	error = Lookup_ContextSubst		( gsub, st, buffer, flags, context_length, nesting_level ); break;
+      case HB_GSUB_LOOKUP_CHAIN:
+	error = Lookup_ChainContextSubst	( gsub, st, buffer, flags, context_length, nesting_level ); break;
+    /*case HB_GSUB_LOOKUP_EXTENSION:
+	error = Lookup_ExtensionSubst		( gsub, st, buffer, flags, context_length, nesting_level ); break;*/
+      case HB_GSUB_LOOKUP_REVERSE_CHAIN:
+	error = Lookup_ReverseChainContextSubst	( gsub, st, buffer, flags, context_length, nesting_level ); break;
+      default:
+	error = HB_Err_Not_Covered;
+    };
+
+    /* Check whether we have a successful substitution or an error other
+       than HB_Err_Not_Covered                                          */
+    if ( error != HB_Err_Not_Covered )
+      return error;
+  }
+
+  return HB_Err_Not_Covered;
+}
+
+
+HB_INTERNAL HB_Error
+_HB_GSUB_Load_SubTable( HB_GSUB_SubTable* st,
+			HB_Stream         stream,
+			HB_UShort         lookup_type )
+{
+  switch (lookup_type) {
+    case HB_GSUB_LOOKUP_SINGLE:		return Load_SingleSubst			( st, stream );
+    case HB_GSUB_LOOKUP_MULTIPLE:	return Load_MultipleSubst		( st, stream );
+    case HB_GSUB_LOOKUP_ALTERNATE:	return Load_AlternateSubst		( st, stream );
+    case HB_GSUB_LOOKUP_LIGATURE:	return Load_LigatureSubst		( st, stream );
+    case HB_GSUB_LOOKUP_CONTEXT:	return Load_ContextSubst		( st, stream );
+    case HB_GSUB_LOOKUP_CHAIN:		return Load_ChainContextSubst		( st, stream );
+  /*case HB_GSUB_LOOKUP_EXTENSION:	return Load_ExtensionSubst		( st, stream );*/
+    case HB_GSUB_LOOKUP_REVERSE_CHAIN:	return Load_ReverseChainContextSubst	( st, stream );
+    default:				return ERR(HB_Err_Invalid_SubTable_Format);
+  };
+}
+
+
+HB_INTERNAL void
+_HB_GSUB_Free_SubTable( HB_GSUB_SubTable* st,
+			HB_UShort         lookup_type )
+{
+  switch ( lookup_type ) {
+    case HB_GSUB_LOOKUP_SINGLE:		Free_SingleSubst		( st ); return;
+    case HB_GSUB_LOOKUP_MULTIPLE:	Free_MultipleSubst		( st ); return;
+    case HB_GSUB_LOOKUP_ALTERNATE:	Free_AlternateSubst		( st ); return;
+    case HB_GSUB_LOOKUP_LIGATURE:	Free_LigatureSubst		( st ); return;
+    case HB_GSUB_LOOKUP_CONTEXT:	Free_ContextSubst		( st ); return;
+    case HB_GSUB_LOOKUP_CHAIN:		Free_ChainContextSubst		( st ); return;
+  /*case HB_GSUB_LOOKUP_EXTENSION:	Free_ExtensionSubst		( st ); return;*/
+    case HB_GSUB_LOOKUP_REVERSE_CHAIN:	Free_ReverseChainContextSubst	( st ); return;
+    default:									return;
+  };
+}
+
+
+
+/* apply one lookup to the input string object */
+
+static HB_Error  GSUB_Do_String_Lookup( HB_GSUBHeader*   gsub,
+				   HB_UShort         lookup_index,
+				   HB_Buffer        buffer )
+{
+  HB_Error  error, retError = HB_Err_Not_Covered;
+
+  HB_UInt*  properties = gsub->LookupList.Properties;
+  int       lookup_type = gsub->LookupList.Lookup[lookup_index].LookupType;
+
+  const int       nesting_level = 0;
+  /* 0xFFFF indicates that we don't have a context length yet */
+  const HB_UShort context_length = 0xFFFF;
+
+  switch (lookup_type) {
+
+    case HB_GSUB_LOOKUP_SINGLE:
+    case HB_GSUB_LOOKUP_MULTIPLE:
+    case HB_GSUB_LOOKUP_ALTERNATE:
+    case HB_GSUB_LOOKUP_LIGATURE:
+    case HB_GSUB_LOOKUP_CONTEXT:
+    case HB_GSUB_LOOKUP_CHAIN:
+      /* in/out forward substitution (implemented lazy) */
+
+      _hb_buffer_clear_output ( buffer );
+      buffer->in_pos = 0;
+  while ( buffer->in_pos < buffer->in_length )
+  {
+    if ( ~IN_PROPERTIES( buffer->in_pos ) & properties[lookup_index] )
+    {
+	  error = GSUB_Do_Glyph_Lookup( gsub, lookup_index, buffer, context_length, nesting_level );
+      if ( error )
+      {
+	if ( error != HB_Err_Not_Covered )
+	  return error;
+      }
+      else
+	retError = error;
+    }
+    else
+      error = HB_Err_Not_Covered;
+
+    if ( error == HB_Err_Not_Covered )
+	  if ( COPY_Glyph ( buffer ) )
+	return error;
+  }
+      /* we shouldn't swap if error occurred.
+       *
+       * also don't swap if nothing changed (ie HB_Err_Not_Covered).
+       * shouldn't matter in that case though.
+       */
+      if ( retError == HB_Err_Ok )
+	_hb_buffer_swap( buffer );
+
+  return retError;
+
+    case HB_GSUB_LOOKUP_REVERSE_CHAIN:
+      /* in-place backward substitution */
+
+      buffer->in_pos = buffer->in_length - 1;
+    do
+    {
+      if ( ~IN_PROPERTIES( buffer->in_pos ) & properties[lookup_index] )
+	{
+	  error = GSUB_Do_Glyph_Lookup( gsub, lookup_index, buffer, context_length, nesting_level );
+	  if ( error )
+	    {
+	      if ( error != HB_Err_Not_Covered )
+		return error;
+	    }
+	  else
+	    retError = error;
+	}
+	else
+	  error = HB_Err_Not_Covered;
+
+	if ( error == HB_Err_Not_Covered )
+	  buffer->in_pos--;
+      }
+      while ((HB_Int) buffer->in_pos >= 0);
+
+      return retError;
+
+  /*case HB_GSUB_LOOKUP_EXTENSION:*/
+    default:
+  return retError;
+  };
+}
+
+
+HB_Error  HB_GSUB_Add_Feature( HB_GSUBHeader*  gsub,
+			       HB_UShort        feature_index,
+			       HB_UInt          property )
+{
+  HB_UShort    i;
+
+  HB_Feature  feature;
+  HB_UInt*     properties;
+  HB_UShort*   index;
+  HB_UShort    lookup_count;
+
+  /* Each feature can only be added once */
+
+  if ( !gsub ||
+       feature_index >= gsub->FeatureList.FeatureCount ||
+       gsub->FeatureList.ApplyCount == gsub->FeatureList.FeatureCount )
+    return ERR(HB_Err_Invalid_Argument);
+
+  gsub->FeatureList.ApplyOrder[gsub->FeatureList.ApplyCount++] = feature_index;
+
+  properties = gsub->LookupList.Properties;
+
+  feature = gsub->FeatureList.FeatureRecord[feature_index].Feature;
+  index   = feature.LookupListIndex;
+  lookup_count = gsub->LookupList.LookupCount;
+
+  for ( i = 0; i < feature.LookupListCount; i++ )
+  {
+    HB_UShort lookup_index = index[i];
+    if (lookup_index < lookup_count)
+      properties[lookup_index] |= property;
+  }
+
+  return HB_Err_Ok;
+}
+
+
+
+HB_Error  HB_GSUB_Clear_Features( HB_GSUBHeader*  gsub )
+{
+  HB_UShort i;
+
+  HB_UInt*  properties;
+
+
+  if ( !gsub )
+    return ERR(HB_Err_Invalid_Argument);
+
+  gsub->FeatureList.ApplyCount = 0;
+
+  properties = gsub->LookupList.Properties;
+
+  for ( i = 0; i < gsub->LookupList.LookupCount; i++ )
+    properties[i] = 0;
+
+  return HB_Err_Ok;
+}
+
+
+
+HB_Error  HB_GSUB_Register_Alternate_Function( HB_GSUBHeader*  gsub,
+					       HB_AltFunction  altfunc,
+					       void*            data )
+{
+  if ( !gsub )
+    return ERR(HB_Err_Invalid_Argument);
+
+  gsub->altfunc = altfunc;
+  gsub->data    = data;
+
+  return HB_Err_Ok;
+}
+
+/* returns error if one happened, otherwise returns HB_Err_Not_Covered if no
+ * feature were applied, or HB_Err_Ok otherwise.
+ */
+HB_Error  HB_GSUB_Apply_String( HB_GSUBHeader*   gsub,
+				HB_Buffer        buffer )
+{
+  HB_Error          error, retError = HB_Err_Not_Covered;
+  int               i, j, lookup_count, num_features;
+
+  if ( !gsub ||
+       !buffer)
+    return ERR(HB_Err_Invalid_Argument);
+
+  if ( buffer->in_length == 0 )
+    return retError;
+
+  lookup_count = gsub->LookupList.LookupCount;
+  num_features = gsub->FeatureList.ApplyCount;
+
+  for ( i = 0; i < num_features; i++)
+  {
+    HB_UShort  feature_index = gsub->FeatureList.ApplyOrder[i];
+    HB_Feature feature = gsub->FeatureList.FeatureRecord[feature_index].Feature;
+
+    for ( j = 0; j < feature.LookupListCount; j++ )
+    {
+      HB_UShort         lookup_index = feature.LookupListIndex[j];
+
+      /* Skip nonexistant lookups */
+      if (lookup_index >= lookup_count)
+       continue;
+
+	error = GSUB_Do_String_Lookup( gsub, lookup_index, buffer );
+      if ( error )
+      {
+	if ( error != HB_Err_Not_Covered )
+	  return error;
+      }
+      else
+	retError = error;
+    }
+  }
+
+  error = retError;
+
+  return error;
+}
+
+
+/* END */
diff -rupN orginal/scribus/harfbuzz/harfbuzz-gsub.h patched/scribus/harfbuzz/harfbuzz-gsub.h
--- orginal/scribus/harfbuzz/harfbuzz-gsub.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/harfbuzz-gsub.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,141 @@
+/*
+ * Copyright (C) 1998-2004  David Turner and Werner Lemberg
+ * Copyright (C) 2006  Behdad Esfahbod
+ *
+ * This is part of HarfBuzz, an OpenType Layout engine library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ */
+
+#ifndef HARFBUZZ_GSUB_H
+#define HARFBUZZ_GSUB_H
+
+#include "harfbuzz-gdef.h"
+#include "harfbuzz-buffer.h"
+
+HB_BEGIN_HEADER
+
+
+/* Lookup types for glyph substitution */
+
+#define HB_GSUB_LOOKUP_SINGLE        1
+#define HB_GSUB_LOOKUP_MULTIPLE      2
+#define HB_GSUB_LOOKUP_ALTERNATE     3
+#define HB_GSUB_LOOKUP_LIGATURE      4
+#define HB_GSUB_LOOKUP_CONTEXT       5
+#define HB_GSUB_LOOKUP_CHAIN         6
+#define HB_GSUB_LOOKUP_EXTENSION     7
+#define HB_GSUB_LOOKUP_REVERSE_CHAIN 8
+
+
+/* A pointer to a function which selects the alternate glyph.  `pos' is
+   the position of the glyph with index `glyphID', `num_alternates'
+   gives the number of alternates in the `alternates' array.  `data'
+   points to the user-defined structure specified during a call to
+   HB_GSUB_Register_Alternate_Function().  The function must return an
+   index into the `alternates' array.                                   */
+
+typedef HB_UShort  (*HB_AltFunction)(HB_UInt    pos,
+				      HB_UShort   glyphID,
+				      HB_UShort   num_alternates,
+				      HB_UShort*  alternates,
+				      void*       data );
+
+
+struct  HB_GSUBHeader_
+{
+  HB_UInt         offset;
+
+  HB_16Dot16         Version;
+
+  HB_ScriptList   ScriptList;
+  HB_FeatureList  FeatureList;
+  HB_LookupList   LookupList;
+
+  HB_GDEFHeader*  gdef;
+
+  /* the next two fields are used for an alternate substitution callback
+     function to select the proper alternate glyph.                      */
+
+  HB_AltFunction  altfunc;
+  void*            data;
+};
+
+typedef struct HB_GSUBHeader_   HB_GSUBHeader;
+typedef HB_GSUBHeader*  HB_GSUB;
+
+
+HB_Error  HB_Load_GSUB_Table( HB_Stream       stream,
+			      HB_GSUBHeader** gsub,
+			      HB_GDEFHeader*  gdef,
+                              HB_Stream       gdefStream );
+
+
+HB_Error  HB_Done_GSUB_Table( HB_GSUBHeader*  gsub );
+
+
+HB_Error  HB_GSUB_Select_Script( HB_GSUBHeader*  gsub,
+				 HB_UInt         script_tag,
+				 HB_UShort*       script_index );
+
+HB_Error  HB_GSUB_Select_Language( HB_GSUBHeader*  gsub,
+				   HB_UInt         language_tag,
+				   HB_UShort        script_index,
+				   HB_UShort*       language_index,
+				   HB_UShort*       req_feature_index );
+
+HB_Error  HB_GSUB_Select_Feature( HB_GSUBHeader*  gsub,
+				  HB_UInt         feature_tag,
+				  HB_UShort        script_index,
+				  HB_UShort        language_index,
+				  HB_UShort*       feature_index );
+
+
+HB_Error  HB_GSUB_Query_Scripts( HB_GSUBHeader*  gsub,
+				 HB_UInt**       script_tag_list );
+
+HB_Error  HB_GSUB_Query_Languages( HB_GSUBHeader*  gsub,
+				   HB_UShort        script_index,
+				   HB_UInt**       language_tag_list );
+
+HB_Error  HB_GSUB_Query_Features( HB_GSUBHeader*  gsub,
+				  HB_UShort        script_index,
+				  HB_UShort        language_index,
+				  HB_UInt**       feature_tag_list );
+
+
+HB_Error  HB_GSUB_Add_Feature( HB_GSUBHeader*  gsub,
+			       HB_UShort        feature_index,
+			       HB_UInt          property );
+
+HB_Error  HB_GSUB_Clear_Features( HB_GSUBHeader*  gsub );
+
+
+HB_Error  HB_GSUB_Register_Alternate_Function( HB_GSUBHeader*  gsub,
+					       HB_AltFunction  altfunc,
+					       void*            data );
+
+
+HB_Error  HB_GSUB_Apply_String( HB_GSUBHeader*   gsub,
+				HB_Buffer        buffer );
+
+
+HB_END_HEADER
+
+#endif /* HARFBUZZ_GSUB_H */
diff -rupN orginal/scribus/harfbuzz/harfbuzz-hangul.c patched/scribus/harfbuzz/harfbuzz-hangul.c
--- orginal/scribus/harfbuzz/harfbuzz-hangul.c	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/harfbuzz-hangul.c	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,268 @@
+/*
+ * Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies)
+ *
+ * This is part of HarfBuzz, an OpenType Layout engine library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ */
+
+#include "harfbuzz-shaper.h"
+#include "harfbuzz-shaper-private.h"
+
+#include <assert.h>
+
+/*
+// Hangul is a syllable based script. Unicode reserves a large range
+// for precomposed hangul, where syllables are already precomposed to
+// their final glyph shape. In addition, a so called jamo range is
+// defined, that can be used to express old Hangul. Modern hangul
+// syllables can also be expressed as jamo, and should be composed
+// into syllables. The operation is rather simple and mathematical.
+
+// Every hangul jamo is classified as being either a Leading consonant
+// (L), and intermediat Vowel (V) or a trailing consonant (T). Modern
+// hangul syllables (the ones in the precomposed area can be of type
+// LV or LVT.
+//
+// Syllable breaks do _not_ occur between:
+//
+// L              L, V or precomposed
+// V, LV          V, T
+// LVT, T         T
+//
+// A standard syllable is of the form L+V+T*. The above rules allow
+// nonstandard syllables L*V*T*. To transform them into standard
+// syllables fill characters L_f and V_f can be inserted.
+*/
+
+enum {
+    Hangul_SBase = 0xac00,
+    Hangul_LBase = 0x1100,
+    Hangul_VBase = 0x1161,
+    Hangul_TBase = 0x11a7,
+    Hangul_SCount = 11172,
+    Hangul_LCount = 19,
+    Hangul_VCount = 21,
+    Hangul_TCount = 28,
+    Hangul_NCount = 21*28
+};
+
+#define hangul_isPrecomposed(uc) \
+    (uc >= Hangul_SBase && uc < Hangul_SBase + Hangul_SCount)
+
+#define hangul_isLV(uc) \
+    ((uc - Hangul_SBase) % Hangul_TCount == 0)
+
+typedef enum {
+    L,
+    V,
+    T,
+    LV,
+    LVT,
+    X
+} HangulType;
+
+static HangulType hangul_type(unsigned short uc) {
+    if (uc > Hangul_SBase && uc < Hangul_SBase + Hangul_SCount)
+        return hangul_isLV(uc) ? LV : LVT;
+    if (uc < Hangul_LBase || uc > 0x11ff)
+        return X;
+    if (uc < Hangul_VBase)
+        return L;
+    if (uc < Hangul_TBase)
+        return V;
+    return T;
+}
+
+static int hangul_nextSyllableBoundary(const HB_UChar16 *s, int start, int end)
+{
+    const HB_UChar16 *uc = s + start;
+
+    HangulType state = hangul_type(*uc);
+    int pos = 1;
+
+    while (pos < end - start) {
+        HangulType newState = hangul_type(uc[pos]);
+        switch(newState) {
+        case X:
+            goto finish;
+        case L:
+        case V:
+        case T:
+            if (state > newState)
+                goto finish;
+            state = newState;
+            break;
+        case LV:
+            if (state > L)
+                goto finish;
+            state = V;
+            break;
+        case LVT:
+            if (state > L)
+                goto finish;
+            state = T;
+        }
+        ++pos;
+    }
+
+ finish:
+    return start+pos;
+}
+
+#ifndef NO_OPENTYPE
+static const HB_OpenTypeFeature hangul_features [] = {
+    { HB_MAKE_TAG('c', 'c', 'm', 'p'), CcmpProperty },
+    { HB_MAKE_TAG('l', 'j', 'm', 'o'), CcmpProperty },
+    { HB_MAKE_TAG('j', 'j', 'm', 'o'), CcmpProperty },
+    { HB_MAKE_TAG('t', 'j', 'm', 'o'), CcmpProperty },
+    { 0, 0 }
+};
+#endif
+
+static HB_Bool hangul_shape_syllable(HB_ShaperItem *item, HB_Bool openType)
+{
+    const HB_UChar16 *ch = item->string + item->item.pos;
+    int len = item->item.length;
+#ifndef NO_OPENTYPE
+    const int availableGlyphs = item->num_glyphs;
+#endif
+
+    int i;
+    HB_UChar16 composed = 0;
+    /* see if we can compose the syllable into a modern hangul */
+    if (item->item.length == 2) {
+        int LIndex = ch[0] - Hangul_LBase;
+        int VIndex = ch[1] - Hangul_VBase;
+        if (LIndex >= 0 && LIndex < Hangul_LCount &&
+            VIndex >= 0 && VIndex < Hangul_VCount)
+            composed = (LIndex * Hangul_VCount + VIndex) * Hangul_TCount + Hangul_SBase;
+    } else if (item->item.length == 3) {
+        int LIndex = ch[0] - Hangul_LBase;
+        int VIndex = ch[1] - Hangul_VBase;
+        int TIndex = ch[2] - Hangul_TBase;
+        if (LIndex >= 0 && LIndex < Hangul_LCount &&
+            VIndex >= 0 && VIndex < Hangul_VCount &&
+            TIndex >= 0 && TIndex < Hangul_TCount)
+            composed = (LIndex * Hangul_VCount + VIndex) * Hangul_TCount + TIndex + Hangul_SBase;
+    }
+
+
+
+    /* if we have a modern hangul use the composed form */
+    if (composed) {
+        ch = &composed;
+        len = 1;
+    }
+
+    if (!item->font->klass->convertStringToGlyphIndices(item->font,
+                                                        ch, len,
+                                                        item->glyphs, &item->num_glyphs,
+                                                        item->item.bidiLevel % 2))
+        return FALSE;
+    for (i = 0; i < len; i++) {
+        item->attributes[i].mark = FALSE;
+        item->attributes[i].clusterStart = FALSE;
+        item->attributes[i].justification = 0;
+        item->attributes[i].zeroWidth = FALSE;
+        /*IDEBUG("    %d: %4x", i, ch[i].unicode()); */
+    }
+
+#ifndef NO_OPENTYPE
+    if (!composed && openType) {
+        HB_Bool positioned;
+
+        HB_STACKARRAY(unsigned short, logClusters, len);
+        for (i = 0; i < len; ++i)
+            logClusters[i] = i;
+        item->log_clusters = logClusters;
+
+        HB_OpenTypeShape(item, /*properties*/0);
+
+        positioned = HB_OpenTypePosition(item, availableGlyphs, /*doLogClusters*/FALSE);
+
+        HB_FREE_STACKARRAY(logClusters);
+
+        if (!positioned)
+            return FALSE;
+    } else {
+        HB_HeuristicPosition(item);
+    }
+#endif
+
+    item->attributes[0].clusterStart = TRUE;
+    return TRUE;
+}
+
+HB_Bool HB_HangulShape(HB_ShaperItem *item)
+{
+    const HB_UChar16 *uc = item->string + item->item.pos;
+    HB_Bool allPrecomposed = TRUE;
+    int i;
+
+    assert(item->item.script == HB_Script_Hangul);
+
+    for (i = 0; i < (int)item->item.length; ++i) {
+        if (!hangul_isPrecomposed(uc[i])) {
+            allPrecomposed = FALSE;
+            break;
+        }
+    }
+
+    if (!allPrecomposed) {
+        HB_Bool openType = FALSE;
+        unsigned short *logClusters = item->log_clusters;
+        HB_ShaperItem syllable;
+        int first_glyph = 0;
+        int sstart = item->item.pos;
+        int end = sstart + item->item.length;
+
+#ifndef NO_OPENTYPE
+        openType = HB_SelectScript(item, hangul_features);
+#endif
+        syllable = *item;
+
+        while (sstart < end) {
+            int send = hangul_nextSyllableBoundary(item->string, sstart, end);
+
+            syllable.item.pos = sstart;
+            syllable.item.length = send-sstart;
+            syllable.glyphs = item->glyphs + first_glyph;
+            syllable.attributes = item->attributes + first_glyph;
+            syllable.offsets = item->offsets + first_glyph;
+            syllable.advances = item->advances + first_glyph;
+            syllable.num_glyphs = item->num_glyphs - first_glyph;
+            if (!hangul_shape_syllable(&syllable, openType)) {
+                item->num_glyphs += syllable.num_glyphs;
+                return FALSE;
+            }
+            /* fix logcluster array */
+            for (i = sstart; i < send; ++i)
+                logClusters[i-item->item.pos] = first_glyph;
+            sstart = send;
+            first_glyph += syllable.num_glyphs;
+        }
+        item->num_glyphs = first_glyph;
+        return TRUE;
+    }
+
+    return HB_BasicShape(item);
+}
+
+
diff -rupN orginal/scribus/harfbuzz/harfbuzz-hebrew.c patched/scribus/harfbuzz/harfbuzz-hebrew.c
--- orginal/scribus/harfbuzz/harfbuzz-hebrew.c	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/harfbuzz-hebrew.c	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,189 @@
+/*
+ * Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies)
+ *
+ * This is part of HarfBuzz, an OpenType Layout engine library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ */
+
+#include "harfbuzz-shaper.h"
+#include "harfbuzz-shaper-private.h"
+#include <assert.h>
+
+/*
+// Uniscribe also defines dlig for Hebrew, but we leave this out for now, as it's mostly
+// ligatures one does not want in modern Hebrew (as lam-alef ligatures).
+*/
+#ifndef NO_OPENTYPE
+static const HB_OpenTypeFeature hebrew_features[] = {
+    { HB_MAKE_TAG('c', 'c', 'm', 'p'), CcmpProperty },
+    {0, 0}
+};
+#endif
+
+/* Hebrew shaping. In the non opentype case we try to use the
+   presentation forms specified for Hebrew. Especially for the
+   ligatures with Dagesh this gives much better results than we could
+   achieve manually.
+*/
+HB_Bool HB_HebrewShape(HB_ShaperItem *shaper_item)
+{
+    enum {
+        Dagesh = 0x5bc,
+        ShinDot = 0x5c1,
+        SinDot = 0x5c2,
+        Patah = 0x5b7,
+        Qamats = 0x5b8,
+        Holam = 0x5b9,
+        Rafe = 0x5bf
+    };
+
+    assert(shaper_item->item.script == HB_Script_Hebrew);
+
+    HB_HeuristicSetGlyphAttributes(shaper_item);
+
+#ifndef NO_OPENTYPE
+    if (HB_SelectScript(shaper_item, hebrew_features)) {
+
+        const int availableGlyphs = shaper_item->num_glyphs;
+        if (!HB_ConvertStringToGlyphIndices(shaper_item))
+            return FALSE;
+
+
+        HB_OpenTypeShape(shaper_item, /*properties*/0);
+        return HB_OpenTypePosition(shaper_item, availableGlyphs, /*doLogClusters*/TRUE);
+    }
+#endif
+
+    {
+        const HB_UChar16 *uc = shaper_item->string + shaper_item->item.pos;
+        unsigned short *logClusters = shaper_item->log_clusters;
+        HB_GlyphAttributes *attributes = shaper_item->attributes;
+
+        HB_Bool haveGlyphs;
+        int slen = 1;
+        int cluster_start = 0;
+        hb_uint32 i;
+
+        HB_STACKARRAY(HB_UChar16, shapedChars, 2 * shaper_item->item.length);
+        *shapedChars = *uc;
+        logClusters[0] = 0;
+
+        for (i = 1; i < shaper_item->item.length; ++i) {
+            hb_uint16 base = shapedChars[slen-1];
+            hb_uint16 shaped = 0;
+            HB_Bool invalid = FALSE;
+            if (uc[i] == Dagesh) {
+                if (base >= 0x5d0
+                    && base <= 0x5ea
+                    && base != 0x5d7
+                    && base != 0x5dd
+                    && base != 0x5df
+                    && base != 0x5e2
+                    && base != 0x5e5) {
+                    shaped = base - 0x5d0 + 0xfb30;
+                } else if (base == 0xfb2a || base == 0xfb2b /* Shin with Shin or Sin dot */) {
+                    shaped = base + 2;
+                } else {
+                    invalid = TRUE;
+                }
+            } else if (uc[i] == ShinDot) {
+                if (base == 0x05e9)
+                    shaped = 0xfb2a;
+                else if (base == 0xfb49)
+                    shaped = 0xfb2c;
+                else
+                    invalid = TRUE;
+            } else if (uc[i] == SinDot) {
+                if (base == 0x05e9)
+                    shaped = 0xfb2b;
+                else if (base == 0xfb49)
+                    shaped = 0xfb2d;
+                else
+                    invalid = TRUE;
+            } else if (uc[i] == Patah) {
+                if (base == 0x5d0)
+                    shaped = 0xfb2e;
+            } else if (uc[i] == Qamats) {
+                if (base == 0x5d0)
+                    shaped = 0xfb2f;
+            } else if (uc[i] == Holam) {
+                if (base == 0x5d5)
+                    shaped = 0xfb4b;
+            } else if (uc[i] == Rafe) {
+                if (base == 0x5d1)
+                    shaped = 0xfb4c;
+                else if (base == 0x5db)
+                    shaped = 0xfb4d;
+                else if (base == 0x5e4)
+                    shaped = 0xfb4e;
+            }
+
+            if (invalid) {
+                shapedChars[slen] = 0x25cc;
+                attributes[slen].clusterStart = TRUE;
+                attributes[slen].mark = FALSE;
+                attributes[slen].combiningClass = 0;
+                cluster_start = slen;
+                ++slen;
+            }
+            if (shaped) {
+                if (shaper_item->font->klass->canRender(shaper_item->font, (HB_UChar16 *)&shaped, 1)) {
+                    shapedChars[slen-1] = shaped;
+                } else
+                    shaped = 0;
+            }
+            if (!shaped) {
+                HB_CharCategory category;
+                int cmb;
+                shapedChars[slen] = uc[i];
+                HB_GetUnicodeCharProperties(uc[i], &category, &cmb);
+                if (category != HB_Mark_NonSpacing) {
+                    attributes[slen].clusterStart = TRUE;
+                    attributes[slen].mark = FALSE;
+                    attributes[slen].combiningClass = 0;
+                    attributes[slen].dontPrint = HB_IsControlChar(uc[i]);
+                    cluster_start = slen;
+                } else {
+                    attributes[slen].clusterStart = FALSE;
+                    attributes[slen].mark = TRUE;
+                    attributes[slen].combiningClass = cmb;
+                }
+                ++slen;
+            }
+            logClusters[i] = cluster_start;
+        }
+
+        haveGlyphs = shaper_item->font->klass
+            ->convertStringToGlyphIndices(shaper_item->font,
+                                          shapedChars, slen,
+                                          shaper_item->glyphs, &shaper_item->num_glyphs,
+                                          shaper_item->item.bidiLevel % 2);
+
+        HB_FREE_STACKARRAY(shapedChars);
+
+        if (!haveGlyphs)
+            return FALSE;
+
+        HB_HeuristicPosition(shaper_item);
+    }
+
+    return TRUE;
+}
+
diff -rupN orginal/scribus/harfbuzz/harfbuzz-impl.c patched/scribus/harfbuzz/harfbuzz-impl.c
--- orginal/scribus/harfbuzz/harfbuzz-impl.c	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/harfbuzz-impl.c	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 1998-2004  David Turner and Werner Lemberg
+ * Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies)
+ * Copyright (C) 2007  Red Hat, Inc.
+ *
+ * This is part of HarfBuzz, an OpenType Layout engine library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ */
+
+#include "harfbuzz-impl.h"
+
+
+HB_INTERNAL HB_Pointer
+_hb_alloc(size_t     size,
+	  HB_Error  *perror )
+{
+  HB_Error    error = (HB_Error)0;
+  HB_Pointer  block = NULL;
+
+  if ( size > 0 )
+  {
+    block = calloc( 1, size );
+    if ( !block )
+      error = ERR(HB_Err_Out_Of_Memory);
+  }
+
+  *perror = error;
+  return block;
+}
+
+
+HB_INTERNAL HB_Pointer
+_hb_realloc(HB_Pointer  block,
+	    size_t      new_size,
+	    HB_Error   *perror )
+{
+    HB_Pointer  block2 = NULL;
+    HB_Error    error  = (HB_Error)0;
+
+    block2 = realloc( block, new_size );
+    if ( block2 == NULL && new_size != 0 )
+        error = ERR(HB_Err_Out_Of_Memory);
+
+    if ( !error )
+        block = block2;
+
+    *perror = error;
+    return block;
+}
+
+
+HB_INTERNAL void
+_hb_free( HB_Pointer  block )
+{
+  if ( block )
+    free( block );
+}
+
+
+/* helper func to set a breakpoint on */
+HB_INTERNAL HB_Error
+_hb_err (HB_Error code)
+{
+  return code;
+}
diff -rupN orginal/scribus/harfbuzz/harfbuzz-impl.h patched/scribus/harfbuzz/harfbuzz-impl.h
--- orginal/scribus/harfbuzz/harfbuzz-impl.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/harfbuzz-impl.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,131 @@
+/*
+ * Copyright (C) 1998-2004  David Turner and Werner Lemberg
+ * Copyright (C) 2006  Behdad Esfahbod
+ *
+ * This is part of HarfBuzz, an OpenType Layout engine library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ */
+
+#ifndef HARFBUZZ_IMPL_H
+#define HARFBUZZ_IMPL_H
+
+#include "harfbuzz-global.h"
+
+#include <stdlib.h>
+
+HB_BEGIN_HEADER
+
+#ifndef HB_INTERNAL
+# define HB_INTERNAL
+#endif
+
+#ifndef NULL
+# define NULL ((void *)0)
+#endif
+
+#ifndef FALSE
+# define FALSE 0
+#endif
+
+#ifndef TRUE
+# define TRUE 1
+#endif
+
+#ifndef TTAG_GDEF
+# define TTAG_GDEF  HB_MAKE_TAG( 'G', 'D', 'E', 'F' )
+#endif
+#ifndef TTAG_GPOS
+# define TTAG_GPOS  HB_MAKE_TAG( 'G', 'P', 'O', 'S' )
+#endif
+#ifndef TTAG_GSUB
+# define TTAG_GSUB  HB_MAKE_TAG( 'G', 'S', 'U', 'B' )
+#endif
+
+#ifndef HB_UNUSED
+# define HB_UNUSED(arg) ((arg) = (arg))
+#endif
+
+#define HB_LIKELY(cond) (cond)
+#define HB_UNLIKELY(cond) (cond)
+
+#define ARRAY_LEN(Array) ((int)(sizeof (Array) / sizeof (Array)[0]))
+
+
+
+#define HB_IsHighSurrogate(ucs) \
+    (((ucs) & 0xfc00) == 0xd800)
+
+#define HB_IsLowSurrogate(ucs) \
+    (((ucs) & 0xfc00) == 0xdc00)
+
+#define HB_SurrogateToUcs4(high, low) \
+    (((HB_UChar32)(high))<<10) + (low) - 0x35fdc00;
+
+
+
+
+
+#define  ALLOC(_ptr,_size)   \
+           ( (_ptr) = _hb_alloc( _size, &error ), error != 0 )
+
+#define  REALLOC(_ptr,_newsz)  \
+           ( (_ptr) = _hb_realloc( (_ptr), (_newsz), &error ), error != 0 )
+
+#define  FREE(_ptr)                    \
+  do {                                 \
+    if ( (_ptr) )                      \
+    {                                  \
+      _hb_free( _ptr );     \
+      _ptr = NULL;                     \
+    }                                  \
+  } while (0)
+
+#define  ALLOC_ARRAY(_ptr,_count,_type)   \
+           ALLOC(_ptr,(_count)*sizeof(_type))
+
+#define  REALLOC_ARRAY(_ptr,_newcnt,_type) \
+           REALLOC(_ptr,(_newcnt)*sizeof(_type))
+
+#define  MEM_Copy(dest,source,count)   memcpy( (char*)(dest), (const char*)(source), (size_t)(count) )
+
+#define ERR(err)   _hb_err (err)
+
+
+HB_INTERNAL HB_Pointer
+_hb_alloc( size_t    size,
+	   HB_Error *perror_ );
+
+HB_INTERNAL HB_Pointer
+_hb_realloc( HB_Pointer block,
+	     size_t     new_size,
+	     HB_Error  *perror_ );
+
+HB_INTERNAL void
+_hb_free( HB_Pointer block );
+
+
+/* helper func to set a breakpoint on */
+HB_INTERNAL HB_Error
+_hb_err (HB_Error code);
+
+
+HB_END_HEADER
+
+#endif /* HARFBUZZ_IMPL_H */
diff -rupN orginal/scribus/harfbuzz/harfbuzz-indic.cpp patched/scribus/harfbuzz/harfbuzz-indic.cpp
--- orginal/scribus/harfbuzz/harfbuzz-indic.cpp	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/harfbuzz-indic.cpp	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,1873 @@
+/*
+ * Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies)
+ *
+ * This is part of HarfBuzz, an OpenType Layout engine library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ */
+
+#include "harfbuzz-shaper.h"
+#include "harfbuzz-shaper-private.h"
+
+#include <assert.h>
+#include <stdio.h>
+
+#define FLAG(x) (1 << (x))
+
+static HB_Bool isLetter(HB_UChar16 ucs)
+{
+    const int test = FLAG(HB_Letter_Uppercase) |
+                     FLAG(HB_Letter_Lowercase) |
+                     FLAG(HB_Letter_Titlecase) |
+                     FLAG(HB_Letter_Modifier) |
+                     FLAG(HB_Letter_Other);
+    return FLAG(HB_GetUnicodeCharCategory(ucs)) & test;
+}
+
+static HB_Bool isMark(HB_UChar16 ucs)
+{
+    const int test = FLAG(HB_Mark_NonSpacing) |
+                     FLAG(HB_Mark_SpacingCombining) |
+                     FLAG(HB_Mark_Enclosing);
+    return FLAG(HB_GetUnicodeCharCategory(ucs)) & test;
+}
+
+enum Form {
+    Invalid = 0x0,
+    UnknownForm = Invalid,
+    Consonant,
+    Nukta,
+    Halant,
+    Matra,
+    VowelMark,
+    StressMark,
+    IndependentVowel,
+    LengthMark,
+    Control,
+    Other
+};
+
+static const unsigned char indicForms[0xe00-0x900] = {
+    // Devangari
+    Invalid, VowelMark, VowelMark, VowelMark,
+    IndependentVowel, IndependentVowel, IndependentVowel, IndependentVowel,
+    IndependentVowel, IndependentVowel, IndependentVowel, IndependentVowel,
+    IndependentVowel, IndependentVowel, IndependentVowel, IndependentVowel,
+
+    IndependentVowel, IndependentVowel, IndependentVowel, IndependentVowel,
+    IndependentVowel, Consonant, Consonant, Consonant,
+    Consonant, Consonant, Consonant, Consonant,
+    Consonant, Consonant, Consonant, Consonant,
+
+    Consonant, Consonant, Consonant, Consonant,
+    Consonant, Consonant, Consonant, Consonant,
+    Consonant, Consonant, Consonant, Consonant,
+    Consonant, Consonant, Consonant, Consonant,
+
+    Consonant, Consonant, Consonant, Consonant,
+    Consonant, Consonant, Consonant, Consonant,
+    Consonant, Consonant, UnknownForm, UnknownForm,
+    Nukta, Other, Matra, Matra,
+
+    Matra, Matra, Matra, Matra,
+    Matra, Matra, Matra, Matra,
+    Matra, Matra, Matra, Matra,
+    Matra, Halant, UnknownForm, UnknownForm,
+
+    Other, StressMark, StressMark, StressMark,
+    StressMark, UnknownForm, UnknownForm, UnknownForm,
+    Consonant, Consonant, Consonant, Consonant,
+    Consonant, Consonant, Consonant, Consonant,
+
+    IndependentVowel, IndependentVowel, VowelMark, VowelMark,
+    Other, Other, Other, Other,
+    Other, Other, Other, Other,
+    Other, Other, Other, Other,
+
+    Other, Other, Other, Other,
+    Other, Other, Other, Other,
+    Other, Other, Other, Consonant,
+    Consonant, Consonant /* ??? */, Consonant, Consonant,
+
+    // Bengali
+    Invalid, VowelMark, VowelMark, VowelMark,
+    Invalid, IndependentVowel, IndependentVowel, IndependentVowel,
+    IndependentVowel, IndependentVowel, IndependentVowel, IndependentVowel,
+    IndependentVowel, Invalid, Invalid, IndependentVowel,
+
+    IndependentVowel, Invalid, Invalid, IndependentVowel,
+    IndependentVowel, Consonant, Consonant, Consonant,
+    Consonant, Consonant, Consonant, Consonant,
+    Consonant, Consonant, Consonant, Consonant,
+
+    Consonant, Consonant, Consonant, Consonant,
+    Consonant, Consonant, Consonant, Consonant,
+    Consonant, Invalid, Consonant, Consonant,
+    Consonant, Consonant, Consonant, Consonant,
+
+    Consonant, Invalid, Consonant, Invalid,
+    Invalid, Invalid, Consonant, Consonant,
+    Consonant, Consonant, UnknownForm, UnknownForm,
+    Nukta, Other, Matra, Matra,
+
+    Matra, Matra, Matra, Matra,
+    Matra, Invalid, Invalid, Matra,
+    Matra, Invalid, Invalid, Matra,
+    Matra, Halant, Consonant, UnknownForm,
+
+    Invalid, Invalid, Invalid, Invalid,
+    Invalid, Invalid, Invalid, VowelMark,
+    Invalid, Invalid, Invalid, Invalid,
+    Consonant, Consonant, Invalid, Consonant,
+
+    IndependentVowel, IndependentVowel, VowelMark, VowelMark,
+    Other, Other, Other, Other,
+    Other, Other, Other, Other,
+    Other, Other, Other, Other,
+
+    Consonant, Consonant, Other, Other,
+    Other, Other, Other, Other,
+    Other, Other, Other, Other,
+    Other, Other, Other, Other,
+
+    // Gurmukhi
+    Invalid, VowelMark, VowelMark, VowelMark,
+    Invalid, IndependentVowel, IndependentVowel, IndependentVowel,
+    IndependentVowel, IndependentVowel, IndependentVowel, Invalid,
+    Invalid, Invalid, Invalid, IndependentVowel,
+
+    IndependentVowel, Invalid, Invalid, IndependentVowel,
+    IndependentVowel, Consonant, Consonant, Consonant,
+    Consonant, Consonant, Consonant, Consonant,
+    Consonant, Consonant, Consonant, Consonant,
+
+    Consonant, Consonant, Consonant, Consonant,
+    Consonant, Consonant, Consonant, Consonant,
+    Consonant, Invalid, Consonant, Consonant,
+    Consonant, Consonant, Consonant, Consonant,
+
+    Consonant, Invalid, Consonant, Consonant,
+    Invalid, Consonant, Consonant, Invalid,
+    Consonant, Consonant, UnknownForm, UnknownForm,
+    Nukta, Other, Matra, Matra,
+
+    Matra, Matra, Matra, Invalid,
+    Invalid, Invalid, Invalid, Matra,
+    Matra, Invalid, Invalid, Matra,
+    Matra, Halant, UnknownForm, UnknownForm,
+
+    Invalid, Invalid, Invalid, Invalid,
+    Invalid, UnknownForm, UnknownForm, UnknownForm,
+    Invalid, Consonant, Consonant, Consonant,
+    Consonant, Invalid, Consonant, Invalid,
+
+    Other, Other, Invalid, Invalid,
+    Other, Other, Other, Other,
+    Other, Other, Other, Other,
+    Other, Other, Other, Other,
+
+    StressMark, StressMark, Consonant, Consonant,
+    Other, Other, Other, Other,
+    Other, Other, Other, Other,
+    Other, Other, Other, Other,
+
+    // Gujarati
+    Invalid, VowelMark, VowelMark, VowelMark,
+    Invalid, IndependentVowel, IndependentVowel, IndependentVowel,
+    IndependentVowel, IndependentVowel, IndependentVowel, IndependentVowel,
+    IndependentVowel, IndependentVowel, Invalid, IndependentVowel,
+
+    IndependentVowel, IndependentVowel, Invalid, IndependentVowel,
+    IndependentVowel, Consonant, Consonant, Consonant,
+    Consonant, Consonant, Consonant, Consonant,
+    Consonant, Consonant, Consonant, Consonant,
+
+    Consonant, Consonant, Consonant, Consonant,
+    Consonant, Consonant, Consonant, Consonant,
+    Consonant, Invalid, Consonant, Consonant,
+    Consonant, Consonant, Consonant, Consonant,
+
+    Consonant, Invalid, Consonant, Consonant,
+    Invalid, Consonant, Consonant, Consonant,
+    Consonant, Consonant, UnknownForm, UnknownForm,
+    Nukta, Other, Matra, Matra,
+
+    Matra, Matra, Matra, Matra,
+    Matra, Matra, Invalid, Matra,
+    Matra, Matra, Invalid, Matra,
+    Matra, Halant, UnknownForm, UnknownForm,
+
+    Other, UnknownForm, UnknownForm, UnknownForm,
+    UnknownForm, UnknownForm, UnknownForm, UnknownForm,
+    UnknownForm, UnknownForm, UnknownForm, UnknownForm,
+    UnknownForm, UnknownForm, UnknownForm, UnknownForm,
+
+    IndependentVowel, IndependentVowel, VowelMark, VowelMark,
+    Other, Other, Other, Other,
+    Other, Other, Other, Other,
+    Other, Other, Other, Other,
+
+    Other, Other, Other, Other,
+    Other, Other, Other, Other,
+    Other, Other, Other, Other,
+    Other, Other, Other, Other,
+
+    // Oriya
+    Invalid, VowelMark, VowelMark, VowelMark,
+    Invalid, IndependentVowel, IndependentVowel, IndependentVowel,
+    IndependentVowel, IndependentVowel, IndependentVowel, IndependentVowel,
+    IndependentVowel, Invalid, Invalid, IndependentVowel,
+
+    IndependentVowel, Invalid, Invalid, IndependentVowel,
+    IndependentVowel, Consonant, Consonant, Consonant,
+    Consonant, Consonant, Consonant, Consonant,
+    Consonant, Consonant, Consonant, Consonant,
+
+    Consonant, Consonant, Consonant, Consonant,
+    Consonant, Consonant, Consonant, Consonant,
+    Consonant, Invalid, Consonant, Consonant,
+    Consonant, Consonant, Consonant, Consonant,
+
+    Consonant, Invalid, Consonant, Consonant,
+    Invalid, Consonant, Consonant, Consonant,
+    Consonant, Consonant, UnknownForm, UnknownForm,
+    Nukta, Other, Matra, Matra,
+
+    Matra, Matra, Matra, Matra,
+    Invalid, Invalid, Invalid, Matra,
+    Matra, Invalid, Invalid, Matra,
+    Matra, Halant, UnknownForm, UnknownForm,
+
+    Other, Invalid, Invalid, Invalid,
+    Invalid, UnknownForm, LengthMark, LengthMark,
+    Invalid, Invalid, Invalid, Invalid,
+    Consonant, Consonant, Invalid, Consonant,
+
+    IndependentVowel, IndependentVowel, Invalid, Invalid,
+    Invalid, Invalid, Other, Other,
+    Other, Other, Other, Other,
+    Other, Other, Other, Other,
+
+    Other, Consonant, Other, Other,
+    Other, Other, Other, Other,
+    Other, Other, Other, Other,
+    Other, Other, Other, Other,
+
+    //Tamil
+    Invalid, Invalid, VowelMark, Other,
+    Invalid, IndependentVowel, IndependentVowel, IndependentVowel,
+    IndependentVowel, IndependentVowel, IndependentVowel, Invalid,
+    Invalid, Invalid, IndependentVowel, IndependentVowel,
+
+    IndependentVowel, Invalid, IndependentVowel, IndependentVowel,
+    IndependentVowel, Consonant, Invalid, Invalid,
+    Invalid, Consonant, Consonant, Invalid,
+    Consonant, Invalid, Consonant, Consonant,
+
+    Invalid, Invalid, Invalid, Consonant,
+    Consonant, Invalid, Invalid, Invalid,
+    Consonant, Consonant, Consonant, Invalid,
+    Invalid, Invalid, Consonant, Consonant,
+
+    Consonant, Consonant, Consonant, Consonant,
+    Consonant, Consonant, Consonant, Consonant,
+    Consonant, Consonant, UnknownForm, UnknownForm,
+    Invalid, Invalid, Matra, Matra,
+
+    Matra, Matra, Matra, Invalid,
+    Invalid, Invalid, Matra, Matra,
+    Matra, Invalid, Matra, Matra,
+    Matra, Halant, Invalid, Invalid,
+
+    Invalid, Invalid, Invalid, Invalid,
+    Invalid, Invalid, Invalid, LengthMark,
+    Invalid, Invalid, Invalid, Invalid,
+    Invalid, Invalid, Invalid, Invalid,
+
+    Invalid, Invalid, Invalid, Invalid,
+    Invalid, Invalid, Other, Other,
+    Other, Other, Other, Other,
+    Other, Other, Other, Other,
+
+    Other, Other, Other, Other,
+    Other, Other, Other, Other,
+    Other, Other, Other, Other,
+    Other, Other, Other, Other,
+
+    // Telugu
+    Invalid, VowelMark, VowelMark, VowelMark,
+    Invalid, IndependentVowel, IndependentVowel, IndependentVowel,
+    IndependentVowel, IndependentVowel, IndependentVowel, IndependentVowel,
+    IndependentVowel, Invalid, IndependentVowel, IndependentVowel,
+
+    IndependentVowel, Invalid, IndependentVowel, IndependentVowel,
+    IndependentVowel, Consonant, Consonant, Consonant,
+    Consonant, Consonant, Consonant, Consonant,
+    Consonant, Consonant, Consonant, Consonant,
+
+    Consonant, Consonant, Consonant, Consonant,
+    Consonant, Consonant, Consonant, Consonant,
+    Consonant, Invalid, Consonant, Consonant,
+    Consonant, Consonant, Consonant, Consonant,
+
+    Consonant, Consonant, Consonant, Consonant,
+    Invalid, Consonant, Consonant, Consonant,
+    Consonant, Consonant, UnknownForm, UnknownForm,
+    Invalid, Invalid, Matra, Matra,
+
+    Matra, Matra, Matra, Matra,
+    Matra, Invalid, Matra, Matra,
+    Matra, Invalid, Matra, Matra,
+    Matra, Halant, Invalid, Invalid,
+
+    Invalid, Invalid, Invalid, Invalid,
+    Invalid, LengthMark, Matra, Invalid,
+    Invalid, Invalid, Invalid, Invalid,
+    Invalid, Invalid, Invalid, Invalid,
+
+    IndependentVowel, IndependentVowel, Invalid, Invalid,
+    Invalid, Invalid, Other, Other,
+    Other, Other, Other, Other,
+    Other, Other, Other, Other,
+
+    Other, Other, Other, Other,
+    Other, Other, Other, Other,
+    Other, Other, Other, Other,
+    Other, Other, Other, Other,
+
+    // Kannada
+    Invalid, Invalid, VowelMark, VowelMark,
+    Invalid, IndependentVowel, IndependentVowel, IndependentVowel,
+    IndependentVowel, IndependentVowel, IndependentVowel, IndependentVowel,
+    IndependentVowel, Invalid, IndependentVowel, IndependentVowel,
+
+    IndependentVowel, Invalid, IndependentVowel, IndependentVowel,
+    IndependentVowel, Consonant, Consonant, Consonant,
+    Consonant, Consonant, Consonant, Consonant,
+    Consonant, Consonant, Consonant, Consonant,
+
+    Consonant, Consonant, Consonant, Consonant,
+    Consonant, Consonant, Consonant, Consonant,
+    Consonant, Invalid, Consonant, Consonant,
+    Consonant, Consonant, Consonant, Consonant,
+
+    Consonant, Consonant, Consonant, Consonant,
+    Invalid, Consonant, Consonant, Consonant,
+    Consonant, Consonant, UnknownForm, UnknownForm,
+    Nukta, Other, Matra, Matra,
+
+    Matra, Matra, Matra, Matra,
+    Matra, Invalid, Matra, Matra,
+    Matra, Invalid, Matra, Matra,
+    Matra, Halant, Invalid, Invalid,
+
+    Invalid, Invalid, Invalid, Invalid,
+    Invalid, LengthMark, LengthMark, Invalid,
+    Invalid, Invalid, Invalid, Invalid,
+    Invalid, Invalid, Consonant, Invalid,
+
+    IndependentVowel, IndependentVowel, VowelMark, VowelMark,
+    Invalid, Invalid, Other, Other,
+    Other, Other, Other, Other,
+    Other, Other, Other, Other,
+
+    Other, Other, Other, Other,
+    Other, Other, Other, Other,
+    Other, Other, Other, Other,
+    Other, Other, Other, Other,
+
+    // Malayalam
+    Invalid, Invalid, VowelMark, VowelMark,
+    Invalid, IndependentVowel, IndependentVowel, IndependentVowel,
+    IndependentVowel, IndependentVowel, IndependentVowel, IndependentVowel,
+    IndependentVowel, Invalid, IndependentVowel, IndependentVowel,
+
+    IndependentVowel, Invalid, IndependentVowel, IndependentVowel,
+    IndependentVowel, Consonant, Consonant, Consonant,
+    Consonant, Consonant, Consonant, Consonant,
+    Consonant, Consonant, Consonant, Consonant,
+
+    Consonant, Consonant, Consonant, Consonant,
+    Consonant, Consonant, Consonant, Consonant,
+    Consonant, Invalid, Consonant, Consonant,
+    Consonant, Consonant, Consonant, Consonant,
+
+    Consonant, Consonant, Consonant, Consonant,
+    Consonant, Consonant, Consonant, Consonant,
+    Consonant, Consonant, UnknownForm, UnknownForm,
+    Invalid, Invalid, Matra, Matra,
+
+    Matra, Matra, Matra, Matra,
+    Invalid, Invalid, Matra, Matra,
+    Matra, Invalid, Matra, Matra,
+    Matra, Halant, Invalid, Invalid,
+
+    Invalid, Invalid, Invalid, Invalid,
+    Invalid, Invalid, Invalid, Matra,
+    Invalid, Invalid, Invalid, Invalid,
+    Invalid, Invalid, Invalid, Invalid,
+
+    IndependentVowel, IndependentVowel, Invalid, Invalid,
+    Invalid, Invalid, Other, Other,
+    Other, Other, Other, Other,
+    Other, Other, Other, Other,
+
+    Other, Other, Other, Other,
+    Other, Other, Other, Other,
+    Other, Other, Other, Other,
+    Other, Other, Other, Other,
+
+    // Sinhala
+    Invalid, Invalid, VowelMark, VowelMark,
+    Invalid, IndependentVowel, IndependentVowel, IndependentVowel,
+    IndependentVowel, IndependentVowel, IndependentVowel, IndependentVowel,
+    IndependentVowel, IndependentVowel, IndependentVowel, IndependentVowel,
+
+    IndependentVowel, IndependentVowel, IndependentVowel, IndependentVowel,
+    IndependentVowel, IndependentVowel, IndependentVowel, Invalid,
+    Invalid, Invalid, Consonant, Consonant,
+    Consonant, Consonant, Consonant, Consonant,
+
+    Consonant, Consonant, Consonant, Consonant,
+    Consonant, Consonant, Consonant, Consonant,
+    Consonant, Consonant, Consonant, Consonant,
+    Consonant, Consonant, Consonant, Consonant,
+
+    Consonant, Consonant, Invalid, Consonant,
+    Consonant, Consonant, Consonant, Consonant,
+    Consonant, Consonant, Consonant, Consonant,
+    Invalid, Consonant, Invalid, Invalid,
+
+    Consonant, Consonant, Consonant, Consonant,
+    Consonant, Consonant, Consonant, Invalid,
+    Invalid, Invalid, Halant, Invalid,
+    Invalid, Invalid, Invalid, Matra,
+
+    Matra, Matra, Matra, Matra,
+    Matra, Invalid, Matra, Invalid,
+    Matra, Matra, Matra, Matra,
+    Matra, Matra, Matra, Matra,
+
+    Invalid, Invalid, Invalid, Invalid,
+    Invalid, Invalid, Invalid, Invalid,
+    Invalid, Invalid, Invalid, Invalid,
+    Invalid, Invalid, Invalid, Invalid,
+
+    Invalid, Invalid, Matra, Matra,
+    Other, Other, Other, Other,
+    Other, Other, Other, Other,
+    Other, Other, Other, Other,
+};
+
+enum Position {
+    None,
+    Pre,
+    Above,
+    Below,
+    Post,
+    Split,
+    Base,
+    Reph,
+    Vattu,
+    Inherit
+};
+
+static const unsigned char indicPosition[0xe00-0x900] = {
+    // Devanagari
+    None, Above, Above, Post,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+
+    Below, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, Post, Pre,
+
+    Post, Below, Below, Below,
+    Below, Above, Above, Above,
+    Above, Post, Post, Post,
+    Post, None, None, None,
+
+    None, Above, Below, Above,
+    Above, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+
+    None, None, Below, Below,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+
+    // Bengali
+    None, Above, Post, Post,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+    Below, None, None, Post,
+
+    Below, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+    Below, None, Post, Pre,
+
+    Post, Below, Below, Below,
+    Below, None, None, Pre,
+    Pre, None, None, Split,
+    Split, Below, None, None,
+
+    None, None, None, None,
+    None, None, None, Post,
+    None, None, None, None,
+    None, None, None, None,
+
+    None, None, Below, Below,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+
+    Below, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+
+    // Gurmukhi
+    None, Above, Above, Post,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, Post,
+
+    Below, None, None, None,
+    None, Below, None, None,
+    None, Below, None, None,
+    Below, None, Post, Pre,
+
+    Post, Below, Below, None,
+    None, None, None, Above,
+    Above, None, None, Above,
+    Above, None, None, None,
+
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+
+    Above, Above, None, None,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+
+    // Gujarati
+    None, Above, Above, Post,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+
+    Below, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, Post, Pre,
+
+    Post, Below, Below, Below,
+    Below, Above, None, Above,
+    Above, Post, None, Post,
+    Post, None, None, None,
+
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+
+    None, None, Below, Below,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+
+    // Oriya
+    None, Above, Post, Post,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+
+    None, None, None, None,
+    Below, None, None, None,
+    Below, None, None, None,
+    Below, Below, Below, Post,
+
+    Below, None, Below, Below,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, Post, Above,
+
+    Post, Below, Below, Below,
+    None, None, None, Pre,
+    Split, None, None, Split,
+    Split, None, None, None,
+
+    None, None, None, None,
+    None, None, Above, Post,
+    None, None, None, None,
+    None, None, None, Post,
+
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+
+    None, Below, None, None,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+
+    // Tamil
+    None, None, Above, None,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, Post, Post,
+
+    Above, Below, Below, None,
+    None, None, Pre, Pre,
+    Pre, None, Split, Split,
+    Split, Halant, None, None,
+
+    None, None, None, None,
+    None, None, None, Post,
+    None, None, None, None,
+    None, None, None, None,
+
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+
+    // Telugu
+    None, Post, Post, Post,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+
+    None, None, None, None,
+    None, Below, Below, Below,
+    Below, Below, Below, Below,
+    Below, Below, Below, Below,
+
+    Below, Below, Below, Below,
+    Below, Below, Below, Below,
+    Below, None, Below, Below,
+    Below, Below, Below, Below,
+
+    Below, None, Below, Below,
+    None, Below, Below, Below,
+    Below, Below, None, None,
+    None, None, Post, Above,
+
+    Above, Post, Post, Post,
+    Post, None, Above, Above,
+    Split, None, Post, Above,
+    Above, Halant, None, None,
+
+    None, None, None, None,
+    None, Above, Below, None,
+    None, None, None, None,
+    None, None, None, None,
+
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+
+    // Kannada
+    None, None, Post, Post,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+
+    None, None, None, None,
+    None, Below, Below, Below,
+    Below, Below, Below, Below,
+    Below, Below, Below, Below,
+
+    Below, Below, Below, Below,
+    Below, Below, Below, Below,
+    Below, Below, Below, Below,
+    Below, Below, Below, Below,
+
+    Below, None, Below, Below,
+    None, Below, Below, Below,
+    Below, Below, None, None,
+    None, None, Post, Above,
+
+    Split, Post, Post, Post,
+    Post, None, Above, Split,
+    Split, None, Split, Split,
+    Above, Halant, None, None,
+
+    None, None, None, None,
+    None, Post, Post, None,
+    None, None, None, None,
+    None, None, Below, None,
+
+    None, None, Below, Below,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+
+    // Malayalam
+    None, None, Post, Post,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, Post,
+
+    Post, None, Below, None,
+    None, Post, None, None,
+    None, None, None, None,
+    None, None, Post, Post,
+
+    Post, Post, Post, Post,
+    None, None, Pre, Pre,
+    Pre, None, Split, Split,
+    Split, Halant, None, None,
+
+    None, None, None, None,
+    None, None, None, Post,
+    None, None, None, None,
+    None, None, None, None,
+
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+
+    // Sinhala
+    None, None, Post, Post,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, Post,
+
+    Post, Post, Above, Above,
+    Below, None, Below, None,
+    Post, Pre, Split, Pre,
+    Split, Split, Split, Post,
+
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None,
+
+    None, None, Post, Post,
+    None, None, None, None,
+    None, None, None, None,
+    None, None, None, None
+};
+
+static inline Form form(unsigned short uc) {
+    if (uc < 0x900 || uc > 0xdff) {
+        if (uc == 0x25cc)
+            return Consonant;
+        if (uc == 0x200c || uc == 0x200d)
+            return Control;
+        return Other;
+    }
+    return (Form)indicForms[uc-0x900];
+}
+
+static inline Position indic_position(unsigned short uc) {
+    if (uc < 0x900 || uc > 0xdff)
+        return None;
+    return (Position) indicPosition[uc-0x900];
+}
+
+
+enum IndicScriptProperties {
+    HasReph = 0x01,
+    HasSplit = 0x02
+};
+
+const hb_uint8 scriptProperties[10] = {
+    // Devanagari,
+    HasReph,
+    // Bengali,
+    HasReph|HasSplit,
+    // Gurmukhi,
+    0,
+    // Gujarati,
+    HasReph,
+    // Oriya,
+    HasReph|HasSplit,
+    // Tamil,
+    HasSplit,
+    // Telugu,
+    HasSplit,
+    // Kannada,
+    HasSplit|HasReph,
+    // Malayalam,
+    HasSplit,
+    // Sinhala,
+    HasSplit
+};
+
+struct IndicOrdering {
+    Form form;
+    Position position;
+};
+
+static const IndicOrdering devanagari_order [] = {
+    { Consonant, Below },
+    { Matra, Below },
+    { VowelMark, Below },
+    { StressMark, Below },
+    { Matra, Above },
+    { Matra, Post },
+    { Consonant, Reph },
+    { VowelMark, Above },
+    { StressMark, Above },
+    { VowelMark, Post },
+    { (Form)0, None }
+};
+
+static const IndicOrdering bengali_order [] = {
+    { Consonant, Below },
+    { Matra, Below },
+    { Matra, Above },
+    { Consonant, Reph },
+    { VowelMark, Above },
+    { Consonant, Post },
+    { Matra, Post },
+    { VowelMark, Post },
+    { (Form)0, None }
+};
+
+static const IndicOrdering gurmukhi_order [] = {
+    { Consonant, Below },
+    { Matra, Below },
+    { Matra, Above },
+    { Consonant, Post },
+    { Matra, Post },
+    { VowelMark, Above },
+    { (Form)0, None }
+};
+
+static const IndicOrdering tamil_order [] = {
+    { Matra, Above },
+    { Matra, Post },
+    { VowelMark, Post },
+    { (Form)0, None }
+};
+
+static const IndicOrdering telugu_order [] = {
+    { Matra, Above },
+    { Matra, Below },
+    { Matra, Post },
+    { Consonant, Below },
+    { Consonant, Post },
+    { VowelMark, Post },
+    { (Form)0, None }
+};
+
+static const IndicOrdering kannada_order [] = {
+    { Matra, Above },
+    { Matra, Post },
+    { Consonant, Below },
+    { Consonant, Post },
+    { LengthMark, Post },
+    { Consonant, Reph },
+    { VowelMark, Post },
+    { (Form)0, None }
+};
+
+static const IndicOrdering malayalam_order [] = {
+    { Consonant, Below },
+    { Matra, Below },
+    { Consonant, Reph },
+    { Consonant, Post },
+    { Matra, Post },
+    { VowelMark, Post },
+    { (Form)0, None }
+};
+
+static const IndicOrdering sinhala_order [] = {
+    { Matra, Below },
+    { Matra, Above },
+    { Matra, Post },
+    { VowelMark, Post },
+    { (Form)0, None }
+};
+
+static const IndicOrdering * const indic_order[] = {
+    devanagari_order, // Devanagari
+    bengali_order, // Bengali
+    gurmukhi_order, // Gurmukhi
+    devanagari_order, // Gujarati
+    bengali_order, // Oriya
+    tamil_order, // Tamil
+    telugu_order, // Telugu
+    kannada_order, // Kannada
+    malayalam_order, // Malayalam
+    sinhala_order // Sinhala
+};
+
+
+
+// vowel matras that have to be split into two parts.
+static const unsigned short split_matras[]  = {
+    //  matra, split1, split2, split3
+
+    // bengalis
+    0x9cb, 0x9c7, 0x9be, 0x0,
+    0x9cc, 0x9c7, 0x9d7, 0x0,
+    // oriya
+    0xb48, 0xb47, 0xb56, 0x0,
+    0xb4b, 0xb47, 0xb3e, 0x0,
+    0xb4c, 0xb47, 0xb57, 0x0,
+    // tamil
+    0xbca, 0xbc6, 0xbbe, 0x0,
+    0xbcb, 0xbc7, 0xbbe, 0x0,
+    0xbcc, 0xbc6, 0xbd7, 0x0,
+    // telugu
+    0xc48, 0xc46, 0xc56, 0x0,
+    // kannada
+    0xcc0, 0xcbf, 0xcd5, 0x0,
+    0xcc7, 0xcc6, 0xcd5, 0x0,
+    0xcc8, 0xcc6, 0xcd6, 0x0,
+    0xcca, 0xcc6, 0xcc2, 0x0,
+    0xccb, 0xcc6, 0xcc2, 0xcd5,
+    // malayalam
+    0xd4a, 0xd46, 0xd3e, 0x0,
+    0xd4b, 0xd47, 0xd3e, 0x0,
+    0xd4c, 0xd46, 0xd57, 0x0,
+    // sinhala
+    0xdda, 0xdd9, 0xdca, 0x0,
+    0xddc, 0xdd9, 0xdcf, 0x0,
+    0xddd, 0xdd9, 0xdcf, 0xdca,
+    0xdde, 0xdd9, 0xddf, 0x0,
+    0xffff
+};
+
+static inline void splitMatra(unsigned short *reordered, int matra, int &len)
+{
+    unsigned short matra_uc = reordered[matra];
+    //qDebug("matra=%d, reordered[matra]=%x", matra, reordered[matra]);
+
+    const unsigned short *split = split_matras;
+    while (split[0] < matra_uc)
+        split += 4;
+
+    assert(*split == matra_uc);
+    ++split;
+
+    int added_chars = split[2] == 0x0 ? 1 : 2;
+
+    memmove(reordered + matra + added_chars, reordered + matra, (len-matra)*sizeof(unsigned short));
+    reordered[matra] = split[0];
+    reordered[matra+1] = split[1];
+    if(added_chars == 2)
+        reordered[matra+2] = split[2];
+    len += added_chars;
+}
+
+#ifndef NO_OPENTYPE
+static const HB_OpenTypeFeature indic_features[] = {
+    { HB_MAKE_TAG('c', 'c', 'm', 'p'), CcmpProperty },
+    { HB_MAKE_TAG('i', 'n', 'i', 't'), InitProperty },
+    { HB_MAKE_TAG('n', 'u', 'k', 't'), NuktaProperty },
+    { HB_MAKE_TAG('a', 'k', 'h', 'n'), AkhantProperty },
+    { HB_MAKE_TAG('r', 'p', 'h', 'f'), RephProperty },
+    { HB_MAKE_TAG('b', 'l', 'w', 'f'), BelowFormProperty },
+    { HB_MAKE_TAG('h', 'a', 'l', 'f'), HalfFormProperty },
+    { HB_MAKE_TAG('p', 's', 't', 'f'), PostFormProperty },
+    { HB_MAKE_TAG('v', 'a', 't', 'u'), VattuProperty },
+    { HB_MAKE_TAG('p', 'r', 'e', 's'), PreSubstProperty },
+    { HB_MAKE_TAG('b', 'l', 'w', 's'), BelowSubstProperty },
+    { HB_MAKE_TAG('a', 'b', 'v', 's'), AboveSubstProperty },
+    { HB_MAKE_TAG('p', 's', 't', 's'), PostSubstProperty },
+    { HB_MAKE_TAG('h', 'a', 'l', 'n'), HalantProperty },
+    { 0, 0 }
+};
+#endif
+
+// #define INDIC_DEBUG
+#ifdef INDIC_DEBUG
+#define IDEBUG hb_debug
+#include <stdarg.h>
+
+static void hb_debug(const char *msg, ...)
+{
+    va_list ap;
+    va_start(ap, msg); // use variable arg list
+    vfprintf(stderr, msg, ap);
+    va_end(ap);
+    fprintf(stderr, "\n");
+}
+
+#else
+#define IDEBUG if(0) printf
+#endif
+
+#if 0 //def INDIC_DEBUG
+static QString propertiesToString(int properties)
+{
+    QString res;
+    properties = ~properties;
+    if (properties & CcmpProperty)
+        res += "Ccmp ";
+    if (properties & InitProperty)
+        res += "Init ";
+    if (properties & NuktaProperty)
+        res += "Nukta ";
+    if (properties & AkhantProperty)
+        res += "Akhant ";
+    if (properties & RephProperty)
+        res += "Reph ";
+    if (properties & PreFormProperty)
+        res += "PreForm ";
+    if (properties & BelowFormProperty)
+        res += "BelowForm ";
+    if (properties & AboveFormProperty)
+        res += "AboveForm ";
+    if (properties & HalfFormProperty)
+        res += "HalfForm ";
+    if (properties & PostFormProperty)
+        res += "PostForm ";
+    if (properties & VattuProperty)
+        res += "Vattu ";
+    if (properties & PreSubstProperty)
+        res += "PreSubst ";
+    if (properties & BelowSubstProperty)
+        res += "BelowSubst ";
+    if (properties & AboveSubstProperty)
+        res += "AboveSubst ";
+    if (properties & PostSubstProperty)
+        res += "PostSubst ";
+    if (properties & HalantProperty)
+        res += "Halant ";
+    if (properties & CligProperty)
+        res += "Clig ";
+    return res;
+}
+#endif
+
+static bool indic_shape_syllable(HB_Bool openType, HB_ShaperItem *item, bool invalid)
+{
+    HB_Script script = item->item.script;
+    assert(script >= HB_Script_Devanagari && script <= HB_Script_Sinhala);
+    const unsigned short script_base = 0x0900 + 0x80*(script-HB_Script_Devanagari);
+    const unsigned short ra = script_base + 0x30;
+    const unsigned short halant = script_base + 0x4d;
+    const unsigned short nukta = script_base + 0x3c;
+    bool control = false;
+
+    int len = (int)item->item.length;
+    IDEBUG(">>>>> indic shape: from=%d, len=%d invalid=%d", item->item.pos, item->item.length, invalid);
+
+    if ((int)item->num_glyphs < len+4) {
+        item->num_glyphs = len+4;
+        return false;
+    }
+
+    HB_STACKARRAY(HB_UChar16, reordered, len + 4);
+    HB_STACKARRAY(hb_uint8, position, len + 4);
+
+    unsigned char properties = scriptProperties[script-HB_Script_Devanagari];
+
+    if (invalid) {
+        *reordered = 0x25cc;
+        memcpy(reordered+1, item->string + item->item.pos, len*sizeof(HB_UChar16));
+        len++;
+    } else {
+        memcpy(reordered, item->string + item->item.pos, len*sizeof(HB_UChar16));
+    }
+    if (reordered[len-1] == 0x200c) // zero width non joiner
+        len--;
+
+    int i;
+    int base = 0;
+    int reph = -1;
+
+#ifdef INDIC_DEBUG
+    IDEBUG("original:");
+    for (i = 0; i < len; i++) {
+        IDEBUG("    %d: %4x", i, reordered[i]);
+    }
+#endif
+
+    if (len != 1) {
+        HB_UChar16 *uc = reordered;
+        bool beginsWithRa = false;
+
+        // Rule 1: find base consonant
+        //
+        // The shaping engine finds the base consonant of the
+        // syllable, using the following algorithm: starting from the
+        // end of the syllable, move backwards until a consonant is
+        // found that does not have a below-base or post-base form
+        // (post-base forms have to follow below-base forms), or
+        // arrive at the first consonant. The consonant stopped at
+        // will be the base.
+        //
+        //  * If the syllable starts with Ra + H (in a script that has
+        //    'Reph'), Ra is excluded from candidates for base
+        //    consonants.
+        //
+        // * In Kannada and Telugu, the base consonant cannot be
+        //   farther than 3 consonants from the end of the syllable.
+        // #### replace the HasReph property by testing if the feature exists in the font!
+        if (form(*uc) == Consonant || (script == HB_Script_Bengali && form(*uc) == IndependentVowel)) {
+            if ((properties & HasReph) && (len > 2) &&
+                (*uc == ra || *uc == 0x9f0) && *(uc+1) == halant)
+                beginsWithRa = true;
+
+            if (beginsWithRa && form(*(uc+2)) == Control)
+                beginsWithRa = false;
+
+            base = (beginsWithRa ? 2 : 0);
+            IDEBUG("    length = %d, beginsWithRa = %d, base=%d", len, beginsWithRa, base);
+
+            int lastConsonant = 0;
+            int matra = -1;
+            // we remember:
+            // * the last consonant since we need it for rule 2
+            // * the matras position for rule 3 and 4
+
+            // figure out possible base glyphs
+            memset(position, 0, len);
+            if (script == HB_Script_Devanagari || script == HB_Script_Gujarati) {
+                bool vattu = false;
+                for (i = base; i < len; ++i) {
+                    position[i] = form(uc[i]);
+                    if (position[i] == Consonant) {
+                        lastConsonant = i;
+                        vattu = (!vattu && uc[i] == ra);
+                        if (vattu) {
+                            IDEBUG("excluding vattu glyph at %d from base candidates", i);
+                            position[i] = Vattu;
+                        }
+                    } else if (position[i] == Matra) {
+                        matra = i;
+                    }
+                }
+            } else {
+                for (i = base; i < len; ++i) {
+                    position[i] = form(uc[i]);
+                    if (position[i] == Consonant)
+                        lastConsonant = i;
+                    else if (matra < 0 && position[i] == Matra)
+                        matra = i;
+                }
+            }
+            int skipped = 0;
+            Position pos = Post;
+            for (i = len-1; i > base; i--) {
+                if (position[i] != Consonant && (position[i] != Control || script == HB_Script_Kannada))
+                    continue;
+
+                Position charPosition = indic_position(uc[i]);
+                if (pos == Post && charPosition == Post) {
+                    pos = Post;
+                } else if ((pos == Post || pos == Below) && charPosition == Below) {
+                    if (script == HB_Script_Devanagari || script == HB_Script_Gujarati)
+                        base = i;
+                    pos = Below;
+                } else {
+                    base = i;
+                    break;
+                }
+                if (skipped == 2 && (script == HB_Script_Kannada || script == HB_Script_Telugu)) {
+                    base = i;
+                    break;
+                }
+                ++skipped;
+            }
+
+            IDEBUG("    base consonant at %d skipped=%d, lastConsonant=%d", base, skipped, lastConsonant);
+
+            // Rule 2:
+            //
+            // If the base consonant is not the last one, Uniscribe
+            // moves the halant from the base consonant to the last
+            // one.
+            if (lastConsonant > base) {
+                int halantPos = 0;
+                if (uc[base+1] == halant)
+                    halantPos = base + 1;
+                else if (uc[base+1] == nukta && uc[base+2] == halant)
+                    halantPos = base + 2;
+                if (halantPos > 0) {
+                    IDEBUG("    moving halant from %d to %d!", base+1, lastConsonant);
+                    for (i = halantPos; i < lastConsonant; i++)
+                        uc[i] = uc[i+1];
+                    uc[lastConsonant] = halant;
+                }
+            }
+
+            // Rule 3:
+            //
+            // If the syllable starts with Ra + H, Uniscribe moves
+            // this combination so that it follows either:
+
+            // * the post-base 'matra' (if any) or the base consonant
+            //   (in scripts that show similarity to Devanagari, i.e.,
+            //   Devanagari, Gujarati, Bengali)
+            // * the base consonant (other scripts)
+            // * the end of the syllable (Kannada)
+
+            Position matra_position = None;
+            if (matra > 0)
+                matra_position = indic_position(uc[matra]);
+            IDEBUG("    matra at %d with form %d, base=%d", matra, matra_position, base);
+
+            if (beginsWithRa && base != 0) {
+                int toPos = base+1;
+                if (toPos < len && uc[toPos] == nukta)
+                    toPos++;
+                if (toPos < len && uc[toPos] == halant)
+                    toPos++;
+                if (toPos < len && uc[toPos] == 0x200d)
+                    toPos++;
+                if (toPos < len-1 && uc[toPos] == ra && uc[toPos+1] == halant)
+                    toPos += 2;
+                if (script == HB_Script_Devanagari || script == HB_Script_Gujarati || script == HB_Script_Bengali) {
+                    if (matra_position == Post || matra_position == Split) {
+                        toPos = matra+1;
+                        matra -= 2;
+                    }
+                } else if (script == HB_Script_Kannada) {
+                    toPos = len;
+                    matra -= 2;
+                }
+
+                IDEBUG("moving leading ra+halant to position %d", toPos);
+                for (i = 2; i < toPos; i++)
+                    uc[i-2] = uc[i];
+                uc[toPos-2] = ra;
+                uc[toPos-1] = halant;
+                base -= 2;
+                if (properties & HasReph)
+                    reph = toPos-2;
+            }
+
+            // Rule 4:
+
+            // Uniscribe splits two- or three-part matras into their
+            // parts. This splitting is a character-to-character
+            // operation).
+            //
+            //      Uniscribe describes some moving operations for these
+            //      matras here. For shaping however all pre matras need
+            //      to be at the beginning of the syllable, so we just move
+            //      them there now.
+            if (matra_position == Split) {
+                splitMatra(uc, matra, len);
+                // Handle three-part matras (0xccb in Kannada)
+                matra_position = indic_position(uc[matra]);
+            }
+
+            if (matra_position == Pre) {
+                unsigned short m = uc[matra];
+                while (matra--)
+                    uc[matra+1] = uc[matra];
+                uc[0] = m;
+                base++;
+            }
+        }
+
+        // Rule 5:
+        //
+        // Uniscribe classifies consonants and 'matra' parts as
+        // pre-base, above-base (Reph), below-base or post-base. This
+        // classification exists on the character code level and is
+        // language-dependent, not font-dependent.
+        for (i = 0; i < base; ++i)
+            position[i] = Pre;
+        position[base] = Base;
+        for (i = base+1; i < len; ++i) {
+            position[i] = indic_position(uc[i]);
+            // #### replace by adjusting table
+            if (uc[i] == nukta || uc[i] == halant)
+                position[i] = Inherit;
+        }
+        if (reph > 0) {
+            // recalculate reph, it might have changed.
+            for (i = base+1; i < len; ++i)
+                if (uc[i] == ra)
+                    reph = i;
+            position[reph] = Reph;
+            position[reph+1] = Inherit;
+        }
+
+        // all reordering happens now to the chars after the base
+        int fixed = base+1;
+        if (fixed < len && uc[fixed] == nukta)
+            fixed++;
+        if (fixed < len && uc[fixed] == halant)
+            fixed++;
+        if (fixed < len && uc[fixed] == 0x200d)
+            fixed++;
+
+#ifdef INDIC_DEBUG
+        for (i = fixed; i < len; ++i)
+            IDEBUG("position[%d] = %d, form=%d uc=%x", i, position[i], form(uc[i]), uc[i]);
+#endif
+        // we continuosly position the matras and vowel marks and increase the fixed
+        // until we reached the end.
+        const IndicOrdering *finalOrder = indic_order[script-HB_Script_Devanagari];
+
+        IDEBUG("    reordering pass:");
+        IDEBUG("        base=%d fixed=%d", base, fixed);
+        int toMove = 0;
+        while (finalOrder[toMove].form && fixed < len-1) {
+            IDEBUG("        fixed = %d, toMove=%d, moving form %d with pos %d", fixed, toMove, finalOrder[toMove].form, finalOrder[toMove].position);
+            for (i = fixed; i < len; i++) {
+//                IDEBUG() << "           i=" << i << "uc=" << hex << uc[i] << "form=" << form(uc[i])
+//                         << "position=" << position[i];
+                if (form(uc[i]) == finalOrder[toMove].form &&
+                     position[i] == finalOrder[toMove].position) {
+                    // need to move this glyph
+                    int to = fixed;
+                    if (i < len-1 && position[i+1] == Inherit) {
+                        IDEBUG("         moving two chars from %d to %d", i, to);
+                        unsigned short ch = uc[i];
+                        unsigned short ch2 = uc[i+1];
+                        unsigned char pos = position[i];
+                        for (int j = i+1; j > to+1; j--) {
+                            uc[j] = uc[j-2];
+                            position[j] = position[j-2];
+                        }
+                        uc[to] = ch;
+                        uc[to+1] = ch2;
+                        position[to] = pos;
+                        position[to+1] = pos;
+                        fixed += 2;
+                    } else {
+                        IDEBUG("         moving one char from %d to %d", i, to);
+                        unsigned short ch = uc[i];
+                        unsigned char pos = position[i];
+                        for (int j = i; j > to; j--) {
+                            uc[j] = uc[j-1];
+                            position[j] = position[j-1];
+                        }
+                        uc[to] = ch;
+                        position[to] = pos;
+                        fixed++;
+                    }
+                }
+            }
+            toMove++;
+        }
+
+    }
+
+    if (reph > 0) {
+        // recalculate reph, it might have changed.
+        for (i = base+1; i < len; ++i)
+            if (reordered[i] == ra)
+                reph = i;
+    }
+
+#ifndef NO_OPENTYPE
+    const int availableGlyphs = item->num_glyphs;
+#endif
+    if (!item->font->klass->convertStringToGlyphIndices(item->font,
+                                                        reordered, len,
+                                                        item->glyphs, &item->num_glyphs,
+                                                        item->item.bidiLevel % 2))
+        goto error;
+
+
+    IDEBUG("  base=%d, reph=%d", base, reph);
+    IDEBUG("reordered:");
+    for (i = 0; i < len; i++) {
+        item->attributes[i].mark = false;
+        item->attributes[i].clusterStart = false;
+        item->attributes[i].justification = 0;
+        item->attributes[i].zeroWidth = false;
+        IDEBUG("    %d: %4x", i, reordered[i]);
+    }
+
+    // now we have the syllable in the right order, and can start running it through open type.
+
+    for (i = 0; i < len; ++i)
+        control |= (form(reordered[i]) == Control);
+
+#ifndef NO_OPENTYPE
+    if (openType) {
+
+        // we need to keep track of where the base glyph is for some
+        // scripts and use the cluster feature for this.  This
+        // also means we have to correct the logCluster output from
+        // the open type engine manually afterwards.  for indic this
+        // is rather simple, as all chars just point to the first
+        // glyph in the syllable.
+        HB_STACKARRAY(unsigned short, clusters, len);
+        HB_STACKARRAY(unsigned int, properties, len);
+
+        for (i = 0; i < len; ++i)
+            clusters[i] = i;
+
+        // features we should always apply
+        for (i = 0; i < len; ++i)
+            properties[i] = ~(CcmpProperty
+                              | NuktaProperty
+                              | VattuProperty
+                              | PreSubstProperty
+                              | BelowSubstProperty
+                              | AboveSubstProperty
+                              | PostSubstProperty
+                              | HalantProperty
+                              | PositioningProperties);
+
+        // Ccmp always applies
+        // Init
+        if (item->item.pos == 0
+            || !(isLetter(item->string[item->item.pos-1]) || isMark(item->string[item->item.pos-1])))
+            properties[0] &= ~InitProperty;
+
+        // Nukta always applies
+        // Akhant
+        for (i = 0; i <= base; ++i)
+            properties[i] &= ~AkhantProperty;
+        // Reph
+        if (reph >= 0) {
+            properties[reph] &= ~RephProperty;
+            properties[reph+1] &= ~RephProperty;
+        }
+        // BelowForm
+        for (i = base+1; i < len; ++i)
+            properties[i] &= ~BelowFormProperty;
+
+        if (script == HB_Script_Devanagari || script == HB_Script_Gujarati) {
+            // vattu glyphs need this aswell
+            bool vattu = false;
+            for (i = base-2; i > 1; --i) {
+                if (form(reordered[i]) == Consonant) {
+                    vattu = (!vattu && reordered[i] == ra);
+                    if (vattu) {
+                        IDEBUG("forming vattu ligature at %d", i);
+                        properties[i] &= ~BelowFormProperty;
+                        properties[i+1] &= ~BelowFormProperty;
+                    }
+                }
+            }
+        }
+        // HalfFormProperty
+        for (i = 0; i < base; ++i)
+            properties[i] &= ~HalfFormProperty;
+        if (control) {
+            for (i = 2; i < len; ++i) {
+                if (reordered[i] == 0x200d /* ZWJ */) {
+                    properties[i-1] &= ~HalfFormProperty;
+                    properties[i-2] &= ~HalfFormProperty;
+                } else if (reordered[i] == 0x200c /* ZWNJ */) {
+                    properties[i-1] &= ~HalfFormProperty;
+                    properties[i-2] &= ~HalfFormProperty;
+                }
+            }
+        }
+        // PostFormProperty
+        for (i = base+1; i < len; ++i)
+            properties[i] &= ~PostFormProperty;
+        // vattu always applies
+        // pres always applies
+        // blws always applies
+        // abvs always applies
+        // psts always applies
+        // halant always applies
+
+#ifdef INDIC_DEBUG
+//        {
+//            IDEBUG("OT properties:");
+//            for (int i = 0; i < len; ++i)
+//                qDebug("    i: %s", ::propertiesToString(properties[i]).toLatin1().data());
+//        }
+#endif
+
+        // initialize
+        item->log_clusters = clusters;
+        HB_OpenTypeShape(item, properties);
+
+        int newLen = item->face->buffer->in_length;
+        HB_GlyphItem otl_glyphs = item->face->buffer->in_string;
+
+        // move the left matra back to its correct position in malayalam and tamil
+        if ((script == HB_Script_Malayalam || script == HB_Script_Tamil) && (form(reordered[0]) == Matra)) {
+//             qDebug("reordering matra, len=%d", newLen);
+            // need to find the base in the shaped string and move the matra there
+            int basePos = 0;
+            while (basePos < newLen && (int)otl_glyphs[basePos].cluster <= base)
+                basePos++;
+            --basePos;
+            if (basePos < newLen && basePos > 1) {
+//                 qDebug("moving prebase matra to position %d in syllable newlen=%d", basePos, newLen);
+                HB_GlyphItemRec m = otl_glyphs[0];
+                --basePos;
+                for (i = 0; i < basePos; ++i)
+                    otl_glyphs[i] = otl_glyphs[i+1];
+                otl_glyphs[basePos] = m;
+            }
+        }
+
+        HB_Bool positioned = HB_OpenTypePosition(item, availableGlyphs, false);
+
+        HB_FREE_STACKARRAY(clusters);
+        HB_FREE_STACKARRAY(properties);
+
+        if (!positioned)
+            goto error;
+
+        if (control) {
+            IDEBUG("found a control char in the syllable");
+            hb_uint32 i = 0, j = 0;
+            while (i < item->num_glyphs) {
+                if (form(reordered[otl_glyphs[i].cluster]) == Control) {
+                    ++i;
+                    if (i >= item->num_glyphs)
+                        break;
+                }
+                item->glyphs[j] = item->glyphs[i];
+                item->attributes[j] = item->attributes[i];
+                ++i;
+                ++j;
+            }
+            item->num_glyphs = j;
+        }
+
+    } else {
+        HB_HeuristicPosition(item);
+    }
+#endif // NO_OPENTYPE
+    item->attributes[0].clusterStart = true;
+
+    HB_FREE_STACKARRAY(reordered);
+    HB_FREE_STACKARRAY(position);
+
+    IDEBUG("<<<<<<");
+    return true;
+
+error:
+    HB_FREE_STACKARRAY(reordered);
+    HB_FREE_STACKARRAY(position);
+    return false;
+}
+
+/* syllables are of the form:
+
+   (Consonant Nukta? Halant)* Consonant Matra? VowelMark? StressMark?
+   (Consonant Nukta? Halant)* Consonant Halant
+   IndependentVowel VowelMark? StressMark?
+
+   We return syllable boundaries on invalid combinations aswell
+*/
+static int indic_nextSyllableBoundary(HB_Script script, const HB_UChar16 *s, int start, int end, bool *invalid)
+{
+    *invalid = false;
+    IDEBUG("indic_nextSyllableBoundary: start=%d, end=%d", start, end);
+    const HB_UChar16 *uc = s+start;
+
+    int pos = 0;
+    Form state = form(uc[pos]);
+    IDEBUG("state[%d]=%d (uc=%4x)", pos, state, uc[pos]);
+    pos++;
+
+    if (state != Consonant && state != IndependentVowel) {
+        if (state != Other)
+            *invalid = true;
+        goto finish;
+    }
+
+    while (pos < end - start) {
+        Form newState = form(uc[pos]);
+        IDEBUG("state[%d]=%d (uc=%4x)", pos, newState, uc[pos]);
+        switch(newState) {
+        case Control:
+            newState = state;
+ 	    if (state == Halant && uc[pos] == 0x200d /* ZWJ */)
+  		break;
+            // the control character should be the last char in the item
+            ++pos;
+            goto finish;
+        case Consonant:
+	    if (state == Halant && (script != HB_Script_Sinhala || uc[pos-1] == 0x200d /* ZWJ */))
+                break;
+            goto finish;
+        case Halant:
+            if (state == Nukta || state == Consonant)
+                break;
+            // Bengali has a special exception allowing the combination Vowel_A/E + Halant + Ya
+            if (script == HB_Script_Bengali && pos == 1 &&
+                 (uc[0] == 0x0985 || uc[0] == 0x098f))
+                break;
+            // Sinhala uses the Halant as a component of certain matras. Allow these, but keep the state on Matra.
+            if (script == HB_Script_Sinhala && state == Matra) {
+                ++pos;
+                continue;
+            }
+            if (script == HB_Script_Malayalam && state == Matra && uc[pos-1] == 0x0d41) {
+                ++pos;
+                continue;
+            }
+            goto finish;
+        case Nukta:
+            if (state == Consonant)
+                break;
+            goto finish;
+        case StressMark:
+            if (state == VowelMark)
+                break;
+            // fall through
+        case VowelMark:
+            if (state == Matra || state == LengthMark || state == IndependentVowel)
+                break;
+            // fall through
+        case Matra:
+            if (state == Consonant || state == Nukta)
+                break;
+            if (state == Matra) {
+                // ### needs proper testing for correct two/three part matras
+                break;
+            }
+            // ### not sure if this is correct. If it is, does it apply only to Bengali or should
+            // it work for all Indic languages?
+            // the combination Independent_A + Vowel Sign AA is allowed.
+            if (script == HB_Script_Bengali && uc[pos] == 0x9be && uc[pos-1] == 0x985)
+                break;
+            if (script == HB_Script_Tamil && state == Matra) {
+                if (uc[pos-1] == 0x0bc6 &&
+                     (uc[pos] == 0xbbe || uc[pos] == 0xbd7))
+                    break;
+                if (uc[pos-1] == 0x0bc7 && uc[pos] == 0xbbe)
+                    break;
+            }
+            goto finish;
+
+        case LengthMark:
+            if (state == Matra) {
+                // ### needs proper testing for correct two/three part matras
+                break;
+            }
+        case IndependentVowel:
+        case Invalid:
+        case Other:
+            goto finish;
+        }
+        state = newState;
+        pos++;
+    }
+ finish:
+    return pos+start;
+}
+
+HB_Bool HB_IndicShape(HB_ShaperItem *item)
+{
+    assert(item->item.script >= HB_Script_Devanagari && item->item.script <= HB_Script_Sinhala);
+
+    HB_Bool openType = false;
+#ifndef NO_OPENTYPE
+    openType = HB_SelectScript(item, indic_features);
+#endif
+    unsigned short *logClusters = item->log_clusters;
+
+    HB_ShaperItem syllable = *item;
+    int first_glyph = 0;
+
+    int sstart = item->item.pos;
+    int end = sstart + item->item.length;
+    IDEBUG("indic_shape: from %d length %d", item->item.pos, item->item.length);
+    while (sstart < end) {
+        bool invalid;
+        int send = indic_nextSyllableBoundary(item->item.script, item->string, sstart, end, &invalid);
+        IDEBUG("syllable from %d, length %d, invalid=%s", sstart, send-sstart,
+               invalid ? "true" : "false");
+        syllable.item.pos = sstart;
+        syllable.item.length = send-sstart;
+        syllable.glyphs = item->glyphs + first_glyph;
+        syllable.attributes = item->attributes + first_glyph;
+        syllable.offsets = item->offsets + first_glyph;
+        syllable.advances = item->advances + first_glyph;
+        syllable.num_glyphs = item->num_glyphs - first_glyph;
+        if (!indic_shape_syllable(openType, &syllable, invalid)) {
+            IDEBUG("syllable shaping failed, syllable requests %d glyphs", syllable.num_glyphs);
+            item->num_glyphs += syllable.num_glyphs;
+            return false;
+        }
+        // fix logcluster array
+        IDEBUG("syllable:");
+        hb_uint32 g;
+        for (g = first_glyph; g < first_glyph + syllable.num_glyphs; ++g)
+            IDEBUG("        %d -> glyph %x", g, item->glyphs[g]);
+        IDEBUG("    logclusters:");
+        int i;
+        for (i = sstart; i < send; ++i) {
+            IDEBUG("        %d -> glyph %d", i, first_glyph);
+            logClusters[i-item->item.pos] = first_glyph;
+        }
+        sstart = send;
+        first_glyph += syllable.num_glyphs;
+    }
+    item->num_glyphs = first_glyph;
+    return true;
+}
+
+void HB_IndicAttributes(HB_Script script, const HB_UChar16 *text, hb_uint32 from, hb_uint32 len, HB_CharAttributes *attributes)
+{
+    int end = from + len;
+    const HB_UChar16 *uc = text + from;
+    attributes += from;
+    hb_uint32 i = 0;
+    while (i < len) {
+        bool invalid;
+        hb_uint32 boundary = indic_nextSyllableBoundary(script, text, from+i, end, &invalid) - from;
+         attributes[i].charStop = true;
+
+        if (boundary > len-1) boundary = len;
+        i++;
+        while (i < boundary) {
+            attributes[i].charStop = false;
+            ++uc;
+            ++i;
+        }
+        assert(i == boundary);
+    }
+
+
+}
+
+
diff -rupN orginal/scribus/harfbuzz/harfbuzz-khmer.c patched/scribus/harfbuzz/harfbuzz-khmer.c
--- orginal/scribus/harfbuzz/harfbuzz-khmer.c	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/harfbuzz-khmer.c	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,667 @@
+/*
+ * Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies)
+ *
+ * This is part of HarfBuzz, an OpenType Layout engine library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ */
+
+#include "harfbuzz-shaper.h"
+#include "harfbuzz-shaper-private.h"
+
+#include <assert.h>
+#include <stdio.h>
+
+/*
+//  Vocabulary
+//      Base ->         A consonant or an independent vowel in its full (not subscript) form. It is the
+//                      center of the syllable, it can be surrounded by coeng (subscript) consonants, vowels,
+//                      split vowels, signs... but there is only one base in a syllable, it has to be coded as
+//                      the first character of the syllable.
+//      split vowel --> vowel that has two parts placed separately (e.g. Before and after the consonant).
+//                      Khmer language has five of them. Khmer split vowels either have one part before the
+//                      base and one after the base or they have a part before the base and a part above the base.
+//                      The first part of all Khmer split vowels is the same character, identical to
+//                      the glyph of Khmer dependent vowel SRA EI
+//      coeng -->  modifier used in Khmer to construct coeng (subscript) consonants
+//                 Differently than indian languages, the coeng modifies the consonant that follows it,
+//                 not the one preceding it  Each consonant has two forms, the base form and the subscript form
+//                 the base form is the normal one (using the consonants code-point), the subscript form is
+//                 displayed when the combination coeng + consonant is encountered.
+//      Consonant of type 1 -> A consonant which has subscript for that only occupies space under a base consonant
+//      Consonant of type 2.-> Its subscript form occupies space under and before the base (only one, RO)
+//      Consonant of Type 3 -> Its subscript form occupies space under and after the base (KHO, CHHO, THHO, BA, YO, SA)
+//      Consonant shifter -> Khmer has to series of consonants. The same dependent vowel has different sounds
+//                           if it is attached to a consonant of the first series or a consonant of the second series
+//                           Most consonants have an equivalent in the other series, but some of theme exist only in
+//                           one series (for example SA). If we want to use the consonant SA with a vowel sound that
+//                           can only be done with a vowel sound that corresponds to a vowel accompanying a consonant
+//                           of the other series, then we need to use a consonant shifter: TRIISAP or MUSIKATOAN
+//                           x17C9 y x17CA. TRIISAP changes a first series consonant to second series sound and
+//                           MUSIKATOAN a second series consonant to have a first series vowel sound.
+//                           Consonant shifter are both normally supercript marks, but, when they are followed by a
+//                           superscript, they change shape and take the form of subscript dependent vowel SRA U.
+//                           If they are in the same syllable as a coeng consonant, Unicode 3.0 says that they
+//                           should be typed before the coeng. Unicode 4.0 breaks the standard and says that it should
+//                           be placed after the coeng consonant.
+//      Dependent vowel ->   In khmer dependent vowels can be placed above, below, before or after the base
+//                           Each vowel has its own position. Only one vowel per syllable is allowed.
+//      Signs            ->  Khmer has above signs and post signs. Only one above sign and/or one post sign are
+//                           Allowed in a syllable.
+//
+//
+//   order is important here! This order must be the same that is found in each horizontal
+//   line in the statetable for Khmer (see khmerStateTable) .
+*/
+enum KhmerCharClassValues {
+    CC_RESERVED             =  0,
+    CC_CONSONANT            =  1, /* Consonant of type 1 or independent vowel */
+    CC_CONSONANT2           =  2, /* Consonant of type 2 */
+    CC_CONSONANT3           =  3, /* Consonant of type 3 */
+    CC_ZERO_WIDTH_NJ_MARK   =  4, /* Zero Width non joiner character (0x200C) */
+    CC_CONSONANT_SHIFTER    =  5,
+    CC_ROBAT                =  6, /* Khmer special diacritic accent -treated differently in state table */
+    CC_COENG                =  7, /* Subscript consonant combining character */
+    CC_DEPENDENT_VOWEL      =  8,
+    CC_SIGN_ABOVE           =  9,
+    CC_SIGN_AFTER           = 10,
+    CC_ZERO_WIDTH_J_MARK    = 11, /* Zero width joiner character */
+    CC_COUNT                = 12  /* This is the number of character classes */
+};
+
+
+enum KhmerCharClassFlags {
+    CF_CLASS_MASK    = 0x0000FFFF,
+
+    CF_CONSONANT     = 0x01000000,  /* flag to speed up comparing */
+    CF_SPLIT_VOWEL   = 0x02000000,  /* flag for a split vowel -> the first part is added in front of the syllable */
+    CF_DOTTED_CIRCLE = 0x04000000,  /* add a dotted circle if a character with this flag is the first in a syllable */
+    CF_COENG         = 0x08000000,  /* flag to speed up comparing */
+    CF_SHIFTER       = 0x10000000,  /* flag to speed up comparing */
+    CF_ABOVE_VOWEL   = 0x20000000,  /* flag to speed up comparing */
+
+    /* position flags */
+    CF_POS_BEFORE    = 0x00080000,
+    CF_POS_BELOW     = 0x00040000,
+    CF_POS_ABOVE     = 0x00020000,
+    CF_POS_AFTER     = 0x00010000,
+    CF_POS_MASK      = 0x000f0000
+};
+
+
+/* Characters that get referred to by name */
+enum KhmerChar {
+    C_SIGN_ZWNJ     = 0x200C,
+    C_SIGN_ZWJ      = 0x200D,
+    C_RO            = 0x179A,
+    C_VOWEL_AA      = 0x17B6,
+    C_SIGN_NIKAHIT  = 0x17C6,
+    C_VOWEL_E       = 0x17C1,
+    C_COENG         = 0x17D2
+};
+
+
+/*
+//  simple classes, they are used in the statetable (in this file) to control the length of a syllable
+//  they are also used to know where a character should be placed (location in reference to the base character)
+//  and also to know if a character, when independently displayed, should be displayed with a dotted-circle to
+//  indicate error in syllable construction
+*/
+enum {
+    _xx = CC_RESERVED,
+    _sa = CC_SIGN_ABOVE | CF_DOTTED_CIRCLE | CF_POS_ABOVE,
+    _sp = CC_SIGN_AFTER | CF_DOTTED_CIRCLE| CF_POS_AFTER,
+    _c1 = CC_CONSONANT | CF_CONSONANT,
+    _c2 = CC_CONSONANT2 | CF_CONSONANT,
+    _c3 = CC_CONSONANT3 | CF_CONSONANT,
+    _rb = CC_ROBAT | CF_POS_ABOVE | CF_DOTTED_CIRCLE,
+    _cs = CC_CONSONANT_SHIFTER | CF_DOTTED_CIRCLE | CF_SHIFTER,
+    _dl = CC_DEPENDENT_VOWEL | CF_POS_BEFORE | CF_DOTTED_CIRCLE,
+    _db = CC_DEPENDENT_VOWEL | CF_POS_BELOW | CF_DOTTED_CIRCLE,
+    _da = CC_DEPENDENT_VOWEL | CF_POS_ABOVE | CF_DOTTED_CIRCLE | CF_ABOVE_VOWEL,
+    _dr = CC_DEPENDENT_VOWEL | CF_POS_AFTER | CF_DOTTED_CIRCLE,
+    _co = CC_COENG | CF_COENG | CF_DOTTED_CIRCLE,
+
+    /* split vowel */
+    _va = _da | CF_SPLIT_VOWEL,
+    _vr = _dr | CF_SPLIT_VOWEL
+};
+
+
+/*
+//   Character class: a character class value
+//   ORed with character class flags.
+*/
+typedef unsigned long KhmerCharClass;
+
+
+/*
+//  Character class tables
+//  _xx character does not combine into syllable, such as numbers, puntuation marks, non-Khmer signs...
+//  _sa Sign placed above the base
+//  _sp Sign placed after the base
+//  _c1 Consonant of type 1 or independent vowel (independent vowels behave as type 1 consonants)
+//  _c2 Consonant of type 2 (only RO)
+//  _c3 Consonant of type 3
+//  _rb Khmer sign robat u17CC. combining mark for subscript consonants
+//  _cd Consonant-shifter
+//  _dl Dependent vowel placed before the base (left of the base)
+//  _db Dependent vowel placed below the base
+//  _da Dependent vowel placed above the base
+//  _dr Dependent vowel placed behind the base (right of the base)
+//  _co Khmer combining mark COENG u17D2, combines with the consonant or independent vowel following
+//      it to create a subscript consonant or independent vowel
+//  _va Khmer split vowel in which the first part is before the base and the second one above the base
+//  _vr Khmer split vowel in which the first part is before the base and the second one behind (right of) the base
+*/
+static const KhmerCharClass khmerCharClasses[] = {
+    _c1, _c1, _c1, _c3, _c1, _c1, _c1, _c1, _c3, _c1, _c1, _c1, _c1, _c3, _c1, _c1, /* 1780 - 178F */
+    _c1, _c1, _c1, _c1, _c3, _c1, _c1, _c1, _c1, _c3, _c2, _c1, _c1, _c1, _c3, _c3, /* 1790 - 179F */
+    _c1, _c3, _c1, _c1, _c1, _c1, _c1, _c1, _c1, _c1, _c1, _c1, _c1, _c1, _c1, _c1, /* 17A0 - 17AF */
+    _c1, _c1, _c1, _c1, _dr, _dr, _dr, _da, _da, _da, _da, _db, _db, _db, _va, _vr, /* 17B0 - 17BF */
+    _vr, _dl, _dl, _dl, _vr, _vr, _sa, _sp, _sp, _cs, _cs, _sa, _rb, _sa, _sa, _sa, /* 17C0 - 17CF */
+    _sa, _sa, _co, _sa, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _sa, _xx, _xx  /* 17D0 - 17DF */
+};
+
+/* this enum must reflect the range of khmerCharClasses */
+enum KhmerCharClassesRange {
+    KhmerFirstChar = 0x1780,
+    KhmerLastChar  = 0x17df
+};
+
+/*
+//  Below we define how a character in the input string is either in the khmerCharClasses table
+//  (in which case we get its type back), a ZWJ or ZWNJ (two characters that may appear
+//  within the syllable, but are not in the table) we also get their type back, or an unknown object
+//  in which case we get _xx (CC_RESERVED) back
+*/
+static KhmerCharClass getKhmerCharClass(HB_UChar16 uc)
+{
+    if (uc == C_SIGN_ZWJ) {
+        return CC_ZERO_WIDTH_J_MARK;
+    }
+
+    if (uc == C_SIGN_ZWNJ) {
+        return CC_ZERO_WIDTH_NJ_MARK;
+    }
+
+    if (uc < KhmerFirstChar || uc > KhmerLastChar) {
+        return CC_RESERVED;
+    }
+
+    return khmerCharClasses[uc - KhmerFirstChar];
+}
+
+
+/*
+//  The stateTable is used to calculate the end (the length) of a well
+//  formed Khmer Syllable.
+//
+//  Each horizontal line is ordered exactly the same way as the values in KhmerClassTable
+//  CharClassValues. This coincidence of values allows the follow up of the table.
+//
+//  Each line corresponds to a state, which does not necessarily need to be a type
+//  of component... for example, state 2 is a base, with is always a first character
+//  in the syllable, but the state could be produced a consonant of any type when
+//  it is the first character that is analysed (in ground state).
+//
+//  Differentiating 3 types of consonants is necessary in order to
+//  forbid the use of certain combinations, such as having a second
+//  coeng after a coeng RO,
+//  The inexistent possibility of having a type 3 after another type 3 is permitted,
+//  eliminating it would very much complicate the table, and it does not create typing
+//  problems, as the case above.
+//
+//  The table is quite complex, in order to limit the number of coeng consonants
+//  to 2 (by means of the table).
+//
+//  There a peculiarity, as far as Unicode is concerned:
+//  - The consonant-shifter is considered in two possible different
+//    locations, the one considered in Unicode 3.0 and the one considered in
+//    Unicode 4.0. (there is a backwards compatibility problem in this standard).
+//
+//
+//  xx    independent character, such as a number, punctuation sign or non-khmer char
+//
+//  c1    Khmer consonant of type 1 or an independent vowel
+//        that is, a letter in which the subscript for is only under the
+//        base, not taking any space to the right or to the left
+//
+//  c2    Khmer consonant of type 2, the coeng form takes space under
+//        and to the left of the base (only RO is of this type)
+//
+//  c3    Khmer consonant of type 3. Its subscript form takes space under
+//        and to the right of the base.
+//
+//  cs    Khmer consonant shifter
+//
+//  rb    Khmer robat
+//
+//  co    coeng character (u17D2)
+//
+//  dv    dependent vowel (including split vowels, they are treated in the same way).
+//        even if dv is not defined above, the component that is really tested for is
+//        KhmerClassTable::CC_DEPENDENT_VOWEL, which is common to all dependent vowels
+//
+//  zwj   Zero Width joiner
+//
+//  zwnj  Zero width non joiner
+//
+//  sa    above sign
+//
+//  sp    post sign
+//
+//  there are lines with equal content but for an easier understanding
+//  (and maybe change in the future) we did not join them
+*/
+static const signed char khmerStateTable[][CC_COUNT] =
+{
+    /* xx  c1  c2  c3 zwnj cs  rb  co  dv  sa  sp zwj */
+    { 1,  2,  2,  2,  1,  1,  1,  6,  1,  1,  1,  2}, /*  0 - ground state */
+    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, /*  1 - exit state (or sign to the right of the syllable) */
+    {-1, -1, -1, -1,  3,  4,  5,  6, 16, 17,  1, -1}, /*  2 - Base consonant */
+    {-1, -1, -1, -1, -1,  4, -1, -1, 16, -1, -1, -1}, /*  3 - First ZWNJ before a register shifter It can only be followed by a shifter or a vowel */
+    {-1, -1, -1, -1, 15, -1, -1,  6, 16, 17,  1, 14}, /*  4 - First register shifter */
+    {-1, -1, -1, -1, -1, -1, -1, -1, 20, -1,  1, -1}, /*  5 - Robat */
+    {-1,  7,  8,  9, -1, -1, -1, -1, -1, -1, -1, -1}, /*  6 - First Coeng */
+    {-1, -1, -1, -1, 12, 13, -1, 10, 16, 17,  1, 14}, /*  7 - First consonant of type 1 after coeng */
+    {-1, -1, -1, -1, 12, 13, -1, -1, 16, 17,  1, 14}, /*  8 - First consonant of type 2 after coeng */
+    {-1, -1, -1, -1, 12, 13, -1, 10, 16, 17,  1, 14}, /*  9 - First consonant or type 3 after ceong */
+    {-1, 11, 11, 11, -1, -1, -1, -1, -1, -1, -1, -1}, /* 10 - Second Coeng (no register shifter before) */
+    {-1, -1, -1, -1, 15, -1, -1, -1, 16, 17,  1, 14}, /* 11 - Second coeng consonant (or ind. vowel) no register shifter before */
+    {-1, -1, -1, -1, -1, 13, -1, -1, 16, -1, -1, -1}, /* 12 - Second ZWNJ before a register shifter */
+    {-1, -1, -1, -1, 15, -1, -1, -1, 16, 17,  1, 14}, /* 13 - Second register shifter */
+    {-1, -1, -1, -1, -1, -1, -1, -1, 16, -1, -1, -1}, /* 14 - ZWJ before vowel */
+    {-1, -1, -1, -1, -1, -1, -1, -1, 16, -1, -1, -1}, /* 15 - ZWNJ before vowel */
+    {-1, -1, -1, -1, -1, -1, -1, -1, -1, 17,  1, 18}, /* 16 - dependent vowel */
+    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  1, 18}, /* 17 - sign above */
+    {-1, -1, -1, -1, -1, -1, -1, 19, -1, -1, -1, -1}, /* 18 - ZWJ after vowel */
+    {-1,  1, -1,  1, -1, -1, -1, -1, -1, -1, -1, -1}, /* 19 - Third coeng */
+    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  1, -1}, /* 20 - dependent vowel after a Robat */
+};
+
+
+/*  #define KHMER_DEBUG */
+#ifdef KHMER_DEBUG
+#define KHDEBUG qDebug
+#else
+#define KHDEBUG if(0) printf
+#endif
+
+/*
+//  Given an input string of characters and a location in which to start looking
+//  calculate, using the state table, which one is the last character of the syllable
+//  that starts in the starting position.
+*/
+static int khmer_nextSyllableBoundary(const HB_UChar16 *s, int start, int end, HB_Bool *invalid)
+{
+    const HB_UChar16 *uc = s + start;
+    int state = 0;
+    int pos = start;
+    *invalid = FALSE;
+
+    while (pos < end) {
+        KhmerCharClass charClass = getKhmerCharClass(*uc);
+        if (pos == start) {
+            *invalid = (charClass > 0) && ! (charClass & CF_CONSONANT);
+        }
+        state = khmerStateTable[state][charClass & CF_CLASS_MASK];
+
+        KHDEBUG("state[%d]=%d class=%8lx (uc=%4x)", pos - start, state,
+                charClass, *uc );
+
+        if (state < 0) {
+            break;
+        }
+        ++uc;
+        ++pos;
+    }
+    return pos;
+}
+
+#ifndef NO_OPENTYPE
+static const HB_OpenTypeFeature khmer_features[] = {
+    { HB_MAKE_TAG( 'p', 'r', 'e', 'f' ), PreFormProperty },
+    { HB_MAKE_TAG( 'b', 'l', 'w', 'f' ), BelowFormProperty },
+    { HB_MAKE_TAG( 'a', 'b', 'v', 'f' ), AboveFormProperty },
+    { HB_MAKE_TAG( 'p', 's', 't', 'f' ), PostFormProperty },
+    { HB_MAKE_TAG( 'p', 'r', 'e', 's' ), PreSubstProperty },
+    { HB_MAKE_TAG( 'b', 'l', 'w', 's' ), BelowSubstProperty },
+    { HB_MAKE_TAG( 'a', 'b', 'v', 's' ), AboveSubstProperty },
+    { HB_MAKE_TAG( 'p', 's', 't', 's' ), PostSubstProperty },
+    { HB_MAKE_TAG( 'c', 'l', 'i', 'g' ), CligProperty },
+    { 0, 0 }
+};
+#endif
+
+
+static HB_Bool khmer_shape_syllable(HB_Bool openType, HB_ShaperItem *item)
+{
+/*    KHDEBUG("syllable from %d len %d, str='%s'", item->from, item->length,
+  	    item->string->mid(item->from, item->length).toUtf8().data()); */
+
+    int len = 0;
+    int syllableEnd = item->item.pos + item->item.length;
+    unsigned short reordered[16];
+    unsigned char properties[16];
+    enum {
+	AboveForm = 0x01,
+	PreForm = 0x02,
+	PostForm = 0x04,
+	BelowForm = 0x08
+    };
+#ifndef NO_OPENTYPE
+    const int availableGlyphs = item->num_glyphs;
+#endif
+    int coengRo;
+    int i;
+
+    /* according to the specs this is the max length one can get
+       ### the real value should be smaller */
+    assert(item->item.length < 13);
+
+    memset(properties, 0, 16*sizeof(unsigned char));
+
+#ifdef KHMER_DEBUG
+    qDebug("original:");
+    for (int i = from; i < syllableEnd; i++) {
+        qDebug("    %d: %4x", i, string[i]);
+    }
+#endif
+
+    /*
+    // write a pre vowel or the pre part of a split vowel first
+    // and look out for coeng + ro. RO is the only vowel of type 2, and
+    // therefore the only one that requires saving space before the base.
+    */
+    coengRo = -1;  /* There is no Coeng Ro, if found this value will change */
+    for (i = item->item.pos; i < syllableEnd; i += 1) {
+        KhmerCharClass charClass = getKhmerCharClass(item->string[i]);
+
+        /* if a split vowel, write the pre part. In Khmer the pre part
+           is the same for all split vowels, same glyph as pre vowel C_VOWEL_E */
+        if (charClass & CF_SPLIT_VOWEL) {
+            reordered[len] = C_VOWEL_E;
+            properties[len] = PreForm;
+            ++len;
+            break; /* there can be only one vowel */
+        }
+        /* if a vowel with pos before write it out */
+        if (charClass & CF_POS_BEFORE) {
+            reordered[len] = item->string[i];
+            properties[len] = PreForm;
+            ++len;
+            break; /* there can be only one vowel */
+        }
+        /* look for coeng + ro and remember position
+           works because coeng + ro is always in front of a vowel (if there is a vowel)
+           and because CC_CONSONANT2 is enough to identify it, as it is the only consonant
+           with this flag */
+        if ( (charClass & CF_COENG) && (i + 1 < syllableEnd) &&
+              ( (getKhmerCharClass(item->string[i+1]) & CF_CLASS_MASK) == CC_CONSONANT2) ) {
+            coengRo = i;
+        }
+    }
+
+    /* write coeng + ro if found */
+    if (coengRo > -1) {
+        reordered[len] = C_COENG;
+        properties[len] = PreForm;
+        ++len;
+        reordered[len] = C_RO;
+        properties[len] = PreForm;
+        ++len;
+    }
+
+    /*
+       shall we add a dotted circle?
+       If in the position in which the base should be (first char in the string) there is
+       a character that has the Dotted circle flag (a character that cannot be a base)
+       then write a dotted circle */
+    if (getKhmerCharClass(item->string[item->item.pos]) & CF_DOTTED_CIRCLE) {
+        reordered[len] = C_DOTTED_CIRCLE;
+        ++len;
+    }
+
+    /* copy what is left to the output, skipping before vowels and
+       coeng Ro if they are present */
+    for (i = item->item.pos; i < syllableEnd; i += 1) {
+        HB_UChar16 uc = item->string[i];
+        KhmerCharClass charClass = getKhmerCharClass(uc);
+
+        /* skip a before vowel, it was already processed */
+        if (charClass & CF_POS_BEFORE) {
+            continue;
+        }
+
+        /* skip coeng + ro, it was already processed */
+        if (i == coengRo) {
+            i += 1;
+            continue;
+        }
+
+        switch (charClass & CF_POS_MASK)
+        {
+            case CF_POS_ABOVE :
+                reordered[len] = uc;
+                properties[len] = AboveForm;
+                ++len;
+                break;
+
+            case CF_POS_AFTER :
+                reordered[len] = uc;
+                properties[len] = PostForm;
+                ++len;
+                break;
+
+            case CF_POS_BELOW :
+                reordered[len] = uc;
+                properties[len] = BelowForm;
+                ++len;
+                break;
+
+            default:
+                /* assign the correct flags to a coeng consonant
+                   Consonants of type 3 are taged as Post forms and those type 1 as below forms */
+                if ( (charClass & CF_COENG) && i + 1 < syllableEnd ) {
+                    unsigned char property = (getKhmerCharClass(item->string[i+1]) & CF_CLASS_MASK) == CC_CONSONANT3 ?
+                                              PostForm : BelowForm;
+                    reordered[len] = uc;
+                    properties[len] = property;
+                    ++len;
+                    i += 1;
+                    reordered[len] = item->string[i];
+                    properties[len] = property;
+                    ++len;
+                    break;
+                }
+
+                /* if a shifter is followed by an above vowel change the shifter to below form,
+                   an above vowel can have two possible positions i + 1 or i + 3
+                   (position i+1 corresponds to unicode 3, position i+3 to Unicode 4)
+                   and there is an extra rule for C_VOWEL_AA + C_SIGN_NIKAHIT also for two
+                   different positions, right after the shifter or after a vowel (Unicode 4) */
+                if ( (charClass & CF_SHIFTER) && (i + 1 < syllableEnd) ) {
+                    if (getKhmerCharClass(item->string[i+1]) & CF_ABOVE_VOWEL ) {
+                        reordered[len] = uc;
+                        properties[len] = BelowForm;
+                        ++len;
+                        break;
+                    }
+                    if (i + 2 < syllableEnd &&
+                        (item->string[i+1] == C_VOWEL_AA) &&
+                        (item->string[i+2] == C_SIGN_NIKAHIT) )
+                    {
+                        reordered[len] = uc;
+                        properties[len] = BelowForm;
+                        ++len;
+                        break;
+                    }
+                    if (i + 3 < syllableEnd && (getKhmerCharClass(item->string[i+3]) & CF_ABOVE_VOWEL) ) {
+                        reordered[len] = uc;
+                        properties[len] = BelowForm;
+                        ++len;
+                        break;
+                    }
+                    if (i + 4 < syllableEnd &&
+                        (item->string[i+3] == C_VOWEL_AA) &&
+                        (item->string[i+4] == C_SIGN_NIKAHIT) )
+                    {
+                        reordered[len] = uc;
+                        properties[len] = BelowForm;
+                        ++len;
+                        break;
+                    }
+                }
+
+                /* default - any other characters */
+                reordered[len] = uc;
+                ++len;
+                break;
+        } /* switch */
+    } /* for */
+
+    if (!item->font->klass->convertStringToGlyphIndices(item->font,
+                                                        reordered, len,
+                                                        item->glyphs, &item->num_glyphs,
+                                                        item->item.bidiLevel % 2))
+        return FALSE;
+
+
+    KHDEBUG("after shaping: len=%d", len);
+    for (i = 0; i < len; i++) {
+	item->attributes[i].mark = FALSE;
+	item->attributes[i].clusterStart = FALSE;
+	item->attributes[i].justification = 0;
+	item->attributes[i].zeroWidth = FALSE;
+	KHDEBUG("    %d: %4x property=%x", i, reordered[i], properties[i]);
+    }
+
+    /* now we have the syllable in the right order, and can start running it through open type. */
+
+#ifndef NO_OPENTYPE
+    if (openType) {
+ 	hb_uint32 where[16];
+        for (i = 0; i < len; ++i) {
+            where[i] = ~(PreSubstProperty
+                         | BelowSubstProperty
+                         | AboveSubstProperty
+                         | PostSubstProperty
+                         | CligProperty
+                         | PositioningProperties);
+            if (properties[i] == PreForm)
+                where[i] &= ~PreFormProperty;
+            else if (properties[i] == BelowForm)
+                where[i] &= ~BelowFormProperty;
+            else if (properties[i] == AboveForm)
+                where[i] &= ~AboveFormProperty;
+            else if (properties[i] == PostForm)
+                where[i] &= ~PostFormProperty;
+        }
+
+        HB_OpenTypeShape(item, where);
+        if (!HB_OpenTypePosition(item, availableGlyphs, /*doLogClusters*/FALSE))
+            return FALSE;
+    } else
+#endif
+    {
+	KHDEBUG("Not using openType");
+        HB_HeuristicPosition(item);
+    }
+
+    item->attributes[0].clusterStart = TRUE;
+    return TRUE;
+}
+
+HB_Bool HB_KhmerShape(HB_ShaperItem *item)
+{
+    HB_Bool openType = FALSE;
+    unsigned short *logClusters = item->log_clusters;
+    int i;
+
+    HB_ShaperItem syllable = *item;
+    int first_glyph = 0;
+
+    int sstart = item->item.pos;
+    int end = sstart + item->item.length;
+
+    assert(item->item.script == HB_Script_Khmer);
+
+#ifndef NO_OPENTYPE
+    openType = HB_SelectScript(item, khmer_features);
+#endif
+
+    KHDEBUG("khmer_shape: from %d length %d", item->item.pos, item->item.length);
+    while (sstart < end) {
+        HB_Bool invalid;
+        int send = khmer_nextSyllableBoundary(item->string, sstart, end, &invalid);
+        KHDEBUG("syllable from %d, length %d, invalid=%s", sstart, send-sstart,
+               invalid ? "TRUE" : "FALSE");
+        syllable.item.pos = sstart;
+        syllable.item.length = send-sstart;
+        syllable.glyphs = item->glyphs + first_glyph;
+        syllable.attributes = item->attributes + first_glyph;
+        syllable.offsets = item->offsets + first_glyph;
+        syllable.advances = item->advances + first_glyph;
+        syllable.num_glyphs = item->num_glyphs - first_glyph;
+        if (!khmer_shape_syllable(openType, &syllable)) {
+            KHDEBUG("syllable shaping failed, syllable requests %d glyphs", syllable.num_glyphs);
+            item->num_glyphs += syllable.num_glyphs;
+            return FALSE;
+        }
+        /* fix logcluster array */
+        KHDEBUG("syllable:");
+        for (i = first_glyph; i < first_glyph + (int)syllable.num_glyphs; ++i)
+            KHDEBUG("        %d -> glyph %x", i, item->glyphs[i]);
+        KHDEBUG("    logclusters:");
+        for (i = sstart; i < send; ++i) {
+            KHDEBUG("        %d -> glyph %d", i, first_glyph);
+            logClusters[i-item->item.pos] = first_glyph;
+        }
+        sstart = send;
+        first_glyph += syllable.num_glyphs;
+    }
+    item->num_glyphs = first_glyph;
+    return TRUE;
+}
+
+void HB_KhmerAttributes(HB_Script script, const HB_UChar16 *text, hb_uint32 from, hb_uint32 len, HB_CharAttributes *attributes)
+{
+    int end = from + len;
+    const HB_UChar16 *uc = text + from;
+    hb_uint32 i = 0;
+    HB_UNUSED(script);
+    attributes += from;
+    while ( i < len ) {
+	HB_Bool invalid;
+	hb_uint32 boundary = khmer_nextSyllableBoundary( text, from+i, end, &invalid ) - from;
+
+	attributes[i].charStop = TRUE;
+
+	if ( boundary > len-1 ) boundary = len;
+	i++;
+	while ( i < boundary ) {
+	    attributes[i].charStop = FALSE;
+	    ++uc;
+	    ++i;
+	}
+	assert( i == boundary );
+    }
+}
+
diff -rupN orginal/scribus/harfbuzz/harfbuzz-myanmar.c patched/scribus/harfbuzz/harfbuzz-myanmar.c
--- orginal/scribus/harfbuzz/harfbuzz-myanmar.c	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/harfbuzz-myanmar.c	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,542 @@
+/*
+ * Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies)
+ *
+ * This is part of HarfBuzz, an OpenType Layout engine library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ */
+
+#include "harfbuzz-shaper.h"
+#include "harfbuzz-shaper-private.h"
+
+#include <assert.h>
+#include <stdio.h>
+
+enum MymrCharClassValues
+{
+    Mymr_CC_RESERVED             =  0,
+    Mymr_CC_CONSONANT            =  1, /* Consonant of type 1, that has subscript form */
+    Mymr_CC_CONSONANT2           =  2, /* Consonant of type 2, that has no subscript form */
+    Mymr_CC_NGA	          =  3, /* Consonant NGA */
+    Mymr_CC_YA		          =  4, /* Consonant YA */
+    Mymr_CC_RA		          =  5, /* Consonant RA */
+    Mymr_CC_WA		          =  6, /* Consonant WA */
+    Mymr_CC_HA		          =  7, /* Consonant HA */
+    Mymr_CC_IND_VOWEL		  =  8, /* Independent vowel */
+    Mymr_CC_ZERO_WIDTH_NJ_MARK   =  9, /* Zero Width non joiner character (0x200C) */
+    Mymr_CC_VIRAMA               = 10, /* Subscript consonant combining character */
+    Mymr_CC_PRE_VOWEL   	  = 11, /* Dependent vowel, prebase (Vowel e) */
+    Mymr_CC_BELOW_VOWEL   	  = 12, /* Dependent vowel, prebase (Vowel u, uu) */
+    Mymr_CC_ABOVE_VOWEL   	  = 13, /* Dependent vowel, prebase (Vowel i, ii, ai) */
+    Mymr_CC_POST_VOWEL   	  = 14, /* Dependent vowel, prebase (Vowel aa) */
+    Mymr_CC_SIGN_ABOVE           = 15,
+    Mymr_CC_SIGN_BELOW           = 16,
+    Mymr_CC_SIGN_AFTER           = 17,
+    Mymr_CC_ZERO_WIDTH_J_MARK    = 18, /* Zero width joiner character */
+    Mymr_CC_COUNT                = 19  /* This is the number of character classes */
+};
+
+enum MymrCharClassFlags
+{
+    Mymr_CF_CLASS_MASK    = 0x0000FFFF,
+
+    Mymr_CF_CONSONANT     = 0x01000000,  /* flag to speed up comparing */
+    Mymr_CF_MEDIAL	   = 0x02000000,  /* flag to speed up comparing */
+    Mymr_CF_IND_VOWEL 	   = 0x04000000,  /* flag to speed up comparing */
+    Mymr_CF_DEP_VOWEL 	   = 0x08000000,  /* flag to speed up comparing */
+    Mymr_CF_DOTTED_CIRCLE = 0x10000000,  /* add a dotted circle if a character with this flag is the first in a syllable */
+    Mymr_CF_VIRAMA        = 0x20000000,  /* flag to speed up comparing */
+
+    /* position flags */
+    Mymr_CF_POS_BEFORE    = 0x00080000,
+    Mymr_CF_POS_BELOW     = 0x00040000,
+    Mymr_CF_POS_ABOVE     = 0x00020000,
+    Mymr_CF_POS_AFTER     = 0x00010000,
+    Mymr_CF_POS_MASK      = 0x000f0000,
+
+    Mymr_CF_AFTER_KINZI   = 0x00100000
+};
+
+/* Characters that get refrered to by name */
+enum MymrChar
+{
+    Mymr_C_SIGN_ZWNJ     = 0x200C,
+    Mymr_C_SIGN_ZWJ      = 0x200D,
+    Mymr_C_DOTTED_CIRCLE = 0x25CC,
+    Mymr_C_RA            = 0x101B,
+    Mymr_C_YA            = 0x101A,
+    Mymr_C_NGA           = 0x1004,
+    Mymr_C_VOWEL_E       = 0x1031,
+    Mymr_C_VIRAMA        = 0x1039
+};
+
+enum
+{
+    Mymr_xx = Mymr_CC_RESERVED,
+    Mymr_c1 = Mymr_CC_CONSONANT | Mymr_CF_CONSONANT | Mymr_CF_POS_BELOW,
+    Mymr_c2 = Mymr_CC_CONSONANT2 | Mymr_CF_CONSONANT,
+    Mymr_ng = Mymr_CC_NGA | Mymr_CF_CONSONANT | Mymr_CF_POS_ABOVE,
+    Mymr_ya = Mymr_CC_YA | Mymr_CF_CONSONANT | Mymr_CF_MEDIAL | Mymr_CF_POS_AFTER | Mymr_CF_AFTER_KINZI,
+    Mymr_ra = Mymr_CC_RA | Mymr_CF_CONSONANT | Mymr_CF_MEDIAL | Mymr_CF_POS_BEFORE,
+    Mymr_wa = Mymr_CC_WA | Mymr_CF_CONSONANT | Mymr_CF_MEDIAL | Mymr_CF_POS_BELOW,
+    Mymr_ha = Mymr_CC_HA | Mymr_CF_CONSONANT | Mymr_CF_MEDIAL | Mymr_CF_POS_BELOW,
+    Mymr_id = Mymr_CC_IND_VOWEL | Mymr_CF_IND_VOWEL,
+    Mymr_vi = Mymr_CC_VIRAMA | Mymr_CF_VIRAMA | Mymr_CF_POS_ABOVE | Mymr_CF_DOTTED_CIRCLE,
+    Mymr_dl = Mymr_CC_PRE_VOWEL | Mymr_CF_DEP_VOWEL | Mymr_CF_POS_BEFORE | Mymr_CF_DOTTED_CIRCLE | Mymr_CF_AFTER_KINZI,
+    Mymr_db = Mymr_CC_BELOW_VOWEL | Mymr_CF_DEP_VOWEL | Mymr_CF_POS_BELOW | Mymr_CF_DOTTED_CIRCLE | Mymr_CF_AFTER_KINZI,
+    Mymr_da = Mymr_CC_ABOVE_VOWEL | Mymr_CF_DEP_VOWEL | Mymr_CF_POS_ABOVE | Mymr_CF_DOTTED_CIRCLE | Mymr_CF_AFTER_KINZI,
+    Mymr_dr = Mymr_CC_POST_VOWEL | Mymr_CF_DEP_VOWEL | Mymr_CF_POS_AFTER | Mymr_CF_DOTTED_CIRCLE | Mymr_CF_AFTER_KINZI,
+    Mymr_sa = Mymr_CC_SIGN_ABOVE | Mymr_CF_DOTTED_CIRCLE | Mymr_CF_POS_ABOVE | Mymr_CF_AFTER_KINZI,
+    Mymr_sb = Mymr_CC_SIGN_BELOW | Mymr_CF_DOTTED_CIRCLE | Mymr_CF_POS_BELOW | Mymr_CF_AFTER_KINZI,
+    Mymr_sp = Mymr_CC_SIGN_AFTER | Mymr_CF_DOTTED_CIRCLE | Mymr_CF_AFTER_KINZI
+};
+
+
+typedef int MymrCharClass;
+
+
+static const MymrCharClass mymrCharClasses[] =
+{
+    Mymr_c1, Mymr_c1, Mymr_c1, Mymr_c1, Mymr_ng, Mymr_c1, Mymr_c1, Mymr_c1,
+    Mymr_c1, Mymr_c1, Mymr_c2, Mymr_c1, Mymr_c1, Mymr_c1, Mymr_c1, Mymr_c1, /* 1000 - 100F */
+    Mymr_c1, Mymr_c1, Mymr_c1, Mymr_c1, Mymr_c1, Mymr_c1, Mymr_c1, Mymr_c1,
+    Mymr_c1, Mymr_c1, Mymr_ya, Mymr_ra, Mymr_c1, Mymr_wa, Mymr_c1, Mymr_ha, /* 1010 - 101F */
+    Mymr_c2, Mymr_c2, Mymr_xx, Mymr_id, Mymr_id, Mymr_id, Mymr_id, Mymr_id,
+    Mymr_xx, Mymr_id, Mymr_id, Mymr_xx, Mymr_dr, Mymr_da, Mymr_da, Mymr_db, /* 1020 - 102F */
+    Mymr_db, Mymr_dl, Mymr_da, Mymr_xx, Mymr_xx, Mymr_xx, Mymr_sa, Mymr_sb,
+    Mymr_sp, Mymr_vi, Mymr_xx, Mymr_xx, Mymr_xx, Mymr_xx, Mymr_xx, Mymr_xx, /* 1030 - 103F */
+    Mymr_xx, Mymr_xx, Mymr_xx, Mymr_xx, Mymr_xx, Mymr_xx, Mymr_xx, Mymr_xx,
+    Mymr_xx, Mymr_xx, Mymr_xx, Mymr_xx, Mymr_xx, Mymr_xx, Mymr_xx, Mymr_xx, /* 1040 - 104F */
+    Mymr_xx, Mymr_xx, Mymr_xx, Mymr_xx, Mymr_xx, Mymr_xx, Mymr_xx, Mymr_xx,
+    Mymr_xx, Mymr_xx, Mymr_xx, Mymr_xx, Mymr_xx, Mymr_xx, Mymr_xx, Mymr_xx, /* 1050 - 105F */
+};
+
+static MymrCharClass
+getMyanmarCharClass (HB_UChar16 ch)
+{
+    if (ch == Mymr_C_SIGN_ZWJ)
+        return Mymr_CC_ZERO_WIDTH_J_MARK;
+
+    if (ch == Mymr_C_SIGN_ZWNJ)
+        return Mymr_CC_ZERO_WIDTH_NJ_MARK;
+
+    if (ch < 0x1000 || ch > 0x105f)
+        return Mymr_CC_RESERVED;
+
+    return mymrCharClasses[ch - 0x1000];
+}
+
+static const signed char mymrStateTable[][Mymr_CC_COUNT] =
+{
+/*   xx  c1, c2  ng  ya  ra  wa  ha  id zwnj vi  dl  db  da  dr  sa  sb  sp zwj */
+    { 1,  4,  4,  2,  4,  4,  4,  4, 24,  1, 27, 17, 18, 19, 20, 21,  1,  1,  4}, /*  0 - ground state */
+    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, /*  1 - exit state (or sp to the right of the syllable) */
+    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  3, 17, 18, 19, 20, 21, -1, -1,  4}, /*  2 - NGA */
+    {-1,  4,  4,  4,  4,  4,  4,  4, -1, 23, -1, -1, -1, -1, -1, -1, -1, -1, -1}, /*  3 - Virama after NGA */
+    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  5, 17, 18, 19, 20, 21,  1,  1, -1}, /*  4 - Base consonant */
+    {-2,  6, -2, -2,  7,  8,  9, 10, -2, 23, -2, -2, -2, -2, -2, -2, -2, -2, -2}, /*  5 - First virama */
+    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 25, 17, 18, 19, 20, 21, -1, -1, -1}, /*  6 - c1 after virama */
+    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 12, 17, 18, 19, 20, 21, -1, -1, -1}, /*  7 - ya after virama */
+    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 12, 17, 18, 19, 20, 21, -1, -1, -1}, /*  8 - ra after virama */
+    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 12, 17, 18, 19, 20, 21, -1, -1, -1}, /*  9 - wa after virama */
+    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 17, 18, 19, 20, 21, -1, -1, -1}, /* 10 - ha after virama */
+    {-1, -1, -1, -1,  7,  8,  9, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, /* 11 - Virama after NGA+zwj */
+    {-2, -2, -2, -2, -2, -2, 13, 14, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2}, /* 12 - Second virama */
+    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 15, 17, 18, 19, 20, 21, -1, -1, -1}, /* 13 - wa after virama */
+    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 17, 18, 19, 20, 21, -1, -1, -1}, /* 14 - ha after virama */
+    {-2, -2, -2, -2, -2, -2, -2, 16, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2}, /* 15 - Third virama */
+    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 17, 18, 19, 20, 21, -1, -1, -1}, /* 16 - ha after virama */
+    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 20, 21,  1,  1, -1}, /* 17 - dl, Dependent vowel e */
+    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 19, -1, 21,  1,  1, -1}, /* 18 - db, Dependent vowel u,uu */
+    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  1,  1,  1, -1}, /* 19 - da, Dependent vowel i,ii,ai */
+    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 22, -1, -1, -1, -1, -1,  1,  1, -1}, /* 20 - dr, Dependent vowel aa */
+    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  1,  1, -1}, /* 21 - sa, Sign anusvara */
+    {-1, -1, -1, -1, -1, -1, -1, -1, -1, 23, -1, -1, -1, -1, -1, -1, -1, -1, -1}, /* 22 - atha */
+    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  1,  1, -1}, /* 23 - zwnj for atha */
+    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  1, -1}, /* 24 - Independent vowel */
+    {-2, -2, -2, -2, 26, 26, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2}, /* 25 - Virama after subscript consonant */
+    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 12, 17, 18, 19, 20, 21, -1,  1, -1}, /* 26 - ra/ya after subscript consonant + virama */
+    {-1,  6, -1, -1,  7,  8,  9, 10, -1, 23, -1, -1, -1, -1, -1, -1, -1, -1, -1}, /* 27 - Virama after ground state */
+/* exit state -2 is for invalid order of medials and combination of invalids
+   with virama where virama should treat as start of next syllable
+ */
+};
+
+
+
+/*#define MYANMAR_DEBUG */
+#ifdef MYANMAR_DEBUG
+#define MMDEBUG qDebug
+#else
+#define MMDEBUG if(0) printf
+#endif
+
+/*
+//  Given an input string of characters and a location in which to start looking
+//  calculate, using the state table, which one is the last character of the syllable
+//  that starts in the starting position.
+*/
+static int myanmar_nextSyllableBoundary(const HB_UChar16 *s, int start, int end, HB_Bool *invalid)
+{
+    const HB_UChar16 *uc = s + start;
+    int state = 0;
+    int pos = start;
+    *invalid = FALSE;
+
+    while (pos < end) {
+        MymrCharClass charClass = getMyanmarCharClass(*uc);
+        state = mymrStateTable[state][charClass & Mymr_CF_CLASS_MASK];
+        if (pos == start)
+            *invalid = (HB_Bool)(charClass & Mymr_CF_DOTTED_CIRCLE);
+
+        MMDEBUG("state[%d]=%d class=%8x (uc=%4x)", pos - start, state, charClass, *uc);
+
+        if (state < 0) {
+            if (state < -1)
+                --pos;
+            break;
+        }
+        ++uc;
+        ++pos;
+    }
+    return pos;
+}
+
+#ifndef NO_OPENTYPE
+/* ###### might have to change order of above and below forms and substitutions,
+   but according to Unicode below comes before above */
+static const HB_OpenTypeFeature myanmar_features[] = {
+    { HB_MAKE_TAG('p', 'r', 'e', 'f'), PreFormProperty },
+    { HB_MAKE_TAG('b', 'l', 'w', 'f'), BelowFormProperty },
+    { HB_MAKE_TAG('a', 'b', 'v', 'f'), AboveFormProperty },
+    { HB_MAKE_TAG('p', 's', 't', 'f'), PostFormProperty },
+    { HB_MAKE_TAG('p', 'r', 'e', 's'), PreSubstProperty },
+    { HB_MAKE_TAG('b', 'l', 'w', 's'), BelowSubstProperty },
+    { HB_MAKE_TAG('a', 'b', 'v', 's'), AboveSubstProperty },
+    { HB_MAKE_TAG('p', 's', 't', 's'), PostSubstProperty },
+    { HB_MAKE_TAG('r', 'l', 'i', 'g'), CligProperty }, /* Myanmar1 uses this instead of the other features */
+    { 0, 0 }
+};
+#endif
+
+
+/*
+// Visual order before shaping should be:
+//
+//    [Vowel Mark E]
+//    [Virama + Medial Ra]
+//    [Base]
+//    [Virama + Consonant]
+//    [Nga + Virama] (Kinzi) ### should probably come before post forms (medial ya)
+//    [Vowels]
+//    [Marks]
+//
+// This means that we can keep the logical order apart from having to
+// move the pre vowel, medial ra and kinzi
+*/
+
+static HB_Bool myanmar_shape_syllable(HB_Bool openType, HB_ShaperItem *item, HB_Bool invalid)
+{
+    /*
+//    MMDEBUG("\nsyllable from %d len %d, str='%s'", item->item.pos, item->item.length,
+//	    item->string->mid(item->from, item->length).toUtf8().data());
+    */
+
+#ifndef NO_OPENTYPE
+    const int availableGlyphs = item->num_glyphs;
+#endif
+    const HB_UChar16 *uc = item->string + item->item.pos;
+    int vowel_e = -1;
+    int kinzi = -1;
+    int medial_ra = -1;
+    int base = -1;
+    int i;
+    int len = 0;
+    unsigned short reordered[32];
+    unsigned char properties[32];
+    enum {
+	AboveForm = 0x01,
+	PreForm = 0x02,
+	PostForm = 0x04,
+	BelowForm = 0x08
+    };
+    HB_Bool lastWasVirama = FALSE;
+    int basePos = -1;
+
+    memset(properties, 0, 32*sizeof(unsigned char));
+
+    /* according to the table the max length of a syllable should be around 14 chars */
+    assert(item->item.length < 32);
+
+#ifdef MYANMAR_DEBUG
+    printf("original:");
+    for (i = 0; i < (int)item->item.length; i++) {
+        printf("    %d: %4x", i, uc[i]);
+    }
+#endif
+    for (i = 0; i < (int)item->item.length; ++i) {
+        HB_UChar16 chr = uc[i];
+
+        if (chr == Mymr_C_VOWEL_E) {
+            vowel_e = i;
+            continue;
+        }
+        if (i == 0
+            && chr == Mymr_C_NGA
+            && i + 2 < (int)item->item.length
+            && uc[i+1] == Mymr_C_VIRAMA) {
+            int mc = getMyanmarCharClass(uc[i+2]);
+            /*MMDEBUG("maybe kinzi: mc=%x", mc);*/
+            if ((mc & Mymr_CF_CONSONANT) == Mymr_CF_CONSONANT) {
+                kinzi = i;
+                continue;
+            }
+        }
+        if (base >= 0
+            && chr == Mymr_C_VIRAMA
+            && i + 1 < (int)item->item.length
+            && uc[i+1] == Mymr_C_RA) {
+            medial_ra = i;
+            continue;
+        }
+        if (base < 0)
+            base = i;
+    }
+
+    MMDEBUG("\n  base=%d, vowel_e=%d, kinzi=%d, medial_ra=%d", base, vowel_e, kinzi, medial_ra);
+    /* write vowel_e if found */
+    if (vowel_e >= 0) {
+        reordered[0] = Mymr_C_VOWEL_E;
+        len = 1;
+    }
+    /* write medial_ra */
+    if (medial_ra >= 0) {
+        reordered[len] = Mymr_C_VIRAMA;
+        reordered[len+1] = Mymr_C_RA;
+        properties[len] = PreForm;
+        properties[len+1] = PreForm;
+        len += 2;
+    }
+
+    /* shall we add a dotted circle?
+       If in the position in which the base should be (first char in the string) there is
+       a character that has the Dotted circle flag (a character that cannot be a base)
+       then write a dotted circle */
+    if (invalid) {
+        reordered[len] = C_DOTTED_CIRCLE;
+        ++len;
+    }
+
+    /* copy the rest of the syllable to the output, inserting the kinzi
+       at the correct place */
+    for (i = 0; i < (int)item->item.length; ++i) {
+        hb_uint16 chr = uc[i];
+        MymrCharClass cc;
+        if (i == vowel_e)
+            continue;
+        if (i == medial_ra || i == kinzi) {
+            ++i;
+            continue;
+        }
+
+        cc = getMyanmarCharClass(uc[i]);
+        if (kinzi >= 0 && i > base && (cc & Mymr_CF_AFTER_KINZI)) {
+            reordered[len] = Mymr_C_NGA;
+            reordered[len+1] = Mymr_C_VIRAMA;
+            properties[len-1] = AboveForm;
+            properties[len] = AboveForm;
+            len += 2;
+            kinzi = -1;
+        }
+
+        if (lastWasVirama) {
+            int prop = 0;
+            switch(cc & Mymr_CF_POS_MASK) {
+            case Mymr_CF_POS_BEFORE:
+                prop = PreForm;
+                break;
+            case Mymr_CF_POS_BELOW:
+                prop = BelowForm;
+                break;
+            case Mymr_CF_POS_ABOVE:
+                prop = AboveForm;
+                break;
+            case Mymr_CF_POS_AFTER:
+                prop = PostForm;
+                break;
+            default:
+                break;
+            }
+            properties[len-1] = prop;
+            properties[len] = prop;
+            if(basePos >= 0 && basePos == len-2)
+                properties[len-2] = prop;
+        }
+        lastWasVirama = (chr == Mymr_C_VIRAMA);
+        if(i == base)
+            basePos = len;
+
+        if ((chr != Mymr_C_SIGN_ZWNJ && chr != Mymr_C_SIGN_ZWJ) || !len) {
+            reordered[len] = chr;
+            ++len;
+        }
+    }
+    if (kinzi >= 0) {
+        reordered[len] = Mymr_C_NGA;
+        reordered[len+1] = Mymr_C_VIRAMA;
+        properties[len] = AboveForm;
+        properties[len+1] = AboveForm;
+        len += 2;
+    }
+
+    if (!item->font->klass->convertStringToGlyphIndices(item->font,
+                                                        reordered, len,
+                                                        item->glyphs, &item->num_glyphs,
+                                                        item->item.bidiLevel % 2))
+        return FALSE;
+
+    MMDEBUG("after shaping: len=%d", len);
+    for (i = 0; i < len; i++) {
+	item->attributes[i].mark = FALSE;
+	item->attributes[i].clusterStart = FALSE;
+	item->attributes[i].justification = 0;
+	item->attributes[i].zeroWidth = FALSE;
+	MMDEBUG("    %d: %4x property=%x", i, reordered[i], properties[i]);
+    }
+
+    /* now we have the syllable in the right order, and can start running it through open type. */
+
+#ifndef NO_OPENTYPE
+    if (openType) {
+	unsigned short logClusters[32];
+ 	hb_uint32 where[32];
+
+	for (i = 0; i < len; ++i)
+	    logClusters[i] = i;
+
+        for (i = 0; i < len; ++i) {
+            where[i] = ~(PreSubstProperty
+                         | BelowSubstProperty
+                         | AboveSubstProperty
+                         | PostSubstProperty
+                         | CligProperty
+                         | PositioningProperties);
+            if (properties[i] & PreForm)
+                where[i] &= ~PreFormProperty;
+            if (properties[i] & BelowForm)
+                where[i] &= ~BelowFormProperty;
+            if (properties[i] & AboveForm)
+                where[i] &= ~AboveFormProperty;
+            if (properties[i] & PostForm)
+                where[i] &= ~PostFormProperty;
+        }
+
+        HB_OpenTypeShape(item, where);
+        if (!HB_OpenTypePosition(item, availableGlyphs, /*doLogClusters*/FALSE))
+            return FALSE;
+    } else
+#endif
+    {
+	MMDEBUG("Not using openType");
+        HB_HeuristicPosition(item);
+    }
+
+    item->attributes[0].clusterStart = TRUE;
+    return TRUE;
+}
+
+HB_Bool HB_MyanmarShape(HB_ShaperItem *item)
+{
+    HB_Bool openType = FALSE;
+    unsigned short *logClusters = item->log_clusters;
+
+    HB_ShaperItem syllable = *item;
+    int first_glyph = 0;
+
+    int sstart = item->item.pos;
+    int end = sstart + item->item.length;
+    int i = 0;
+
+    assert(item->item.script == HB_Script_Myanmar);
+#ifndef NO_OPENTYPE
+    openType = HB_SelectScript(item, myanmar_features);
+#endif
+
+    MMDEBUG("myanmar_shape: from %d length %d", item->item.pos, item->item.length);
+    while (sstart < end) {
+        HB_Bool invalid;
+        int send = myanmar_nextSyllableBoundary(item->string, sstart, end, &invalid);
+        MMDEBUG("syllable from %d, length %d, invalid=%s", sstart, send-sstart,
+               invalid ? "TRUE" : "FALSE");
+        syllable.item.pos = sstart;
+        syllable.item.length = send-sstart;
+        syllable.glyphs = item->glyphs + first_glyph;
+        syllable.attributes = item->attributes + first_glyph;
+        syllable.advances = item->advances + first_glyph;
+        syllable.offsets = item->offsets + first_glyph;
+        syllable.num_glyphs = item->num_glyphs - first_glyph;
+        if (!myanmar_shape_syllable(openType, &syllable, invalid)) {
+            MMDEBUG("syllable shaping failed, syllable requests %d glyphs", syllable.num_glyphs);
+            item->num_glyphs += syllable.num_glyphs;
+            return FALSE;
+        }
+
+        /* fix logcluster array */
+        MMDEBUG("syllable:");
+        for (i = first_glyph; i < first_glyph + (int)syllable.num_glyphs; ++i)
+            MMDEBUG("        %d -> glyph %x", i, item->glyphs[i]);
+        MMDEBUG("    logclusters:");
+        for (i = sstart; i < send; ++i) {
+            MMDEBUG("        %d -> glyph %d", i, first_glyph);
+            logClusters[i-item->item.pos] = first_glyph;
+        }
+        sstart = send;
+        first_glyph += syllable.num_glyphs;
+    }
+    item->num_glyphs = first_glyph;
+    return TRUE;
+}
+
+void HB_MyanmarAttributes(HB_Script script, const HB_UChar16 *text, hb_uint32 from, hb_uint32 len, HB_CharAttributes *attributes)
+{
+    int end = from + len;
+    const HB_UChar16 *uc = text + from;
+    hb_uint32 i = 0;
+    HB_UNUSED(script);
+    attributes += from;
+    while (i < len) {
+	HB_Bool invalid;
+	hb_uint32 boundary = myanmar_nextSyllableBoundary(text, from+i, end, &invalid) - from;
+
+	attributes[i].charStop = TRUE;
+        if (i)
+            attributes[i-1].lineBreakType = HB_Break;
+
+	if (boundary > len-1)
+            boundary = len;
+	i++;
+	while (i < boundary) {
+	    attributes[i].charStop = FALSE;
+	    ++uc;
+	    ++i;
+	}
+	assert(i == boundary);
+    }
+}
+
diff -rupN orginal/scribus/harfbuzz/harfbuzz-open-private.h patched/scribus/harfbuzz/harfbuzz-open-private.h
--- orginal/scribus/harfbuzz/harfbuzz-open-private.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/harfbuzz-open-private.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 1998-2004  David Turner and Werner Lemberg
+ * Copyright (C) 2006  Behdad Esfahbod
+ *
+ * This is part of HarfBuzz, an OpenType Layout engine library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ */
+
+#ifndef HARFBUZZ_OPEN_PRIVATE_H
+#define HARFBUZZ_OPEN_PRIVATE_H
+
+#include "harfbuzz-impl.h"
+#include "harfbuzz-open.h"
+#include "harfbuzz-gsub-private.h"
+#include "harfbuzz-gpos-private.h"
+
+HB_BEGIN_HEADER
+
+
+struct  HB_SubTable_
+{
+  union
+  {
+    HB_GSUB_SubTable  gsub;
+    HB_GPOS_SubTable  gpos;
+  } st;
+};
+
+
+HB_INTERNAL HB_Error
+_HB_OPEN_Load_ScriptList( HB_ScriptList* sl,
+			   HB_Stream     input );
+HB_INTERNAL HB_Error
+_HB_OPEN_Load_FeatureList( HB_FeatureList* fl,
+			    HB_Stream         input );
+HB_INTERNAL HB_Error
+_HB_OPEN_Load_LookupList( HB_LookupList*  ll,
+			   HB_Stream        input,
+			   HB_Type         type );
+
+HB_INTERNAL HB_Error
+_HB_OPEN_Load_Coverage( HB_Coverage* c,
+			 HB_Stream      input );
+HB_INTERNAL HB_Error
+_HB_OPEN_Load_ClassDefinition( HB_ClassDefinition* cd,
+				HB_UShort             limit,
+				HB_Stream             input );
+HB_INTERNAL HB_Error
+_HB_OPEN_Load_EmptyOrClassDefinition( HB_ClassDefinition* cd,
+					       HB_UShort             limit,
+					       HB_UInt              class_offset,
+					       HB_UInt              base_offset,
+					       HB_Stream             input );
+HB_INTERNAL HB_Error
+_HB_OPEN_Load_Device( HB_Device* d,
+		       HB_Stream    input );
+
+HB_INTERNAL void  _HB_OPEN_Free_ScriptList( HB_ScriptList*  sl );
+HB_INTERNAL void  _HB_OPEN_Free_FeatureList( HB_FeatureList*  fl );
+HB_INTERNAL void  _HB_OPEN_Free_LookupList( HB_LookupList*  ll,
+		       HB_Type         type );
+
+HB_INTERNAL void  _HB_OPEN_Free_Coverage( HB_Coverage*  c );
+HB_INTERNAL void  _HB_OPEN_Free_ClassDefinition( HB_ClassDefinition*  cd );
+HB_INTERNAL void  _HB_OPEN_Free_Device( HB_Device*  d );
+
+
+
+HB_INTERNAL HB_Error
+_HB_OPEN_Coverage_Index( HB_Coverage* c,
+			  HB_UShort      glyphID,
+			  HB_UShort*     index );
+HB_INTERNAL HB_Error
+_HB_OPEN_Get_Class( HB_ClassDefinition* cd,
+		     HB_UShort             glyphID,
+		    HB_UShort*          klass,
+		     HB_UShort*            index );
+HB_INTERNAL HB_Error
+_HB_OPEN_Get_Device( HB_Device* d,
+		      HB_UShort    size,
+		      HB_Short*    value );
+
+HB_END_HEADER
+
+#endif /* HARFBUZZ_OPEN_PRIVATE_H */
diff -rupN orginal/scribus/harfbuzz/harfbuzz-open.c patched/scribus/harfbuzz/harfbuzz-open.c
--- orginal/scribus/harfbuzz/harfbuzz-open.c	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/harfbuzz-open.c	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,1416 @@
+/*
+ * Copyright (C) 1998-2004  David Turner and Werner Lemberg
+ * Copyright (C) 2006  Behdad Esfahbod
+ *
+ * This is part of HarfBuzz, an OpenType Layout engine library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ */
+
+#include "harfbuzz-impl.h"
+#include "harfbuzz-open-private.h"
+
+
+/***************************
+ * Script related functions
+ ***************************/
+
+
+/* LangSys */
+
+static HB_Error  Load_LangSys( HB_LangSys*  ls,
+			       HB_Stream     stream )
+{
+  HB_Error   error;
+  HB_UShort  n, count;
+  HB_UShort* fi;
+
+
+  if ( ACCESS_Frame( 6L ) )
+    return error;
+
+  ls->LookupOrderOffset    = GET_UShort();    /* should be 0 */
+  ls->ReqFeatureIndex      = GET_UShort();
+  count = ls->FeatureCount = GET_UShort();
+
+  FORGET_Frame();
+
+  ls->FeatureIndex = NULL;
+
+  if ( ALLOC_ARRAY( ls->FeatureIndex, count, HB_UShort ) )
+    return error;
+
+  if ( ACCESS_Frame( count * 2L ) )
+  {
+    FREE( ls->FeatureIndex );
+    return error;
+  }
+
+  fi = ls->FeatureIndex;
+
+  for ( n = 0; n < count; n++ )
+    fi[n] = GET_UShort();
+
+  FORGET_Frame();
+
+  return HB_Err_Ok;
+}
+
+
+static void  Free_LangSys( HB_LangSys*  ls )
+{
+  FREE( ls->FeatureIndex );
+}
+
+
+/* Script */
+
+static HB_Error  Load_Script( HB_ScriptTable*  s,
+			      HB_Stream    stream )
+{
+  HB_Error   error;
+  HB_UShort  n, m, count;
+  HB_UInt   cur_offset, new_offset, base_offset;
+
+  HB_LangSysRecord*  lsr;
+
+
+  base_offset = FILE_Pos();
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  new_offset = GET_UShort() + base_offset;
+
+  FORGET_Frame();
+
+  if ( new_offset != base_offset )        /* not a NULL offset */
+  {
+    cur_offset = FILE_Pos();
+    if ( FILE_Seek( new_offset ) ||
+	 ( error = Load_LangSys( &s->DefaultLangSys,
+				 stream ) ) != HB_Err_Ok )
+      return error;
+    (void)FILE_Seek( cur_offset );
+  }
+  else
+  {
+    /* we create a DefaultLangSys table with no entries */
+
+    s->DefaultLangSys.LookupOrderOffset = 0;
+    s->DefaultLangSys.ReqFeatureIndex   = 0xFFFF;
+    s->DefaultLangSys.FeatureCount      = 0;
+    s->DefaultLangSys.FeatureIndex      = NULL;
+  }
+
+  if ( ACCESS_Frame( 2L ) )
+    goto Fail2;
+
+  count = s->LangSysCount = GET_UShort();
+
+  /* safety check; otherwise the official handling of TrueType Open
+     fonts won't work */
+
+  if ( s->LangSysCount == 0 && s->DefaultLangSys.FeatureCount == 0 )
+  {
+    error = HB_Err_Not_Covered;
+    goto Fail2;
+  }
+
+  FORGET_Frame();
+
+  s->LangSysRecord = NULL;
+
+  if ( ALLOC_ARRAY( s->LangSysRecord, count, HB_LangSysRecord ) )
+    goto Fail2;
+
+  lsr = s->LangSysRecord;
+
+  for ( n = 0; n < count; n++ )
+  {
+    if ( ACCESS_Frame( 6L ) )
+      goto Fail1;
+
+    lsr[n].LangSysTag = GET_ULong();
+    new_offset = GET_UShort() + base_offset;
+
+    FORGET_Frame();
+
+    cur_offset = FILE_Pos();
+    if ( FILE_Seek( new_offset ) ||
+	 ( error = Load_LangSys( &lsr[n].LangSys, stream ) ) != HB_Err_Ok )
+      goto Fail1;
+    (void)FILE_Seek( cur_offset );
+  }
+
+  return HB_Err_Ok;
+
+Fail1:
+  for ( m = 0; m < n; m++ )
+    Free_LangSys( &lsr[m].LangSys );
+
+  FREE( s->LangSysRecord );
+
+Fail2:
+  Free_LangSys( &s->DefaultLangSys );
+  return error;
+}
+
+
+static void  Free_Script( HB_ScriptTable*  s )
+{
+  HB_UShort           n, count;
+
+  HB_LangSysRecord*  lsr;
+
+
+  Free_LangSys( &s->DefaultLangSys );
+
+  if ( s->LangSysRecord )
+  {
+    count = s->LangSysCount;
+    lsr   = s->LangSysRecord;
+
+    for ( n = 0; n < count; n++ )
+      Free_LangSys( &lsr[n].LangSys );
+
+    FREE( lsr );
+  }
+}
+
+
+/* ScriptList */
+
+HB_INTERNAL HB_Error
+_HB_OPEN_Load_ScriptList( HB_ScriptList* sl,
+			   HB_Stream        stream )
+{
+  HB_Error   error;
+
+  HB_UShort          n, script_count;
+  HB_UInt           cur_offset, new_offset, base_offset;
+
+  HB_ScriptRecord*  sr;
+
+
+  base_offset = FILE_Pos();
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  script_count = GET_UShort();
+
+  FORGET_Frame();
+
+  sl->ScriptRecord = NULL;
+
+  if ( ALLOC_ARRAY( sl->ScriptRecord, script_count, HB_ScriptRecord ) )
+    return error;
+
+  sr = sl->ScriptRecord;
+
+  sl->ScriptCount= 0;
+  for ( n = 0; n < script_count; n++ )
+  {
+    if ( ACCESS_Frame( 6L ) )
+      goto Fail;
+
+    sr[sl->ScriptCount].ScriptTag = GET_ULong();
+    new_offset = GET_UShort() + base_offset;
+
+    FORGET_Frame();
+
+    cur_offset = FILE_Pos();
+
+    if ( FILE_Seek( new_offset ) )
+      goto Fail;
+
+    error = Load_Script( &sr[sl->ScriptCount].Script, stream );
+    if ( error == HB_Err_Ok )
+      sl->ScriptCount += 1;
+    else if ( error != HB_Err_Not_Covered )
+      goto Fail;
+
+    (void)FILE_Seek( cur_offset );
+  }
+
+  /* Empty tables are harmless and generated by fontforge.
+   * See http://bugzilla.gnome.org/show_bug.cgi?id=347073
+   */
+#if 0
+  if ( sl->ScriptCount == 0 )
+  {
+    error = ERR(HB_Err_Invalid_SubTable);
+    goto Fail;
+  }
+#endif
+  
+  return HB_Err_Ok;
+
+Fail:
+  for ( n = 0; n < sl->ScriptCount; n++ )
+    Free_Script( &sr[n].Script );
+
+  FREE( sl->ScriptRecord );
+  return error;
+}
+
+
+HB_INTERNAL void
+_HB_OPEN_Free_ScriptList( HB_ScriptList* sl )
+{
+  HB_UShort          n, count;
+
+  HB_ScriptRecord*  sr;
+
+
+  if ( sl->ScriptRecord )
+  {
+    count = sl->ScriptCount;
+    sr    = sl->ScriptRecord;
+
+    for ( n = 0; n < count; n++ )
+      Free_Script( &sr[n].Script );
+
+    FREE( sr );
+  }
+}
+
+
+
+/*********************************
+ * Feature List related functions
+ *********************************/
+
+
+/* Feature */
+
+static HB_Error  Load_Feature( HB_Feature*  f,
+			       HB_Stream     stream )
+{
+  HB_Error   error;
+
+  HB_UShort   n, count;
+
+  HB_UShort*  lli;
+
+
+  if ( ACCESS_Frame( 4L ) )
+    return error;
+
+  f->FeatureParams           = GET_UShort();    /* should be 0 */
+  count = f->LookupListCount = GET_UShort();
+
+  FORGET_Frame();
+
+  f->LookupListIndex = NULL;
+
+  if ( ALLOC_ARRAY( f->LookupListIndex, count, HB_UShort ) )
+    return error;
+
+  lli = f->LookupListIndex;
+
+  if ( ACCESS_Frame( count * 2L ) )
+  {
+    FREE( f->LookupListIndex );
+    return error;
+  }
+
+  for ( n = 0; n < count; n++ )
+    lli[n] = GET_UShort();
+
+  FORGET_Frame();
+
+  return HB_Err_Ok;
+}
+
+
+static void  Free_Feature( HB_Feature*  f )
+{
+  FREE( f->LookupListIndex );
+}
+
+
+/* FeatureList */
+
+HB_INTERNAL HB_Error
+_HB_OPEN_Load_FeatureList( HB_FeatureList* fl,
+			    HB_Stream         stream )
+{
+  HB_Error   error;
+
+  HB_UShort           n, m, count;
+  HB_UInt            cur_offset, new_offset, base_offset;
+
+  HB_FeatureRecord*  fr;
+
+
+  base_offset = FILE_Pos();
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  count = fl->FeatureCount = GET_UShort();
+
+  FORGET_Frame();
+
+  fl->FeatureRecord = NULL;
+
+  if ( ALLOC_ARRAY( fl->FeatureRecord, count, HB_FeatureRecord ) )
+    return error;
+  if ( ALLOC_ARRAY( fl->ApplyOrder, count, HB_UShort ) )
+    goto Fail2;
+  
+  fl->ApplyCount = 0;
+
+  fr = fl->FeatureRecord;
+
+  for ( n = 0; n < count; n++ )
+  {
+    if ( ACCESS_Frame( 6L ) )
+      goto Fail1;
+
+    fr[n].FeatureTag = GET_ULong();
+    new_offset = GET_UShort() + base_offset;
+
+    FORGET_Frame();
+
+    cur_offset = FILE_Pos();
+    if ( FILE_Seek( new_offset ) ||
+	 ( error = Load_Feature( &fr[n].Feature, stream ) ) != HB_Err_Ok )
+      goto Fail1;
+    (void)FILE_Seek( cur_offset );
+  }
+
+  return HB_Err_Ok;
+
+Fail1:
+  for ( m = 0; m < n; m++ )
+    Free_Feature( &fr[m].Feature );
+
+  FREE( fl->ApplyOrder );
+
+Fail2:
+  FREE( fl->FeatureRecord );
+
+  return error;
+}
+
+
+HB_INTERNAL void
+_HB_OPEN_Free_FeatureList( HB_FeatureList*  fl )
+{
+  HB_UShort           n, count;
+
+  HB_FeatureRecord*  fr;
+
+
+  if ( fl->FeatureRecord )
+  {
+    count = fl->FeatureCount;
+    fr    = fl->FeatureRecord;
+
+    for ( n = 0; n < count; n++ )
+      Free_Feature( &fr[n].Feature );
+
+    FREE( fr );
+  }
+  
+  FREE( fl->ApplyOrder );
+}
+
+
+
+/********************************
+ * Lookup List related functions
+ ********************************/
+
+/* the subroutines of the following two functions are defined in
+   ftxgsub.c and ftxgpos.c respectively                          */
+
+
+/* SubTable */
+
+static HB_Error  Load_SubTable( HB_SubTable*  st,
+				HB_Stream     stream,
+				HB_Type       table_type,
+				HB_UShort     lookup_type )
+{
+  if ( table_type == HB_Type_GSUB )
+    return _HB_GSUB_Load_SubTable ( &st->st.gsub, stream, lookup_type );
+  else
+    return _HB_GPOS_Load_SubTable ( &st->st.gpos, stream, lookup_type );
+}
+
+
+static void  Free_SubTable( HB_SubTable*  st,
+			    HB_Type       table_type,
+			    HB_UShort      lookup_type )
+{
+  if ( table_type == HB_Type_GSUB )
+    _HB_GSUB_Free_SubTable ( &st->st.gsub, lookup_type );
+  else
+    _HB_GPOS_Free_SubTable ( &st->st.gpos, lookup_type );
+}
+
+
+/* Lookup */
+
+static HB_Error  Load_Lookup( HB_Lookup*   l,
+			      HB_Stream     stream,
+			      HB_Type      type )
+{
+  HB_Error   error;
+
+  HB_UShort      n, m, count;
+  HB_UInt       cur_offset, new_offset, base_offset;
+
+  HB_SubTable*  st;
+
+  HB_Bool        is_extension = FALSE;
+
+
+  base_offset = FILE_Pos();
+
+  if ( ACCESS_Frame( 6L ) )
+    return error;
+
+  l->LookupType            = GET_UShort();
+  l->LookupFlag            = GET_UShort();
+  count = l->SubTableCount = GET_UShort();
+
+  FORGET_Frame();
+
+  l->SubTable = NULL;
+
+  if ( ALLOC_ARRAY( l->SubTable, count, HB_SubTable ) )
+    return error;
+
+  st = l->SubTable;
+
+  if ( ( type == HB_Type_GSUB && l->LookupType == HB_GSUB_LOOKUP_EXTENSION ) ||
+       ( type == HB_Type_GPOS && l->LookupType == HB_GPOS_LOOKUP_EXTENSION ) )
+    is_extension = TRUE;
+
+  for ( n = 0; n < count; n++ )
+  {
+    if ( ACCESS_Frame( 2L ) )
+      goto Fail;
+
+    new_offset = GET_UShort() + base_offset;
+
+    FORGET_Frame();
+
+    cur_offset = FILE_Pos();
+
+    if ( is_extension )
+    {
+      if ( FILE_Seek( new_offset ) || ACCESS_Frame( 8L ) )
+	goto Fail;
+
+      if (GET_UShort() != 1) /* format should be 1 */
+	goto Fail;
+
+      l->LookupType = GET_UShort();
+      new_offset += GET_ULong();
+
+      FORGET_Frame();
+    }
+
+    if ( FILE_Seek( new_offset ) ||
+	 ( error = Load_SubTable( &st[n], stream,
+				  type, l->LookupType ) ) != HB_Err_Ok )
+      goto Fail;
+    (void)FILE_Seek( cur_offset );
+  }
+
+  return HB_Err_Ok;
+
+Fail:
+  for ( m = 0; m < n; m++ )
+    Free_SubTable( &st[m], type, l->LookupType );
+
+  FREE( l->SubTable );
+  return error;
+}
+
+
+static void  Free_Lookup( HB_Lookup*   l,
+			  HB_Type      type)
+{
+  HB_UShort      n, count;
+
+  HB_SubTable*  st;
+
+
+  if ( l->SubTable )
+  {
+    count = l->SubTableCount;
+    st    = l->SubTable;
+
+    for ( n = 0; n < count; n++ )
+      Free_SubTable( &st[n], type, l->LookupType );
+
+    FREE( st );
+  }
+}
+
+
+/* LookupList */
+
+HB_INTERNAL HB_Error
+_HB_OPEN_Load_LookupList( HB_LookupList* ll,
+			   HB_Stream        stream,
+			   HB_Type         type )
+{
+  HB_Error   error;
+
+  HB_UShort    n, m, count;
+  HB_UInt     cur_offset, new_offset, base_offset;
+
+  HB_Lookup*  l;
+
+
+  base_offset = FILE_Pos();
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  count = ll->LookupCount = GET_UShort();
+
+  FORGET_Frame();
+
+  ll->Lookup = NULL;
+
+  if ( ALLOC_ARRAY( ll->Lookup, count, HB_Lookup ) )
+    return error;
+  if ( ALLOC_ARRAY( ll->Properties, count, HB_UInt ) )
+    goto Fail2;
+
+  l = ll->Lookup;
+
+  for ( n = 0; n < count; n++ )
+  {
+    if ( ACCESS_Frame( 2L ) )
+      goto Fail1;
+
+    new_offset = GET_UShort() + base_offset;
+
+    FORGET_Frame();
+
+    cur_offset = FILE_Pos();
+    if ( FILE_Seek( new_offset ) ||
+	 ( error = Load_Lookup( &l[n], stream, type ) ) != HB_Err_Ok )
+      goto Fail1;
+    (void)FILE_Seek( cur_offset );
+  }
+
+  return HB_Err_Ok;
+
+Fail1:
+  FREE( ll->Properties );
+
+  for ( m = 0; m < n; m++ )
+    Free_Lookup( &l[m], type );
+
+Fail2:
+  FREE( ll->Lookup );
+  return error;
+}
+
+
+HB_INTERNAL void
+_HB_OPEN_Free_LookupList( HB_LookupList* ll,
+		       HB_Type         type )
+{
+  HB_UShort    n, count;
+
+  HB_Lookup*  l;
+
+
+  FREE( ll->Properties );
+
+  if ( ll->Lookup )
+  {
+    count = ll->LookupCount;
+    l     = ll->Lookup;
+
+    for ( n = 0; n < count; n++ )
+      Free_Lookup( &l[n], type );
+
+    FREE( l );
+  }
+}
+
+
+
+/*****************************
+ * Coverage related functions
+ *****************************/
+
+
+/* CoverageFormat1 */
+
+static HB_Error  Load_Coverage1( HB_CoverageFormat1*  cf1,
+				 HB_Stream             stream )
+{
+  HB_Error   error;
+
+  HB_UShort  n, count;
+
+  HB_UShort* ga;
+
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  count = cf1->GlyphCount = GET_UShort();
+
+  FORGET_Frame();
+
+  cf1->GlyphArray = NULL;
+
+  if ( ALLOC_ARRAY( cf1->GlyphArray, count, HB_UShort ) )
+    return error;
+
+  ga = cf1->GlyphArray;
+
+  if ( ACCESS_Frame( count * 2L ) )
+  {
+    FREE( cf1->GlyphArray );
+    return error;
+  }
+
+  for ( n = 0; n < count; n++ )
+    ga[n] = GET_UShort();
+
+  FORGET_Frame();
+
+  return HB_Err_Ok;
+}
+
+
+static void  Free_Coverage1( HB_CoverageFormat1*  cf1)
+{
+  FREE( cf1->GlyphArray );
+}
+
+
+/* CoverageFormat2 */
+
+static HB_Error  Load_Coverage2( HB_CoverageFormat2*  cf2,
+				 HB_Stream             stream )
+{
+  HB_Error   error;
+
+  HB_UShort         n, count;
+
+  HB_RangeRecord*  rr;
+
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  count = cf2->RangeCount = GET_UShort();
+
+  FORGET_Frame();
+
+  cf2->RangeRecord = NULL;
+
+  if ( ALLOC_ARRAY( cf2->RangeRecord, count, HB_RangeRecord ) )
+    return error;
+
+  rr = cf2->RangeRecord;
+
+  if ( ACCESS_Frame( count * 6L ) )
+    goto Fail;
+
+  for ( n = 0; n < count; n++ )
+  {
+    rr[n].Start              = GET_UShort();
+    rr[n].End                = GET_UShort();
+    rr[n].StartCoverageIndex = GET_UShort();
+
+    /* sanity check; we are limited to 16bit integers */
+    if ( rr[n].Start > rr[n].End ||
+	 ( rr[n].End - rr[n].Start + (long)rr[n].StartCoverageIndex ) >=
+	   0x10000L )
+    {
+      error = ERR(HB_Err_Invalid_SubTable);
+      goto Fail;
+    }
+  }
+
+  FORGET_Frame();
+
+  return HB_Err_Ok;
+
+Fail:
+  FREE( cf2->RangeRecord );
+  return error;
+}
+
+
+static void  Free_Coverage2( HB_CoverageFormat2*  cf2 )
+{
+  FREE( cf2->RangeRecord );
+}
+
+
+HB_INTERNAL HB_Error
+_HB_OPEN_Load_Coverage( HB_Coverage* c,
+			 HB_Stream      stream )
+{
+  HB_Error   error;
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  c->CoverageFormat = GET_UShort();
+
+  FORGET_Frame();
+
+  switch ( c->CoverageFormat )
+  {
+  case 1:  return Load_Coverage1( &c->cf.cf1, stream );
+  case 2:  return Load_Coverage2( &c->cf.cf2, stream );
+  default: return ERR(HB_Err_Invalid_SubTable_Format);
+  }
+
+  return HB_Err_Ok;               /* never reached */
+}
+
+
+HB_INTERNAL void
+_HB_OPEN_Free_Coverage( HB_Coverage* c )
+{
+  switch ( c->CoverageFormat )
+  {
+  case 1:  Free_Coverage1( &c->cf.cf1 ); break;
+  case 2:  Free_Coverage2( &c->cf.cf2 ); break;
+  default:					 break;
+  }
+}
+
+
+static HB_Error  Coverage_Index1( HB_CoverageFormat1*  cf1,
+				  HB_UShort             glyphID,
+				  HB_UShort*            index )
+{
+  HB_UShort min, max, new_min, new_max, middle;
+
+  HB_UShort*  array = cf1->GlyphArray;
+
+
+  /* binary search */
+
+  if ( cf1->GlyphCount == 0 )
+    return HB_Err_Not_Covered;
+
+  new_min = 0;
+  new_max = cf1->GlyphCount - 1;
+
+  do
+  {
+    min = new_min;
+    max = new_max;
+
+    /* we use (min + max) / 2 = max - (max - min) / 2  to avoid
+       overflow and rounding errors                             */
+
+    middle = max - ( ( max - min ) >> 1 );
+
+    if ( glyphID == array[middle] )
+    {
+      *index = middle;
+      return HB_Err_Ok;
+    }
+    else if ( glyphID < array[middle] )
+    {
+      if ( middle == min )
+	break;
+      new_max = middle - 1;
+    }
+    else
+    {
+      if ( middle == max )
+	break;
+      new_min = middle + 1;
+    }
+  } while ( min < max );
+
+  return HB_Err_Not_Covered;
+}
+
+
+static HB_Error  Coverage_Index2( HB_CoverageFormat2*  cf2,
+				  HB_UShort             glyphID,
+				  HB_UShort*            index )
+{
+  HB_UShort         min, max, new_min, new_max, middle;
+
+  HB_RangeRecord*  rr = cf2->RangeRecord;
+
+
+  /* binary search */
+
+  if ( cf2->RangeCount == 0 )
+    return HB_Err_Not_Covered;
+
+  new_min = 0;
+  new_max = cf2->RangeCount - 1;
+
+  do
+  {
+    min = new_min;
+    max = new_max;
+
+    /* we use (min + max) / 2 = max - (max - min) / 2  to avoid
+       overflow and rounding errors                             */
+
+    middle = max - ( ( max - min ) >> 1 );
+
+    if ( glyphID >= rr[middle].Start && glyphID <= rr[middle].End )
+    {
+      *index = rr[middle].StartCoverageIndex + glyphID - rr[middle].Start;
+      return HB_Err_Ok;
+    }
+    else if ( glyphID < rr[middle].Start )
+    {
+      if ( middle == min )
+	break;
+      new_max = middle - 1;
+    }
+    else
+    {
+      if ( middle == max )
+	break;
+      new_min = middle + 1;
+    }
+  } while ( min < max );
+
+  return HB_Err_Not_Covered;
+}
+
+
+HB_INTERNAL HB_Error
+_HB_OPEN_Coverage_Index( HB_Coverage* c,
+			  HB_UShort      glyphID,
+			  HB_UShort*     index )
+{
+  switch ( c->CoverageFormat )
+  {
+  case 1:  return Coverage_Index1( &c->cf.cf1, glyphID, index );
+  case 2:  return Coverage_Index2( &c->cf.cf2, glyphID, index );
+  default: return ERR(HB_Err_Invalid_SubTable_Format);
+  }
+
+  return HB_Err_Ok;               /* never reached */
+}
+
+
+
+/*************************************
+ * Class Definition related functions
+ *************************************/
+
+
+/* ClassDefFormat1 */
+
+static HB_Error  Load_ClassDef1( HB_ClassDefinition*  cd,
+				 HB_UShort             limit,
+				 HB_Stream             stream )
+{
+  HB_Error   error;
+
+  HB_UShort             n, count;
+
+  HB_UShort*            cva;
+
+  HB_ClassDefFormat1*  cdf1;
+
+
+  cdf1 = &cd->cd.cd1;
+
+  if ( ACCESS_Frame( 4L ) )
+    return error;
+
+  cdf1->StartGlyph         = GET_UShort();
+  count = cdf1->GlyphCount = GET_UShort();
+
+  FORGET_Frame();
+
+  /* sanity check; we are limited to 16bit integers */
+
+  if ( cdf1->StartGlyph + (long)count >= 0x10000L )
+    return ERR(HB_Err_Invalid_SubTable);
+
+  cdf1->ClassValueArray = NULL;
+
+  if ( ALLOC_ARRAY( cdf1->ClassValueArray, count, HB_UShort ) )
+    return error;
+
+  cva = cdf1->ClassValueArray;
+
+  if ( ACCESS_Frame( count * 2L ) )
+    goto Fail;
+
+  for ( n = 0; n < count; n++ )
+  {
+    cva[n] = GET_UShort();
+    if ( cva[n] >= limit )
+    {
+      error = ERR(HB_Err_Invalid_SubTable);
+      goto Fail;
+    }
+  }
+
+  FORGET_Frame();
+
+  return HB_Err_Ok;
+
+Fail:
+  FREE( cva );
+
+  return error;
+}
+
+
+static void  Free_ClassDef1( HB_ClassDefFormat1*  cdf1 )
+{
+  FREE( cdf1->ClassValueArray );
+}
+
+
+/* ClassDefFormat2 */
+
+static HB_Error  Load_ClassDef2( HB_ClassDefinition*  cd,
+				 HB_UShort             limit,
+				 HB_Stream             stream )
+{
+  HB_Error   error;
+
+  HB_UShort              n, count;
+
+  HB_ClassRangeRecord*  crr;
+
+  HB_ClassDefFormat2*   cdf2;
+
+
+  cdf2 = &cd->cd.cd2;
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  count = GET_UShort();
+  cdf2->ClassRangeCount = 0; /* zero for now.  we fill with the number of good entries later */
+
+  FORGET_Frame();
+
+  cdf2->ClassRangeRecord = NULL;
+
+  if ( ALLOC_ARRAY( cdf2->ClassRangeRecord, count, HB_ClassRangeRecord ) )
+    return error;
+
+  crr = cdf2->ClassRangeRecord;
+
+  if ( ACCESS_Frame( count * 6L ) )
+    goto Fail;
+
+  for ( n = 0; n < count; n++ )
+  {
+    crr[n].Start = GET_UShort();
+    crr[n].End   = GET_UShort();
+    crr[n].Class = GET_UShort();
+
+    /* sanity check */
+
+    if ( crr[n].Start > crr[n].End ||
+	 crr[n].Class >= limit )
+    {
+      /* XXX
+       * Corrupt entry.  Skip it.
+       * This is hit by Nafees Nastaliq font for example
+       */
+       n--;
+       count--;
+    }
+  }
+
+  FORGET_Frame();
+
+  cdf2->ClassRangeCount = count;
+
+  return HB_Err_Ok;
+
+Fail:
+  FREE( crr );
+
+  return error;
+}
+
+
+static void  Free_ClassDef2( HB_ClassDefFormat2*  cdf2 )
+{
+  FREE( cdf2->ClassRangeRecord );
+}
+
+
+/* ClassDefinition */
+
+HB_INTERNAL HB_Error
+_HB_OPEN_Load_ClassDefinition( HB_ClassDefinition* cd,
+				HB_UShort             limit,
+				HB_Stream             stream )
+{
+  HB_Error   error;
+
+  if ( ACCESS_Frame( 2L ) )
+    return error;
+
+  cd->ClassFormat = GET_UShort();
+
+  FORGET_Frame();
+
+  switch ( cd->ClassFormat )
+  {
+  case 1:  error = Load_ClassDef1( cd, limit, stream ); break;
+  case 2:  error = Load_ClassDef2( cd, limit, stream ); break;
+  default: error = ERR(HB_Err_Invalid_SubTable_Format);	break;
+  }
+
+  if ( error )
+    return error;
+
+  cd->loaded = TRUE;
+
+  return HB_Err_Ok;
+}
+
+
+static HB_Error
+_HB_OPEN_Load_EmptyClassDefinition( HB_ClassDefinition*  cd )
+{
+  HB_Error   error;
+
+  cd->ClassFormat = 1; /* Meaningless */
+
+  if ( ALLOC_ARRAY( cd->cd.cd1.ClassValueArray, 1, HB_UShort ) )
+    return error;
+
+  cd->loaded = TRUE;
+
+  return HB_Err_Ok;
+}
+
+HB_INTERNAL HB_Error
+_HB_OPEN_Load_EmptyOrClassDefinition( HB_ClassDefinition* cd,
+					       HB_UShort             limit,
+					       HB_UInt              class_offset,
+					       HB_UInt              base_offset,
+					       HB_Stream             stream )
+{
+  HB_Error error;
+  HB_UInt               cur_offset;
+
+  cur_offset = FILE_Pos();
+
+  if ( class_offset )
+    {
+      if ( !FILE_Seek( class_offset + base_offset ) )
+	error = _HB_OPEN_Load_ClassDefinition( cd, limit, stream );
+    }
+  else
+     error = _HB_OPEN_Load_EmptyClassDefinition ( cd );
+
+  if (error == HB_Err_Ok)
+    (void)FILE_Seek( cur_offset ); /* Changes error as a side-effect */
+
+  return error;
+}
+
+HB_INTERNAL void
+_HB_OPEN_Free_ClassDefinition( HB_ClassDefinition*  cd )
+{
+  if ( !cd->loaded )
+    return;
+
+  switch ( cd->ClassFormat )
+  {
+  case 1:  Free_ClassDef1( &cd->cd.cd1 ); break;
+  case 2:  Free_ClassDef2( &cd->cd.cd2 ); break;
+  default:				  break;
+  }
+}
+
+
+static HB_Error  Get_Class1( HB_ClassDefFormat1*  cdf1,
+			     HB_UShort             glyphID,
+			     HB_UShort*            klass,
+			     HB_UShort*            index )
+{
+  HB_UShort*  cva = cdf1->ClassValueArray;
+
+
+  if ( index )
+    *index = 0;
+
+  if ( glyphID >= cdf1->StartGlyph &&
+       glyphID < cdf1->StartGlyph + cdf1->GlyphCount )
+  {
+    *klass = cva[glyphID - cdf1->StartGlyph];
+    return HB_Err_Ok;
+  }
+  else
+  {
+    *klass = 0;
+    return HB_Err_Not_Covered;
+  }
+}
+
+
+/* we need the index value of the last searched class range record
+   in case of failure for constructed GDEF tables                  */
+
+static HB_Error  Get_Class2( HB_ClassDefFormat2*  cdf2,
+			     HB_UShort             glyphID,
+			     HB_UShort*            klass,
+			     HB_UShort*            index )
+{
+  HB_Error               error = HB_Err_Ok;
+  HB_UShort              min, max, new_min, new_max, middle;
+
+  HB_ClassRangeRecord*  crr = cdf2->ClassRangeRecord;
+
+
+  /* binary search */
+
+  if ( cdf2->ClassRangeCount == 0 )
+    {
+      *klass = 0;
+      if ( index )
+	*index = 0;
+      
+      return HB_Err_Not_Covered;
+    }
+
+  new_min = 0;
+  new_max = cdf2->ClassRangeCount - 1;
+
+  do
+  {
+    min = new_min;
+    max = new_max;
+
+    /* we use (min + max) / 2 = max - (max - min) / 2  to avoid
+       overflow and rounding errors                             */
+
+    middle = max - ( ( max - min ) >> 1 );
+
+    if ( glyphID >= crr[middle].Start && glyphID <= crr[middle].End )
+    {
+      *klass = crr[middle].Class;
+      error  = HB_Err_Ok;
+      break;
+    }
+    else if ( glyphID < crr[middle].Start )
+    {
+      if ( middle == min )
+      {
+	*klass = 0;
+	error  = HB_Err_Not_Covered;
+	break;
+      }
+      new_max = middle - 1;
+    }
+    else
+    {
+      if ( middle == max )
+      {
+	*klass = 0;
+	error  = HB_Err_Not_Covered;
+	break;
+      }
+      new_min = middle + 1;
+    }
+  } while ( min < max );
+
+  if ( index )
+    *index = middle;
+
+  return error;
+}
+
+
+HB_INTERNAL HB_Error
+_HB_OPEN_Get_Class( HB_ClassDefinition* cd,
+		     HB_UShort             glyphID,
+		    HB_UShort*          klass,
+		     HB_UShort*            index )
+{
+  switch ( cd->ClassFormat )
+  {
+  case 1:  return Get_Class1( &cd->cd.cd1, glyphID, klass, index );
+  case 2:  return Get_Class2( &cd->cd.cd2, glyphID, klass, index );
+  default: return ERR(HB_Err_Invalid_SubTable_Format);
+  }
+
+  return HB_Err_Ok;               /* never reached */
+}
+
+
+
+/***************************
+ * Device related functions
+ ***************************/
+
+
+HB_INTERNAL HB_Error
+_HB_OPEN_Load_Device( HB_Device* d,
+		       HB_Stream    stream )
+{
+  HB_Error   error;
+
+  HB_UShort   n, count;
+
+  HB_UShort*  dv;
+
+
+  if ( ACCESS_Frame( 6L ) )
+    return error;
+
+  d->StartSize   = GET_UShort();
+  d->EndSize     = GET_UShort();
+  d->DeltaFormat = GET_UShort();
+
+  FORGET_Frame();
+
+  d->DeltaValue = NULL;
+
+  if ( d->StartSize > d->EndSize ||
+       d->DeltaFormat == 0 || d->DeltaFormat > 3 )
+    {
+      /* XXX
+       * I've seen fontforge generate DeltaFormat == 0.
+       * Just return Ok and let the NULL DeltaValue disable
+       * this table.
+       */
+      return HB_Err_Ok;
+    }
+
+  count = ( ( d->EndSize - d->StartSize + 1 ) >>
+	      ( 4 - d->DeltaFormat ) ) + 1;
+
+  if ( ALLOC_ARRAY( d->DeltaValue, count, HB_UShort ) )
+    return error;
+
+  if ( ACCESS_Frame( count * 2L ) )
+  {
+    FREE( d->DeltaValue );
+    return error;
+  }
+
+  dv = d->DeltaValue;
+
+  for ( n = 0; n < count; n++ )
+    dv[n] = GET_UShort();
+
+  FORGET_Frame();
+
+  return HB_Err_Ok;
+}
+
+
+HB_INTERNAL void
+_HB_OPEN_Free_Device( HB_Device* d )
+{
+  FREE( d->DeltaValue );
+}
+
+
+/* Since we have the delta values stored in compressed form, we must
+   uncompress it now.  To simplify the interface, the function always
+   returns a meaningful value in `value'; the error is just for
+   information.
+			       |                |
+   format = 1: 0011223344556677|8899101112131415|...
+			       |                |
+		    byte 1           byte 2
+
+     00: (byte >> 14) & mask
+     11: (byte >> 12) & mask
+     ...
+
+     mask = 0x0003
+			       |                |
+   format = 2: 0000111122223333|4444555566667777|...
+			       |                |
+		    byte 1           byte 2
+
+     0000: (byte >> 12) & mask
+     1111: (byte >>  8) & mask
+     ...
+
+     mask = 0x000F
+			       |                |
+   format = 3: 0000000011111111|2222222233333333|...
+			       |                |
+		    byte 1           byte 2
+
+     00000000: (byte >> 8) & mask
+     11111111: (byte >> 0) & mask
+     ....
+
+     mask = 0x00FF                                    */
+
+HB_INTERNAL HB_Error
+_HB_OPEN_Get_Device( HB_Device* d,
+		      HB_UShort    size,
+		      HB_Short*    value )
+{
+  HB_UShort  byte, bits, mask, f, s;
+
+
+  f = d->DeltaFormat;
+
+  if ( d->DeltaValue && size >= d->StartSize && size <= d->EndSize )
+  {
+    s    = size - d->StartSize;
+    byte = d->DeltaValue[s >> ( 4 - f )];
+    bits = byte >> ( 16 - ( ( s % ( 1 << ( 4 - f ) ) + 1 ) << f ) );
+    mask = 0xFFFF >> ( 16 - ( 1 << f ) );
+
+    *value = (HB_Short)( bits & mask );
+
+    /* conversion to a signed value */
+
+    if ( *value >= ( ( mask + 1 ) >> 1 ) )
+      *value -= mask + 1;
+
+    return HB_Err_Ok;
+  }
+  else
+  {
+    *value = 0;
+    return HB_Err_Not_Covered;
+  }
+}
+
+
+/* END */
diff -rupN orginal/scribus/harfbuzz/harfbuzz-open.h patched/scribus/harfbuzz/harfbuzz-open.h
--- orginal/scribus/harfbuzz/harfbuzz-open.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/harfbuzz-open.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,282 @@
+/*
+ * Copyright (C) 1998-2004  David Turner and Werner Lemberg
+ * Copyright (C) 2006  Behdad Esfahbod
+ *
+ * This is part of HarfBuzz, an OpenType Layout engine library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ */
+
+#ifndef HARFBUZZ_OPEN_H
+#define HARFBUZZ_OPEN_H
+
+#include "harfbuzz-global.h"
+
+HB_BEGIN_HEADER
+
+/* Use this if a feature applies to all glyphs */
+#define HB_ALL_GLYPHS                    0xFFFF
+
+#define HB_DEFAULT_LANGUAGE              0xFFFF
+
+#define HB_MAX_NESTING_LEVEL             100
+
+
+/* Script list related structures */
+
+struct  HB_LangSys_
+{
+  HB_UShort   LookupOrderOffset;      /* always 0 for TT Open 1.0  */
+  HB_UShort   ReqFeatureIndex;        /* required FeatureIndex     */
+  HB_UShort   FeatureCount;           /* number of Feature indices */
+  HB_UShort*  FeatureIndex;           /* array of Feature indices  */
+};
+
+typedef struct HB_LangSys_  HB_LangSys;
+
+
+struct  HB_LangSysRecord_
+{
+  HB_UInt     LangSysTag;            /* LangSysTag identifier */
+  HB_LangSys  LangSys;               /* LangSys table         */
+};
+
+typedef struct HB_LangSysRecord_  HB_LangSysRecord;
+
+
+struct  HB_ScriptTable_
+{
+  HB_LangSys         DefaultLangSys; /* DefaultLangSys table     */
+  HB_UShort           LangSysCount;   /* number of LangSysRecords */
+  HB_LangSysRecord*  LangSysRecord;  /* array of LangSysRecords  */
+};
+
+typedef struct HB_ScriptTable_  HB_ScriptTable;
+
+
+struct  HB_ScriptRecord_
+{
+  HB_UInt        ScriptTag;              /* ScriptTag identifier */
+  HB_ScriptTable  Script;                 /* Script table         */
+};
+
+typedef struct HB_ScriptRecord_  HB_ScriptRecord;
+
+
+struct  HB_ScriptList_
+{
+  HB_UShort          ScriptCount;     /* number of ScriptRecords */
+  HB_ScriptRecord*  ScriptRecord;    /* array of ScriptRecords  */
+};
+
+typedef struct HB_ScriptList_  HB_ScriptList;
+
+
+/* Feature list related structures */
+
+struct HB_Feature_
+{
+  HB_UShort   FeatureParams;          /* always 0 for TT Open 1.0     */
+  HB_UShort   LookupListCount;        /* number of LookupList indices */
+  HB_UShort*  LookupListIndex;        /* array of LookupList indices  */
+};
+
+typedef struct HB_Feature_  HB_Feature;
+
+
+struct  HB_FeatureRecord_
+{
+  HB_UInt     FeatureTag;            /* FeatureTag identifier */
+  HB_Feature  Feature;               /* Feature table         */
+};
+
+typedef struct HB_FeatureRecord_  HB_FeatureRecord;
+
+
+struct  HB_FeatureList_
+{
+  HB_UShort           FeatureCount;   /* number of FeatureRecords */
+  HB_FeatureRecord*  FeatureRecord;  /* array of FeatureRecords  */
+  HB_UShort*		ApplyOrder;	/* order to apply features */
+  HB_UShort		ApplyCount;	/* number of elements in ApplyOrder */
+};
+
+typedef struct HB_FeatureList_  HB_FeatureList;
+
+
+/* Lookup list related structures */
+
+typedef struct HB_SubTable_  HB_SubTable;
+
+
+struct  HB_Lookup_
+{
+  HB_UShort      LookupType;          /* Lookup type         */
+  HB_UShort      LookupFlag;          /* Lookup qualifiers   */
+  HB_UShort      SubTableCount;       /* number of SubTables */
+  HB_SubTable*  SubTable;            /* array of SubTables  */
+};
+
+typedef struct HB_Lookup_  HB_Lookup;
+
+
+/* The `Properties' field is not defined in the OpenType specification but
+   is needed for processing lookups.  If properties[n] is > 0, the
+   functions HB_GSUB_Apply_String() resp. HB_GPOS_Apply_String() will
+   process Lookup[n] for glyphs which have the specific bit not set in
+   the `properties' field of the input string object.                  */
+
+struct  HB_LookupList_
+{
+  HB_UShort    LookupCount;           /* number of Lookups       */
+  HB_Lookup*  Lookup;                /* array of Lookup records */
+  HB_UInt*     Properties;            /* array of flags          */
+};
+
+typedef struct HB_LookupList_  HB_LookupList;
+
+
+/* Possible LookupFlag bit masks.  `HB_LOOKUP_FLAG_IGNORE_SPECIAL_MARKS' comes from the
+   OpenType 1.2 specification; HB_LOOKUP_FLAG_RIGHT_TO_LEFT has been (re)introduced in
+   OpenType 1.3 -- if set, the last glyph in a cursive attachment
+   sequence has to be positioned on the baseline -- regardless of the
+   writing direction.                                                    */
+
+#define HB_LOOKUP_FLAG_RIGHT_TO_LEFT         0x0001
+#define HB_LOOKUP_FLAG_IGNORE_BASE_GLYPHS    0x0002
+#define HB_LOOKUP_FLAG_IGNORE_LIGATURES      0x0004
+#define HB_LOOKUP_FLAG_IGNORE_MARKS          0x0008
+#define HB_LOOKUP_FLAG_IGNORE_SPECIAL_MARKS  0xFF00
+
+
+struct  HB_CoverageFormat1_
+{
+  HB_UShort   GlyphCount;             /* number of glyphs in GlyphArray */
+  HB_UShort*  GlyphArray;             /* array of glyph IDs             */
+};
+
+typedef struct HB_CoverageFormat1_  HB_CoverageFormat1;
+
+
+struct HB_RangeRecord_
+{
+  HB_UShort  Start;                   /* first glyph ID in the range */
+  HB_UShort  End;                     /* last glyph ID in the range  */
+  HB_UShort  StartCoverageIndex;      /* coverage index of first
+					 glyph ID in the range       */
+};
+
+typedef struct HB_RangeRecord_  HB_RangeRecord;
+
+
+struct  HB_CoverageFormat2_
+{
+  HB_UShort         RangeCount;       /* number of RangeRecords */
+  HB_RangeRecord*  RangeRecord;      /* array of RangeRecords  */
+};
+
+typedef struct HB_CoverageFormat2_  HB_CoverageFormat2;
+
+
+struct  HB_Coverage_
+{
+  HB_UShort  CoverageFormat;          /* 1 or 2 */
+
+  union
+  {
+    HB_CoverageFormat1  cf1;
+    HB_CoverageFormat2  cf2;
+  } cf;
+};
+
+typedef struct HB_Coverage_  HB_Coverage;
+
+
+struct  HB_ClassDefFormat1_
+{
+  HB_UShort   StartGlyph;             /* first glyph ID of the
+					 ClassValueArray             */
+  HB_UShort   GlyphCount;             /* size of the ClassValueArray */
+  HB_UShort*  ClassValueArray;        /* array of class values       */
+};
+
+typedef struct HB_ClassDefFormat1_  HB_ClassDefFormat1;
+
+
+struct  HB_ClassRangeRecord_
+{
+  HB_UShort  Start;                   /* first glyph ID in the range    */
+  HB_UShort  End;                     /* last glyph ID in the range     */
+  HB_UShort  Class;                   /* applied to all glyphs in range */
+};
+
+typedef struct HB_ClassRangeRecord_  HB_ClassRangeRecord;
+
+
+struct  HB_ClassDefFormat2_
+{
+  HB_UShort              ClassRangeCount;
+				      /* number of ClassRangeRecords */
+  HB_ClassRangeRecord*  ClassRangeRecord;
+				      /* array of ClassRangeRecords  */
+};
+
+typedef struct HB_ClassDefFormat2_  HB_ClassDefFormat2;
+
+
+struct  HB_ClassDefinition_
+{
+  HB_Bool    loaded;
+
+  HB_UShort  ClassFormat;             /* 1 or 2                      */
+
+  union
+  {
+    HB_ClassDefFormat1  cd1;
+    HB_ClassDefFormat2  cd2;
+  } cd;
+};
+
+typedef struct HB_ClassDefinition_  HB_ClassDefinition;
+
+
+struct HB_Device_
+{
+  HB_UShort   StartSize;              /* smallest size to correct      */
+  HB_UShort   EndSize;                /* largest size to correct       */
+  HB_UShort   DeltaFormat;            /* DeltaValue array data format:
+					 1, 2, or 3                    */
+  HB_UShort*  DeltaValue;             /* array of compressed data      */
+};
+
+typedef struct HB_Device_  HB_Device;
+
+
+enum  HB_Type_
+{
+  HB_Type_GSUB,
+  HB_Type_GPOS
+};
+
+typedef enum HB_Type_  HB_Type;
+
+
+HB_END_HEADER
+
+#endif /* HARFBUZZ_OPEN_H */
diff -rupN orginal/scribus/harfbuzz/harfbuzz-shaper-all.cpp patched/scribus/harfbuzz/harfbuzz-shaper-all.cpp
--- orginal/scribus/harfbuzz/harfbuzz-shaper-all.cpp	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/harfbuzz-shaper-all.cpp	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies)
+ *
+ * This is part of HarfBuzz, an OpenType Layout engine library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ */
+
+#include "harfbuzz-shaper.cpp"
+#include "harfbuzz-indic.cpp"
+extern "C" {
+#include "harfbuzz-tibetan.c"
+#include "harfbuzz-khmer.c"
+#include "harfbuzz-hebrew.c"
+#include "harfbuzz-arabic.c"
+#include "harfbuzz-hangul.c"
+#include "harfbuzz-myanmar.c"
+#include "harfbuzz-thai.c"
+}
+
diff -rupN orginal/scribus/harfbuzz/harfbuzz-shaper-private.h patched/scribus/harfbuzz/harfbuzz-shaper-private.h
--- orginal/scribus/harfbuzz/harfbuzz-shaper-private.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/harfbuzz-shaper-private.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,167 @@
+/*
+ * Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies)
+ *
+ * This is part of HarfBuzz, an OpenType Layout engine library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ */
+
+#ifndef HARFBUZZ_SHAPER_PRIVATE_H
+#define HARFBUZZ_SHAPER_PRIVATE_H
+
+HB_BEGIN_HEADER
+
+enum {
+    C_DOTTED_CIRCLE = 0x25CC
+};
+
+typedef enum 
+{
+    HB_Combining_BelowLeftAttached       = 200,
+    HB_Combining_BelowAttached           = 202,
+    HB_Combining_BelowRightAttached      = 204,
+    HB_Combining_LeftAttached            = 208,
+    HB_Combining_RightAttached           = 210,
+    HB_Combining_AboveLeftAttached       = 212,
+    HB_Combining_AboveAttached           = 214,
+    HB_Combining_AboveRightAttached      = 216,
+
+    HB_Combining_BelowLeft               = 218,
+    HB_Combining_Below                   = 220,
+    HB_Combining_BelowRight              = 222,
+    HB_Combining_Left                    = 224,
+    HB_Combining_Right                   = 226,
+    HB_Combining_AboveLeft               = 228,
+    HB_Combining_Above                   = 230,
+    HB_Combining_AboveRight              = 232,
+
+    HB_Combining_DoubleBelow             = 233,
+    HB_Combining_DoubleAbove             = 234,
+    HB_Combining_IotaSubscript           = 240
+} HB_CombiningClass;
+
+typedef enum {
+    CcmpProperty = 0x1,
+    InitProperty = 0x2,
+    IsolProperty = 0x4,
+    FinaProperty = 0x8,
+    MediProperty = 0x10,
+    RligProperty = 0x20,
+    CaltProperty = 0x40,
+    LigaProperty = 0x80,
+    DligProperty = 0x100,
+    CswhProperty = 0x200,
+    MsetProperty = 0x400,
+
+    /* used by indic and myanmar shaper */
+    NuktaProperty = 0x4,
+    AkhantProperty = 0x8,
+    RephProperty = 0x10,
+    PreFormProperty = 0x20,
+    BelowFormProperty = 0x40,
+    AboveFormProperty = 0x80,
+    HalfFormProperty = 0x100,
+    PostFormProperty = 0x200,
+    VattuProperty = 0x400,
+    PreSubstProperty = 0x800,
+    BelowSubstProperty = 0x1000,
+    AboveSubstProperty = 0x2000,
+    PostSubstProperty = 0x4000,
+    HalantProperty = 0x8000,
+    CligProperty = 0x10000
+
+} HB_OpenTypeProperty;
+
+/* return true if ok. */
+typedef HB_Bool (*HB_ShapeFunction)(HB_ShaperItem *shaper_item);
+typedef void (*HB_AttributeFunction)(HB_Script script, const HB_UChar16 *string, hb_uint32 from, hb_uint32 len, HB_CharAttributes *attributes);
+
+typedef struct {
+    HB_ShapeFunction shape;
+    HB_AttributeFunction charAttributes;
+} HB_ScriptEngine;
+
+extern const HB_ScriptEngine hb_scriptEngines[];
+
+extern HB_Bool HB_BasicShape(HB_ShaperItem *shaper_item);
+extern HB_Bool HB_TibetanShape(HB_ShaperItem *shaper_item);
+extern HB_Bool HB_HebrewShape(HB_ShaperItem *shaper_item);
+extern HB_Bool HB_ArabicShape(HB_ShaperItem *shaper_item);
+extern HB_Bool HB_HangulShape(HB_ShaperItem *shaper_item);
+extern HB_Bool HB_MyanmarShape(HB_ShaperItem *shaper_item);
+extern HB_Bool HB_KhmerShape(HB_ShaperItem *shaper_item);
+extern HB_Bool HB_IndicShape(HB_ShaperItem *shaper_item);
+
+extern void HB_TibetanAttributes(HB_Script script, const HB_UChar16 *string, hb_uint32 from, hb_uint32 len, HB_CharAttributes *attributes);
+
+extern void HB_MyanmarAttributes(HB_Script script, const HB_UChar16 *string, hb_uint32 from, hb_uint32 len, HB_CharAttributes *attributes);
+
+extern void HB_KhmerAttributes(HB_Script script, const HB_UChar16 *string, hb_uint32 from, hb_uint32 len, HB_CharAttributes *attributes);
+
+extern void HB_IndicAttributes(HB_Script script, const HB_UChar16 *string, hb_uint32 from, hb_uint32 len, HB_CharAttributes *attributes);
+
+extern void HB_ThaiAttributes(HB_Script script, const HB_UChar16 *string, hb_uint32 from, hb_uint32 len, HB_CharAttributes *attributes);
+
+typedef struct {
+    hb_uint32 tag;
+    hb_uint32 property;
+} HB_OpenTypeFeature;
+
+#define PositioningProperties 0x80000000
+
+HB_Bool HB_SelectScript(HB_ShaperItem *item, const HB_OpenTypeFeature *features);
+
+HB_Bool HB_OpenTypeShape(HB_ShaperItem *item, const hb_uint32 *properties);
+HB_Bool HB_OpenTypePosition(HB_ShaperItem *item, int availableGlyphs, HB_Bool doLogClusters);
+
+void HB_HeuristicPosition(HB_ShaperItem *item);
+void HB_HeuristicSetGlyphAttributes(HB_ShaperItem *item);
+
+#define HB_IsControlChar(uc) \
+    ((uc >= 0x200b && uc <= 0x200f /* ZW Space, ZWNJ, ZWJ, LRM and RLM */) \
+     || (uc >= 0x2028 && uc <= 0x202f /* LS, PS, LRE, RLE, PDF, LRO, RLO, NNBSP */) \
+     || (uc >= 0x206a && uc <= 0x206f /* ISS, ASS, IAFS, AFS, NADS, NODS */))
+
+HB_Bool HB_ConvertStringToGlyphIndices(HB_ShaperItem *shaper_item);
+
+#define HB_GetGlyphAdvances(shaper_item) \
+    shaper_item->font->klass->getGlyphAdvances(shaper_item->font, \
+                                               shaper_item->glyphs, shaper_item->num_glyphs, \
+                                               shaper_item->advances, \
+                                               shaper_item->face->current_flags);
+
+#define HB_DECLARE_STACKARRAY(Type, Name) \
+    Type stack##Name[512]; \
+    Type *Name = stack##Name;
+
+#define HB_INIT_STACKARRAY(Type, Name, Length) \
+    if ((Length) >= 512) \
+        Name = (Type *)malloc((Length) * sizeof(Type));
+
+#define HB_STACKARRAY(Type, Name, Length) \
+    HB_DECLARE_STACKARRAY(Type, Name) \
+    HB_INIT_STACKARRAY(Type, Name, Length)
+
+#define HB_FREE_STACKARRAY(Name) \
+    if (stack##Name != Name) \
+        free(Name);
+
+HB_END_HEADER
+
+#endif
diff -rupN orginal/scribus/harfbuzz/harfbuzz-shaper.cpp patched/scribus/harfbuzz/harfbuzz-shaper.cpp
--- orginal/scribus/harfbuzz/harfbuzz-shaper.cpp	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/harfbuzz-shaper.cpp	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,1341 @@
+/*
+ * Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies)
+ *
+ * This is part of HarfBuzz, an OpenType Layout engine library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ */
+
+#include "harfbuzz-shaper.h"
+#include "harfbuzz-shaper-private.h"
+
+#include "harfbuzz-stream-private.h"
+#include <assert.h>
+#include <stdio.h>
+
+#define HB_MIN(a, b) ((a) < (b) ? (a) : (b))
+#define HB_MAX(a, b) ((a) > (b) ? (a) : (b))
+
+// -----------------------------------------------------------------------------------------------------
+//
+// The line break algorithm. See http://www.unicode.org/reports/tr14/tr14-13.html
+//
+// -----------------------------------------------------------------------------------------------------
+
+/* The Unicode algorithm does in our opinion allow line breaks at some
+   places they shouldn't be allowed. The following changes were thus
+   made in comparison to the Unicode reference:
+
+   EX->AL from DB to IB
+   SY->AL from DB to IB
+   SY->PO from DB to IB
+   SY->PR from DB to IB
+   SY->OP from DB to IB
+   AL->PR from DB to IB
+   AL->PO from DB to IB
+   PR->PR from DB to IB
+   PO->PO from DB to IB
+   PR->PO from DB to IB
+   PO->PR from DB to IB
+   HY->PO from DB to IB
+   HY->PR from DB to IB
+   HY->OP from DB to IB
+   NU->EX from PB to IB
+   EX->PO from DB to IB
+*/
+
+// The following line break classes are not treated by the table:
+//  AI, BK, CB, CR, LF, NL, SA, SG, SP, XX
+
+enum break_class {
+    // the first 4 values have to agree with the enum in QCharAttributes
+    ProhibitedBreak,            // PB in table
+    DirectBreak,                // DB in table
+    IndirectBreak,              // IB in table
+    CombiningIndirectBreak,     // CI in table
+    CombiningProhibitedBreak    // CP in table
+};
+#define DB DirectBreak
+#define IB IndirectBreak
+#define CI CombiningIndirectBreak
+#define CP CombiningProhibitedBreak
+#define PB ProhibitedBreak
+
+static const hb_uint8 breakTable[HB_LineBreak_JT+1][HB_LineBreak_JT+1] =
+{
+/*          OP  CL  QU  GL  NS  EX  SY  IS  PR  PO  NU  AL  ID  IN  HY  BA  BB  B2  ZW  CM  WJ  H2  H3  JL  JV  JT */
+/* OP */ { PB, PB, PB, PB, PB, PB, PB, PB, PB, PB, PB, PB, PB, PB, PB, PB, PB, PB, PB, CP, PB, PB, PB, PB, PB, PB },
+/* CL */ { DB, PB, IB, IB, PB, PB, PB, PB, IB, IB, IB, IB, DB, DB, IB, IB, DB, DB, PB, CI, PB, DB, DB, DB, DB, DB },
+/* QU */ { PB, PB, IB, IB, IB, PB, PB, PB, IB, IB, IB, IB, IB, IB, IB, IB, IB, IB, PB, CI, PB, IB, IB, IB, IB, IB },
+/* GL */ { IB, PB, IB, IB, IB, PB, PB, PB, IB, IB, IB, IB, IB, IB, IB, IB, IB, IB, PB, CI, PB, IB, IB, IB, IB, IB },
+/* NS */ { DB, PB, IB, IB, IB, PB, PB, PB, DB, DB, DB, DB, DB, DB, IB, IB, DB, DB, PB, CI, PB, DB, DB, DB, DB, DB },
+/* EX */ { DB, PB, IB, IB, IB, PB, PB, PB, DB, IB, DB, IB, DB, DB, IB, IB, DB, DB, PB, CI, PB, DB, DB, DB, DB, DB },
+/* SY */ { IB, PB, IB, IB, IB, PB, PB, PB, IB, IB, IB, IB, DB, DB, IB, IB, DB, DB, PB, CI, PB, DB, DB, DB, DB, DB },
+/* IS */ { DB, PB, IB, IB, IB, PB, PB, PB, DB, DB, IB, IB, DB, DB, IB, IB, DB, DB, PB, CI, PB, DB, DB, DB, DB, DB },
+/* PR */ { IB, PB, IB, IB, IB, PB, PB, PB, IB, IB, IB, IB, IB, DB, IB, IB, DB, DB, PB, CI, PB, IB, IB, IB, IB, IB },
+/* PO */ { IB, PB, IB, IB, IB, PB, PB, PB, IB, IB, IB, IB, DB, DB, IB, IB, DB, DB, PB, CI, PB, DB, DB, DB, DB, DB },
+/* NU */ { IB, PB, IB, IB, IB, IB, PB, PB, IB, IB, IB, IB, DB, IB, IB, IB, DB, DB, PB, CI, PB, DB, DB, DB, DB, DB },
+/* AL */ { IB, PB, IB, IB, IB, PB, PB, PB, IB, IB, IB, IB, DB, IB, IB, IB, DB, DB, PB, CI, PB, DB, DB, DB, DB, DB },
+/* ID */ { DB, PB, IB, IB, IB, PB, PB, PB, DB, IB, DB, DB, DB, IB, IB, IB, DB, DB, PB, CI, PB, DB, DB, DB, DB, DB },
+/* IN */ { DB, PB, IB, IB, IB, PB, PB, PB, DB, DB, DB, DB, DB, IB, IB, IB, DB, DB, PB, CI, PB, DB, DB, DB, DB, DB },
+/* HY */ { IB, PB, IB, IB, IB, PB, PB, PB, IB, IB, IB, DB, DB, DB, IB, IB, DB, DB, PB, CI, PB, DB, DB, DB, DB, DB },
+/* BA */ { DB, PB, IB, IB, IB, PB, PB, PB, DB, DB, DB, DB, DB, DB, IB, IB, DB, DB, PB, CI, PB, DB, DB, DB, DB, DB },
+/* BB */ { IB, PB, IB, IB, IB, PB, PB, PB, IB, IB, IB, IB, IB, IB, IB, IB, IB, IB, PB, CI, PB, IB, IB, IB, IB, IB },
+/* B2 */ { DB, PB, IB, IB, IB, PB, PB, PB, DB, DB, DB, DB, DB, DB, IB, IB, DB, PB, PB, CI, PB, DB, DB, DB, DB, DB },
+/* ZW */ { DB, DB, DB, DB, DB, DB, DB, DB, DB, DB, DB, DB, DB, DB, DB, DB, DB, DB, PB, DB, DB, DB, DB, DB, DB, DB },
+/* CM */ { DB, PB, IB, IB, IB, PB, PB, PB, DB, DB, IB, IB, DB, IB, IB, IB, DB, DB, PB, CI, PB, DB, DB, DB, DB, DB },
+/* WJ */ { IB, PB, IB, IB, IB, PB, PB, PB, IB, IB, IB, IB, IB, IB, IB, IB, IB, IB, PB, CI, PB, IB, IB, IB, IB, IB },
+/* H2 */ { DB, PB, IB, IB, IB, PB, PB, PB, DB, IB, DB, DB, DB, IB, IB, IB, DB, DB, PB, CI, PB, DB, DB, DB, IB, IB },
+/* H3 */ { DB, PB, IB, IB, IB, PB, PB, PB, DB, IB, DB, DB, DB, IB, IB, IB, DB, DB, PB, CI, PB, DB, DB, DB, DB, IB },
+/* JL */ { DB, PB, IB, IB, IB, PB, PB, PB, DB, IB, DB, DB, DB, IB, IB, IB, DB, DB, PB, CI, PB, IB, IB, IB, IB, DB },
+/* JV */ { DB, PB, IB, IB, IB, PB, PB, PB, DB, IB, DB, DB, DB, IB, IB, IB, DB, DB, PB, CI, PB, DB, DB, DB, IB, IB },
+/* JT */ { DB, PB, IB, IB, IB, PB, PB, PB, DB, IB, DB, DB, DB, IB, IB, IB, DB, DB, PB, CI, PB, DB, DB, DB, DB, IB }
+};
+#undef DB
+#undef IB
+#undef CI
+#undef CP
+#undef PB
+
+static const hb_uint8 graphemeTable[HB_Grapheme_LVT + 1][HB_Grapheme_LVT + 1] =
+{
+//      Other, CR,    LF,    Control,Extend,L,    V,     T,     LV,    LVT
+    { true , true , true , true , true , true , true , true , true , true  }, // Other, 
+    { true , true , true , true , true , true , true , true , true , true  }, // CR,
+    { true , false, true , true , true , true , true , true , true , true  }, // LF,
+    { true , true , true , true , true , true , true , true , true , true  }, // Control,
+    { false, true , true , true , false, false, false, false, false, false }, // Extend,
+    { true , true , true , true , true , false, true , true , true , true  }, // L, 
+    { true , true , true , true , true , false, false, true , false, true  }, // V, 
+    { true , true , true , true , true , true , false, false, false, false }, // T, 
+    { true , true , true , true , true , false, true , true , true , true  }, // LV, 
+    { true , true , true , true , true , false, true , true , true , true  }, // LVT
+};
+    
+static void calcLineBreaks(const HB_UChar16 *uc, hb_uint32 len, HB_CharAttributes *charAttributes)
+{
+    if (!len)
+        return;
+
+    // ##### can this fail if the first char is a surrogate?
+    HB_LineBreakClass cls;
+    HB_GraphemeClass grapheme;
+    HB_GetGraphemeAndLineBreakClass(*uc, &grapheme, &cls);
+    // handle case where input starts with an LF
+    if (cls == HB_LineBreak_LF)
+        cls = HB_LineBreak_BK;
+
+    charAttributes[0].whiteSpace = (cls == HB_LineBreak_SP || cls == HB_LineBreak_BK);
+    charAttributes[0].charStop = true;
+
+    int lcls = cls;
+    for (hb_uint32 i = 1; i < len; ++i) {
+        charAttributes[i].whiteSpace = false;
+        charAttributes[i].charStop = true;
+
+        HB_UChar32 code = uc[i];
+        HB_GraphemeClass ngrapheme;
+        HB_LineBreakClass ncls;
+        HB_GetGraphemeAndLineBreakClass(code, &ngrapheme, &ncls);
+        charAttributes[i].charStop = graphemeTable[ngrapheme][grapheme];
+        // handle surrogates
+        if (ncls == HB_LineBreak_SG) {
+            if (HB_IsHighSurrogate(uc[i]) && i < len - 1 && HB_IsLowSurrogate(uc[i+1])) {
+                continue;
+            } else if (HB_IsLowSurrogate(uc[i]) && HB_IsHighSurrogate(uc[i-1])) {
+                code = HB_SurrogateToUcs4(uc[i-1], uc[i]);
+                HB_GetGraphemeAndLineBreakClass(code, &ngrapheme, &ncls);
+                charAttributes[i].charStop = false;
+            } else {
+                ncls = HB_LineBreak_AL;
+            }
+        }
+
+        // set white space and char stop flag
+        if (ncls >= HB_LineBreak_SP)
+            charAttributes[i].whiteSpace = true;
+
+        HB_LineBreakType lineBreakType = HB_NoBreak;
+        if (cls >= HB_LineBreak_LF) {
+            lineBreakType = HB_ForcedBreak;
+        } else if(cls == HB_LineBreak_CR) {
+            lineBreakType = (ncls == HB_LineBreak_LF) ? HB_NoBreak : HB_ForcedBreak;
+        }
+
+        if (ncls == HB_LineBreak_SP)
+            goto next_no_cls_update;
+        if (ncls >= HB_LineBreak_CR)
+            goto next;
+
+        // two complex chars (thai or lao), thai_attributes might override, but here we do a best guess
+	if (cls == HB_LineBreak_SA && ncls == HB_LineBreak_SA) {
+            lineBreakType = HB_Break;
+            goto next;
+        }
+
+        {
+            int tcls = ncls;
+            if (tcls >= HB_LineBreak_SA)
+                tcls = HB_LineBreak_ID;
+            if (cls >= HB_LineBreak_SA)
+                cls = HB_LineBreak_ID;
+
+            int brk = breakTable[cls][tcls];
+            switch (brk) {
+            case DirectBreak:
+                lineBreakType = HB_Break;
+                if (uc[i-1] == 0xad) // soft hyphen
+                    lineBreakType = HB_SoftHyphen;
+                break;
+            case IndirectBreak:
+                lineBreakType = (lcls == HB_LineBreak_SP) ? HB_Break : HB_NoBreak;
+                break;
+            case CombiningIndirectBreak:
+                lineBreakType = HB_NoBreak;
+                if (lcls == HB_LineBreak_SP){
+                    if (i > 1)
+                        charAttributes[i-2].lineBreakType = HB_Break;
+                } else {
+                    goto next_no_cls_update;
+                }
+                break;
+            case CombiningProhibitedBreak:
+                lineBreakType = HB_NoBreak;
+                if (lcls != HB_LineBreak_SP)
+                    goto next_no_cls_update;
+            case ProhibitedBreak:
+            default:
+                break;
+            }
+        }
+    next:
+        cls = ncls;
+    next_no_cls_update:
+        lcls = ncls;
+        grapheme = ngrapheme;
+        charAttributes[i-1].lineBreakType = lineBreakType;
+    }
+    charAttributes[len-1].lineBreakType = HB_ForcedBreak;
+}
+
+// --------------------------------------------------------------------------------------------------------------------------------------------
+//
+// Basic processing
+//
+// --------------------------------------------------------------------------------------------------------------------------------------------
+
+static inline void positionCluster(HB_ShaperItem *item, int gfrom,  int glast)
+{
+    int nmarks = glast - gfrom;
+    assert(nmarks > 0);
+
+    HB_Glyph *glyphs = item->glyphs;
+    HB_GlyphAttributes *attributes = item->attributes;
+
+    HB_GlyphMetrics baseMetrics;
+    item->font->klass->getGlyphMetrics(item->font, glyphs[gfrom], &baseMetrics);
+
+    if (item->item.script == HB_Script_Hebrew
+        && (-baseMetrics.y) > baseMetrics.height)
+        // we need to attach below the baseline, because of the hebrew iud.
+        baseMetrics.height = -baseMetrics.y;
+
+//     qDebug("---> positionCluster: cluster from %d to %d", gfrom, glast);
+//     qDebug("baseInfo: %f/%f (%f/%f) off=%f/%f", baseInfo.x, baseInfo.y, baseInfo.width, baseInfo.height, baseInfo.xoff, baseInfo.yoff);
+
+    HB_Fixed size = item->font->klass->getFontMetric(item->font, HB_FontAscent) / 10;
+    HB_Fixed offsetBase = HB_FIXED_CONSTANT(1) + (size - HB_FIXED_CONSTANT(4)) / 4;
+    if (size > HB_FIXED_CONSTANT(4))
+        offsetBase += HB_FIXED_CONSTANT(4);
+    else
+        offsetBase += size;
+    //qreal offsetBase = (size - 4) / 4 + qMin<qreal>(size, 4) + 1;
+//     qDebug("offset = %f", offsetBase);
+
+    bool rightToLeft = item->item.bidiLevel % 2;
+
+    int i;
+    unsigned char lastCmb = 0;
+    HB_GlyphMetrics attachmentRect;
+    memset(&attachmentRect, 0, sizeof(attachmentRect));
+
+    for(i = 1; i <= nmarks; i++) {
+        HB_Glyph mark = glyphs[gfrom+i];
+        HB_GlyphMetrics markMetrics;
+        item->font->klass->getGlyphMetrics(item->font, mark, &markMetrics);
+        HB_FixedPoint p;
+        p.x = p.y = 0;
+//          qDebug("markInfo: %f/%f (%f/%f) off=%f/%f", markInfo.x, markInfo.y, markInfo.width, markInfo.height, markInfo.xoff, markInfo.yoff);
+
+        HB_Fixed offset = offsetBase;
+        unsigned char cmb = attributes[gfrom+i].combiningClass;
+
+        // ### maybe the whole position determination should move down to heuristicSetGlyphAttributes. Would save some
+        // bits  in the glyphAttributes structure.
+        if (cmb < 200) {
+            // fixed position classes. We approximate by mapping to one of the others.
+            // currently I added only the ones for arabic, hebrew, lao and thai.
+
+            // for Lao and Thai marks with class 0, see below (heuristicSetGlyphAttributes)
+
+            // add a bit more offset to arabic, a bit hacky
+            if (cmb >= 27 && cmb <= 36 && offset < 3)
+                offset +=1;
+            // below
+            if ((cmb >= 10 && cmb <= 18) ||
+                 cmb == 20 || cmb == 22 ||
+                 cmb == 29 || cmb == 32)
+                cmb = HB_Combining_Below;
+            // above
+            else if (cmb == 23 || cmb == 27 || cmb == 28 ||
+                      cmb == 30 || cmb == 31 || (cmb >= 33 && cmb <= 36))
+                cmb = HB_Combining_Above;
+            //below-right
+            else if (cmb == 9 || cmb == 103 || cmb == 118)
+                cmb = HB_Combining_BelowRight;
+            // above-right
+            else if (cmb == 24 || cmb == 107 || cmb == 122)
+                cmb = HB_Combining_AboveRight;
+            else if (cmb == 25)
+                cmb = HB_Combining_AboveLeft;
+            // fixed:
+            //  19 21
+
+        }
+
+        // combining marks of different class don't interact. Reset the rectangle.
+        if (cmb != lastCmb) {
+            //qDebug("resetting rect");
+            attachmentRect = baseMetrics;
+        }
+
+        switch(cmb) {
+        case HB_Combining_DoubleBelow:
+                // ### wrong in rtl context!
+        case HB_Combining_BelowLeft:
+            p.y += offset;
+        case HB_Combining_BelowLeftAttached:
+            p.x += attachmentRect.x - markMetrics.x;
+            p.y += (attachmentRect.y + attachmentRect.height) - markMetrics.y;
+            break;
+        case HB_Combining_Below:
+            p.y += offset;
+        case HB_Combining_BelowAttached:
+            p.x += attachmentRect.x - markMetrics.x;
+            p.y += (attachmentRect.y + attachmentRect.height) - markMetrics.y;
+
+            p.x += (attachmentRect.width - markMetrics.width) / 2;
+            break;
+        case HB_Combining_BelowRight:
+            p.y += offset;
+        case HB_Combining_BelowRightAttached:
+            p.x += attachmentRect.x + attachmentRect.width - markMetrics.width - markMetrics.x;
+            p.y += attachmentRect.y + attachmentRect.height - markMetrics.y;
+            break;
+        case HB_Combining_Left:
+            p.x -= offset;
+        case HB_Combining_LeftAttached:
+            break;
+        case HB_Combining_Right:
+            p.x += offset;
+        case HB_Combining_RightAttached:
+            break;
+        case HB_Combining_DoubleAbove:
+            // ### wrong in RTL context!
+        case HB_Combining_AboveLeft:
+            p.y -= offset;
+        case HB_Combining_AboveLeftAttached:
+            p.x += attachmentRect.x - markMetrics.x;
+            p.y += attachmentRect.y - markMetrics.y - markMetrics.height;
+            break;
+        case HB_Combining_Above:
+            p.y -= offset;
+        case HB_Combining_AboveAttached:
+            p.x += attachmentRect.x - markMetrics.x;
+            p.y += attachmentRect.y - markMetrics.y - markMetrics.height;
+
+            p.x += (attachmentRect.width - markMetrics.width) / 2;
+            break;
+        case HB_Combining_AboveRight:
+            p.y -= offset;
+        case HB_Combining_AboveRightAttached:
+            p.x += attachmentRect.x + attachmentRect.width - markMetrics.x - markMetrics.width;
+            p.y += attachmentRect.y - markMetrics.y - markMetrics.height;
+            break;
+
+        case HB_Combining_IotaSubscript:
+            default:
+                break;
+        }
+//          qDebug("char=%x combiningClass = %d offset=%f/%f", mark, cmb, p.x(), p.y());
+        markMetrics.x += p.x;
+        markMetrics.y += p.y;
+
+        HB_GlyphMetrics unitedAttachmentRect = attachmentRect;
+        unitedAttachmentRect.x = HB_MIN(attachmentRect.x, markMetrics.x);
+        unitedAttachmentRect.y = HB_MIN(attachmentRect.y, markMetrics.y);
+        unitedAttachmentRect.width = HB_MAX(attachmentRect.x + attachmentRect.width, markMetrics.x + markMetrics.width) - unitedAttachmentRect.x;
+        unitedAttachmentRect.height = HB_MAX(attachmentRect.y + attachmentRect.height, markMetrics.y + markMetrics.height) - unitedAttachmentRect.y;
+        attachmentRect = unitedAttachmentRect;
+
+        lastCmb = cmb;
+        if (rightToLeft) {
+            item->offsets[gfrom+i].x = p.x;
+            item->offsets[gfrom+i].y = p.y;
+        } else {
+            item->offsets[gfrom+i].x = p.x - baseMetrics.xOffset;
+            item->offsets[gfrom+i].y = p.y - baseMetrics.yOffset;
+        }
+        item->advances[gfrom+i] = 0;
+    }
+}
+
+void HB_HeuristicPosition(HB_ShaperItem *item)
+{
+    HB_GetGlyphAdvances(item);
+    HB_GlyphAttributes *attributes = item->attributes;
+
+    int cEnd = -1;
+    int i = item->num_glyphs;
+    while (i--) {
+        if (cEnd == -1 && attributes[i].mark) {
+            cEnd = i;
+        } else if (cEnd != -1 && !attributes[i].mark) {
+            positionCluster(item, i, cEnd);
+            cEnd = -1;
+        }
+    }
+}
+
+// set the glyph attributes heuristically. Assumes a 1 to 1 relationship between chars and glyphs
+// and no reordering.
+// also computes logClusters heuristically
+void HB_HeuristicSetGlyphAttributes(HB_ShaperItem *item)
+{
+    const HB_UChar16 *uc = item->string + item->item.pos;
+    hb_uint32 length = item->item.length;
+
+    // ### zeroWidth and justification are missing here!!!!!
+
+    assert(item->num_glyphs <= length);
+
+//     qDebug("QScriptEngine::heuristicSetGlyphAttributes, num_glyphs=%d", item->num_glyphs);
+    HB_GlyphAttributes *attributes = item->attributes;
+    unsigned short *logClusters = item->log_clusters;
+
+    hb_uint32 glyph_pos = 0;
+    hb_uint32 i;
+    for (i = 0; i < length; i++) {
+        if (HB_IsHighSurrogate(uc[i]) && i < length - 1
+            && HB_IsLowSurrogate(uc[i + 1])) {
+            logClusters[i] = glyph_pos;
+            logClusters[++i] = glyph_pos;
+        } else {
+            logClusters[i] = glyph_pos;
+        }
+        ++glyph_pos;
+    }
+    assert(glyph_pos == item->num_glyphs);
+
+    // first char in a run is never (treated as) a mark
+    int cStart = 0;
+    const bool symbolFont = item->face->isSymbolFont;
+    attributes[0].mark = false;
+    attributes[0].clusterStart = true;
+    attributes[0].dontPrint = (!symbolFont && uc[0] == 0x00ad) || HB_IsControlChar(uc[0]);
+
+    int pos = 0;
+    HB_CharCategory lastCat;
+    int dummy;
+    HB_GetUnicodeCharProperties(uc[0], &lastCat, &dummy);
+    for (i = 1; i < length; ++i) {
+        if (logClusters[i] == pos)
+            // same glyph
+            continue;
+        ++pos;
+        while (pos < logClusters[i]) {
+            attributes[pos] = attributes[pos-1];
+            ++pos;
+        }
+        // hide soft-hyphens by default
+        if ((!symbolFont && uc[i] == 0x00ad) || HB_IsControlChar(uc[i]))
+            attributes[pos].dontPrint = true;
+        HB_CharCategory cat;
+        int cmb;
+        HB_GetUnicodeCharProperties(uc[i], &cat, &cmb);
+        if (cat != HB_Mark_NonSpacing) {
+            attributes[pos].mark = false;
+            attributes[pos].clusterStart = true;
+            attributes[pos].combiningClass = 0;
+            cStart = logClusters[i];
+        } else {
+            if (cmb == 0) {
+                // Fix 0 combining classes
+                if ((uc[pos] & 0xff00) == 0x0e00) {
+                    // thai or lao
+                    if (uc[pos] == 0xe31 ||
+                         uc[pos] == 0xe34 ||
+                         uc[pos] == 0xe35 ||
+                         uc[pos] == 0xe36 ||
+                         uc[pos] == 0xe37 ||
+                         uc[pos] == 0xe47 ||
+                         uc[pos] == 0xe4c ||
+                         uc[pos] == 0xe4d ||
+                         uc[pos] == 0xe4e) {
+                        cmb = HB_Combining_AboveRight;
+                    } else if (uc[pos] == 0xeb1 ||
+                                uc[pos] == 0xeb4 ||
+                                uc[pos] == 0xeb5 ||
+                                uc[pos] == 0xeb6 ||
+                                uc[pos] == 0xeb7 ||
+                                uc[pos] == 0xebb ||
+                                uc[pos] == 0xecc ||
+                                uc[pos] == 0xecd) {
+                        cmb = HB_Combining_Above;
+                    } else if (uc[pos] == 0xebc) {
+                        cmb = HB_Combining_Below;
+                    }
+                }
+            }
+
+            attributes[pos].mark = true;
+            attributes[pos].clusterStart = false;
+            attributes[pos].combiningClass = cmb;
+            logClusters[i] = cStart;
+        }
+        // one gets an inter character justification point if the current char is not a non spacing mark.
+        // as then the current char belongs to the last one and one gets a space justification point
+        // after the space char.
+        if (lastCat == HB_Separator_Space)
+            attributes[pos-1].justification = HB_Space;
+        else if (cat != HB_Mark_NonSpacing)
+            attributes[pos-1].justification = HB_Character;
+        else
+            attributes[pos-1].justification = HB_NoJustification;
+
+        lastCat = cat;
+    }
+    pos = logClusters[length-1];
+    if (lastCat == HB_Separator_Space)
+        attributes[pos].justification = HB_Space;
+    else
+        attributes[pos].justification = HB_Character;
+}
+
+#ifndef NO_OPENTYPE
+static const HB_OpenTypeFeature basic_features[] = {
+    { HB_MAKE_TAG('c', 'c', 'm', 'p'), CcmpProperty },
+    { HB_MAKE_TAG('l', 'i', 'g', 'a'), CcmpProperty },
+    { HB_MAKE_TAG('c', 'l', 'i', 'g'), CcmpProperty },
+    {0, 0}
+};
+#endif
+
+HB_Bool HB_ConvertStringToGlyphIndices(HB_ShaperItem *shaper_item)
+{
+    if (shaper_item->glyphIndicesPresent) {
+        shaper_item->num_glyphs = shaper_item->initialGlyphCount;
+        shaper_item->glyphIndicesPresent = false;
+        return true;
+    }
+    return shaper_item->font->klass
+           ->convertStringToGlyphIndices(shaper_item->font,
+                                         shaper_item->string + shaper_item->item.pos, shaper_item->item.length,
+                                         shaper_item->glyphs, &shaper_item->num_glyphs,
+                                         shaper_item->item.bidiLevel % 2);
+}
+
+HB_Bool HB_BasicShape(HB_ShaperItem *shaper_item)
+{
+#ifndef NO_OPENTYPE
+    const int availableGlyphs = shaper_item->num_glyphs;
+#endif
+
+    if (!HB_ConvertStringToGlyphIndices(shaper_item))
+        return false;
+
+    HB_HeuristicSetGlyphAttributes(shaper_item);
+
+#ifndef NO_OPENTYPE
+    if (HB_SelectScript(shaper_item, basic_features)) {
+        HB_OpenTypeShape(shaper_item, /*properties*/0);
+        return HB_OpenTypePosition(shaper_item, availableGlyphs, /*doLogClusters*/true);
+    }
+#endif
+
+    HB_HeuristicPosition(shaper_item);
+    return true;
+}
+
+const HB_ScriptEngine HB_ScriptEngines[] = {
+    // Common
+    { HB_BasicShape, 0},
+    // Greek
+    { HB_BasicShape, 0},
+    // Cyrillic
+    { HB_BasicShape, 0},
+    // Armenian
+    { HB_BasicShape, 0},
+    // Hebrew
+    { HB_HebrewShape, 0 },
+    // Arabic
+    { HB_ArabicShape, 0},
+    // Syriac
+    { HB_ArabicShape, 0},
+    // Thaana
+    { HB_BasicShape, 0 },
+    // Devanagari
+    { HB_IndicShape, HB_IndicAttributes },
+    // Bengali
+    { HB_IndicShape, HB_IndicAttributes },
+    // Gurmukhi
+    { HB_IndicShape, HB_IndicAttributes },
+    // Gujarati
+    { HB_IndicShape, HB_IndicAttributes },
+    // Oriya
+    { HB_IndicShape, HB_IndicAttributes },
+    // Tamil
+    { HB_IndicShape, HB_IndicAttributes },
+    // Telugu
+    { HB_IndicShape, HB_IndicAttributes },
+    // Kannada
+    { HB_IndicShape, HB_IndicAttributes },
+    // Malayalam
+    { HB_IndicShape, HB_IndicAttributes },
+    // Sinhala
+    { HB_IndicShape, HB_IndicAttributes },
+    // Thai
+    { HB_BasicShape, HB_ThaiAttributes },
+    // Lao
+    { HB_BasicShape, 0 },
+    // Tibetan
+    { HB_TibetanShape, HB_TibetanAttributes },
+    // Myanmar
+    { HB_MyanmarShape, HB_MyanmarAttributes },
+    // Georgian
+    { HB_BasicShape, 0 },
+    // Hangul
+    { HB_HangulShape, 0 },
+    // Ogham
+    { HB_BasicShape, 0 },
+    // Runic
+    { HB_BasicShape, 0 },
+    // Khmer
+    { HB_KhmerShape, HB_KhmerAttributes },
+    // N'Ko
+    { HB_ArabicShape, 0}
+};
+
+void HB_GetCharAttributes(const HB_UChar16 *string, hb_uint32 stringLength,
+                          const HB_ScriptItem *items, hb_uint32 numItems,
+                          HB_CharAttributes *attributes)
+{
+    calcLineBreaks(string, stringLength, attributes);
+
+    for (hb_uint32 i = 0; i < numItems; ++i) {
+        HB_Script script = items[i].script;
+        if (script == HB_Script_Inherited)
+            script = HB_Script_Common;
+        HB_AttributeFunction attributeFunction = HB_ScriptEngines[script].charAttributes;
+        if (!attributeFunction)
+            continue;
+        attributeFunction(script, string, items[i].pos, items[i].length, attributes);
+    }
+}
+
+
+enum BreakRule { NoBreak = 0, Break = 1, Middle = 2 };
+
+static const hb_uint8 wordbreakTable[HB_Word_ExtendNumLet + 1][HB_Word_ExtendNumLet + 1] = {
+//        Other    Format   Katakana ALetter  MidLetter MidNum  Numeric  ExtendNumLet
+    {   Break,   Break,   Break,   Break,   Break,   Break,   Break,   Break }, // Other
+    {   Break,   Break,   Break,   Break,   Break,   Break,   Break,   Break }, // Format 
+    {   Break,   Break, NoBreak,   Break,   Break,   Break,   Break, NoBreak }, // Katakana
+    {   Break,   Break,   Break, NoBreak,  Middle,   Break, NoBreak, NoBreak }, // ALetter
+    {   Break,   Break,   Break,   Break,   Break,   Break,   Break,   Break }, // MidLetter
+    {   Break,   Break,   Break,   Break,   Break,   Break,   Break,   Break }, // MidNum
+    {   Break,   Break,   Break, NoBreak,   Break,  Middle, NoBreak, NoBreak }, // Numeric
+    {   Break,   Break, NoBreak, NoBreak,   Break,   Break, NoBreak, NoBreak }, // ExtendNumLet
+};
+
+void HB_GetWordBoundaries(const HB_UChar16 *string, hb_uint32 stringLength,
+                          const HB_ScriptItem * /*items*/, hb_uint32 /*numItems*/,
+                          HB_CharAttributes *attributes)
+{
+    if (stringLength == 0)
+        return;
+    unsigned int brk = HB_GetWordClass(string[0]);
+    attributes[0].wordBoundary = true;
+    for (hb_uint32 i = 1; i < stringLength; ++i) {
+        if (!attributes[i].charStop) {
+            attributes[i].wordBoundary = false;
+            continue;
+        }
+        hb_uint32 nbrk = HB_GetWordClass(string[i]);
+        if (nbrk == HB_Word_Format) {
+            attributes[i].wordBoundary = (HB_GetSentenceClass(string[i-1]) == HB_Sentence_Sep);
+            continue;
+        }
+        BreakRule rule = (BreakRule)wordbreakTable[brk][nbrk];
+        if (rule == Middle) {
+            rule = Break;
+            hb_uint32 lookahead = i + 1;
+            while (lookahead < stringLength) {
+                hb_uint32 testbrk = HB_GetWordClass(string[lookahead]);
+                if (testbrk == HB_Word_Format && HB_GetSentenceClass(string[lookahead]) != HB_Sentence_Sep) {
+                    ++lookahead;
+                    continue;
+                }
+                if (testbrk == brk) {
+                    rule = NoBreak;
+                    while (i < lookahead)
+                        attributes[i++].wordBoundary = false;
+                    nbrk = testbrk;
+                }
+                break;
+            }
+        }
+        attributes[i].wordBoundary = (rule == Break);
+        brk = nbrk;
+    }
+}
+
+
+enum SentenceBreakStates {
+    SB_Initial,
+    SB_Upper,
+    SB_UpATerm, 
+    SB_ATerm,
+    SB_ATermC, 
+    SB_ACS, 
+    SB_STerm, 
+    SB_STermC, 
+    SB_SCS,
+    SB_BAfter, 
+    SB_Break,
+    SB_Look
+};
+
+static const hb_uint8 sentenceBreakTable[HB_Sentence_Close + 1][HB_Sentence_Close + 1] = {
+//        Other       Sep         Format      Sp          Lower       Upper       OLetter     Numeric     ATerm       STerm       Close
+      { SB_Initial, SB_BAfter , SB_Initial, SB_Initial, SB_Initial, SB_Upper  , SB_Initial, SB_Initial, SB_ATerm  , SB_STerm  , SB_Initial }, // SB_Initial,
+      { SB_Initial, SB_BAfter , SB_Upper  , SB_Initial, SB_Initial, SB_Upper  , SB_Initial, SB_Initial, SB_UpATerm, SB_STerm  , SB_Initial }, // SB_Upper
+      
+      { SB_Look   , SB_BAfter , SB_UpATerm, SB_ACS    , SB_Initial, SB_Upper  , SB_Break  , SB_Initial, SB_ATerm  , SB_STerm  , SB_ATermC  }, // SB_UpATerm
+      { SB_Look   , SB_BAfter , SB_ATerm  , SB_ACS    , SB_Initial, SB_Break  , SB_Break  , SB_Initial, SB_ATerm  , SB_STerm  , SB_ATermC  }, // SB_ATerm
+      { SB_Look   , SB_BAfter , SB_ATermC , SB_ACS    , SB_Initial, SB_Break  , SB_Break  , SB_Look   , SB_ATerm  , SB_STerm  , SB_ATermC  }, // SB_ATermC,
+      { SB_Look   , SB_BAfter , SB_ACS    , SB_ACS    , SB_Initial, SB_Break  , SB_Break  , SB_Look   , SB_ATerm  , SB_STerm  , SB_Look    }, // SB_ACS,
+      
+      { SB_Break  , SB_BAfter , SB_STerm  , SB_SCS    , SB_Break  , SB_Break  , SB_Break  , SB_Break  , SB_ATerm  , SB_STerm  , SB_STermC  }, // SB_STerm,
+      { SB_Break  , SB_BAfter , SB_STermC , SB_SCS    , SB_Break  , SB_Break  , SB_Break  , SB_Break  , SB_ATerm  , SB_STerm  , SB_STermC  }, // SB_STermC,
+      { SB_Break  , SB_BAfter , SB_SCS    , SB_SCS    , SB_Break  , SB_Break  , SB_Break  , SB_Break  , SB_ATerm  , SB_STerm  , SB_Break   }, // SB_SCS,
+      { SB_Break  , SB_Break  , SB_Break  , SB_Break  , SB_Break  , SB_Break  , SB_Break  , SB_Break  , SB_Break  , SB_Break  , SB_Break   }, // SB_BAfter,
+};
+
+void HB_GetSentenceBoundaries(const HB_UChar16 *string, hb_uint32 stringLength,
+                              const HB_ScriptItem * /*items*/, hb_uint32 /*numItems*/,
+                              HB_CharAttributes *attributes)
+{
+    if (stringLength == 0)
+        return;
+    hb_uint32 brk = sentenceBreakTable[SB_Initial][HB_GetSentenceClass(string[0])];
+    attributes[0].sentenceBoundary = true;
+    for (hb_uint32 i = 1; i < stringLength; ++i) {
+        if (!attributes[i].charStop) {
+            attributes[i].sentenceBoundary = false;
+            continue;
+        }
+        brk = sentenceBreakTable[brk][HB_GetSentenceClass(string[i])];
+        if (brk == SB_Look) {
+            brk = SB_Break;
+            hb_uint32 lookahead = i + 1;
+            while (lookahead < stringLength) {
+                hb_uint32 sbrk = HB_GetSentenceClass(string[lookahead]);
+                if (sbrk != HB_Sentence_Other && sbrk != HB_Sentence_Numeric && sbrk != HB_Sentence_Close) {
+                    break;
+                } else if (sbrk == HB_Sentence_Lower) {
+                    brk = SB_Initial;
+                    break;
+                }
+                ++lookahead;
+            }
+            if (brk == SB_Initial) {
+                while (i < lookahead)
+                    attributes[i++].sentenceBoundary = false;
+            }
+        }
+        if (brk == SB_Break) {
+            attributes[i].sentenceBoundary = true;
+            brk = sentenceBreakTable[SB_Initial][HB_GetSentenceClass(string[i])];
+        } else {
+            attributes[i].sentenceBoundary = false;
+        }
+    }
+}
+
+
+static inline char *tag_to_string(HB_UInt tag)
+{
+    static char string[5];
+    string[0] = (tag >> 24)&0xff;
+    string[1] = (tag >> 16)&0xff;
+    string[2] = (tag >> 8)&0xff;
+    string[3] = tag&0xff;
+    string[4] = 0;
+    return string;
+}
+
+#ifdef OT_DEBUG
+static void dump_string(HB_Buffer buffer)
+{
+    for (uint i = 0; i < buffer->in_length; ++i) {
+        qDebug("    %x: cluster=%d", buffer->in_string[i].gindex, buffer->in_string[i].cluster);
+    }
+}
+#define DEBUG printf
+#else
+#define DEBUG if (1) ; else printf
+#endif
+
+#define DefaultLangSys 0xffff
+#define DefaultScript HB_MAKE_TAG('D', 'F', 'L', 'T')
+
+enum {
+    RequiresGsub = 1,
+    RequiresGpos = 2
+};
+
+struct OTScripts {
+    unsigned int tag;
+    int flags;
+};
+static const OTScripts ot_scripts [] = {
+    // Common
+    { HB_MAKE_TAG('l', 'a', 't', 'n'), 0 },
+    // Greek
+    { HB_MAKE_TAG('g', 'r', 'e', 'k'), 0 },
+    // Cyrillic
+    { HB_MAKE_TAG('c', 'y', 'r', 'l'), 0 },
+    // Armenian
+    { HB_MAKE_TAG('a', 'r', 'm', 'n'), 0 },
+    // Hebrew
+    { HB_MAKE_TAG('h', 'e', 'b', 'r'), 1 },
+    // Arabic
+    { HB_MAKE_TAG('a', 'r', 'a', 'b'), 1 },
+    // Syriac
+    { HB_MAKE_TAG('s', 'y', 'r', 'c'), 1 },
+    // Thaana
+    { HB_MAKE_TAG('t', 'h', 'a', 'a'), 1 },
+    // Devanagari
+    { HB_MAKE_TAG('d', 'e', 'v', 'a'), 1 },
+    // Bengali
+    { HB_MAKE_TAG('b', 'e', 'n', 'g'), 1 },
+    // Gurmukhi
+    { HB_MAKE_TAG('g', 'u', 'r', 'u'), 1 },
+    // Gujarati
+    { HB_MAKE_TAG('g', 'u', 'j', 'r'), 1 },
+    // Oriya
+    { HB_MAKE_TAG('o', 'r', 'y', 'a'), 1 },
+    // Tamil
+    { HB_MAKE_TAG('t', 'a', 'm', 'l'), 1 },
+    // Telugu
+    { HB_MAKE_TAG('t', 'e', 'l', 'u'), 1 },
+    // Kannada
+    { HB_MAKE_TAG('k', 'n', 'd', 'a'), 1 },
+    // Malayalam
+    { HB_MAKE_TAG('m', 'l', 'y', 'm'), 1 },
+    // Sinhala
+    { HB_MAKE_TAG('s', 'i', 'n', 'h'), 1 },
+    // Thai
+    { HB_MAKE_TAG('t', 'h', 'a', 'i'), 1 },
+    // Lao
+    { HB_MAKE_TAG('l', 'a', 'o', ' '), 1 },
+    // Tibetan
+    { HB_MAKE_TAG('t', 'i', 'b', 't'), 1 },
+    // Myanmar
+    { HB_MAKE_TAG('m', 'y', 'm', 'r'), 1 },
+    // Georgian
+    { HB_MAKE_TAG('g', 'e', 'o', 'r'), 0 },
+    // Hangul
+    { HB_MAKE_TAG('h', 'a', 'n', 'g'), 1 },
+    // Ogham
+    { HB_MAKE_TAG('o', 'g', 'a', 'm'), 0 },
+    // Runic
+    { HB_MAKE_TAG('r', 'u', 'n', 'r'), 0 },
+    // Khmer
+    { HB_MAKE_TAG('k', 'h', 'm', 'r'), 1 },
+    // N'Ko
+    { HB_MAKE_TAG('n', 'k', 'o', ' '), 1 }
+};
+enum { NumOTScripts = sizeof(ot_scripts)/sizeof(OTScripts) };
+
+static HB_Bool checkScript(HB_Face face, int script)
+{
+    assert(script < HB_ScriptCount);
+
+    if (!face->gsub && !face->gpos)
+        return false;
+
+    unsigned int tag = ot_scripts[script].tag;
+    int requirements = ot_scripts[script].flags;
+
+    if (requirements & RequiresGsub) {
+        if (!face->gsub)
+            return false;
+
+        HB_UShort script_index;
+        HB_Error error = HB_GSUB_Select_Script(face->gsub, tag, &script_index);
+        if (error) {
+            DEBUG("could not select script %d in GSub table: %d", (int)script, error);
+            error = HB_GSUB_Select_Script(face->gsub, HB_MAKE_TAG('D', 'F', 'L', 'T'), &script_index);
+            if (error)
+                return false;
+        }
+    }
+
+    if (requirements & RequiresGpos) {
+        if (!face->gpos)
+            return false;
+
+        HB_UShort script_index;
+        HB_Error error = HB_GPOS_Select_Script(face->gpos, script, &script_index);
+        if (error) {
+            DEBUG("could not select script in gpos table: %d", error);
+            error = HB_GPOS_Select_Script(face->gpos, HB_MAKE_TAG('D', 'F', 'L', 'T'), &script_index);
+            if (error)
+                return false;
+        }
+
+    }
+    return true;
+}
+
+static HB_Stream getTableStream(void *font, HB_GetFontTableFunc tableFunc, HB_Tag tag)
+{
+    HB_Error error;
+    HB_UInt length = 0;
+    HB_Stream stream = 0;
+
+    if (!font)
+        return 0;
+
+    error = tableFunc(font, tag, 0, &length);
+    if (error)
+        return 0;
+    stream = (HB_Stream)malloc(sizeof(HB_StreamRec));
+    if (!stream)
+        return 0;
+    stream->base = (HB_Byte*)malloc(length);
+    if (!stream->base) {
+        free(stream);
+        return 0;
+    }
+    error = tableFunc(font, tag, stream->base, &length);
+    if (error) {
+        _hb_close_stream(stream);
+        return 0;
+    }
+    stream->size = length;
+    stream->pos = 0;
+    stream->cursor = NULL;
+    return stream;
+}
+
+HB_Face HB_NewFace(void *font, HB_GetFontTableFunc tableFunc)
+{
+    HB_Face face = (HB_Face )malloc(sizeof(HB_FaceRec));
+    if (!face)
+        return 0;
+
+    face->isSymbolFont = false;
+    face->gdef = 0;
+    face->gpos = 0;
+    face->gsub = 0;
+    face->current_script = HB_ScriptCount;
+    face->current_flags = HB_ShaperFlag_Default;
+    face->has_opentype_kerning = false;
+    face->tmpAttributes = 0;
+    face->tmpLogClusters = 0;
+    face->glyphs_substituted = false;
+    face->buffer = 0;
+
+    HB_Error error = HB_Err_Ok;
+    HB_Stream stream;
+    HB_Stream gdefStream;
+
+    gdefStream = getTableStream(font, tableFunc, TTAG_GDEF);
+    error = HB_Err_Not_Covered;
+    if (!gdefStream || (error = HB_Load_GDEF_Table(gdefStream, &face->gdef))) {
+        //DEBUG("error loading gdef table: %d", error);
+        face->gdef = 0;
+    }
+
+    //DEBUG() << "trying to load gsub table";
+    stream = getTableStream(font, tableFunc, TTAG_GSUB);
+    error = HB_Err_Not_Covered;
+    if (!stream || (error = HB_Load_GSUB_Table(stream, &face->gsub, face->gdef, gdefStream))) {
+        face->gsub = 0;
+        if (error != HB_Err_Not_Covered) {
+            //DEBUG("error loading gsub table: %d", error);
+        } else {
+            //DEBUG("face doesn't have a gsub table");
+        }
+    }
+    _hb_close_stream(stream);
+
+    stream = getTableStream(font, tableFunc, TTAG_GPOS);
+    error = HB_Err_Not_Covered;
+    if (!stream || (error = HB_Load_GPOS_Table(stream, &face->gpos, face->gdef, gdefStream))) {
+        face->gpos = 0;
+        DEBUG("error loading gpos table: %d", error);
+    }
+    _hb_close_stream(stream);
+
+    _hb_close_stream(gdefStream);
+
+    for (unsigned int i = 0; i < HB_ScriptCount; ++i)
+        face->supported_scripts[i] = checkScript(face, i);
+
+    if (hb_buffer_new(&face->buffer) != HB_Err_Ok) {
+        HB_FreeFace(face);
+        return 0;
+    }
+
+    return face;
+}
+
+void HB_FreeFace(HB_Face face)
+{
+    if (!face)
+        return;
+    if (face->gpos)
+        HB_Done_GPOS_Table(face->gpos);
+    if (face->gsub)
+        HB_Done_GSUB_Table(face->gsub);
+    if (face->gdef)
+        HB_Done_GDEF_Table(face->gdef);
+    if (face->buffer)
+        hb_buffer_free(face->buffer);
+    if (face->tmpAttributes)
+        free(face->tmpAttributes);
+    if (face->tmpLogClusters)
+        free(face->tmpLogClusters);
+    free(face);
+}
+
+HB_Bool HB_SelectScript(HB_ShaperItem *shaper_item, const HB_OpenTypeFeature *features)
+{
+    HB_Script script = shaper_item->item.script;
+
+    if (!shaper_item->face->supported_scripts[script])
+        return false;
+
+    HB_Face face = shaper_item->face;
+    if (face->current_script == script && face->current_flags == shaper_item->shaperFlags)
+        return true;
+
+    face->current_script = script;
+    face->current_flags = shaper_item->shaperFlags;
+
+    assert(script < HB_ScriptCount);
+    // find script in our list of supported scripts.
+    unsigned int tag = ot_scripts[script].tag;
+
+    if (face->gsub && features) {
+#ifdef OT_DEBUG
+        {
+            HB_FeatureList featurelist = face->gsub->FeatureList;
+            int numfeatures = featurelist.FeatureCount;
+            DEBUG("gsub table has %d features", numfeatures);
+            for (int i = 0; i < numfeatures; i++) {
+                HB_FeatureRecord *r = featurelist.FeatureRecord + i;
+                DEBUG("   feature '%s'", tag_to_string(r->FeatureTag));
+            }
+        }
+#endif
+        HB_GSUB_Clear_Features(face->gsub);
+        HB_UShort script_index;
+        HB_Error error = HB_GSUB_Select_Script(face->gsub, tag, &script_index);
+        if (!error) {
+            DEBUG("script %s has script index %d", tag_to_string(script), script_index);
+            while (features->tag) {
+                HB_UShort feature_index;
+                error = HB_GSUB_Select_Feature(face->gsub, features->tag, script_index, 0xffff, &feature_index);
+                if (!error) {
+                    DEBUG("  adding feature %s", tag_to_string(features->tag));
+                    HB_GSUB_Add_Feature(face->gsub, feature_index, features->property);
+                }
+                ++features;
+            }
+        }
+    }
+
+    // reset
+    face->has_opentype_kerning = false;
+
+    if (face->gpos) {
+        HB_GPOS_Clear_Features(face->gpos);
+        HB_UShort script_index;
+        HB_Error error = HB_GPOS_Select_Script(face->gpos, tag, &script_index);
+        if (!error) {
+#ifdef OT_DEBUG
+            {
+                HB_FeatureList featurelist = face->gpos->FeatureList;
+                int numfeatures = featurelist.FeatureCount;
+                DEBUG("gpos table has %d features", numfeatures);
+                for(int i = 0; i < numfeatures; i++) {
+                    HB_FeatureRecord *r = featurelist.FeatureRecord + i;
+                    HB_UShort feature_index;
+                    HB_GPOS_Select_Feature(face->gpos, r->FeatureTag, script_index, 0xffff, &feature_index);
+                    DEBUG("   feature '%s'", tag_to_string(r->FeatureTag));
+                }
+            }
+#endif
+            HB_UInt *feature_tag_list_buffer;
+            error = HB_GPOS_Query_Features(face->gpos, script_index, 0xffff, &feature_tag_list_buffer);
+            if (!error) {
+                HB_UInt *feature_tag_list = feature_tag_list_buffer;
+                while (*feature_tag_list) {
+                    HB_UShort feature_index;
+                    if (*feature_tag_list == HB_MAKE_TAG('k', 'e', 'r', 'n')) {
+                        if (face->current_flags & HB_ShaperFlag_NoKerning) {
+                            ++feature_tag_list;
+                            continue;
+                        }
+                        face->has_opentype_kerning = true;
+                    }
+                    error = HB_GPOS_Select_Feature(face->gpos, *feature_tag_list, script_index, 0xffff, &feature_index);
+                    if (!error)
+                        HB_GPOS_Add_Feature(face->gpos, feature_index, PositioningProperties);
+                    ++feature_tag_list;
+                }
+                FREE(feature_tag_list_buffer);
+            }
+        }
+    }
+
+    return true;
+}
+
+HB_Bool HB_OpenTypeShape(HB_ShaperItem *item, const hb_uint32 *properties)
+{
+    HB_GlyphAttributes *tmpAttributes;
+    unsigned int *tmpLogClusters;
+
+    HB_Face face = item->face;
+
+    face->length = item->num_glyphs;
+
+    hb_buffer_clear(face->buffer);
+
+    tmpAttributes = (HB_GlyphAttributes *) realloc(face->tmpAttributes, face->length*sizeof(HB_GlyphAttributes));
+    if (!tmpAttributes)
+        return false;
+    face->tmpAttributes = tmpAttributes;
+
+    tmpLogClusters = (unsigned int *) realloc(face->tmpLogClusters, face->length*sizeof(unsigned int));
+    if (!tmpLogClusters)
+        return false;
+    face->tmpLogClusters = tmpLogClusters;
+
+    for (int i = 0; i < face->length; ++i) {
+        hb_buffer_add_glyph(face->buffer, item->glyphs[i], properties ? properties[i] : 0, i);
+        face->tmpAttributes[i] = item->attributes[i];
+        face->tmpLogClusters[i] = item->log_clusters[i];
+    }
+
+#ifdef OT_DEBUG
+    DEBUG("-----------------------------------------");
+//     DEBUG("log clusters before shaping:");
+//     for (int j = 0; j < length; j++)
+//         DEBUG("    log[%d] = %d", j, item->log_clusters[j]);
+    DEBUG("original glyphs: %p", item->glyphs);
+    for (int i = 0; i < length; ++i)
+        DEBUG("   glyph=%4x", hb_buffer->in_string[i].gindex);
+//     dump_string(hb_buffer);
+#endif
+
+    face->glyphs_substituted = false;
+    if (face->gsub) {
+        unsigned int error = HB_GSUB_Apply_String(face->gsub, face->buffer);
+        if (error && error != HB_Err_Not_Covered)
+            return false;
+        face->glyphs_substituted = (error != HB_Err_Not_Covered);
+    }
+
+#ifdef OT_DEBUG
+//     DEBUG("log clusters before shaping:");
+//     for (int j = 0; j < length; j++)
+//         DEBUG("    log[%d] = %d", j, item->log_clusters[j]);
+    DEBUG("shaped glyphs:");
+    for (int i = 0; i < length; ++i)
+        DEBUG("   glyph=%4x", hb_buffer->in_string[i].gindex);
+    DEBUG("-----------------------------------------");
+//     dump_string(hb_buffer);
+#endif
+
+    return true;
+}
+
+HB_Bool HB_OpenTypePosition(HB_ShaperItem *item, int availableGlyphs, HB_Bool doLogClusters)
+{
+    HB_Face face = item->face;
+
+    bool glyphs_positioned = false;
+    if (face->gpos) {
+        if (face->buffer->positions)
+            memset(face->buffer->positions, 0, face->buffer->in_length*sizeof(HB_PositionRec));
+        // #### check that passing "false,false" is correct
+        glyphs_positioned = HB_GPOS_Apply_String(item->font, face->gpos, face->current_flags, face->buffer, false, false) != HB_Err_Not_Covered;
+    }
+
+    if (!face->glyphs_substituted && !glyphs_positioned) {
+        HB_GetGlyphAdvances(item);
+        return true; // nothing to do for us
+    }
+
+    // make sure we have enough space to write everything back
+    if (availableGlyphs < (int)face->buffer->in_length) {
+        item->num_glyphs = face->buffer->in_length;
+        return false;
+    }
+
+    HB_Glyph *glyphs = item->glyphs;
+    HB_GlyphAttributes *attributes = item->attributes;
+
+    for (unsigned int i = 0; i < face->buffer->in_length; ++i) {
+        glyphs[i] = face->buffer->in_string[i].gindex;
+        attributes[i] = face->tmpAttributes[face->buffer->in_string[i].cluster];
+        if (i && face->buffer->in_string[i].cluster == face->buffer->in_string[i-1].cluster)
+            attributes[i].clusterStart = false;
+    }
+    item->num_glyphs = face->buffer->in_length;
+
+    if (doLogClusters && face->glyphs_substituted) {
+        // we can't do this for indic, as we pass the stuf in syllables and it's easier to do it in the shaper.
+        unsigned short *logClusters = item->log_clusters;
+        int clusterStart = 0;
+        int oldCi = 0;
+        // #### the reconstruction of the logclusters currently does not work if the original string
+        // contains surrogate pairs
+        for (unsigned int i = 0; i < face->buffer->in_length; ++i) {
+            int ci = face->buffer->in_string[i].cluster;
+            //         DEBUG("   ci[%d] = %d mark=%d, cmb=%d, cs=%d",
+            //                i, ci, glyphAttributes[i].mark, glyphAttributes[i].combiningClass, glyphAttributes[i].clusterStart);
+            if (!attributes[i].mark && attributes[i].clusterStart && ci != oldCi) {
+                for (int j = oldCi; j < ci; j++)
+                    logClusters[j] = clusterStart;
+                clusterStart = i;
+                oldCi = ci;
+            }
+        }
+        for (int j = oldCi; j < face->length; j++)
+            logClusters[j] = clusterStart;
+    }
+
+    // calulate the advances for the shaped glyphs
+//     DEBUG("unpositioned: ");
+
+    // positioning code:
+    if (glyphs_positioned) {
+        HB_GetGlyphAdvances(item);
+        HB_Position positions = face->buffer->positions;
+        HB_Fixed *advances = item->advances;
+
+//         DEBUG("positioned glyphs:");
+        for (unsigned int i = 0; i < face->buffer->in_length; i++) {
+//             DEBUG("    %d:\t orig advance: (%d/%d)\tadv=(%d/%d)\tpos=(%d/%d)\tback=%d\tnew_advance=%d", i,
+//                    glyphs[i].advance.x.toInt(), glyphs[i].advance.y.toInt(),
+//                    (int)(positions[i].x_advance >> 6), (int)(positions[i].y_advance >> 6),
+//                    (int)(positions[i].x_pos >> 6), (int)(positions[i].y_pos >> 6),
+//                    positions[i].back, positions[i].new_advance);
+
+            HB_Fixed adjustment = (item->item.bidiLevel % 2) ? -positions[i].x_advance : positions[i].x_advance;
+
+            if (!(face->current_flags & HB_ShaperFlag_UseDesignMetrics))
+                adjustment = HB_FIXED_ROUND(adjustment);
+
+            if (positions[i].new_advance) {
+                advances[i] = adjustment;
+            } else {
+                advances[i] += adjustment;
+            }
+
+            int back = 0;
+            HB_FixedPoint *offsets = item->offsets;
+            offsets[i].x = positions[i].x_pos;
+            offsets[i].y = positions[i].y_pos;
+            while (positions[i - back].back) {
+                back += positions[i - back].back;
+                offsets[i].x += positions[i - back].x_pos;
+                offsets[i].y += positions[i - back].y_pos;
+            }
+            offsets[i].y = -offsets[i].y;
+
+            if (item->item.bidiLevel % 2) {
+                // ### may need to go back multiple glyphs like in ltr
+                back = positions[i].back;
+                while (back--)
+                    offsets[i].x -= advances[i-back];
+            } else {
+                back = 0;
+                while (positions[i - back].back) {
+                    back += positions[i - back].back;
+                    offsets[i].x -= advances[i-back];
+                }
+            }
+//             DEBUG("   ->\tadv=%d\tpos=(%d/%d)",
+//                    glyphs[i].advance.x.toInt(), glyphs[i].offset.x.toInt(), glyphs[i].offset.y.toInt());
+        }
+        item->kerning_applied = face->has_opentype_kerning;
+    } else {
+        HB_HeuristicPosition(item);
+    }
+
+#ifdef OT_DEBUG
+    if (doLogClusters) {
+        DEBUG("log clusters after shaping:");
+        for (int j = 0; j < length; j++)
+            DEBUG("    log[%d] = %d", j, item->log_clusters[j]);
+    }
+    DEBUG("final glyphs:");
+    for (int i = 0; i < (int)hb_buffer->in_length; ++i)
+        DEBUG("   glyph=%4x char_index=%d mark: %d cmp: %d, clusterStart: %d advance=%d/%d offset=%d/%d",
+               glyphs[i].glyph, hb_buffer->in_string[i].cluster, glyphs[i].attributes.mark,
+               glyphs[i].attributes.combiningClass, glyphs[i].attributes.clusterStart,
+               glyphs[i].advance.x.toInt(), glyphs[i].advance.y.toInt(),
+               glyphs[i].offset.x.toInt(), glyphs[i].offset.y.toInt());
+    DEBUG("-----------------------------------------");
+#endif
+    return true;
+}
+
+HB_Bool HB_ShapeItem(HB_ShaperItem *shaper_item)
+{
+    HB_Bool result = false;
+    if (shaper_item->num_glyphs < shaper_item->item.length) {
+        shaper_item->num_glyphs = shaper_item->item.length;
+        return false;
+    }
+    assert(shaper_item->item.script < HB_ScriptCount);
+    result = HB_ScriptEngines[shaper_item->item.script].shape(shaper_item);
+    shaper_item->glyphIndicesPresent = false;
+    return result;
+}
+
diff -rupN orginal/scribus/harfbuzz/harfbuzz-shaper.h patched/scribus/harfbuzz/harfbuzz-shaper.h
--- orginal/scribus/harfbuzz/harfbuzz-shaper.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/harfbuzz-shaper.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,274 @@
+/*
+ * Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies)
+ *
+ * This is part of HarfBuzz, an OpenType Layout engine library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ */
+
+#ifndef HARFBUZZ_SHAPER_H
+#define HARFBUZZ_SHAPER_H
+
+#include "harfbuzz-global.h"
+#include "harfbuzz-gdef.h"
+#include "harfbuzz-gpos.h"
+#include "harfbuzz-gsub.h"
+#include "harfbuzz-external.h"
+#include "harfbuzz-stream-private.h"
+
+HB_BEGIN_HEADER
+
+typedef enum {
+        HB_Script_Common,
+        HB_Script_Greek,
+        HB_Script_Cyrillic,
+        HB_Script_Armenian,
+        HB_Script_Hebrew,
+        HB_Script_Arabic,
+        HB_Script_Syriac,
+        HB_Script_Thaana,
+        HB_Script_Devanagari,
+        HB_Script_Bengali,
+        HB_Script_Gurmukhi,
+        HB_Script_Gujarati,
+        HB_Script_Oriya,
+        HB_Script_Tamil,
+        HB_Script_Telugu,
+        HB_Script_Kannada,
+        HB_Script_Malayalam,
+        HB_Script_Sinhala,
+        HB_Script_Thai,
+        HB_Script_Lao,
+        HB_Script_Tibetan,
+        HB_Script_Myanmar,
+        HB_Script_Georgian,
+        HB_Script_Hangul,
+        HB_Script_Ogham,
+        HB_Script_Runic,
+        HB_Script_Khmer,
+        HB_Script_Nko,
+        HB_Script_Inherited,
+        HB_ScriptCount = HB_Script_Inherited
+        /*
+        HB_Script_Latin = Common,
+        HB_Script_Ethiopic = Common,
+        HB_Script_Cherokee = Common,
+        HB_Script_CanadianAboriginal = Common,
+        HB_Script_Mongolian = Common,
+        HB_Script_Hiragana = Common,
+        HB_Script_Katakana = Common,
+        HB_Script_Bopomofo = Common,
+        HB_Script_Han = Common,
+        HB_Script_Yi = Common,
+        HB_Script_OldItalic = Common,
+        HB_Script_Gothic = Common,
+        HB_Script_Deseret = Common,
+        HB_Script_Tagalog = Common,
+        HB_Script_Hanunoo = Common,
+        HB_Script_Buhid = Common,
+        HB_Script_Tagbanwa = Common,
+        HB_Script_Limbu = Common,
+        HB_Script_TaiLe = Common,
+        HB_Script_LinearB = Common,
+        HB_Script_Ugaritic = Common,
+        HB_Script_Shavian = Common,
+        HB_Script_Osmanya = Common,
+        HB_Script_Cypriot = Common,
+        HB_Script_Braille = Common,
+        HB_Script_Buginese = Common,
+        HB_Script_Coptic = Common,
+        HB_Script_NewTaiLue = Common,
+        HB_Script_Glagolitic = Common,
+        HB_Script_Tifinagh = Common,
+        HB_Script_SylotiNagri = Common,
+        HB_Script_OldPersian = Common,
+        HB_Script_Kharoshthi = Common,
+        HB_Script_Balinese = Common,
+        HB_Script_Cuneiform = Common,
+        HB_Script_Phoenician = Common,
+        HB_Script_PhagsPa = Common,
+        */
+} HB_Script;
+
+typedef struct
+{
+    hb_uint32 pos;
+    hb_uint32 length;
+    HB_Script script;
+    hb_uint8 bidiLevel;
+} HB_ScriptItem;
+
+typedef enum {
+    HB_NoBreak,
+    HB_SoftHyphen,
+    HB_Break,
+    HB_ForcedBreak
+} HB_LineBreakType;
+
+
+typedef struct {
+    /*HB_LineBreakType*/ unsigned lineBreakType  :2;
+    /*HB_Bool*/ unsigned whiteSpace              :1;     /* A unicode whitespace character, except NBSP, ZWNBSP */
+    /*HB_Bool*/ unsigned charStop                :1;     /* Valid cursor position (for left/right arrow) */
+    /*HB_Bool*/ unsigned wordBoundary            :1;
+    /*HB_Bool*/ unsigned sentenceBoundary        :1;
+    unsigned unused                  :2;
+} HB_CharAttributes;
+
+void HB_GetCharAttributes(const HB_UChar16 *string, hb_uint32 stringLength,
+                          const HB_ScriptItem *items, hb_uint32 numItems,
+                          HB_CharAttributes *attributes);
+
+/* requires HB_GetCharAttributes to be called before */
+void HB_GetWordBoundaries(const HB_UChar16 *string, hb_uint32 stringLength,
+                          const HB_ScriptItem *items, hb_uint32 numItems,
+                          HB_CharAttributes *attributes);
+
+/* requires HB_GetCharAttributes to be called before */
+void HB_GetSentenceBoundaries(const HB_UChar16 *string, hb_uint32 stringLength,
+                              const HB_ScriptItem *items, hb_uint32 numItems,
+                              HB_CharAttributes *attributes);
+
+
+typedef enum {
+    HB_LeftToRight = 0,
+    HB_RightToLeft = 1
+} HB_StringToGlyphsFlags;
+
+typedef enum {
+    HB_ShaperFlag_Default = 0,
+    HB_ShaperFlag_NoKerning = 1,
+    HB_ShaperFlag_UseDesignMetrics = 2
+} HB_ShaperFlag;
+
+/* 
+   highest value means highest priority for justification. Justification is done by first inserting kashidas
+   starting with the highest priority positions, then stretching spaces, afterwards extending inter char
+   spacing, and last spacing between arabic words.
+   NoJustification is for example set for arabic where no Kashida can be inserted or for diacritics.
+*/
+typedef enum {
+    HB_NoJustification= 0,   /* Justification can't be applied after this glyph */
+    HB_Arabic_Space   = 1,   /* This glyph represents a space inside arabic text */
+    HB_Character      = 2,   /* Inter-character justification point follows this glyph */
+    HB_Space          = 4,   /* This glyph represents a blank outside an Arabic run */
+    HB_Arabic_Normal  = 7,   /* Normal Middle-Of-Word glyph that connects to the right (begin) */
+    HB_Arabic_Waw     = 8,   /* Next character is final form of Waw/Ain/Qaf/Fa */
+    HB_Arabic_BaRa    = 9,   /* Next two chars are Ba + Ra/Ya/AlefMaksura */
+    HB_Arabic_Alef    = 10,  /* Next character is final form of Alef/Tah/Lam/Kaf/Gaf */
+    HB_Arabic_HaaDal  = 11,  /* Next character is final form of Haa/Dal/Taa Marbutah */
+    HB_Arabic_Seen    = 12,  /* Initial or Medial form Of Seen/Sad */
+    HB_Arabic_Kashida = 13   /* Kashida(U+640) in middle of word */
+} HB_JustificationClass;
+
+/* This structure is binary compatible with Uniscribe's SCRIPT_VISATTR. Would be nice to keep
+ * it like that. If this is a problem please tell Trolltech :)
+ */
+typedef struct {
+    unsigned justification   :4;  /* Justification class */
+    unsigned clusterStart    :1;  /* First glyph of representation of cluster */
+    unsigned mark            :1;  /* needs to be positioned around base char */
+    unsigned zeroWidth       :1;  /* ZWJ, ZWNJ etc, with no width */
+    unsigned dontPrint       :1;
+    unsigned combiningClass  :8;
+} HB_GlyphAttributes;
+
+typedef struct HB_FaceRec_ {
+    HB_Bool isSymbolFont;
+
+    HB_GDEF gdef;
+    HB_GSUB gsub;
+    HB_GPOS gpos;
+    HB_Bool supported_scripts[HB_ScriptCount];
+    HB_Buffer buffer;
+    HB_Script current_script;
+    int current_flags; /* HB_ShaperFlags */
+    HB_Bool has_opentype_kerning;
+    HB_Bool glyphs_substituted;
+    HB_GlyphAttributes *tmpAttributes;
+    unsigned int *tmpLogClusters;
+    int length;
+    int orig_nglyphs;
+} HB_FaceRec;
+
+typedef HB_Error (*HB_GetFontTableFunc)(void *font, HB_Tag tag, HB_Byte *buffer, HB_UInt *length);
+
+HB_Face HB_NewFace(void *font, HB_GetFontTableFunc tableFunc);
+void HB_FreeFace(HB_Face face);
+
+typedef struct {
+    HB_Fixed x, y;
+    HB_Fixed width, height;
+    HB_Fixed xOffset, yOffset;
+} HB_GlyphMetrics;
+
+typedef enum {
+    HB_FontAscent
+} HB_FontMetric;
+
+typedef struct {
+    HB_Bool  (*convertStringToGlyphIndices)(HB_Font font, const HB_UChar16 *string, hb_uint32 length, HB_Glyph *glyphs, hb_uint32 *numGlyphs, HB_Bool rightToLeft);
+    void     (*getGlyphAdvances)(HB_Font font, const HB_Glyph *glyphs, hb_uint32 numGlyphs, HB_Fixed *advances, int flags /*HB_ShaperFlag*/);
+    HB_Bool  (*canRender)(HB_Font font, const HB_UChar16 *string, hb_uint32 length);
+    /* implementation needs to make sure to load a scaled glyph, so /no/ FT_LOAD_NO_SCALE */
+    HB_Error (*getPointInOutline)(HB_Font font, HB_Glyph glyph, int flags /*HB_ShaperFlag*/, hb_uint32 point, HB_Fixed *xpos, HB_Fixed *ypos, hb_uint32 *nPoints);
+    void     (*getGlyphMetrics)(HB_Font font, HB_Glyph glyph, HB_GlyphMetrics *metrics);
+    HB_Fixed (*getFontMetric)(HB_Font font, HB_FontMetric metric);
+} HB_FontClass;
+
+typedef struct HB_Font_ {
+    const HB_FontClass *klass;
+
+    /* Metrics */
+    HB_UShort x_ppem, y_ppem;
+    HB_16Dot16 x_scale, y_scale;
+
+    void *userData;
+} HB_FontRec;
+
+typedef struct HB_ShaperItem_ HB_ShaperItem;
+
+struct HB_ShaperItem_ {
+    const HB_UChar16 *string;               /* input: the Unicode UTF16 text to be shaped */
+    hb_uint32 stringLength;                 /* input: the length of the input in 16-bit words */
+    HB_ScriptItem item;                     /* input: the current run to be shaped: a run of text all in the same script that is a substring of <string> */
+    HB_Font font;                           /* input: the font: scale, units and function pointers supplying glyph indices and metrics */
+    HB_Face face;                           /* input: the shaper state; current script, access to the OpenType tables , etc. */
+    int shaperFlags;                        /* input (unused) should be set to 0; intended to support flags defined in HB_ShaperFlag */
+    HB_Bool glyphIndicesPresent;            /* input: true if the <glyphs> array contains glyph indices ready to be shaped */
+    hb_uint32 initialGlyphCount;            /* input: if glyphIndicesPresent is true, the number of glyph indices in the <glyphs> array */
+
+    hb_uint32 num_glyphs;                   /* input: capacity of output arrays <glyphs>, <attributes>, <advances>, <offsets>, and <log_clusters>; */
+                                            /* output: required capacity (may be larger than actual capacity) */
+
+    HB_Glyph *glyphs;                       /* output: <num_glyphs> indices of shaped glyphs */
+    HB_GlyphAttributes *attributes;         /* output: <num_glyphs> glyph attributes */
+    HB_Fixed *advances;                     /* output: <num_glyphs> advances */
+    HB_FixedPoint *offsets;                 /* output: <num_glyphs> offsets */
+    unsigned short *log_clusters;           /* output: for each output glyph, the index in the input of the start of its logical cluster */
+
+    /* internal */
+    HB_Bool kerning_applied;                /* output: true if kerning was applied by the shaper */
+};
+
+HB_Bool HB_ShapeItem(HB_ShaperItem *item);
+
+HB_END_HEADER
+
+#endif
diff -rupN orginal/scribus/harfbuzz/harfbuzz-shape.h patched/scribus/harfbuzz/harfbuzz-shape.h
--- orginal/scribus/harfbuzz/harfbuzz-shape.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/harfbuzz-shape.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,199 @@
+/*
+ * Copyright (C) 2006  Red Hat, Inc.
+ *
+ * This is part of HarfBuzz, an OpenType Layout engine library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Owen Taylor
+ */
+
+#include <stdint.h>
+
+/* Base Types */
+
+typedef hb_uint16 HB_CodePoint; /* UTF-16 codepoint (not character ) */
+typedef char HB_Boolean;
+typedef hb_uint32 HB_Fixed; /* 26.6 */
+typedef hb_uint32 HB_Glyph;
+typedef hb_uint32 HB_Unichar;
+
+/* Metrics reported by the font backend for use of the shaper */
+typedef struct _HB_GlyphMetrics HB_GlyphMetrics;
+struct _HB_GlyphMetrics
+{
+    HB_Fixed advance;
+    
+    /* Do we need ink/logical extents for the glyph here? */
+};
+
+/*
+ * HB_Font: Abstract font interface.
+ *  First pass of this might just have FT_Face *getFace();
+ */
+typedef struct _HB_Font HB_Font;
+typedef struct _HB_FontClass HB_FontClass;
+
+struct HB_FontClass {
+    HB_Glyph   (*charToGlyph)(HB_Font *font, HB_Unichar chr);
+    void       (*getMetrics)(HB_Font *font, HB_Glyph glyph, HB_GlyphMetrics *metrics);
+    HB_Boolean (*getSFontTable)(HB_Font *font, void **cookie, char **start, int *len);
+    HB_Boolean (*freeSFontTable)(void **cookie);
+};
+
+struct _HB_Font {
+    HB_FontClass *clazz;
+};
+
+/*
+ * Language tags, of the form en-us; represented as interned, canonicalized
+ * strings. hb_language_from_string("en_US"), hb_language_from_string("en-us")
+ * both return the same (pointer-comparable) HB_Language).
+ */
+typedef struct HB_Language_ *HB_Language;
+
+HB_Language hb_language_from_string(const char *str);
+const char *hb_language_to_string(HB_Language language);
+
+/* Special treatment for the edges of runs.
+ */
+typedef enum {
+    HB_RUN_EDGE_LINE_VISUAL_EDGE    = 1 << 0,
+    HB_RUN_EDGE_LINE_LOGICAL_EDGE   = 1 << 1,
+    HB_RUN_EDGE_LINE_ADD_HYPHEN     = 1 << 2  /* ???? */
+} HB_RunEdge;
+
+/* Defines optional informaiton in HB_ShapeInput; this allows extension
+ * of HB_ShapeInput while keeping binary compatibility
+ */
+typedef enum {
+    HB_SHAPE_START_TYPE = 1 << 0,
+    HB_SHAPE_END_TYPE   = 1 << 1
+} HB_ShapeFlags;
+
+/* Attributes types are described by "interned strings"; this is a little
+ * annoying if you want to write a switch statement, but keeps things
+ * simple.
+ */
+typedef struct _HB_AttributeType *HB_AttributeType;
+
+HB_AttributeType hb_attribute_type_from_string(const char *str);
+const char *hb_attribute_type_to_string(HB_AttributeType attribute_type);
+
+struct HB_Attribute {
+    HB_AttributeType type;
+    int start; 
+    int end;
+};
+
+
+/**
+ * You could handle this like HB_Language, but an enum seems a little nicer;
+ * another approach would be to use OpenType script tags.
+ */
+typedef enum {
+    HB_SCRIPT_LATIN
+    /* ... */
+} HB_ShapeScript;
+
+/* This is just the subset of direction information needed by the shaper */
+typedef enum {
+    HB_DIRECTION_LTR,
+    HB_DIRECTION_RTL,
+    HB_DIRECTION_TTB
+} HB_Direction;
+
+typedef struct _HB_ShapeInput HB_ShapeInput;
+struct _HB_ShapeInput {
+    /* Defines what fields the caller has initialized - fields not in
+     * the enum are mandatory.
+     */
+    HB_ShapeFlags flags;
+    
+    HB_CodePoint *text;
+    int length;       /* total length of text to shape */
+    int shape_offset; /* start of section to shape */
+    int shape_length; /* number of code points to shape */
+
+    HB_Direction direction;
+    HB_ShapeScript script;
+    HB_Language language;
+
+    HB_AttributeType *attributes;
+    int n_attributes;
+
+    HB_RunEdge start_type;
+    HB_RunEdge end_type;
+};
+
+struct HB_GlyphItem {
+    HB_Glyph glyph;
+    
+    HB_Fixed x_offset;
+    HB_Fixed y_offset;
+    HB_Fixed advance;
+
+    /* Add kashida information, etc, here */
+};
+
+typedef enum {
+    HB_RESULT_SUCCESS,
+    HB_RESULT_NO_MEMORY,
+    HB_SHAPE_RESULT_FAILED
+} HB_Result;
+
+/*
+ * Buffer for output 
+ */
+typedef struct _HB_GlyphBuffer HB_GlyphBuffer;
+struct _HB_GlyphBuffer {
+    int glyph_item_size;
+    int total_glyphs;
+    
+    int *log_clusters; /* Uniscribe style */
+    int cluster_space;
+  
+    int glyph_space;
+    void *glyph_buffer;
+};
+
+/* Making this self-allocating simplifies writing shapers and
+ * also keeps things easier for caller. item_size passed in
+ * must be at least sizeof(HB_GlyphItem) but can be bigger,
+ * to accomodate application structures that extend HB_GlyphItem.
+ * The allocated items will be zero-initialized.
+ *
+ * (Hack: Harfbuzz could choose to use even a *bigger* item size
+ * and stick internal information before the public item structure.
+ * This hack could possibly be used to unify this with HB_Buffer)
+ */
+HB_GlyphBuffer *hb_glyph_buffer_new             (size_t item_size);
+void            hb_glyph_buffer_clear           (HB_GlyphBuffer *buf);
+HB_Result       hb_glyph_buffer_extend_glyphs   (HB_GlyphBuffer *buf, int n_items);
+HB_Result       hb_glyph_buffer_extend_clusters (HB_GlyphBuffer *buf, int n_clusters);
+void            hb_glyph_buffer_free            (HB_GlyphBuffer *buf);
+
+
+/* Accessor for a particular glyph */
+#define HB_GLYPH_BUFFER_ITEM(buffer, index)
+
+/*
+ * Main shaping function
+ */
+HB_Result hb_shape(HB_ShapeInput *input, HB_GlyphBuffer *output);
diff -rupN orginal/scribus/harfbuzz/harfbuzz-stream-private.h patched/scribus/harfbuzz/harfbuzz-stream-private.h
--- orginal/scribus/harfbuzz/harfbuzz-stream-private.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/harfbuzz-stream-private.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 1998-2004  David Turner and Werner Lemberg
+ * Copyright (C) 2006  Behdad Esfahbod
+ *
+ * This is part of HarfBuzz, an OpenType Layout engine library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ */
+
+#ifndef HARFBUZZ_STREAM_PRIVATE_H
+#define HARFBUZZ_STREAM_PRIVATE_H
+
+#include "harfbuzz-impl.h"
+#include "harfbuzz-stream.h"
+
+HB_BEGIN_HEADER
+
+HB_INTERNAL void
+_hb_close_stream( HB_Stream stream );
+
+HB_INTERNAL HB_Int
+_hb_stream_pos( HB_Stream stream );
+
+HB_INTERNAL HB_Error
+_hb_stream_seek( HB_Stream stream,
+                 HB_UInt   pos );
+
+HB_INTERNAL HB_Error
+_hb_stream_frame_enter( HB_Stream stream,
+                        HB_UInt   size );
+
+HB_INTERNAL void
+_hb_stream_frame_exit( HB_Stream stream );
+
+/* convenience macros */
+
+#define  SET_ERR(c)   ( (error = (c)) != 0 )
+
+#define  GOTO_Table(tag) (0)
+#define  FILE_Pos()      _hb_stream_pos( stream )
+#define  FILE_Seek(pos)  SET_ERR( _hb_stream_seek( stream, pos ) )
+#define  ACCESS_Frame(size)  SET_ERR( _hb_stream_frame_enter( stream, size ) )
+#define  FORGET_Frame()      _hb_stream_frame_exit( stream )
+
+#define  GET_Byte()      (*stream->cursor++)
+#define  GET_Short()     (stream->cursor += 2, (HB_Short)( \
+				(*(((HB_Byte*)stream->cursor)-2) << 8) | \
+				 *(((HB_Byte*)stream->cursor)-1) \
+			 ))
+#define  GET_Long()      (stream->cursor += 4, (HB_Int)( \
+				(*(((HB_Byte*)stream->cursor)-4) << 24) | \
+				(*(((HB_Byte*)stream->cursor)-3) << 16) | \
+				(*(((HB_Byte*)stream->cursor)-2) << 8) | \
+				 *(((HB_Byte*)stream->cursor)-1) \
+			 ))
+
+
+#define  GET_Char()      ((HB_Char)GET_Byte())
+#define  GET_UShort()    ((HB_UShort)GET_Short())
+#define  GET_ULong()     ((HB_UInt)GET_Long())
+#define  GET_Tag4()      GET_ULong()
+
+HB_END_HEADER
+
+#endif /* HARFBUZZ_STREAM_PRIVATE_H */
diff -rupN orginal/scribus/harfbuzz/harfbuzz-stream.c patched/scribus/harfbuzz/harfbuzz-stream.c
--- orginal/scribus/harfbuzz/harfbuzz-stream.c	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/harfbuzz-stream.c	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2005  David Turner
+ * Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies)
+ * Copyright (C) 2007  Red Hat, Inc.
+ *
+ * This is part of HarfBuzz, an OpenType Layout engine library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ */
+
+#include "harfbuzz-impl.h"
+#include "harfbuzz-stream-private.h"
+#include <stdlib.h>
+
+#if 0
+#include <stdio.h>
+#define  LOG(x)  _hb_log x
+
+static void
+_hb_log( const char*   format, ... )
+{
+  va_list  ap;
+ 
+  va_start( ap, format );
+  vfprintf( stderr, format, ap );
+  va_end( ap );
+}
+
+#else
+#define  LOG(x)  do {} while (0)
+#endif
+
+HB_INTERNAL void
+_hb_close_stream( HB_Stream stream )
+{
+  if (!stream)
+      return;
+  free(stream->base);
+  free(stream);
+}
+
+
+HB_INTERNAL HB_Int
+_hb_stream_pos( HB_Stream stream )
+{
+  LOG(( "_hb_stream_pos() -> %ld\n", stream->pos ));
+  return stream->pos;
+}
+
+
+HB_INTERNAL HB_Error
+_hb_stream_seek( HB_Stream stream,
+		 HB_UInt pos )
+{
+  HB_Error  error = (HB_Error)0;
+
+  stream->pos = pos;
+  if (pos > stream->size)
+      error = ERR(HB_Err_Read_Error);
+
+  LOG(( "_hb_stream_seek(%ld) -> 0x%04X\n", pos, error ));
+  return error;
+}
+
+
+HB_INTERNAL HB_Error
+_hb_stream_frame_enter( HB_Stream stream,
+			HB_UInt count )
+{
+  HB_Error  error = HB_Err_Ok;
+
+  /* check new position, watch for overflow */
+  if (HB_UNLIKELY (stream->pos + count > stream->size ||
+		   stream->pos + count < stream->pos))
+  {
+    error = ERR(HB_Err_Read_Error);
+    goto Exit;
+  }
+
+  /* set cursor */
+  stream->cursor = stream->base + stream->pos;
+  stream->pos   += count;
+
+Exit:
+  LOG(( "_hb_stream_frame_enter(%ld) -> 0x%04X\n", count, error ));
+  return error;
+}
+
+
+HB_INTERNAL void
+_hb_stream_frame_exit( HB_Stream stream )
+{
+  stream->cursor = NULL;
+
+  LOG(( "_hb_stream_frame_exit()\n" ));
+}
diff -rupN orginal/scribus/harfbuzz/harfbuzz-stream.h patched/scribus/harfbuzz/harfbuzz-stream.h
--- orginal/scribus/harfbuzz/harfbuzz-stream.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/harfbuzz-stream.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2005  David Turner
+ * Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies)
+ *
+ * This is part of HarfBuzz, an OpenType Layout engine library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ */
+
+#ifndef HARFBUZZ_STREAM_H
+#define HARFBUZZ_STREAM_H
+
+#include "harfbuzz-global.h"
+
+HB_BEGIN_HEADER
+
+typedef struct HB_StreamRec_
+{
+    HB_Byte*       base;
+    HB_UInt        size;
+    HB_UInt        pos;
+    
+    HB_Byte*       cursor;
+} HB_StreamRec;
+
+
+HB_END_HEADER
+
+#endif
diff -rupN orginal/scribus/harfbuzz/harfbuzz-thai.c patched/scribus/harfbuzz/harfbuzz-thai.c
--- orginal/scribus/harfbuzz/harfbuzz-thai.c	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/harfbuzz-thai.c	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies)
+ *
+ * This is part of HarfBuzz, an OpenType Layout engine library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ */
+
+#include "harfbuzz-shaper.h"
+#include "harfbuzz-shaper-private.h"
+#include "harfbuzz-external.h"
+
+#include <assert.h>
+
+static void thaiWordBreaks(const HB_UChar16 *string, hb_uint32 len, HB_CharAttributes *attributes)
+{
+    typedef int (*th_brk_def)(const char*, int[], int);
+    static void *thaiCodec = 0;
+    static th_brk_def th_brk = 0;
+    char *cstr = 0;
+    int brp[128];
+    int *break_positions = brp;
+    hb_uint32 numbreaks;
+    hb_uint32 i;
+
+    if (!thaiCodec)
+        thaiCodec = HB_TextCodecForMib(2259);
+
+    /* load libthai dynamically */
+    if (!th_brk && thaiCodec) {
+        th_brk = (th_brk_def)HB_Library_Resolve("thai", "th_brk");
+        if (!th_brk)
+            thaiCodec = 0;
+    }
+
+    if (!th_brk)
+        return;
+
+    cstr = HB_TextCodec_ConvertFromUnicode(thaiCodec, string, len, 0);
+    if (!cstr)
+        return;
+
+    break_positions = brp;
+    numbreaks = th_brk(cstr, break_positions, 128);
+    if (numbreaks > 128) {
+        break_positions = (int *)malloc(numbreaks * sizeof(int));
+        numbreaks = th_brk(cstr, break_positions, numbreaks);
+    }
+
+    for (i = 0; i < len; ++i)
+        attributes[i].lineBreakType = HB_NoBreak;
+
+    for (i = 0; i < numbreaks; ++i) {
+        if (break_positions[i] > 0)
+            attributes[break_positions[i]-1].lineBreakType = HB_Break;
+    }
+
+    if (break_positions != brp)
+        free(break_positions);
+
+    HB_TextCodec_FreeResult(cstr);
+}
+
+
+void HB_ThaiAttributes(HB_Script script, const HB_UChar16 *text, hb_uint32 from, hb_uint32 len, HB_CharAttributes *attributes)
+{
+    assert(script == HB_Script_Thai);
+    attributes += from;
+    thaiWordBreaks(text + from, len, attributes);
+}
+
diff -rupN orginal/scribus/harfbuzz/harfbuzz-tibetan.c patched/scribus/harfbuzz/harfbuzz-tibetan.c
--- orginal/scribus/harfbuzz/harfbuzz-tibetan.c	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/harfbuzz-tibetan.c	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,274 @@
+/*
+ * Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies)
+ *
+ * This is part of HarfBuzz, an OpenType Layout engine library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ */
+
+#include "harfbuzz-shaper.h"
+#include "harfbuzz-shaper-private.h"
+
+#include <assert.h>
+
+/*
+ tibetan syllables are of the form:
+    head position consonant
+    first sub-joined consonant
+    ....intermediate sub-joined consonants (if any)
+    last sub-joined consonant
+    sub-joined vowel (a-chung U+0F71)
+    standard or compound vowel sign (or 'virama' for devanagari transliteration)
+*/
+
+typedef enum {
+    TibetanOther,
+    TibetanHeadConsonant,
+    TibetanSubjoinedConsonant,
+    TibetanSubjoinedVowel,
+    TibetanVowel
+} TibetanForm;
+
+/* this table starts at U+0f40 */
+static const unsigned char tibetanForm[0x80] = {
+    TibetanHeadConsonant, TibetanHeadConsonant, TibetanHeadConsonant, TibetanHeadConsonant,
+    TibetanHeadConsonant, TibetanHeadConsonant, TibetanHeadConsonant, TibetanHeadConsonant,
+    TibetanHeadConsonant, TibetanHeadConsonant, TibetanHeadConsonant, TibetanHeadConsonant,
+    TibetanHeadConsonant, TibetanHeadConsonant, TibetanHeadConsonant, TibetanHeadConsonant,
+
+    TibetanHeadConsonant, TibetanHeadConsonant, TibetanHeadConsonant, TibetanHeadConsonant,
+    TibetanHeadConsonant, TibetanHeadConsonant, TibetanHeadConsonant, TibetanHeadConsonant,
+    TibetanHeadConsonant, TibetanHeadConsonant, TibetanHeadConsonant, TibetanHeadConsonant,
+    TibetanHeadConsonant, TibetanHeadConsonant, TibetanHeadConsonant, TibetanHeadConsonant,
+
+    TibetanHeadConsonant, TibetanHeadConsonant, TibetanHeadConsonant, TibetanHeadConsonant,
+    TibetanHeadConsonant, TibetanHeadConsonant, TibetanHeadConsonant, TibetanHeadConsonant,
+    TibetanHeadConsonant, TibetanHeadConsonant, TibetanHeadConsonant, TibetanHeadConsonant,
+    TibetanOther, TibetanOther, TibetanOther, TibetanOther,
+
+    TibetanOther, TibetanVowel, TibetanVowel, TibetanVowel,
+    TibetanVowel, TibetanVowel, TibetanVowel, TibetanVowel,
+    TibetanVowel, TibetanVowel, TibetanVowel, TibetanVowel,
+    TibetanVowel, TibetanVowel, TibetanVowel, TibetanVowel,
+
+    TibetanVowel, TibetanVowel, TibetanVowel, TibetanVowel,
+    TibetanVowel, TibetanVowel, TibetanVowel, TibetanVowel,
+    TibetanOther, TibetanOther, TibetanOther, TibetanOther,
+    TibetanOther, TibetanOther, TibetanOther, TibetanOther,
+
+    TibetanSubjoinedConsonant, TibetanSubjoinedConsonant, TibetanSubjoinedConsonant, TibetanSubjoinedConsonant,
+    TibetanSubjoinedConsonant, TibetanSubjoinedConsonant, TibetanSubjoinedConsonant, TibetanSubjoinedConsonant,
+    TibetanSubjoinedConsonant, TibetanSubjoinedConsonant, TibetanSubjoinedConsonant, TibetanSubjoinedConsonant,
+    TibetanSubjoinedConsonant, TibetanSubjoinedConsonant, TibetanSubjoinedConsonant, TibetanSubjoinedConsonant,
+
+    TibetanSubjoinedConsonant, TibetanSubjoinedConsonant, TibetanSubjoinedConsonant, TibetanSubjoinedConsonant,
+    TibetanSubjoinedConsonant, TibetanSubjoinedConsonant, TibetanSubjoinedConsonant, TibetanSubjoinedConsonant,
+    TibetanSubjoinedConsonant, TibetanSubjoinedConsonant, TibetanSubjoinedConsonant, TibetanSubjoinedConsonant,
+    TibetanSubjoinedConsonant, TibetanSubjoinedConsonant, TibetanSubjoinedConsonant, TibetanSubjoinedConsonant,
+
+    TibetanSubjoinedConsonant, TibetanSubjoinedConsonant, TibetanSubjoinedConsonant, TibetanSubjoinedConsonant,
+    TibetanSubjoinedConsonant, TibetanSubjoinedConsonant, TibetanSubjoinedConsonant, TibetanSubjoinedConsonant,
+    TibetanSubjoinedConsonant, TibetanSubjoinedConsonant, TibetanSubjoinedConsonant, TibetanSubjoinedConsonant,
+    TibetanSubjoinedConsonant, TibetanOther, TibetanOther, TibetanOther
+};
+
+
+#define tibetan_form(c) \
+    (TibetanForm)tibetanForm[c - 0x0f40]
+
+static const HB_OpenTypeFeature tibetan_features[] = {
+    { HB_MAKE_TAG('c', 'c', 'm', 'p'), CcmpProperty },
+    { HB_MAKE_TAG('a', 'b', 'v', 's'), AboveSubstProperty },
+    { HB_MAKE_TAG('b', 'l', 'w', 's'), BelowSubstProperty },
+    { HB_MAKE_TAG('c', 'a', 'l', 't'), CaltProperty },
+    {0, 0}
+};
+
+static HB_Bool tibetan_shape_syllable(HB_Bool openType, HB_ShaperItem *item, HB_Bool invalid)
+{
+    hb_uint32 i;
+    const HB_UChar16 *str = item->string + item->item.pos;
+    int len = item->item.length;
+#ifndef NO_OPENTYPE
+    const int availableGlyphs = item->num_glyphs;
+#endif
+    HB_Bool haveGlyphs;
+    HB_STACKARRAY(HB_UChar16, reordered, len + 4);
+
+    if (item->num_glyphs < item->item.length + 4) {
+        item->num_glyphs = item->item.length + 4;
+        return FALSE;
+    }
+
+    if (invalid) {
+        *reordered = 0x25cc;
+        memcpy(reordered+1, str, len*sizeof(HB_UChar16));
+        len++;
+        str = reordered;
+    }
+
+    haveGlyphs = item->font->klass->convertStringToGlyphIndices(item->font,
+                                                                str, len,
+                                                                item->glyphs, &item->num_glyphs,
+                                                                item->item.bidiLevel % 2);
+
+    HB_FREE_STACKARRAY(reordered);
+
+    if (!haveGlyphs)
+        return FALSE;
+
+    for (i = 0; i < item->item.length; i++) {
+        item->attributes[i].mark = FALSE;
+        item->attributes[i].clusterStart = FALSE;
+        item->attributes[i].justification = 0;
+        item->attributes[i].zeroWidth = FALSE;
+/*        IDEBUG("    %d: %4x", i, str[i]); */
+    }
+
+    /* now we have the syllable in the right order, and can start running it through open type. */
+
+#ifndef NO_OPENTYPE
+    if (openType) {
+        HB_OpenTypeShape(item, /*properties*/0);
+        if (!HB_OpenTypePosition(item, availableGlyphs, /*doLogClusters*/FALSE))
+            return FALSE;
+    } else {
+        HB_HeuristicPosition(item);
+    }
+#endif
+
+    item->attributes[0].clusterStart = TRUE;
+    return TRUE;
+}
+
+
+static int tibetan_nextSyllableBoundary(const HB_UChar16 *s, int start, int end, HB_Bool *invalid)
+{
+    const HB_UChar16 *uc = s + start;
+
+    int pos = 0;
+    TibetanForm state = tibetan_form(*uc);
+
+/*     qDebug("state[%d]=%d (uc=%4x)", pos, state, uc[pos]);*/
+    pos++;
+
+    if (state != TibetanHeadConsonant) {
+        if (state != TibetanOther)
+            *invalid = TRUE;
+        goto finish;
+    }
+
+    while (pos < end - start) {
+        TibetanForm newState = tibetan_form(uc[pos]);
+        switch(newState) {
+        case TibetanSubjoinedConsonant:
+        case TibetanSubjoinedVowel:
+            if (state != TibetanHeadConsonant &&
+                 state != TibetanSubjoinedConsonant)
+                goto finish;
+            state = newState;
+            break;
+        case TibetanVowel:
+            if (state != TibetanHeadConsonant &&
+                 state != TibetanSubjoinedConsonant &&
+                 state != TibetanSubjoinedVowel)
+                goto finish;
+            break;
+        case TibetanOther:
+        case TibetanHeadConsonant:
+            goto finish;
+        }
+        pos++;
+    }
+
+finish:
+    *invalid = FALSE;
+    return start+pos;
+}
+
+HB_Bool HB_TibetanShape(HB_ShaperItem *item)
+{
+
+    HB_Bool openType = FALSE;
+    unsigned short *logClusters = item->log_clusters;
+
+    HB_ShaperItem syllable = *item;
+    int first_glyph = 0;
+
+    int sstart = item->item.pos;
+    int end = sstart + item->item.length;
+
+    assert(item->item.script == HB_Script_Tibetan);
+
+#ifndef QT_NO_OPENTYPE
+    openType = HB_SelectScript(item, tibetan_features);
+#endif
+
+    while (sstart < end) {
+        HB_Bool invalid;
+        int i;
+        int send = tibetan_nextSyllableBoundary(item->string, sstart, end, &invalid);
+/*        IDEBUG("syllable from %d, length %d, invalid=%s", sstart, send-sstart,
+                 invalid ? "TRUE" : "FALSE"); */
+        syllable.item.pos = sstart;
+        syllable.item.length = send-sstart;
+        syllable.glyphs = item->glyphs + first_glyph;
+        syllable.attributes = item->attributes + first_glyph;
+        syllable.offsets = item->offsets + first_glyph;
+        syllable.advances = item->advances + first_glyph;
+        syllable.num_glyphs = item->num_glyphs - first_glyph;
+        if (!tibetan_shape_syllable(openType, &syllable, invalid)) {
+            item->num_glyphs += syllable.num_glyphs;
+            return FALSE;
+        }
+        /* fix logcluster array */
+        for (i = sstart; i < send; ++i)
+            logClusters[i-item->item.pos] = first_glyph;
+        sstart = send;
+        first_glyph += syllable.num_glyphs;
+    }
+    item->num_glyphs = first_glyph;
+    return TRUE;
+}
+
+void HB_TibetanAttributes(HB_Script script, const HB_UChar16 *text, hb_uint32 from, hb_uint32 len, HB_CharAttributes *attributes)
+{
+    int end = from + len;
+    const HB_UChar16 *uc = text + from;
+    hb_uint32 i = 0;
+    HB_UNUSED(script);
+    attributes += from;
+    while (i < len) {
+        HB_Bool invalid;
+        hb_uint32 boundary = tibetan_nextSyllableBoundary(text, from+i, end, &invalid) - from;
+
+        attributes[i].charStop = TRUE;
+
+        if (boundary > len-1) boundary = len;
+        i++;
+        while (i < boundary) {
+            attributes[i].charStop = FALSE;
+            ++uc;
+            ++i;
+        }
+        assert(i == boundary);
+    }
+}
+
+
diff -rupN orginal/scribus/harfbuzz/harfbuzz-unicode-tables.c patched/scribus/harfbuzz/harfbuzz-unicode-tables.c
--- orginal/scribus/harfbuzz/harfbuzz-unicode-tables.c	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/harfbuzz-unicode-tables.c	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,84 @@
+#include <stdlib.h>
+#include <stdint.h>
+
+#include <harfbuzz-external.h>
+
+#include "tables/category-properties.h"
+#include "tables/combining-properties.h"
+
+HB_LineBreakClass
+HB_GetLineBreakClass(HB_UChar32 ch) {
+  abort();
+  return 0;
+}
+
+static int
+combining_property_cmp(const void *vkey, const void *vcandidate) {
+  const uint32_t key = (uint32_t) (intptr_t) vkey;
+  const struct combining_property *candidate = vcandidate;
+
+  if (key < candidate->range_start) {
+    return -1;
+  } else if (key > candidate->range_end) {
+    return 1;
+  } else {
+    return 0;
+  }
+}
+
+static int
+code_point_to_combining_class(HB_UChar32 cp) {
+  const void *vprop = bsearch((void *) (intptr_t) cp, combining_properties,
+                              combining_properties_count,
+                              sizeof(struct combining_property),
+                              combining_property_cmp);
+  if (!vprop)
+    return 0;
+
+  return ((const struct combining_property *) vprop)->klass;
+}
+
+int
+HB_GetUnicodeCharCombiningClass(HB_UChar32 ch) {
+  return code_point_to_combining_class(ch);
+  return 0;
+}
+
+static int
+category_property_cmp(const void *vkey, const void *vcandidate) {
+  const uint32_t key = (uint32_t) (intptr_t) vkey;
+  const struct category_property *candidate = vcandidate;
+
+  if (key < candidate->range_start) {
+    return -1;
+  } else if (key > candidate->range_end) {
+    return 1;
+  } else {
+    return 0;
+  }
+}
+
+static HB_CharCategory
+code_point_to_category(HB_UChar32 cp) {
+  const void *vprop = bsearch((void *) (intptr_t) cp, category_properties,
+                              category_properties_count,
+                              sizeof(struct category_property),
+                              category_property_cmp);
+  if (!vprop)
+    return HB_NoCategory;
+
+  return ((const struct category_property *) vprop)->category;
+}
+
+void
+HB_GetUnicodeCharProperties(HB_UChar32 ch,
+                            HB_CharCategory *category,
+                            int *combiningClass) {
+  *category = code_point_to_category(ch);
+  *combiningClass = code_point_to_combining_class(ch);
+}
+
+HB_CharCategory
+HB_GetUnicodeCharCategory(HB_UChar32 ch) {
+  return code_point_to_category(ch);
+}
diff -rupN orginal/scribus/harfbuzz/harfbuzz-unicode.c patched/scribus/harfbuzz/harfbuzz-unicode.c
--- orginal/scribus/harfbuzz/harfbuzz-unicode.c	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/harfbuzz-unicode.c	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,285 @@
+#include <stdint.h>
+#include <stdlib.h>
+
+#include <harfbuzz-external.h>
+#include <harfbuzz-impl.h>
+#include <harfbuzz-shaper.h>
+#include "harfbuzz-unicode.h"
+
+#include "tables/grapheme-break-properties.h"
+#include "tables/mirroring-properties.h"
+#include "tables/script-properties.h"
+
+uint32_t
+utf16_to_code_point(const uint16_t *chars, size_t len, ssize_t *iter) {
+  const uint16_t v = chars[(*iter)++];
+  if (HB_IsHighSurrogate(v)) {
+    // surrogate pair
+    if (*iter >= len) {
+      // the surrogate is incomplete.
+      return HB_InvalidCodePoint;
+    }
+    const uint16_t v2 = chars[(*iter)++];
+    if (!HB_IsLowSurrogate(v2)) {
+      // invalidate surrogate pair.
+      return HB_InvalidCodePoint;
+    }
+
+    return HB_SurrogateToUcs4(v, v2);
+  }
+
+  if (HB_IsLowSurrogate(v)) {
+    // this isn't a valid code point
+    return HB_InvalidCodePoint;
+  }
+
+  return v;
+}
+
+uint32_t
+utf16_to_code_point_prev(const uint16_t *chars, size_t len, ssize_t *iter) {
+  const uint16_t v = chars[(*iter)--];
+  if (HB_IsLowSurrogate(v)) {
+    // surrogate pair
+    if (*iter < 0) {
+      // the surrogate is incomplete.
+      return HB_InvalidCodePoint;
+    }
+    const uint16_t v2 = chars[(*iter)--];
+    if (!HB_IsHighSurrogate(v2)) {
+      // invalidate surrogate pair.
+      return HB_InvalidCodePoint;
+    }
+
+    return HB_SurrogateToUcs4(v2, v);
+  }
+
+  if (HB_IsHighSurrogate(v)) {
+    // this isn't a valid code point
+    return HB_InvalidCodePoint;
+  }
+
+  return v;
+}
+
+static int
+script_property_cmp(const void *vkey, const void *vcandidate) {
+  const uint32_t key = (uint32_t) (intptr_t) vkey;
+  const struct script_property *candidate = vcandidate;
+
+  if (key < candidate->range_start) {
+    return -1;
+  } else if (key > candidate->range_end) {
+    return 1;
+  } else {
+    return 0;
+  }
+}
+
+HB_Script
+code_point_to_script(uint32_t cp) {
+  const void *vprop = bsearch((void *) (intptr_t) cp, script_properties,
+                              script_properties_count,
+                              sizeof(struct script_property),
+                              script_property_cmp);
+  if (!vprop)
+    return HB_Script_Common;
+
+  return ((const struct script_property *) vprop)->script;
+}
+
+char
+hb_utf16_script_run_next(unsigned *num_code_points, HB_ScriptItem *output,
+                         const uint16_t *chars, size_t len, ssize_t *iter) {
+  if (*iter == len)
+    return 0;
+
+  output->pos = *iter;
+  const uint32_t init_cp = utf16_to_code_point(chars, len, iter);
+  unsigned cps = 1;
+  if (init_cp == HB_InvalidCodePoint)
+    return 0;
+  const HB_Script init_script = code_point_to_script(init_cp);
+  HB_Script current_script = init_script;
+  output->script = init_script;
+
+  for (;;) {
+    if (*iter == len)
+      break;
+    const ssize_t prev_iter = *iter;
+    const uint32_t cp = utf16_to_code_point(chars, len, iter);
+    if (cp == HB_InvalidCodePoint)
+      return 0;
+    cps++;
+    const HB_Script script = code_point_to_script(cp);
+
+    if (script != current_script) {
+      if (current_script == init_script == HB_Script_Inherited) {
+        // If we started off as inherited, we take whatever we can find.
+        output->script = script;
+        current_script = script;
+        continue;
+      } else if (script == HB_Script_Inherited) {
+        current_script = script;
+        continue;
+      } else {
+        *iter = prev_iter;
+        cps--;
+        break;
+      }
+    }
+  }
+
+  if (output->script == HB_Script_Inherited)
+    output->script = HB_Script_Common;
+
+  output->length = *iter - output->pos;
+  if (num_code_points)
+    *num_code_points = cps;
+  return 1;
+}
+
+char
+hb_utf16_script_run_prev(unsigned *num_code_points, HB_ScriptItem *output,
+                         const uint16_t *chars, size_t len, ssize_t *iter) {
+  if (*iter == (size_t) -1)
+    return 0;
+
+  const size_t ending_index = *iter;
+  const uint32_t init_cp = utf16_to_code_point_prev(chars, len, iter);
+  unsigned cps = 1;
+  if (init_cp == HB_InvalidCodePoint)
+    return 0;
+  const HB_Script init_script = code_point_to_script(init_cp);
+  HB_Script current_script = init_script;
+  output->script = init_script;
+
+  for (;;) {
+    if (*iter < 0)
+      break;
+    const ssize_t prev_iter = *iter;
+    const uint32_t cp = utf16_to_code_point_prev(chars, len, iter);
+    if (cp == HB_InvalidCodePoint)
+      return 0;
+    cps++;
+    const HB_Script script = code_point_to_script(cp);
+
+    if (script != current_script) {
+      if (current_script == init_script == HB_Script_Inherited) {
+        // If we started off as inherited, we take whatever we can find.
+        output->script = script;
+        current_script = script;
+        continue;
+      } else if (script == HB_Script_Inherited) {
+        current_script = script;
+        continue;
+      } else {
+        *iter = prev_iter;
+        cps--;
+        break;
+      }
+    }
+  }
+
+  if (output->script == HB_Script_Inherited)
+    output->script = HB_Script_Common;
+
+  output->pos = *iter + 1;
+  output->length = ending_index - *iter;
+  if (num_code_points)
+    *num_code_points = cps;
+  return 1;
+}
+
+static int
+grapheme_break_property_cmp(const void *vkey, const void *vcandidate) {
+  const uint32_t key = (uint32_t) (intptr_t) vkey;
+  const struct grapheme_break_property *candidate = vcandidate;
+
+  if (key < candidate->range_start) {
+    return -1;
+  } else if (key > candidate->range_end) {
+    return 1;
+  } else {
+    return 0;
+  }
+}
+
+HB_GraphemeClass
+HB_GetGraphemeClass(HB_UChar32 ch) {
+  const void *vprop = bsearch((void *) (intptr_t) ch, grapheme_break_properties,
+                              grapheme_break_properties_count,
+                              sizeof(struct grapheme_break_property),
+                              grapheme_break_property_cmp);
+  if (!vprop)
+    return HB_Grapheme_Other;
+
+  return ((const struct grapheme_break_property *) vprop)->klass;
+}
+
+HB_WordClass
+HB_GetWordClass(HB_UChar32 ch) {
+  abort();
+  return 0;
+}
+
+HB_SentenceClass
+HB_GetSentenceClass(HB_UChar32 ch) {
+  abort();
+  return 0;
+}
+
+void
+HB_GetGraphemeAndLineBreakClass(HB_UChar32 ch, HB_GraphemeClass *gclass, HB_LineBreakClass *breakclass) {
+  *gclass = HB_GetGraphemeClass(ch);
+  *breakclass = HB_GetLineBreakClass(ch);
+}
+
+static int
+mirroring_property_cmp(const void *vkey, const void *vcandidate) {
+  const uint32_t key = (uint32_t) (intptr_t) vkey;
+  const struct mirroring_property *candidate = vcandidate;
+
+  if (key < candidate->a) {
+    return -1;
+  } else if (key > candidate->a) {
+    return 1;
+  } else {
+    return 0;
+  }
+}
+
+HB_UChar16
+HB_GetMirroredChar(HB_UChar16 ch) {
+  const void *mprop = bsearch((void *) (intptr_t) ch, mirroring_properties,
+                              mirroring_properties_count,
+                              sizeof(struct mirroring_property),
+                              mirroring_property_cmp);
+  if (!mprop)
+    return ch;
+
+  return ((const struct mirroring_property *) mprop)->b;
+}
+
+void *
+HB_Library_Resolve(const char *library, const char *symbol) {
+  abort();
+  return NULL;
+}
+
+void *
+HB_TextCodecForMib(int mib) {
+  abort();
+  return NULL;
+}
+
+char *
+HB_TextCodec_ConvertFromUnicode(void *codec, const HB_UChar16 *unicode, hb_uint32 length, hb_uint32 *outputLength) {
+  abort();
+  return NULL;
+}
+
+void
+HB_TextCodec_FreeResult(char *v) {
+  abort();
+}
diff -rupN orginal/scribus/harfbuzz/harfbuzz-unicode.h patched/scribus/harfbuzz/harfbuzz-unicode.h
--- orginal/scribus/harfbuzz/harfbuzz-unicode.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/harfbuzz-unicode.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,54 @@
+#ifndef SCRIPT_IDENTIFY_H_
+#define SCRIPT_IDENTIFY_H_
+
+#include <stdint.h>
+
+#include "harfbuzz-shaper.h"
+
+static const uint32_t HB_InvalidCodePoint = 0xffffffffu;
+
+// -----------------------------------------------------------------------------
+// Return the next Unicode code point from a UTF-16 vector
+//   chars: a pointer to @len words
+//   iter: (input/output) an index into @chars. This is updated.
+//   returns: HB_InvalidCodePoint on error and the code point otherwise.
+// -----------------------------------------------------------------------------
+uint32_t utf16_to_code_point(const uint16_t *chars, size_t len, ssize_t *iter);
+
+// -----------------------------------------------------------------------------
+// Like the above, except that the code points are traversed backwards. Thus,
+// on the first call, |iter| should be |len| - 1.
+// -----------------------------------------------------------------------------
+uint32_t utf16_to_code_point(const uint16_t *chars, size_t len, ssize_t *iter);
+
+// -----------------------------------------------------------------------------
+// Return the script of the given code point
+// -----------------------------------------------------------------------------
+HB_Script code_point_to_script(uint32_t cp);
+
+// -----------------------------------------------------------------------------
+// Find the next script run in a UTF-16 string.
+//
+// A script run is a subvector of codepoints, all of which are in the same
+// script. A run will never cut a surrogate pair in half at either end.
+//
+// num_code_points: (output, maybe NULL) the number of code points in the run
+// output: (output) the @pos, @length and @script fields are set on success
+// chars: the UTF-16 string
+// len: the length of @chars, in words
+// iter: (in/out) the current index into the string. This should be 0 for the
+//   first call and is updated on exit.
+//
+// returns: non-zero if a script run was found and returned.
+// -----------------------------------------------------------------------------
+char hb_utf16_script_run_next(unsigned *num_code_points, HB_ScriptItem *output,
+                              const uint16_t *chars, size_t len, ssize_t *iter);
+
+// -----------------------------------------------------------------------------
+// This is the same as above, except that the input is traversed backwards.
+// Thus, on the first call, |iter| should be |len| - 1.
+// -----------------------------------------------------------------------------
+char hb_utf16_script_run_prev(unsigned *num_code_points, HB_ScriptItem *output,
+                              const uint16_t *chars, size_t len, ssize_t *iter);
+
+#endif
diff -rupN orginal/scribus/harfbuzz/harfbuzz.c patched/scribus/harfbuzz/harfbuzz.c
--- orginal/scribus/harfbuzz/harfbuzz.c	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/harfbuzz.c	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2006  Behdad Esfahbod
+ *
+ * This is part of HarfBuzz, an OpenType Layout engine library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ */
+
+#define HB_INTERNAL static
+#include "harfbuzz-buffer.c"
+#include "harfbuzz-gdef.c"
+#include "harfbuzz-gsub.c"
+#include "harfbuzz-gpos.c"
+#include "harfbuzz-impl.c"
+#include "harfbuzz-open.c"
+#include "harfbuzz-stream.c"
diff -rupN orginal/scribus/harfbuzz/harfbuzz.h patched/scribus/harfbuzz/harfbuzz.h
--- orginal/scribus/harfbuzz/harfbuzz.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/harfbuzz.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 1998-2004  David Turner and Werner Lemberg
+ * Copyright (C) 2006  Behdad Esfahbod
+ *
+ * This is part of HarfBuzz, an OpenType Layout engine library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ */
+
+#ifndef HARFBUZZ_H
+#define HARFBUZZ_H
+
+#include "harfbuzz-external.h"
+#include "harfbuzz-global.h"
+#include "harfbuzz-buffer.h"
+#include "harfbuzz-gdef.h"
+#include "harfbuzz-gsub.h"
+#include "harfbuzz-gpos.h"
+#include "harfbuzz-open.h"
+#include "harfbuzz-shaper.h"
+
+#endif /* HARFBUZZ_OPEN_H */
diff -rupN orginal/scribus/harfbuzz/README patched/scribus/harfbuzz/README
--- orginal/scribus/harfbuzz/README	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/README	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,7 @@
+This is HarfBuzz, an OpenType Layout engine library.
+
+To report bugs or post to discussion mailing list, see:
+
+	http://freedesktop.org/wiki/Software/HarfBuzz
+
+For license information, see the file COPYING. 
diff -rupN orginal/scribus/harfbuzz/tables/category-properties.h patched/scribus/harfbuzz/tables/category-properties.h
--- orginal/scribus/harfbuzz/tables/category-properties.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/tables/category-properties.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,2869 @@
+// Generated from Unicode script tables
+
+#ifndef CATEGORY_PROPERTIES_H_
+#define CATEGORY_PROPERTIES_H_
+
+#include <stdint.h>
+#include "harfbuzz-external.h"
+
+struct category_property {
+  uint32_t range_start;
+  uint32_t range_end;
+  HB_CharCategory category;
+};
+
+static const struct category_property category_properties[] = {
+  {0x0, 0x1f, HB_Other_Control},
+  {0x20, 0x20, HB_Separator_Space},
+  {0x21, 0x23, HB_Punctuation_Other},
+  {0x24, 0x24, HB_Symbol_Currency},
+  {0x25, 0x27, HB_Punctuation_Other},
+  {0x28, 0x28, HB_Punctuation_Open},
+  {0x29, 0x29, HB_Punctuation_Close},
+  {0x2a, 0x2a, HB_Punctuation_Other},
+  {0x2b, 0x2b, HB_Symbol_Math},
+  {0x2c, 0x2c, HB_Punctuation_Other},
+  {0x2d, 0x2d, HB_Punctuation_Dash},
+  {0x2e, 0x2f, HB_Punctuation_Other},
+  {0x30, 0x39, HB_Number_DecimalDigit},
+  {0x3a, 0x3b, HB_Punctuation_Other},
+  {0x3c, 0x3e, HB_Symbol_Math},
+  {0x3f, 0x40, HB_Punctuation_Other},
+  {0x41, 0x5a, HB_Letter_Uppercase},
+  {0x5b, 0x5b, HB_Punctuation_Open},
+  {0x5c, 0x5c, HB_Punctuation_Other},
+  {0x5d, 0x5d, HB_Punctuation_Close},
+  {0x5e, 0x5e, HB_Symbol_Modifier},
+  {0x5f, 0x5f, HB_Punctuation_Connector},
+  {0x60, 0x60, HB_Symbol_Modifier},
+  {0x61, 0x7a, HB_Letter_Lowercase},
+  {0x7b, 0x7b, HB_Punctuation_Open},
+  {0x7c, 0x7c, HB_Symbol_Math},
+  {0x7d, 0x7d, HB_Punctuation_Close},
+  {0x7e, 0x7e, HB_Symbol_Math},
+  {0x7f, 0x9f, HB_Other_Control},
+  {0xa0, 0xa0, HB_Separator_Space},
+  {0xa1, 0xa1, HB_Punctuation_Other},
+  {0xa2, 0xa5, HB_Symbol_Currency},
+  {0xa6, 0xa7, HB_Symbol_Other},
+  {0xa8, 0xa8, HB_Symbol_Modifier},
+  {0xa9, 0xa9, HB_Symbol_Other},
+  {0xaa, 0xaa, HB_Letter_Lowercase},
+  {0xab, 0xab, HB_Punctuation_InitialQuote},
+  {0xac, 0xac, HB_Symbol_Math},
+  {0xad, 0xad, HB_Other_Format},
+  {0xae, 0xae, HB_Symbol_Other},
+  {0xaf, 0xaf, HB_Symbol_Modifier},
+  {0xb0, 0xb0, HB_Symbol_Other},
+  {0xb1, 0xb1, HB_Symbol_Math},
+  {0xb2, 0xb3, HB_Number_Other},
+  {0xb4, 0xb4, HB_Symbol_Modifier},
+  {0xb5, 0xb5, HB_Letter_Lowercase},
+  {0xb6, 0xb6, HB_Symbol_Other},
+  {0xb7, 0xb7, HB_Punctuation_Other},
+  {0xb8, 0xb8, HB_Symbol_Modifier},
+  {0xb9, 0xb9, HB_Number_Other},
+  {0xba, 0xba, HB_Letter_Lowercase},
+  {0xbb, 0xbb, HB_Punctuation_FinalQuote},
+  {0xbc, 0xbe, HB_Number_Other},
+  {0xbf, 0xbf, HB_Punctuation_Other},
+  {0xc0, 0xd6, HB_Letter_Uppercase},
+  {0xd7, 0xd7, HB_Symbol_Math},
+  {0xd8, 0xde, HB_Letter_Uppercase},
+  {0xdf, 0xf6, HB_Letter_Lowercase},
+  {0xf7, 0xf7, HB_Symbol_Math},
+  {0xf8, 0xff, HB_Letter_Lowercase},
+  {0x100, 0x100, HB_Letter_Uppercase},
+  {0x101, 0x101, HB_Letter_Lowercase},
+  {0x102, 0x102, HB_Letter_Uppercase},
+  {0x103, 0x103, HB_Letter_Lowercase},
+  {0x104, 0x104, HB_Letter_Uppercase},
+  {0x105, 0x105, HB_Letter_Lowercase},
+  {0x106, 0x106, HB_Letter_Uppercase},
+  {0x107, 0x107, HB_Letter_Lowercase},
+  {0x108, 0x108, HB_Letter_Uppercase},
+  {0x109, 0x109, HB_Letter_Lowercase},
+  {0x10a, 0x10a, HB_Letter_Uppercase},
+  {0x10b, 0x10b, HB_Letter_Lowercase},
+  {0x10c, 0x10c, HB_Letter_Uppercase},
+  {0x10d, 0x10d, HB_Letter_Lowercase},
+  {0x10e, 0x10e, HB_Letter_Uppercase},
+  {0x10f, 0x10f, HB_Letter_Lowercase},
+  {0x110, 0x110, HB_Letter_Uppercase},
+  {0x111, 0x111, HB_Letter_Lowercase},
+  {0x112, 0x112, HB_Letter_Uppercase},
+  {0x113, 0x113, HB_Letter_Lowercase},
+  {0x114, 0x114, HB_Letter_Uppercase},
+  {0x115, 0x115, HB_Letter_Lowercase},
+  {0x116, 0x116, HB_Letter_Uppercase},
+  {0x117, 0x117, HB_Letter_Lowercase},
+  {0x118, 0x118, HB_Letter_Uppercase},
+  {0x119, 0x119, HB_Letter_Lowercase},
+  {0x11a, 0x11a, HB_Letter_Uppercase},
+  {0x11b, 0x11b, HB_Letter_Lowercase},
+  {0x11c, 0x11c, HB_Letter_Uppercase},
+  {0x11d, 0x11d, HB_Letter_Lowercase},
+  {0x11e, 0x11e, HB_Letter_Uppercase},
+  {0x11f, 0x11f, HB_Letter_Lowercase},
+  {0x120, 0x120, HB_Letter_Uppercase},
+  {0x121, 0x121, HB_Letter_Lowercase},
+  {0x122, 0x122, HB_Letter_Uppercase},
+  {0x123, 0x123, HB_Letter_Lowercase},
+  {0x124, 0x124, HB_Letter_Uppercase},
+  {0x125, 0x125, HB_Letter_Lowercase},
+  {0x126, 0x126, HB_Letter_Uppercase},
+  {0x127, 0x127, HB_Letter_Lowercase},
+  {0x128, 0x128, HB_Letter_Uppercase},
+  {0x129, 0x129, HB_Letter_Lowercase},
+  {0x12a, 0x12a, HB_Letter_Uppercase},
+  {0x12b, 0x12b, HB_Letter_Lowercase},
+  {0x12c, 0x12c, HB_Letter_Uppercase},
+  {0x12d, 0x12d, HB_Letter_Lowercase},
+  {0x12e, 0x12e, HB_Letter_Uppercase},
+  {0x12f, 0x12f, HB_Letter_Lowercase},
+  {0x130, 0x130, HB_Letter_Uppercase},
+  {0x131, 0x131, HB_Letter_Lowercase},
+  {0x132, 0x132, HB_Letter_Uppercase},
+  {0x133, 0x133, HB_Letter_Lowercase},
+  {0x134, 0x134, HB_Letter_Uppercase},
+  {0x135, 0x135, HB_Letter_Lowercase},
+  {0x136, 0x136, HB_Letter_Uppercase},
+  {0x137, 0x138, HB_Letter_Lowercase},
+  {0x139, 0x139, HB_Letter_Uppercase},
+  {0x13a, 0x13a, HB_Letter_Lowercase},
+  {0x13b, 0x13b, HB_Letter_Uppercase},
+  {0x13c, 0x13c, HB_Letter_Lowercase},
+  {0x13d, 0x13d, HB_Letter_Uppercase},
+  {0x13e, 0x13e, HB_Letter_Lowercase},
+  {0x13f, 0x13f, HB_Letter_Uppercase},
+  {0x140, 0x140, HB_Letter_Lowercase},
+  {0x141, 0x141, HB_Letter_Uppercase},
+  {0x142, 0x142, HB_Letter_Lowercase},
+  {0x143, 0x143, HB_Letter_Uppercase},
+  {0x144, 0x144, HB_Letter_Lowercase},
+  {0x145, 0x145, HB_Letter_Uppercase},
+  {0x146, 0x146, HB_Letter_Lowercase},
+  {0x147, 0x147, HB_Letter_Uppercase},
+  {0x148, 0x149, HB_Letter_Lowercase},
+  {0x14a, 0x14a, HB_Letter_Uppercase},
+  {0x14b, 0x14b, HB_Letter_Lowercase},
+  {0x14c, 0x14c, HB_Letter_Uppercase},
+  {0x14d, 0x14d, HB_Letter_Lowercase},
+  {0x14e, 0x14e, HB_Letter_Uppercase},
+  {0x14f, 0x14f, HB_Letter_Lowercase},
+  {0x150, 0x150, HB_Letter_Uppercase},
+  {0x151, 0x151, HB_Letter_Lowercase},
+  {0x152, 0x152, HB_Letter_Uppercase},
+  {0x153, 0x153, HB_Letter_Lowercase},
+  {0x154, 0x154, HB_Letter_Uppercase},
+  {0x155, 0x155, HB_Letter_Lowercase},
+  {0x156, 0x156, HB_Letter_Uppercase},
+  {0x157, 0x157, HB_Letter_Lowercase},
+  {0x158, 0x158, HB_Letter_Uppercase},
+  {0x159, 0x159, HB_Letter_Lowercase},
+  {0x15a, 0x15a, HB_Letter_Uppercase},
+  {0x15b, 0x15b, HB_Letter_Lowercase},
+  {0x15c, 0x15c, HB_Letter_Uppercase},
+  {0x15d, 0x15d, HB_Letter_Lowercase},
+  {0x15e, 0x15e, HB_Letter_Uppercase},
+  {0x15f, 0x15f, HB_Letter_Lowercase},
+  {0x160, 0x160, HB_Letter_Uppercase},
+  {0x161, 0x161, HB_Letter_Lowercase},
+  {0x162, 0x162, HB_Letter_Uppercase},
+  {0x163, 0x163, HB_Letter_Lowercase},
+  {0x164, 0x164, HB_Letter_Uppercase},
+  {0x165, 0x165, HB_Letter_Lowercase},
+  {0x166, 0x166, HB_Letter_Uppercase},
+  {0x167, 0x167, HB_Letter_Lowercase},
+  {0x168, 0x168, HB_Letter_Uppercase},
+  {0x169, 0x169, HB_Letter_Lowercase},
+  {0x16a, 0x16a, HB_Letter_Uppercase},
+  {0x16b, 0x16b, HB_Letter_Lowercase},
+  {0x16c, 0x16c, HB_Letter_Uppercase},
+  {0x16d, 0x16d, HB_Letter_Lowercase},
+  {0x16e, 0x16e, HB_Letter_Uppercase},
+  {0x16f, 0x16f, HB_Letter_Lowercase},
+  {0x170, 0x170, HB_Letter_Uppercase},
+  {0x171, 0x171, HB_Letter_Lowercase},
+  {0x172, 0x172, HB_Letter_Uppercase},
+  {0x173, 0x173, HB_Letter_Lowercase},
+  {0x174, 0x174, HB_Letter_Uppercase},
+  {0x175, 0x175, HB_Letter_Lowercase},
+  {0x176, 0x176, HB_Letter_Uppercase},
+  {0x177, 0x177, HB_Letter_Lowercase},
+  {0x178, 0x179, HB_Letter_Uppercase},
+  {0x17a, 0x17a, HB_Letter_Lowercase},
+  {0x17b, 0x17b, HB_Letter_Uppercase},
+  {0x17c, 0x17c, HB_Letter_Lowercase},
+  {0x17d, 0x17d, HB_Letter_Uppercase},
+  {0x17e, 0x180, HB_Letter_Lowercase},
+  {0x181, 0x182, HB_Letter_Uppercase},
+  {0x183, 0x183, HB_Letter_Lowercase},
+  {0x184, 0x184, HB_Letter_Uppercase},
+  {0x185, 0x185, HB_Letter_Lowercase},
+  {0x186, 0x187, HB_Letter_Uppercase},
+  {0x188, 0x188, HB_Letter_Lowercase},
+  {0x189, 0x18b, HB_Letter_Uppercase},
+  {0x18c, 0x18d, HB_Letter_Lowercase},
+  {0x18e, 0x191, HB_Letter_Uppercase},
+  {0x192, 0x192, HB_Letter_Lowercase},
+  {0x193, 0x194, HB_Letter_Uppercase},
+  {0x195, 0x195, HB_Letter_Lowercase},
+  {0x196, 0x198, HB_Letter_Uppercase},
+  {0x199, 0x19b, HB_Letter_Lowercase},
+  {0x19c, 0x19d, HB_Letter_Uppercase},
+  {0x19e, 0x19e, HB_Letter_Lowercase},
+  {0x19f, 0x1a0, HB_Letter_Uppercase},
+  {0x1a1, 0x1a1, HB_Letter_Lowercase},
+  {0x1a2, 0x1a2, HB_Letter_Uppercase},
+  {0x1a3, 0x1a3, HB_Letter_Lowercase},
+  {0x1a4, 0x1a4, HB_Letter_Uppercase},
+  {0x1a5, 0x1a5, HB_Letter_Lowercase},
+  {0x1a6, 0x1a7, HB_Letter_Uppercase},
+  {0x1a8, 0x1a8, HB_Letter_Lowercase},
+  {0x1a9, 0x1a9, HB_Letter_Uppercase},
+  {0x1aa, 0x1ab, HB_Letter_Lowercase},
+  {0x1ac, 0x1ac, HB_Letter_Uppercase},
+  {0x1ad, 0x1ad, HB_Letter_Lowercase},
+  {0x1ae, 0x1af, HB_Letter_Uppercase},
+  {0x1b0, 0x1b0, HB_Letter_Lowercase},
+  {0x1b1, 0x1b3, HB_Letter_Uppercase},
+  {0x1b4, 0x1b4, HB_Letter_Lowercase},
+  {0x1b5, 0x1b5, HB_Letter_Uppercase},
+  {0x1b6, 0x1b6, HB_Letter_Lowercase},
+  {0x1b7, 0x1b8, HB_Letter_Uppercase},
+  {0x1b9, 0x1ba, HB_Letter_Lowercase},
+  {0x1bb, 0x1bb, HB_Letter_Other},
+  {0x1bc, 0x1bc, HB_Letter_Uppercase},
+  {0x1bd, 0x1bf, HB_Letter_Lowercase},
+  {0x1c0, 0x1c3, HB_Letter_Other},
+  {0x1c4, 0x1c4, HB_Letter_Uppercase},
+  {0x1c5, 0x1c5, HB_Letter_Titlecase},
+  {0x1c6, 0x1c6, HB_Letter_Lowercase},
+  {0x1c7, 0x1c7, HB_Letter_Uppercase},
+  {0x1c8, 0x1c8, HB_Letter_Titlecase},
+  {0x1c9, 0x1c9, HB_Letter_Lowercase},
+  {0x1ca, 0x1ca, HB_Letter_Uppercase},
+  {0x1cb, 0x1cb, HB_Letter_Titlecase},
+  {0x1cc, 0x1cc, HB_Letter_Lowercase},
+  {0x1cd, 0x1cd, HB_Letter_Uppercase},
+  {0x1ce, 0x1ce, HB_Letter_Lowercase},
+  {0x1cf, 0x1cf, HB_Letter_Uppercase},
+  {0x1d0, 0x1d0, HB_Letter_Lowercase},
+  {0x1d1, 0x1d1, HB_Letter_Uppercase},
+  {0x1d2, 0x1d2, HB_Letter_Lowercase},
+  {0x1d3, 0x1d3, HB_Letter_Uppercase},
+  {0x1d4, 0x1d4, HB_Letter_Lowercase},
+  {0x1d5, 0x1d5, HB_Letter_Uppercase},
+  {0x1d6, 0x1d6, HB_Letter_Lowercase},
+  {0x1d7, 0x1d7, HB_Letter_Uppercase},
+  {0x1d8, 0x1d8, HB_Letter_Lowercase},
+  {0x1d9, 0x1d9, HB_Letter_Uppercase},
+  {0x1da, 0x1da, HB_Letter_Lowercase},
+  {0x1db, 0x1db, HB_Letter_Uppercase},
+  {0x1dc, 0x1dd, HB_Letter_Lowercase},
+  {0x1de, 0x1de, HB_Letter_Uppercase},
+  {0x1df, 0x1df, HB_Letter_Lowercase},
+  {0x1e0, 0x1e0, HB_Letter_Uppercase},
+  {0x1e1, 0x1e1, HB_Letter_Lowercase},
+  {0x1e2, 0x1e2, HB_Letter_Uppercase},
+  {0x1e3, 0x1e3, HB_Letter_Lowercase},
+  {0x1e4, 0x1e4, HB_Letter_Uppercase},
+  {0x1e5, 0x1e5, HB_Letter_Lowercase},
+  {0x1e6, 0x1e6, HB_Letter_Uppercase},
+  {0x1e7, 0x1e7, HB_Letter_Lowercase},
+  {0x1e8, 0x1e8, HB_Letter_Uppercase},
+  {0x1e9, 0x1e9, HB_Letter_Lowercase},
+  {0x1ea, 0x1ea, HB_Letter_Uppercase},
+  {0x1eb, 0x1eb, HB_Letter_Lowercase},
+  {0x1ec, 0x1ec, HB_Letter_Uppercase},
+  {0x1ed, 0x1ed, HB_Letter_Lowercase},
+  {0x1ee, 0x1ee, HB_Letter_Uppercase},
+  {0x1ef, 0x1f0, HB_Letter_Lowercase},
+  {0x1f1, 0x1f1, HB_Letter_Uppercase},
+  {0x1f2, 0x1f2, HB_Letter_Titlecase},
+  {0x1f3, 0x1f3, HB_Letter_Lowercase},
+  {0x1f4, 0x1f4, HB_Letter_Uppercase},
+  {0x1f5, 0x1f5, HB_Letter_Lowercase},
+  {0x1f6, 0x1f8, HB_Letter_Uppercase},
+  {0x1f9, 0x1f9, HB_Letter_Lowercase},
+  {0x1fa, 0x1fa, HB_Letter_Uppercase},
+  {0x1fb, 0x1fb, HB_Letter_Lowercase},
+  {0x1fc, 0x1fc, HB_Letter_Uppercase},
+  {0x1fd, 0x1fd, HB_Letter_Lowercase},
+  {0x1fe, 0x1fe, HB_Letter_Uppercase},
+  {0x1ff, 0x1ff, HB_Letter_Lowercase},
+  {0x200, 0x200, HB_Letter_Uppercase},
+  {0x201, 0x201, HB_Letter_Lowercase},
+  {0x202, 0x202, HB_Letter_Uppercase},
+  {0x203, 0x203, HB_Letter_Lowercase},
+  {0x204, 0x204, HB_Letter_Uppercase},
+  {0x205, 0x205, HB_Letter_Lowercase},
+  {0x206, 0x206, HB_Letter_Uppercase},
+  {0x207, 0x207, HB_Letter_Lowercase},
+  {0x208, 0x208, HB_Letter_Uppercase},
+  {0x209, 0x209, HB_Letter_Lowercase},
+  {0x20a, 0x20a, HB_Letter_Uppercase},
+  {0x20b, 0x20b, HB_Letter_Lowercase},
+  {0x20c, 0x20c, HB_Letter_Uppercase},
+  {0x20d, 0x20d, HB_Letter_Lowercase},
+  {0x20e, 0x20e, HB_Letter_Uppercase},
+  {0x20f, 0x20f, HB_Letter_Lowercase},
+  {0x210, 0x210, HB_Letter_Uppercase},
+  {0x211, 0x211, HB_Letter_Lowercase},
+  {0x212, 0x212, HB_Letter_Uppercase},
+  {0x213, 0x213, HB_Letter_Lowercase},
+  {0x214, 0x214, HB_Letter_Uppercase},
+  {0x215, 0x215, HB_Letter_Lowercase},
+  {0x216, 0x216, HB_Letter_Uppercase},
+  {0x217, 0x217, HB_Letter_Lowercase},
+  {0x218, 0x218, HB_Letter_Uppercase},
+  {0x219, 0x219, HB_Letter_Lowercase},
+  {0x21a, 0x21a, HB_Letter_Uppercase},
+  {0x21b, 0x21b, HB_Letter_Lowercase},
+  {0x21c, 0x21c, HB_Letter_Uppercase},
+  {0x21d, 0x21d, HB_Letter_Lowercase},
+  {0x21e, 0x21e, HB_Letter_Uppercase},
+  {0x21f, 0x21f, HB_Letter_Lowercase},
+  {0x220, 0x220, HB_Letter_Uppercase},
+  {0x221, 0x221, HB_Letter_Lowercase},
+  {0x222, 0x222, HB_Letter_Uppercase},
+  {0x223, 0x223, HB_Letter_Lowercase},
+  {0x224, 0x224, HB_Letter_Uppercase},
+  {0x225, 0x225, HB_Letter_Lowercase},
+  {0x226, 0x226, HB_Letter_Uppercase},
+  {0x227, 0x227, HB_Letter_Lowercase},
+  {0x228, 0x228, HB_Letter_Uppercase},
+  {0x229, 0x229, HB_Letter_Lowercase},
+  {0x22a, 0x22a, HB_Letter_Uppercase},
+  {0x22b, 0x22b, HB_Letter_Lowercase},
+  {0x22c, 0x22c, HB_Letter_Uppercase},
+  {0x22d, 0x22d, HB_Letter_Lowercase},
+  {0x22e, 0x22e, HB_Letter_Uppercase},
+  {0x22f, 0x22f, HB_Letter_Lowercase},
+  {0x230, 0x230, HB_Letter_Uppercase},
+  {0x231, 0x231, HB_Letter_Lowercase},
+  {0x232, 0x232, HB_Letter_Uppercase},
+  {0x233, 0x239, HB_Letter_Lowercase},
+  {0x23a, 0x23b, HB_Letter_Uppercase},
+  {0x23c, 0x23c, HB_Letter_Lowercase},
+  {0x23d, 0x23e, HB_Letter_Uppercase},
+  {0x23f, 0x240, HB_Letter_Lowercase},
+  {0x241, 0x241, HB_Letter_Uppercase},
+  {0x242, 0x242, HB_Letter_Lowercase},
+  {0x243, 0x246, HB_Letter_Uppercase},
+  {0x247, 0x247, HB_Letter_Lowercase},
+  {0x248, 0x248, HB_Letter_Uppercase},
+  {0x249, 0x249, HB_Letter_Lowercase},
+  {0x24a, 0x24a, HB_Letter_Uppercase},
+  {0x24b, 0x24b, HB_Letter_Lowercase},
+  {0x24c, 0x24c, HB_Letter_Uppercase},
+  {0x24d, 0x24d, HB_Letter_Lowercase},
+  {0x24e, 0x24e, HB_Letter_Uppercase},
+  {0x24f, 0x293, HB_Letter_Lowercase},
+  {0x294, 0x294, HB_Letter_Other},
+  {0x295, 0x2af, HB_Letter_Lowercase},
+  {0x2b0, 0x2c1, HB_Letter_Modifier},
+  {0x2c2, 0x2c5, HB_Symbol_Modifier},
+  {0x2c6, 0x2d1, HB_Letter_Modifier},
+  {0x2d2, 0x2df, HB_Symbol_Modifier},
+  {0x2e0, 0x2e4, HB_Letter_Modifier},
+  {0x2e5, 0x2eb, HB_Symbol_Modifier},
+  {0x2ec, 0x2ec, HB_Letter_Modifier},
+  {0x2ed, 0x2ed, HB_Symbol_Modifier},
+  {0x2ee, 0x2ee, HB_Letter_Modifier},
+  {0x2ef, 0x2ff, HB_Symbol_Modifier},
+  {0x300, 0x36f, HB_Mark_NonSpacing},
+  {0x370, 0x370, HB_Letter_Uppercase},
+  {0x371, 0x371, HB_Letter_Lowercase},
+  {0x372, 0x372, HB_Letter_Uppercase},
+  {0x373, 0x373, HB_Letter_Lowercase},
+  {0x374, 0x374, HB_Letter_Modifier},
+  {0x375, 0x375, HB_Symbol_Modifier},
+  {0x376, 0x376, HB_Letter_Uppercase},
+  {0x377, 0x377, HB_Letter_Lowercase},
+  {0x378, 0x379, HB_Other_NotAssigned},
+  {0x37a, 0x37a, HB_Letter_Modifier},
+  {0x37b, 0x37d, HB_Letter_Lowercase},
+  {0x37e, 0x37e, HB_Punctuation_Other},
+  {0x37f, 0x383, HB_Other_NotAssigned},
+  {0x384, 0x385, HB_Symbol_Modifier},
+  {0x386, 0x386, HB_Letter_Uppercase},
+  {0x387, 0x387, HB_Punctuation_Other},
+  {0x388, 0x38a, HB_Letter_Uppercase},
+  {0x38b, 0x38b, HB_Other_NotAssigned},
+  {0x38c, 0x38c, HB_Letter_Uppercase},
+  {0x38d, 0x38d, HB_Other_NotAssigned},
+  {0x38e, 0x38f, HB_Letter_Uppercase},
+  {0x390, 0x390, HB_Letter_Lowercase},
+  {0x391, 0x3a1, HB_Letter_Uppercase},
+  {0x3a2, 0x3a2, HB_Other_NotAssigned},
+  {0x3a3, 0x3ab, HB_Letter_Uppercase},
+  {0x3ac, 0x3ce, HB_Letter_Lowercase},
+  {0x3cf, 0x3cf, HB_Letter_Uppercase},
+  {0x3d0, 0x3d1, HB_Letter_Lowercase},
+  {0x3d2, 0x3d4, HB_Letter_Uppercase},
+  {0x3d5, 0x3d7, HB_Letter_Lowercase},
+  {0x3d8, 0x3d8, HB_Letter_Uppercase},
+  {0x3d9, 0x3d9, HB_Letter_Lowercase},
+  {0x3da, 0x3da, HB_Letter_Uppercase},
+  {0x3db, 0x3db, HB_Letter_Lowercase},
+  {0x3dc, 0x3dc, HB_Letter_Uppercase},
+  {0x3dd, 0x3dd, HB_Letter_Lowercase},
+  {0x3de, 0x3de, HB_Letter_Uppercase},
+  {0x3df, 0x3df, HB_Letter_Lowercase},
+  {0x3e0, 0x3e0, HB_Letter_Uppercase},
+  {0x3e1, 0x3e1, HB_Letter_Lowercase},
+  {0x3e2, 0x3e2, HB_Letter_Uppercase},
+  {0x3e3, 0x3e3, HB_Letter_Lowercase},
+  {0x3e4, 0x3e4, HB_Letter_Uppercase},
+  {0x3e5, 0x3e5, HB_Letter_Lowercase},
+  {0x3e6, 0x3e6, HB_Letter_Uppercase},
+  {0x3e7, 0x3e7, HB_Letter_Lowercase},
+  {0x3e8, 0x3e8, HB_Letter_Uppercase},
+  {0x3e9, 0x3e9, HB_Letter_Lowercase},
+  {0x3ea, 0x3ea, HB_Letter_Uppercase},
+  {0x3eb, 0x3eb, HB_Letter_Lowercase},
+  {0x3ec, 0x3ec, HB_Letter_Uppercase},
+  {0x3ed, 0x3ed, HB_Letter_Lowercase},
+  {0x3ee, 0x3ee, HB_Letter_Uppercase},
+  {0x3ef, 0x3f3, HB_Letter_Lowercase},
+  {0x3f4, 0x3f4, HB_Letter_Uppercase},
+  {0x3f5, 0x3f5, HB_Letter_Lowercase},
+  {0x3f6, 0x3f6, HB_Symbol_Math},
+  {0x3f7, 0x3f7, HB_Letter_Uppercase},
+  {0x3f8, 0x3f8, HB_Letter_Lowercase},
+  {0x3f9, 0x3fa, HB_Letter_Uppercase},
+  {0x3fb, 0x3fc, HB_Letter_Lowercase},
+  {0x3fd, 0x42f, HB_Letter_Uppercase},
+  {0x430, 0x45f, HB_Letter_Lowercase},
+  {0x460, 0x460, HB_Letter_Uppercase},
+  {0x461, 0x461, HB_Letter_Lowercase},
+  {0x462, 0x462, HB_Letter_Uppercase},
+  {0x463, 0x463, HB_Letter_Lowercase},
+  {0x464, 0x464, HB_Letter_Uppercase},
+  {0x465, 0x465, HB_Letter_Lowercase},
+  {0x466, 0x466, HB_Letter_Uppercase},
+  {0x467, 0x467, HB_Letter_Lowercase},
+  {0x468, 0x468, HB_Letter_Uppercase},
+  {0x469, 0x469, HB_Letter_Lowercase},
+  {0x46a, 0x46a, HB_Letter_Uppercase},
+  {0x46b, 0x46b, HB_Letter_Lowercase},
+  {0x46c, 0x46c, HB_Letter_Uppercase},
+  {0x46d, 0x46d, HB_Letter_Lowercase},
+  {0x46e, 0x46e, HB_Letter_Uppercase},
+  {0x46f, 0x46f, HB_Letter_Lowercase},
+  {0x470, 0x470, HB_Letter_Uppercase},
+  {0x471, 0x471, HB_Letter_Lowercase},
+  {0x472, 0x472, HB_Letter_Uppercase},
+  {0x473, 0x473, HB_Letter_Lowercase},
+  {0x474, 0x474, HB_Letter_Uppercase},
+  {0x475, 0x475, HB_Letter_Lowercase},
+  {0x476, 0x476, HB_Letter_Uppercase},
+  {0x477, 0x477, HB_Letter_Lowercase},
+  {0x478, 0x478, HB_Letter_Uppercase},
+  {0x479, 0x479, HB_Letter_Lowercase},
+  {0x47a, 0x47a, HB_Letter_Uppercase},
+  {0x47b, 0x47b, HB_Letter_Lowercase},
+  {0x47c, 0x47c, HB_Letter_Uppercase},
+  {0x47d, 0x47d, HB_Letter_Lowercase},
+  {0x47e, 0x47e, HB_Letter_Uppercase},
+  {0x47f, 0x47f, HB_Letter_Lowercase},
+  {0x480, 0x480, HB_Letter_Uppercase},
+  {0x481, 0x481, HB_Letter_Lowercase},
+  {0x482, 0x482, HB_Symbol_Other},
+  {0x483, 0x487, HB_Mark_NonSpacing},
+  {0x488, 0x489, HB_Mark_Enclosing},
+  {0x48a, 0x48a, HB_Letter_Uppercase},
+  {0x48b, 0x48b, HB_Letter_Lowercase},
+  {0x48c, 0x48c, HB_Letter_Uppercase},
+  {0x48d, 0x48d, HB_Letter_Lowercase},
+  {0x48e, 0x48e, HB_Letter_Uppercase},
+  {0x48f, 0x48f, HB_Letter_Lowercase},
+  {0x490, 0x490, HB_Letter_Uppercase},
+  {0x491, 0x491, HB_Letter_Lowercase},
+  {0x492, 0x492, HB_Letter_Uppercase},
+  {0x493, 0x493, HB_Letter_Lowercase},
+  {0x494, 0x494, HB_Letter_Uppercase},
+  {0x495, 0x495, HB_Letter_Lowercase},
+  {0x496, 0x496, HB_Letter_Uppercase},
+  {0x497, 0x497, HB_Letter_Lowercase},
+  {0x498, 0x498, HB_Letter_Uppercase},
+  {0x499, 0x499, HB_Letter_Lowercase},
+  {0x49a, 0x49a, HB_Letter_Uppercase},
+  {0x49b, 0x49b, HB_Letter_Lowercase},
+  {0x49c, 0x49c, HB_Letter_Uppercase},
+  {0x49d, 0x49d, HB_Letter_Lowercase},
+  {0x49e, 0x49e, HB_Letter_Uppercase},
+  {0x49f, 0x49f, HB_Letter_Lowercase},
+  {0x4a0, 0x4a0, HB_Letter_Uppercase},
+  {0x4a1, 0x4a1, HB_Letter_Lowercase},
+  {0x4a2, 0x4a2, HB_Letter_Uppercase},
+  {0x4a3, 0x4a3, HB_Letter_Lowercase},
+  {0x4a4, 0x4a4, HB_Letter_Uppercase},
+  {0x4a5, 0x4a5, HB_Letter_Lowercase},
+  {0x4a6, 0x4a6, HB_Letter_Uppercase},
+  {0x4a7, 0x4a7, HB_Letter_Lowercase},
+  {0x4a8, 0x4a8, HB_Letter_Uppercase},
+  {0x4a9, 0x4a9, HB_Letter_Lowercase},
+  {0x4aa, 0x4aa, HB_Letter_Uppercase},
+  {0x4ab, 0x4ab, HB_Letter_Lowercase},
+  {0x4ac, 0x4ac, HB_Letter_Uppercase},
+  {0x4ad, 0x4ad, HB_Letter_Lowercase},
+  {0x4ae, 0x4ae, HB_Letter_Uppercase},
+  {0x4af, 0x4af, HB_Letter_Lowercase},
+  {0x4b0, 0x4b0, HB_Letter_Uppercase},
+  {0x4b1, 0x4b1, HB_Letter_Lowercase},
+  {0x4b2, 0x4b2, HB_Letter_Uppercase},
+  {0x4b3, 0x4b3, HB_Letter_Lowercase},
+  {0x4b4, 0x4b4, HB_Letter_Uppercase},
+  {0x4b5, 0x4b5, HB_Letter_Lowercase},
+  {0x4b6, 0x4b6, HB_Letter_Uppercase},
+  {0x4b7, 0x4b7, HB_Letter_Lowercase},
+  {0x4b8, 0x4b8, HB_Letter_Uppercase},
+  {0x4b9, 0x4b9, HB_Letter_Lowercase},
+  {0x4ba, 0x4ba, HB_Letter_Uppercase},
+  {0x4bb, 0x4bb, HB_Letter_Lowercase},
+  {0x4bc, 0x4bc, HB_Letter_Uppercase},
+  {0x4bd, 0x4bd, HB_Letter_Lowercase},
+  {0x4be, 0x4be, HB_Letter_Uppercase},
+  {0x4bf, 0x4bf, HB_Letter_Lowercase},
+  {0x4c0, 0x4c1, HB_Letter_Uppercase},
+  {0x4c2, 0x4c2, HB_Letter_Lowercase},
+  {0x4c3, 0x4c3, HB_Letter_Uppercase},
+  {0x4c4, 0x4c4, HB_Letter_Lowercase},
+  {0x4c5, 0x4c5, HB_Letter_Uppercase},
+  {0x4c6, 0x4c6, HB_Letter_Lowercase},
+  {0x4c7, 0x4c7, HB_Letter_Uppercase},
+  {0x4c8, 0x4c8, HB_Letter_Lowercase},
+  {0x4c9, 0x4c9, HB_Letter_Uppercase},
+  {0x4ca, 0x4ca, HB_Letter_Lowercase},
+  {0x4cb, 0x4cb, HB_Letter_Uppercase},
+  {0x4cc, 0x4cc, HB_Letter_Lowercase},
+  {0x4cd, 0x4cd, HB_Letter_Uppercase},
+  {0x4ce, 0x4cf, HB_Letter_Lowercase},
+  {0x4d0, 0x4d0, HB_Letter_Uppercase},
+  {0x4d1, 0x4d1, HB_Letter_Lowercase},
+  {0x4d2, 0x4d2, HB_Letter_Uppercase},
+  {0x4d3, 0x4d3, HB_Letter_Lowercase},
+  {0x4d4, 0x4d4, HB_Letter_Uppercase},
+  {0x4d5, 0x4d5, HB_Letter_Lowercase},
+  {0x4d6, 0x4d6, HB_Letter_Uppercase},
+  {0x4d7, 0x4d7, HB_Letter_Lowercase},
+  {0x4d8, 0x4d8, HB_Letter_Uppercase},
+  {0x4d9, 0x4d9, HB_Letter_Lowercase},
+  {0x4da, 0x4da, HB_Letter_Uppercase},
+  {0x4db, 0x4db, HB_Letter_Lowercase},
+  {0x4dc, 0x4dc, HB_Letter_Uppercase},
+  {0x4dd, 0x4dd, HB_Letter_Lowercase},
+  {0x4de, 0x4de, HB_Letter_Uppercase},
+  {0x4df, 0x4df, HB_Letter_Lowercase},
+  {0x4e0, 0x4e0, HB_Letter_Uppercase},
+  {0x4e1, 0x4e1, HB_Letter_Lowercase},
+  {0x4e2, 0x4e2, HB_Letter_Uppercase},
+  {0x4e3, 0x4e3, HB_Letter_Lowercase},
+  {0x4e4, 0x4e4, HB_Letter_Uppercase},
+  {0x4e5, 0x4e5, HB_Letter_Lowercase},
+  {0x4e6, 0x4e6, HB_Letter_Uppercase},
+  {0x4e7, 0x4e7, HB_Letter_Lowercase},
+  {0x4e8, 0x4e8, HB_Letter_Uppercase},
+  {0x4e9, 0x4e9, HB_Letter_Lowercase},
+  {0x4ea, 0x4ea, HB_Letter_Uppercase},
+  {0x4eb, 0x4eb, HB_Letter_Lowercase},
+  {0x4ec, 0x4ec, HB_Letter_Uppercase},
+  {0x4ed, 0x4ed, HB_Letter_Lowercase},
+  {0x4ee, 0x4ee, HB_Letter_Uppercase},
+  {0x4ef, 0x4ef, HB_Letter_Lowercase},
+  {0x4f0, 0x4f0, HB_Letter_Uppercase},
+  {0x4f1, 0x4f1, HB_Letter_Lowercase},
+  {0x4f2, 0x4f2, HB_Letter_Uppercase},
+  {0x4f3, 0x4f3, HB_Letter_Lowercase},
+  {0x4f4, 0x4f4, HB_Letter_Uppercase},
+  {0x4f5, 0x4f5, HB_Letter_Lowercase},
+  {0x4f6, 0x4f6, HB_Letter_Uppercase},
+  {0x4f7, 0x4f7, HB_Letter_Lowercase},
+  {0x4f8, 0x4f8, HB_Letter_Uppercase},
+  {0x4f9, 0x4f9, HB_Letter_Lowercase},
+  {0x4fa, 0x4fa, HB_Letter_Uppercase},
+  {0x4fb, 0x4fb, HB_Letter_Lowercase},
+  {0x4fc, 0x4fc, HB_Letter_Uppercase},
+  {0x4fd, 0x4fd, HB_Letter_Lowercase},
+  {0x4fe, 0x4fe, HB_Letter_Uppercase},
+  {0x4ff, 0x4ff, HB_Letter_Lowercase},
+  {0x500, 0x500, HB_Letter_Uppercase},
+  {0x501, 0x501, HB_Letter_Lowercase},
+  {0x502, 0x502, HB_Letter_Uppercase},
+  {0x503, 0x503, HB_Letter_Lowercase},
+  {0x504, 0x504, HB_Letter_Uppercase},
+  {0x505, 0x505, HB_Letter_Lowercase},
+  {0x506, 0x506, HB_Letter_Uppercase},
+  {0x507, 0x507, HB_Letter_Lowercase},
+  {0x508, 0x508, HB_Letter_Uppercase},
+  {0x509, 0x509, HB_Letter_Lowercase},
+  {0x50a, 0x50a, HB_Letter_Uppercase},
+  {0x50b, 0x50b, HB_Letter_Lowercase},
+  {0x50c, 0x50c, HB_Letter_Uppercase},
+  {0x50d, 0x50d, HB_Letter_Lowercase},
+  {0x50e, 0x50e, HB_Letter_Uppercase},
+  {0x50f, 0x50f, HB_Letter_Lowercase},
+  {0x510, 0x510, HB_Letter_Uppercase},
+  {0x511, 0x511, HB_Letter_Lowercase},
+  {0x512, 0x512, HB_Letter_Uppercase},
+  {0x513, 0x513, HB_Letter_Lowercase},
+  {0x514, 0x514, HB_Letter_Uppercase},
+  {0x515, 0x515, HB_Letter_Lowercase},
+  {0x516, 0x516, HB_Letter_Uppercase},
+  {0x517, 0x517, HB_Letter_Lowercase},
+  {0x518, 0x518, HB_Letter_Uppercase},
+  {0x519, 0x519, HB_Letter_Lowercase},
+  {0x51a, 0x51a, HB_Letter_Uppercase},
+  {0x51b, 0x51b, HB_Letter_Lowercase},
+  {0x51c, 0x51c, HB_Letter_Uppercase},
+  {0x51d, 0x51d, HB_Letter_Lowercase},
+  {0x51e, 0x51e, HB_Letter_Uppercase},
+  {0x51f, 0x51f, HB_Letter_Lowercase},
+  {0x520, 0x520, HB_Letter_Uppercase},
+  {0x521, 0x521, HB_Letter_Lowercase},
+  {0x522, 0x522, HB_Letter_Uppercase},
+  {0x523, 0x523, HB_Letter_Lowercase},
+  {0x524, 0x530, HB_Other_NotAssigned},
+  {0x531, 0x556, HB_Letter_Uppercase},
+  {0x557, 0x558, HB_Other_NotAssigned},
+  {0x559, 0x559, HB_Letter_Modifier},
+  {0x55a, 0x55f, HB_Punctuation_Other},
+  {0x560, 0x560, HB_Other_NotAssigned},
+  {0x561, 0x587, HB_Letter_Lowercase},
+  {0x588, 0x588, HB_Other_NotAssigned},
+  {0x589, 0x589, HB_Punctuation_Other},
+  {0x58a, 0x58a, HB_Punctuation_Dash},
+  {0x58b, 0x590, HB_Other_NotAssigned},
+  {0x591, 0x5bd, HB_Mark_NonSpacing},
+  {0x5be, 0x5be, HB_Punctuation_Dash},
+  {0x5bf, 0x5bf, HB_Mark_NonSpacing},
+  {0x5c0, 0x5c0, HB_Punctuation_Other},
+  {0x5c1, 0x5c2, HB_Mark_NonSpacing},
+  {0x5c3, 0x5c3, HB_Punctuation_Other},
+  {0x5c4, 0x5c5, HB_Mark_NonSpacing},
+  {0x5c6, 0x5c6, HB_Punctuation_Other},
+  {0x5c7, 0x5c7, HB_Mark_NonSpacing},
+  {0x5c8, 0x5cf, HB_Other_NotAssigned},
+  {0x5d0, 0x5ea, HB_Letter_Other},
+  {0x5eb, 0x5ef, HB_Other_NotAssigned},
+  {0x5f0, 0x5f2, HB_Letter_Other},
+  {0x5f3, 0x5f4, HB_Punctuation_Other},
+  {0x5f5, 0x5ff, HB_Other_NotAssigned},
+  {0x600, 0x603, HB_Other_Format},
+  {0x604, 0x605, HB_Other_NotAssigned},
+  {0x606, 0x608, HB_Symbol_Math},
+  {0x609, 0x60a, HB_Punctuation_Other},
+  {0x60b, 0x60b, HB_Symbol_Currency},
+  {0x60c, 0x60d, HB_Punctuation_Other},
+  {0x60e, 0x60f, HB_Symbol_Other},
+  {0x610, 0x61a, HB_Mark_NonSpacing},
+  {0x61b, 0x61b, HB_Punctuation_Other},
+  {0x61c, 0x61d, HB_Other_NotAssigned},
+  {0x61e, 0x61f, HB_Punctuation_Other},
+  {0x620, 0x620, HB_Other_NotAssigned},
+  {0x621, 0x63f, HB_Letter_Other},
+  {0x640, 0x640, HB_Letter_Modifier},
+  {0x641, 0x64a, HB_Letter_Other},
+  {0x64b, 0x65e, HB_Mark_NonSpacing},
+  {0x65f, 0x65f, HB_Other_NotAssigned},
+  {0x660, 0x669, HB_Number_DecimalDigit},
+  {0x66a, 0x66d, HB_Punctuation_Other},
+  {0x66e, 0x66f, HB_Letter_Other},
+  {0x670, 0x670, HB_Mark_NonSpacing},
+  {0x671, 0x6d3, HB_Letter_Other},
+  {0x6d4, 0x6d4, HB_Punctuation_Other},
+  {0x6d5, 0x6d5, HB_Letter_Other},
+  {0x6d6, 0x6dc, HB_Mark_NonSpacing},
+  {0x6dd, 0x6dd, HB_Other_Format},
+  {0x6de, 0x6de, HB_Mark_Enclosing},
+  {0x6df, 0x6e4, HB_Mark_NonSpacing},
+  {0x6e5, 0x6e6, HB_Letter_Modifier},
+  {0x6e7, 0x6e8, HB_Mark_NonSpacing},
+  {0x6e9, 0x6e9, HB_Symbol_Other},
+  {0x6ea, 0x6ed, HB_Mark_NonSpacing},
+  {0x6ee, 0x6ef, HB_Letter_Other},
+  {0x6f0, 0x6f9, HB_Number_DecimalDigit},
+  {0x6fa, 0x6fc, HB_Letter_Other},
+  {0x6fd, 0x6fe, HB_Symbol_Other},
+  {0x6ff, 0x6ff, HB_Letter_Other},
+  {0x700, 0x70d, HB_Punctuation_Other},
+  {0x70e, 0x70e, HB_Other_NotAssigned},
+  {0x70f, 0x70f, HB_Other_Format},
+  {0x710, 0x710, HB_Letter_Other},
+  {0x711, 0x711, HB_Mark_NonSpacing},
+  {0x712, 0x72f, HB_Letter_Other},
+  {0x730, 0x74a, HB_Mark_NonSpacing},
+  {0x74b, 0x74c, HB_Other_NotAssigned},
+  {0x74d, 0x7a5, HB_Letter_Other},
+  {0x7a6, 0x7b0, HB_Mark_NonSpacing},
+  {0x7b1, 0x7b1, HB_Letter_Other},
+  {0x7b2, 0x7bf, HB_Other_NotAssigned},
+  {0x7c0, 0x7c9, HB_Number_DecimalDigit},
+  {0x7ca, 0x7ea, HB_Letter_Other},
+  {0x7eb, 0x7f3, HB_Mark_NonSpacing},
+  {0x7f4, 0x7f5, HB_Letter_Modifier},
+  {0x7f6, 0x7f6, HB_Symbol_Other},
+  {0x7f7, 0x7f9, HB_Punctuation_Other},
+  {0x7fa, 0x7fa, HB_Letter_Modifier},
+  {0x7fb, 0x900, HB_Other_NotAssigned},
+  {0x901, 0x902, HB_Mark_NonSpacing},
+  {0x903, 0x903, HB_Mark_SpacingCombining},
+  {0x904, 0x939, HB_Letter_Other},
+  {0x93a, 0x93b, HB_Other_NotAssigned},
+  {0x93c, 0x93c, HB_Mark_NonSpacing},
+  {0x93d, 0x93d, HB_Letter_Other},
+  {0x93e, 0x940, HB_Mark_SpacingCombining},
+  {0x941, 0x948, HB_Mark_NonSpacing},
+  {0x949, 0x94c, HB_Mark_SpacingCombining},
+  {0x94d, 0x94d, HB_Mark_NonSpacing},
+  {0x94e, 0x94f, HB_Other_NotAssigned},
+  {0x950, 0x950, HB_Letter_Other},
+  {0x951, 0x954, HB_Mark_NonSpacing},
+  {0x955, 0x957, HB_Other_NotAssigned},
+  {0x958, 0x961, HB_Letter_Other},
+  {0x962, 0x963, HB_Mark_NonSpacing},
+  {0x964, 0x965, HB_Punctuation_Other},
+  {0x966, 0x96f, HB_Number_DecimalDigit},
+  {0x970, 0x970, HB_Punctuation_Other},
+  {0x971, 0x971, HB_Letter_Modifier},
+  {0x972, 0x972, HB_Letter_Other},
+  {0x973, 0x97a, HB_Other_NotAssigned},
+  {0x97b, 0x97f, HB_Letter_Other},
+  {0x980, 0x980, HB_Other_NotAssigned},
+  {0x981, 0x981, HB_Mark_NonSpacing},
+  {0x982, 0x983, HB_Mark_SpacingCombining},
+  {0x984, 0x984, HB_Other_NotAssigned},
+  {0x985, 0x98c, HB_Letter_Other},
+  {0x98d, 0x98e, HB_Other_NotAssigned},
+  {0x98f, 0x990, HB_Letter_Other},
+  {0x991, 0x992, HB_Other_NotAssigned},
+  {0x993, 0x9a8, HB_Letter_Other},
+  {0x9a9, 0x9a9, HB_Other_NotAssigned},
+  {0x9aa, 0x9b0, HB_Letter_Other},
+  {0x9b1, 0x9b1, HB_Other_NotAssigned},
+  {0x9b2, 0x9b2, HB_Letter_Other},
+  {0x9b3, 0x9b5, HB_Other_NotAssigned},
+  {0x9b6, 0x9b9, HB_Letter_Other},
+  {0x9ba, 0x9bb, HB_Other_NotAssigned},
+  {0x9bc, 0x9bc, HB_Mark_NonSpacing},
+  {0x9bd, 0x9bd, HB_Letter_Other},
+  {0x9be, 0x9c0, HB_Mark_SpacingCombining},
+  {0x9c1, 0x9c4, HB_Mark_NonSpacing},
+  {0x9c5, 0x9c6, HB_Other_NotAssigned},
+  {0x9c7, 0x9c8, HB_Mark_SpacingCombining},
+  {0x9c9, 0x9ca, HB_Other_NotAssigned},
+  {0x9cb, 0x9cc, HB_Mark_SpacingCombining},
+  {0x9cd, 0x9cd, HB_Mark_NonSpacing},
+  {0x9ce, 0x9ce, HB_Letter_Other},
+  {0x9cf, 0x9d6, HB_Other_NotAssigned},
+  {0x9d7, 0x9d7, HB_Mark_SpacingCombining},
+  {0x9d8, 0x9db, HB_Other_NotAssigned},
+  {0x9dc, 0x9dd, HB_Letter_Other},
+  {0x9de, 0x9de, HB_Other_NotAssigned},
+  {0x9df, 0x9e1, HB_Letter_Other},
+  {0x9e2, 0x9e3, HB_Mark_NonSpacing},
+  {0x9e4, 0x9e5, HB_Other_NotAssigned},
+  {0x9e6, 0x9ef, HB_Number_DecimalDigit},
+  {0x9f0, 0x9f1, HB_Letter_Other},
+  {0x9f2, 0x9f3, HB_Symbol_Currency},
+  {0x9f4, 0x9f9, HB_Number_Other},
+  {0x9fa, 0x9fa, HB_Symbol_Other},
+  {0x9fb, 0xa00, HB_Other_NotAssigned},
+  {0xa01, 0xa02, HB_Mark_NonSpacing},
+  {0xa03, 0xa03, HB_Mark_SpacingCombining},
+  {0xa04, 0xa04, HB_Other_NotAssigned},
+  {0xa05, 0xa0a, HB_Letter_Other},
+  {0xa0b, 0xa0e, HB_Other_NotAssigned},
+  {0xa0f, 0xa10, HB_Letter_Other},
+  {0xa11, 0xa12, HB_Other_NotAssigned},
+  {0xa13, 0xa28, HB_Letter_Other},
+  {0xa29, 0xa29, HB_Other_NotAssigned},
+  {0xa2a, 0xa30, HB_Letter_Other},
+  {0xa31, 0xa31, HB_Other_NotAssigned},
+  {0xa32, 0xa33, HB_Letter_Other},
+  {0xa34, 0xa34, HB_Other_NotAssigned},
+  {0xa35, 0xa36, HB_Letter_Other},
+  {0xa37, 0xa37, HB_Other_NotAssigned},
+  {0xa38, 0xa39, HB_Letter_Other},
+  {0xa3a, 0xa3b, HB_Other_NotAssigned},
+  {0xa3c, 0xa3c, HB_Mark_NonSpacing},
+  {0xa3d, 0xa3d, HB_Other_NotAssigned},
+  {0xa3e, 0xa40, HB_Mark_SpacingCombining},
+  {0xa41, 0xa42, HB_Mark_NonSpacing},
+  {0xa43, 0xa46, HB_Other_NotAssigned},
+  {0xa47, 0xa48, HB_Mark_NonSpacing},
+  {0xa49, 0xa4a, HB_Other_NotAssigned},
+  {0xa4b, 0xa4d, HB_Mark_NonSpacing},
+  {0xa4e, 0xa50, HB_Other_NotAssigned},
+  {0xa51, 0xa51, HB_Mark_NonSpacing},
+  {0xa52, 0xa58, HB_Other_NotAssigned},
+  {0xa59, 0xa5c, HB_Letter_Other},
+  {0xa5d, 0xa5d, HB_Other_NotAssigned},
+  {0xa5e, 0xa5e, HB_Letter_Other},
+  {0xa5f, 0xa65, HB_Other_NotAssigned},
+  {0xa66, 0xa6f, HB_Number_DecimalDigit},
+  {0xa70, 0xa71, HB_Mark_NonSpacing},
+  {0xa72, 0xa74, HB_Letter_Other},
+  {0xa75, 0xa75, HB_Mark_NonSpacing},
+  {0xa76, 0xa80, HB_Other_NotAssigned},
+  {0xa81, 0xa82, HB_Mark_NonSpacing},
+  {0xa83, 0xa83, HB_Mark_SpacingCombining},
+  {0xa84, 0xa84, HB_Other_NotAssigned},
+  {0xa85, 0xa8d, HB_Letter_Other},
+  {0xa8e, 0xa8e, HB_Other_NotAssigned},
+  {0xa8f, 0xa91, HB_Letter_Other},
+  {0xa92, 0xa92, HB_Other_NotAssigned},
+  {0xa93, 0xaa8, HB_Letter_Other},
+  {0xaa9, 0xaa9, HB_Other_NotAssigned},
+  {0xaaa, 0xab0, HB_Letter_Other},
+  {0xab1, 0xab1, HB_Other_NotAssigned},
+  {0xab2, 0xab3, HB_Letter_Other},
+  {0xab4, 0xab4, HB_Other_NotAssigned},
+  {0xab5, 0xab9, HB_Letter_Other},
+  {0xaba, 0xabb, HB_Other_NotAssigned},
+  {0xabc, 0xabc, HB_Mark_NonSpacing},
+  {0xabd, 0xabd, HB_Letter_Other},
+  {0xabe, 0xac0, HB_Mark_SpacingCombining},
+  {0xac1, 0xac5, HB_Mark_NonSpacing},
+  {0xac6, 0xac6, HB_Other_NotAssigned},
+  {0xac7, 0xac8, HB_Mark_NonSpacing},
+  {0xac9, 0xac9, HB_Mark_SpacingCombining},
+  {0xaca, 0xaca, HB_Other_NotAssigned},
+  {0xacb, 0xacc, HB_Mark_SpacingCombining},
+  {0xacd, 0xacd, HB_Mark_NonSpacing},
+  {0xace, 0xacf, HB_Other_NotAssigned},
+  {0xad0, 0xad0, HB_Letter_Other},
+  {0xad1, 0xadf, HB_Other_NotAssigned},
+  {0xae0, 0xae1, HB_Letter_Other},
+  {0xae2, 0xae3, HB_Mark_NonSpacing},
+  {0xae4, 0xae5, HB_Other_NotAssigned},
+  {0xae6, 0xaef, HB_Number_DecimalDigit},
+  {0xaf0, 0xaf0, HB_Other_NotAssigned},
+  {0xaf1, 0xaf1, HB_Symbol_Currency},
+  {0xaf2, 0xb00, HB_Other_NotAssigned},
+  {0xb01, 0xb01, HB_Mark_NonSpacing},
+  {0xb02, 0xb03, HB_Mark_SpacingCombining},
+  {0xb04, 0xb04, HB_Other_NotAssigned},
+  {0xb05, 0xb0c, HB_Letter_Other},
+  {0xb0d, 0xb0e, HB_Other_NotAssigned},
+  {0xb0f, 0xb10, HB_Letter_Other},
+  {0xb11, 0xb12, HB_Other_NotAssigned},
+  {0xb13, 0xb28, HB_Letter_Other},
+  {0xb29, 0xb29, HB_Other_NotAssigned},
+  {0xb2a, 0xb30, HB_Letter_Other},
+  {0xb31, 0xb31, HB_Other_NotAssigned},
+  {0xb32, 0xb33, HB_Letter_Other},
+  {0xb34, 0xb34, HB_Other_NotAssigned},
+  {0xb35, 0xb39, HB_Letter_Other},
+  {0xb3a, 0xb3b, HB_Other_NotAssigned},
+  {0xb3c, 0xb3c, HB_Mark_NonSpacing},
+  {0xb3d, 0xb3d, HB_Letter_Other},
+  {0xb3e, 0xb3e, HB_Mark_SpacingCombining},
+  {0xb3f, 0xb3f, HB_Mark_NonSpacing},
+  {0xb40, 0xb40, HB_Mark_SpacingCombining},
+  {0xb41, 0xb44, HB_Mark_NonSpacing},
+  {0xb45, 0xb46, HB_Other_NotAssigned},
+  {0xb47, 0xb48, HB_Mark_SpacingCombining},
+  {0xb49, 0xb4a, HB_Other_NotAssigned},
+  {0xb4b, 0xb4c, HB_Mark_SpacingCombining},
+  {0xb4d, 0xb4d, HB_Mark_NonSpacing},
+  {0xb4e, 0xb55, HB_Other_NotAssigned},
+  {0xb56, 0xb56, HB_Mark_NonSpacing},
+  {0xb57, 0xb57, HB_Mark_SpacingCombining},
+  {0xb58, 0xb5b, HB_Other_NotAssigned},
+  {0xb5c, 0xb5d, HB_Letter_Other},
+  {0xb5e, 0xb5e, HB_Other_NotAssigned},
+  {0xb5f, 0xb61, HB_Letter_Other},
+  {0xb62, 0xb63, HB_Mark_NonSpacing},
+  {0xb64, 0xb65, HB_Other_NotAssigned},
+  {0xb66, 0xb6f, HB_Number_DecimalDigit},
+  {0xb70, 0xb70, HB_Symbol_Other},
+  {0xb71, 0xb71, HB_Letter_Other},
+  {0xb72, 0xb81, HB_Other_NotAssigned},
+  {0xb82, 0xb82, HB_Mark_NonSpacing},
+  {0xb83, 0xb83, HB_Letter_Other},
+  {0xb84, 0xb84, HB_Other_NotAssigned},
+  {0xb85, 0xb8a, HB_Letter_Other},
+  {0xb8b, 0xb8d, HB_Other_NotAssigned},
+  {0xb8e, 0xb90, HB_Letter_Other},
+  {0xb91, 0xb91, HB_Other_NotAssigned},
+  {0xb92, 0xb95, HB_Letter_Other},
+  {0xb96, 0xb98, HB_Other_NotAssigned},
+  {0xb99, 0xb9a, HB_Letter_Other},
+  {0xb9b, 0xb9b, HB_Other_NotAssigned},
+  {0xb9c, 0xb9c, HB_Letter_Other},
+  {0xb9d, 0xb9d, HB_Other_NotAssigned},
+  {0xb9e, 0xb9f, HB_Letter_Other},
+  {0xba0, 0xba2, HB_Other_NotAssigned},
+  {0xba3, 0xba4, HB_Letter_Other},
+  {0xba5, 0xba7, HB_Other_NotAssigned},
+  {0xba8, 0xbaa, HB_Letter_Other},
+  {0xbab, 0xbad, HB_Other_NotAssigned},
+  {0xbae, 0xbb9, HB_Letter_Other},
+  {0xbba, 0xbbd, HB_Other_NotAssigned},
+  {0xbbe, 0xbbf, HB_Mark_SpacingCombining},
+  {0xbc0, 0xbc0, HB_Mark_NonSpacing},
+  {0xbc1, 0xbc2, HB_Mark_SpacingCombining},
+  {0xbc3, 0xbc5, HB_Other_NotAssigned},
+  {0xbc6, 0xbc8, HB_Mark_SpacingCombining},
+  {0xbc9, 0xbc9, HB_Other_NotAssigned},
+  {0xbca, 0xbcc, HB_Mark_SpacingCombining},
+  {0xbcd, 0xbcd, HB_Mark_NonSpacing},
+  {0xbce, 0xbcf, HB_Other_NotAssigned},
+  {0xbd0, 0xbd0, HB_Letter_Other},
+  {0xbd1, 0xbd6, HB_Other_NotAssigned},
+  {0xbd7, 0xbd7, HB_Mark_SpacingCombining},
+  {0xbd8, 0xbe5, HB_Other_NotAssigned},
+  {0xbe6, 0xbef, HB_Number_DecimalDigit},
+  {0xbf0, 0xbf2, HB_Number_Other},
+  {0xbf3, 0xbf8, HB_Symbol_Other},
+  {0xbf9, 0xbf9, HB_Symbol_Currency},
+  {0xbfa, 0xbfa, HB_Symbol_Other},
+  {0xbfb, 0xc00, HB_Other_NotAssigned},
+  {0xc01, 0xc03, HB_Mark_SpacingCombining},
+  {0xc04, 0xc04, HB_Other_NotAssigned},
+  {0xc05, 0xc0c, HB_Letter_Other},
+  {0xc0d, 0xc0d, HB_Other_NotAssigned},
+  {0xc0e, 0xc10, HB_Letter_Other},
+  {0xc11, 0xc11, HB_Other_NotAssigned},
+  {0xc12, 0xc28, HB_Letter_Other},
+  {0xc29, 0xc29, HB_Other_NotAssigned},
+  {0xc2a, 0xc33, HB_Letter_Other},
+  {0xc34, 0xc34, HB_Other_NotAssigned},
+  {0xc35, 0xc39, HB_Letter_Other},
+  {0xc3a, 0xc3c, HB_Other_NotAssigned},
+  {0xc3d, 0xc3d, HB_Letter_Other},
+  {0xc3e, 0xc40, HB_Mark_NonSpacing},
+  {0xc41, 0xc44, HB_Mark_SpacingCombining},
+  {0xc45, 0xc45, HB_Other_NotAssigned},
+  {0xc46, 0xc48, HB_Mark_NonSpacing},
+  {0xc49, 0xc49, HB_Other_NotAssigned},
+  {0xc4a, 0xc4d, HB_Mark_NonSpacing},
+  {0xc4e, 0xc54, HB_Other_NotAssigned},
+  {0xc55, 0xc56, HB_Mark_NonSpacing},
+  {0xc57, 0xc57, HB_Other_NotAssigned},
+  {0xc58, 0xc59, HB_Letter_Other},
+  {0xc5a, 0xc5f, HB_Other_NotAssigned},
+  {0xc60, 0xc61, HB_Letter_Other},
+  {0xc62, 0xc63, HB_Mark_NonSpacing},
+  {0xc64, 0xc65, HB_Other_NotAssigned},
+  {0xc66, 0xc6f, HB_Number_DecimalDigit},
+  {0xc70, 0xc77, HB_Other_NotAssigned},
+  {0xc78, 0xc7e, HB_Number_Other},
+  {0xc7f, 0xc7f, HB_Symbol_Other},
+  {0xc80, 0xc81, HB_Other_NotAssigned},
+  {0xc82, 0xc83, HB_Mark_SpacingCombining},
+  {0xc84, 0xc84, HB_Other_NotAssigned},
+  {0xc85, 0xc8c, HB_Letter_Other},
+  {0xc8d, 0xc8d, HB_Other_NotAssigned},
+  {0xc8e, 0xc90, HB_Letter_Other},
+  {0xc91, 0xc91, HB_Other_NotAssigned},
+  {0xc92, 0xca8, HB_Letter_Other},
+  {0xca9, 0xca9, HB_Other_NotAssigned},
+  {0xcaa, 0xcb3, HB_Letter_Other},
+  {0xcb4, 0xcb4, HB_Other_NotAssigned},
+  {0xcb5, 0xcb9, HB_Letter_Other},
+  {0xcba, 0xcbb, HB_Other_NotAssigned},
+  {0xcbc, 0xcbc, HB_Mark_NonSpacing},
+  {0xcbd, 0xcbd, HB_Letter_Other},
+  {0xcbe, 0xcbe, HB_Mark_SpacingCombining},
+  {0xcbf, 0xcbf, HB_Mark_NonSpacing},
+  {0xcc0, 0xcc4, HB_Mark_SpacingCombining},
+  {0xcc5, 0xcc5, HB_Other_NotAssigned},
+  {0xcc6, 0xcc6, HB_Mark_NonSpacing},
+  {0xcc7, 0xcc8, HB_Mark_SpacingCombining},
+  {0xcc9, 0xcc9, HB_Other_NotAssigned},
+  {0xcca, 0xccb, HB_Mark_SpacingCombining},
+  {0xccc, 0xccd, HB_Mark_NonSpacing},
+  {0xcce, 0xcd4, HB_Other_NotAssigned},
+  {0xcd5, 0xcd6, HB_Mark_SpacingCombining},
+  {0xcd7, 0xcdd, HB_Other_NotAssigned},
+  {0xcde, 0xcde, HB_Letter_Other},
+  {0xcdf, 0xcdf, HB_Other_NotAssigned},
+  {0xce0, 0xce1, HB_Letter_Other},
+  {0xce2, 0xce3, HB_Mark_NonSpacing},
+  {0xce4, 0xce5, HB_Other_NotAssigned},
+  {0xce6, 0xcef, HB_Number_DecimalDigit},
+  {0xcf0, 0xcf0, HB_Other_NotAssigned},
+  {0xcf1, 0xcf2, HB_Symbol_Other},
+  {0xcf3, 0xd01, HB_Other_NotAssigned},
+  {0xd02, 0xd03, HB_Mark_SpacingCombining},
+  {0xd04, 0xd04, HB_Other_NotAssigned},
+  {0xd05, 0xd0c, HB_Letter_Other},
+  {0xd0d, 0xd0d, HB_Other_NotAssigned},
+  {0xd0e, 0xd10, HB_Letter_Other},
+  {0xd11, 0xd11, HB_Other_NotAssigned},
+  {0xd12, 0xd28, HB_Letter_Other},
+  {0xd29, 0xd29, HB_Other_NotAssigned},
+  {0xd2a, 0xd39, HB_Letter_Other},
+  {0xd3a, 0xd3c, HB_Other_NotAssigned},
+  {0xd3d, 0xd3d, HB_Letter_Other},
+  {0xd3e, 0xd40, HB_Mark_SpacingCombining},
+  {0xd41, 0xd44, HB_Mark_NonSpacing},
+  {0xd45, 0xd45, HB_Other_NotAssigned},
+  {0xd46, 0xd48, HB_Mark_SpacingCombining},
+  {0xd49, 0xd49, HB_Other_NotAssigned},
+  {0xd4a, 0xd4c, HB_Mark_SpacingCombining},
+  {0xd4d, 0xd4d, HB_Mark_NonSpacing},
+  {0xd4e, 0xd56, HB_Other_NotAssigned},
+  {0xd57, 0xd57, HB_Mark_SpacingCombining},
+  {0xd58, 0xd5f, HB_Other_NotAssigned},
+  {0xd60, 0xd61, HB_Letter_Other},
+  {0xd62, 0xd63, HB_Mark_NonSpacing},
+  {0xd64, 0xd65, HB_Other_NotAssigned},
+  {0xd66, 0xd6f, HB_Number_DecimalDigit},
+  {0xd70, 0xd75, HB_Number_Other},
+  {0xd76, 0xd78, HB_Other_NotAssigned},
+  {0xd79, 0xd79, HB_Symbol_Other},
+  {0xd7a, 0xd7f, HB_Letter_Other},
+  {0xd80, 0xd81, HB_Other_NotAssigned},
+  {0xd82, 0xd83, HB_Mark_SpacingCombining},
+  {0xd84, 0xd84, HB_Other_NotAssigned},
+  {0xd85, 0xd96, HB_Letter_Other},
+  {0xd97, 0xd99, HB_Other_NotAssigned},
+  {0xd9a, 0xdb1, HB_Letter_Other},
+  {0xdb2, 0xdb2, HB_Other_NotAssigned},
+  {0xdb3, 0xdbb, HB_Letter_Other},
+  {0xdbc, 0xdbc, HB_Other_NotAssigned},
+  {0xdbd, 0xdbd, HB_Letter_Other},
+  {0xdbe, 0xdbf, HB_Other_NotAssigned},
+  {0xdc0, 0xdc6, HB_Letter_Other},
+  {0xdc7, 0xdc9, HB_Other_NotAssigned},
+  {0xdca, 0xdca, HB_Mark_NonSpacing},
+  {0xdcb, 0xdce, HB_Other_NotAssigned},
+  {0xdcf, 0xdd1, HB_Mark_SpacingCombining},
+  {0xdd2, 0xdd4, HB_Mark_NonSpacing},
+  {0xdd5, 0xdd5, HB_Other_NotAssigned},
+  {0xdd6, 0xdd6, HB_Mark_NonSpacing},
+  {0xdd7, 0xdd7, HB_Other_NotAssigned},
+  {0xdd8, 0xddf, HB_Mark_SpacingCombining},
+  {0xde0, 0xdf1, HB_Other_NotAssigned},
+  {0xdf2, 0xdf3, HB_Mark_SpacingCombining},
+  {0xdf4, 0xdf4, HB_Punctuation_Other},
+  {0xdf5, 0xe00, HB_Other_NotAssigned},
+  {0xe01, 0xe30, HB_Letter_Other},
+  {0xe31, 0xe31, HB_Mark_NonSpacing},
+  {0xe32, 0xe33, HB_Letter_Other},
+  {0xe34, 0xe3a, HB_Mark_NonSpacing},
+  {0xe3b, 0xe3e, HB_Other_NotAssigned},
+  {0xe3f, 0xe3f, HB_Symbol_Currency},
+  {0xe40, 0xe45, HB_Letter_Other},
+  {0xe46, 0xe46, HB_Letter_Modifier},
+  {0xe47, 0xe4e, HB_Mark_NonSpacing},
+  {0xe4f, 0xe4f, HB_Punctuation_Other},
+  {0xe50, 0xe59, HB_Number_DecimalDigit},
+  {0xe5a, 0xe5b, HB_Punctuation_Other},
+  {0xe5c, 0xe80, HB_Other_NotAssigned},
+  {0xe81, 0xe82, HB_Letter_Other},
+  {0xe83, 0xe83, HB_Other_NotAssigned},
+  {0xe84, 0xe84, HB_Letter_Other},
+  {0xe85, 0xe86, HB_Other_NotAssigned},
+  {0xe87, 0xe88, HB_Letter_Other},
+  {0xe89, 0xe89, HB_Other_NotAssigned},
+  {0xe8a, 0xe8a, HB_Letter_Other},
+  {0xe8b, 0xe8c, HB_Other_NotAssigned},
+  {0xe8d, 0xe8d, HB_Letter_Other},
+  {0xe8e, 0xe93, HB_Other_NotAssigned},
+  {0xe94, 0xe97, HB_Letter_Other},
+  {0xe98, 0xe98, HB_Other_NotAssigned},
+  {0xe99, 0xe9f, HB_Letter_Other},
+  {0xea0, 0xea0, HB_Other_NotAssigned},
+  {0xea1, 0xea3, HB_Letter_Other},
+  {0xea4, 0xea4, HB_Other_NotAssigned},
+  {0xea5, 0xea5, HB_Letter_Other},
+  {0xea6, 0xea6, HB_Other_NotAssigned},
+  {0xea7, 0xea7, HB_Letter_Other},
+  {0xea8, 0xea9, HB_Other_NotAssigned},
+  {0xeaa, 0xeab, HB_Letter_Other},
+  {0xeac, 0xeac, HB_Other_NotAssigned},
+  {0xead, 0xeb0, HB_Letter_Other},
+  {0xeb1, 0xeb1, HB_Mark_NonSpacing},
+  {0xeb2, 0xeb3, HB_Letter_Other},
+  {0xeb4, 0xeb9, HB_Mark_NonSpacing},
+  {0xeba, 0xeba, HB_Other_NotAssigned},
+  {0xebb, 0xebc, HB_Mark_NonSpacing},
+  {0xebd, 0xebd, HB_Letter_Other},
+  {0xebe, 0xebf, HB_Other_NotAssigned},
+  {0xec0, 0xec4, HB_Letter_Other},
+  {0xec5, 0xec5, HB_Other_NotAssigned},
+  {0xec6, 0xec6, HB_Letter_Modifier},
+  {0xec7, 0xec7, HB_Other_NotAssigned},
+  {0xec8, 0xecd, HB_Mark_NonSpacing},
+  {0xece, 0xecf, HB_Other_NotAssigned},
+  {0xed0, 0xed9, HB_Number_DecimalDigit},
+  {0xeda, 0xedb, HB_Other_NotAssigned},
+  {0xedc, 0xedd, HB_Letter_Other},
+  {0xede, 0xeff, HB_Other_NotAssigned},
+  {0xf00, 0xf00, HB_Letter_Other},
+  {0xf01, 0xf03, HB_Symbol_Other},
+  {0xf04, 0xf12, HB_Punctuation_Other},
+  {0xf13, 0xf17, HB_Symbol_Other},
+  {0xf18, 0xf19, HB_Mark_NonSpacing},
+  {0xf1a, 0xf1f, HB_Symbol_Other},
+  {0xf20, 0xf29, HB_Number_DecimalDigit},
+  {0xf2a, 0xf33, HB_Number_Other},
+  {0xf34, 0xf34, HB_Symbol_Other},
+  {0xf35, 0xf35, HB_Mark_NonSpacing},
+  {0xf36, 0xf36, HB_Symbol_Other},
+  {0xf37, 0xf37, HB_Mark_NonSpacing},
+  {0xf38, 0xf38, HB_Symbol_Other},
+  {0xf39, 0xf39, HB_Mark_NonSpacing},
+  {0xf3a, 0xf3a, HB_Punctuation_Open},
+  {0xf3b, 0xf3b, HB_Punctuation_Close},
+  {0xf3c, 0xf3c, HB_Punctuation_Open},
+  {0xf3d, 0xf3d, HB_Punctuation_Close},
+  {0xf3e, 0xf3f, HB_Mark_SpacingCombining},
+  {0xf40, 0xf47, HB_Letter_Other},
+  {0xf48, 0xf48, HB_Other_NotAssigned},
+  {0xf49, 0xf6c, HB_Letter_Other},
+  {0xf6d, 0xf70, HB_Other_NotAssigned},
+  {0xf71, 0xf7e, HB_Mark_NonSpacing},
+  {0xf7f, 0xf7f, HB_Mark_SpacingCombining},
+  {0xf80, 0xf84, HB_Mark_NonSpacing},
+  {0xf85, 0xf85, HB_Punctuation_Other},
+  {0xf86, 0xf87, HB_Mark_NonSpacing},
+  {0xf88, 0xf8b, HB_Letter_Other},
+  {0xf8c, 0xf8f, HB_Other_NotAssigned},
+  {0xf90, 0xf97, HB_Mark_NonSpacing},
+  {0xf98, 0xf98, HB_Other_NotAssigned},
+  {0xf99, 0xfbc, HB_Mark_NonSpacing},
+  {0xfbd, 0xfbd, HB_Other_NotAssigned},
+  {0xfbe, 0xfc5, HB_Symbol_Other},
+  {0xfc6, 0xfc6, HB_Mark_NonSpacing},
+  {0xfc7, 0xfcc, HB_Symbol_Other},
+  {0xfcd, 0xfcd, HB_Other_NotAssigned},
+  {0xfce, 0xfcf, HB_Symbol_Other},
+  {0xfd0, 0xfd4, HB_Punctuation_Other},
+  {0xfd5, 0xfff, HB_Other_NotAssigned},
+  {0x1000, 0x102a, HB_Letter_Other},
+  {0x102b, 0x102c, HB_Mark_SpacingCombining},
+  {0x102d, 0x1030, HB_Mark_NonSpacing},
+  {0x1031, 0x1031, HB_Mark_SpacingCombining},
+  {0x1032, 0x1037, HB_Mark_NonSpacing},
+  {0x1038, 0x1038, HB_Mark_SpacingCombining},
+  {0x1039, 0x103a, HB_Mark_NonSpacing},
+  {0x103b, 0x103c, HB_Mark_SpacingCombining},
+  {0x103d, 0x103e, HB_Mark_NonSpacing},
+  {0x103f, 0x103f, HB_Letter_Other},
+  {0x1040, 0x1049, HB_Number_DecimalDigit},
+  {0x104a, 0x104f, HB_Punctuation_Other},
+  {0x1050, 0x1055, HB_Letter_Other},
+  {0x1056, 0x1057, HB_Mark_SpacingCombining},
+  {0x1058, 0x1059, HB_Mark_NonSpacing},
+  {0x105a, 0x105d, HB_Letter_Other},
+  {0x105e, 0x1060, HB_Mark_NonSpacing},
+  {0x1061, 0x1061, HB_Letter_Other},
+  {0x1062, 0x1064, HB_Mark_SpacingCombining},
+  {0x1065, 0x1066, HB_Letter_Other},
+  {0x1067, 0x106d, HB_Mark_SpacingCombining},
+  {0x106e, 0x1070, HB_Letter_Other},
+  {0x1071, 0x1074, HB_Mark_NonSpacing},
+  {0x1075, 0x1081, HB_Letter_Other},
+  {0x1082, 0x1082, HB_Mark_NonSpacing},
+  {0x1083, 0x1084, HB_Mark_SpacingCombining},
+  {0x1085, 0x1086, HB_Mark_NonSpacing},
+  {0x1087, 0x108c, HB_Mark_SpacingCombining},
+  {0x108d, 0x108d, HB_Mark_NonSpacing},
+  {0x108e, 0x108e, HB_Letter_Other},
+  {0x108f, 0x108f, HB_Mark_SpacingCombining},
+  {0x1090, 0x1099, HB_Number_DecimalDigit},
+  {0x109a, 0x109d, HB_Other_NotAssigned},
+  {0x109e, 0x109f, HB_Symbol_Other},
+  {0x10a0, 0x10c5, HB_Letter_Uppercase},
+  {0x10c6, 0x10cf, HB_Other_NotAssigned},
+  {0x10d0, 0x10fa, HB_Letter_Other},
+  {0x10fb, 0x10fb, HB_Punctuation_Other},
+  {0x10fc, 0x10fc, HB_Letter_Modifier},
+  {0x10fd, 0x10ff, HB_Other_NotAssigned},
+  {0x1100, 0x1159, HB_Letter_Other},
+  {0x115a, 0x115e, HB_Other_NotAssigned},
+  {0x115f, 0x11a2, HB_Letter_Other},
+  {0x11a3, 0x11a7, HB_Other_NotAssigned},
+  {0x11a8, 0x11f9, HB_Letter_Other},
+  {0x11fa, 0x11ff, HB_Other_NotAssigned},
+  {0x1200, 0x1248, HB_Letter_Other},
+  {0x1249, 0x1249, HB_Other_NotAssigned},
+  {0x124a, 0x124d, HB_Letter_Other},
+  {0x124e, 0x124f, HB_Other_NotAssigned},
+  {0x1250, 0x1256, HB_Letter_Other},
+  {0x1257, 0x1257, HB_Other_NotAssigned},
+  {0x1258, 0x1258, HB_Letter_Other},
+  {0x1259, 0x1259, HB_Other_NotAssigned},
+  {0x125a, 0x125d, HB_Letter_Other},
+  {0x125e, 0x125f, HB_Other_NotAssigned},
+  {0x1260, 0x1288, HB_Letter_Other},
+  {0x1289, 0x1289, HB_Other_NotAssigned},
+  {0x128a, 0x128d, HB_Letter_Other},
+  {0x128e, 0x128f, HB_Other_NotAssigned},
+  {0x1290, 0x12b0, HB_Letter_Other},
+  {0x12b1, 0x12b1, HB_Other_NotAssigned},
+  {0x12b2, 0x12b5, HB_Letter_Other},
+  {0x12b6, 0x12b7, HB_Other_NotAssigned},
+  {0x12b8, 0x12be, HB_Letter_Other},
+  {0x12bf, 0x12bf, HB_Other_NotAssigned},
+  {0x12c0, 0x12c0, HB_Letter_Other},
+  {0x12c1, 0x12c1, HB_Other_NotAssigned},
+  {0x12c2, 0x12c5, HB_Letter_Other},
+  {0x12c6, 0x12c7, HB_Other_NotAssigned},
+  {0x12c8, 0x12d6, HB_Letter_Other},
+  {0x12d7, 0x12d7, HB_Other_NotAssigned},
+  {0x12d8, 0x1310, HB_Letter_Other},
+  {0x1311, 0x1311, HB_Other_NotAssigned},
+  {0x1312, 0x1315, HB_Letter_Other},
+  {0x1316, 0x1317, HB_Other_NotAssigned},
+  {0x1318, 0x135a, HB_Letter_Other},
+  {0x135b, 0x135e, HB_Other_NotAssigned},
+  {0x135f, 0x135f, HB_Mark_NonSpacing},
+  {0x1360, 0x1360, HB_Symbol_Other},
+  {0x1361, 0x1368, HB_Punctuation_Other},
+  {0x1369, 0x137c, HB_Number_Other},
+  {0x137d, 0x137f, HB_Other_NotAssigned},
+  {0x1380, 0x138f, HB_Letter_Other},
+  {0x1390, 0x1399, HB_Symbol_Other},
+  {0x139a, 0x139f, HB_Other_NotAssigned},
+  {0x13a0, 0x13f4, HB_Letter_Other},
+  {0x13f5, 0x1400, HB_Other_NotAssigned},
+  {0x1401, 0x166c, HB_Letter_Other},
+  {0x166d, 0x166e, HB_Punctuation_Other},
+  {0x166f, 0x1676, HB_Letter_Other},
+  {0x1677, 0x167f, HB_Other_NotAssigned},
+  {0x1680, 0x1680, HB_Separator_Space},
+  {0x1681, 0x169a, HB_Letter_Other},
+  {0x169b, 0x169b, HB_Punctuation_Open},
+  {0x169c, 0x169c, HB_Punctuation_Close},
+  {0x169d, 0x169f, HB_Other_NotAssigned},
+  {0x16a0, 0x16ea, HB_Letter_Other},
+  {0x16eb, 0x16ed, HB_Punctuation_Other},
+  {0x16ee, 0x16f0, HB_Number_Letter},
+  {0x16f1, 0x16ff, HB_Other_NotAssigned},
+  {0x1700, 0x170c, HB_Letter_Other},
+  {0x170d, 0x170d, HB_Other_NotAssigned},
+  {0x170e, 0x1711, HB_Letter_Other},
+  {0x1712, 0x1714, HB_Mark_NonSpacing},
+  {0x1715, 0x171f, HB_Other_NotAssigned},
+  {0x1720, 0x1731, HB_Letter_Other},
+  {0x1732, 0x1734, HB_Mark_NonSpacing},
+  {0x1735, 0x1736, HB_Punctuation_Other},
+  {0x1737, 0x173f, HB_Other_NotAssigned},
+  {0x1740, 0x1751, HB_Letter_Other},
+  {0x1752, 0x1753, HB_Mark_NonSpacing},
+  {0x1754, 0x175f, HB_Other_NotAssigned},
+  {0x1760, 0x176c, HB_Letter_Other},
+  {0x176d, 0x176d, HB_Other_NotAssigned},
+  {0x176e, 0x1770, HB_Letter_Other},
+  {0x1771, 0x1771, HB_Other_NotAssigned},
+  {0x1772, 0x1773, HB_Mark_NonSpacing},
+  {0x1774, 0x177f, HB_Other_NotAssigned},
+  {0x1780, 0x17b3, HB_Letter_Other},
+  {0x17b4, 0x17b5, HB_Other_Format},
+  {0x17b6, 0x17b6, HB_Mark_SpacingCombining},
+  {0x17b7, 0x17bd, HB_Mark_NonSpacing},
+  {0x17be, 0x17c5, HB_Mark_SpacingCombining},
+  {0x17c6, 0x17c6, HB_Mark_NonSpacing},
+  {0x17c7, 0x17c8, HB_Mark_SpacingCombining},
+  {0x17c9, 0x17d3, HB_Mark_NonSpacing},
+  {0x17d4, 0x17d6, HB_Punctuation_Other},
+  {0x17d7, 0x17d7, HB_Letter_Modifier},
+  {0x17d8, 0x17da, HB_Punctuation_Other},
+  {0x17db, 0x17db, HB_Symbol_Currency},
+  {0x17dc, 0x17dc, HB_Letter_Other},
+  {0x17dd, 0x17dd, HB_Mark_NonSpacing},
+  {0x17de, 0x17df, HB_Other_NotAssigned},
+  {0x17e0, 0x17e9, HB_Number_DecimalDigit},
+  {0x17ea, 0x17ef, HB_Other_NotAssigned},
+  {0x17f0, 0x17f9, HB_Number_Other},
+  {0x17fa, 0x17ff, HB_Other_NotAssigned},
+  {0x1800, 0x1805, HB_Punctuation_Other},
+  {0x1806, 0x1806, HB_Punctuation_Dash},
+  {0x1807, 0x180a, HB_Punctuation_Other},
+  {0x180b, 0x180d, HB_Mark_NonSpacing},
+  {0x180e, 0x180e, HB_Separator_Space},
+  {0x180f, 0x180f, HB_Other_NotAssigned},
+  {0x1810, 0x1819, HB_Number_DecimalDigit},
+  {0x181a, 0x181f, HB_Other_NotAssigned},
+  {0x1820, 0x1842, HB_Letter_Other},
+  {0x1843, 0x1843, HB_Letter_Modifier},
+  {0x1844, 0x1877, HB_Letter_Other},
+  {0x1878, 0x187f, HB_Other_NotAssigned},
+  {0x1880, 0x18a8, HB_Letter_Other},
+  {0x18a9, 0x18a9, HB_Mark_NonSpacing},
+  {0x18aa, 0x18aa, HB_Letter_Other},
+  {0x18ab, 0x18ff, HB_Other_NotAssigned},
+  {0x1900, 0x191c, HB_Letter_Other},
+  {0x191d, 0x191f, HB_Other_NotAssigned},
+  {0x1920, 0x1922, HB_Mark_NonSpacing},
+  {0x1923, 0x1926, HB_Mark_SpacingCombining},
+  {0x1927, 0x1928, HB_Mark_NonSpacing},
+  {0x1929, 0x192b, HB_Mark_SpacingCombining},
+  {0x192c, 0x192f, HB_Other_NotAssigned},
+  {0x1930, 0x1931, HB_Mark_SpacingCombining},
+  {0x1932, 0x1932, HB_Mark_NonSpacing},
+  {0x1933, 0x1938, HB_Mark_SpacingCombining},
+  {0x1939, 0x193b, HB_Mark_NonSpacing},
+  {0x193c, 0x193f, HB_Other_NotAssigned},
+  {0x1940, 0x1940, HB_Symbol_Other},
+  {0x1941, 0x1943, HB_Other_NotAssigned},
+  {0x1944, 0x1945, HB_Punctuation_Other},
+  {0x1946, 0x194f, HB_Number_DecimalDigit},
+  {0x1950, 0x196d, HB_Letter_Other},
+  {0x196e, 0x196f, HB_Other_NotAssigned},
+  {0x1970, 0x1974, HB_Letter_Other},
+  {0x1975, 0x197f, HB_Other_NotAssigned},
+  {0x1980, 0x19a9, HB_Letter_Other},
+  {0x19aa, 0x19af, HB_Other_NotAssigned},
+  {0x19b0, 0x19c0, HB_Mark_SpacingCombining},
+  {0x19c1, 0x19c7, HB_Letter_Other},
+  {0x19c8, 0x19c9, HB_Mark_SpacingCombining},
+  {0x19ca, 0x19cf, HB_Other_NotAssigned},
+  {0x19d0, 0x19d9, HB_Number_DecimalDigit},
+  {0x19da, 0x19dd, HB_Other_NotAssigned},
+  {0x19de, 0x19df, HB_Punctuation_Other},
+  {0x19e0, 0x19ff, HB_Symbol_Other},
+  {0x1a00, 0x1a16, HB_Letter_Other},
+  {0x1a17, 0x1a18, HB_Mark_NonSpacing},
+  {0x1a19, 0x1a1b, HB_Mark_SpacingCombining},
+  {0x1a1c, 0x1a1d, HB_Other_NotAssigned},
+  {0x1a1e, 0x1a1f, HB_Punctuation_Other},
+  {0x1a20, 0x1aff, HB_Other_NotAssigned},
+  {0x1b00, 0x1b03, HB_Mark_NonSpacing},
+  {0x1b04, 0x1b04, HB_Mark_SpacingCombining},
+  {0x1b05, 0x1b33, HB_Letter_Other},
+  {0x1b34, 0x1b34, HB_Mark_NonSpacing},
+  {0x1b35, 0x1b35, HB_Mark_SpacingCombining},
+  {0x1b36, 0x1b3a, HB_Mark_NonSpacing},
+  {0x1b3b, 0x1b3b, HB_Mark_SpacingCombining},
+  {0x1b3c, 0x1b3c, HB_Mark_NonSpacing},
+  {0x1b3d, 0x1b41, HB_Mark_SpacingCombining},
+  {0x1b42, 0x1b42, HB_Mark_NonSpacing},
+  {0x1b43, 0x1b44, HB_Mark_SpacingCombining},
+  {0x1b45, 0x1b4b, HB_Letter_Other},
+  {0x1b4c, 0x1b4f, HB_Other_NotAssigned},
+  {0x1b50, 0x1b59, HB_Number_DecimalDigit},
+  {0x1b5a, 0x1b60, HB_Punctuation_Other},
+  {0x1b61, 0x1b6a, HB_Symbol_Other},
+  {0x1b6b, 0x1b73, HB_Mark_NonSpacing},
+  {0x1b74, 0x1b7c, HB_Symbol_Other},
+  {0x1b7d, 0x1b7f, HB_Other_NotAssigned},
+  {0x1b80, 0x1b81, HB_Mark_NonSpacing},
+  {0x1b82, 0x1b82, HB_Mark_SpacingCombining},
+  {0x1b83, 0x1ba0, HB_Letter_Other},
+  {0x1ba1, 0x1ba1, HB_Mark_SpacingCombining},
+  {0x1ba2, 0x1ba5, HB_Mark_NonSpacing},
+  {0x1ba6, 0x1ba7, HB_Mark_SpacingCombining},
+  {0x1ba8, 0x1ba9, HB_Mark_NonSpacing},
+  {0x1baa, 0x1baa, HB_Mark_SpacingCombining},
+  {0x1bab, 0x1bad, HB_Other_NotAssigned},
+  {0x1bae, 0x1baf, HB_Letter_Other},
+  {0x1bb0, 0x1bb9, HB_Number_DecimalDigit},
+  {0x1bba, 0x1bff, HB_Other_NotAssigned},
+  {0x1c00, 0x1c23, HB_Letter_Other},
+  {0x1c24, 0x1c2b, HB_Mark_SpacingCombining},
+  {0x1c2c, 0x1c33, HB_Mark_NonSpacing},
+  {0x1c34, 0x1c35, HB_Mark_SpacingCombining},
+  {0x1c36, 0x1c37, HB_Mark_NonSpacing},
+  {0x1c38, 0x1c3a, HB_Other_NotAssigned},
+  {0x1c3b, 0x1c3f, HB_Punctuation_Other},
+  {0x1c40, 0x1c49, HB_Number_DecimalDigit},
+  {0x1c4a, 0x1c4c, HB_Other_NotAssigned},
+  {0x1c4d, 0x1c4f, HB_Letter_Other},
+  {0x1c50, 0x1c59, HB_Number_DecimalDigit},
+  {0x1c5a, 0x1c77, HB_Letter_Other},
+  {0x1c78, 0x1c7d, HB_Letter_Modifier},
+  {0x1c7e, 0x1c7f, HB_Punctuation_Other},
+  {0x1c80, 0x1cff, HB_Other_NotAssigned},
+  {0x1d00, 0x1d2b, HB_Letter_Lowercase},
+  {0x1d2c, 0x1d61, HB_Letter_Modifier},
+  {0x1d62, 0x1d77, HB_Letter_Lowercase},
+  {0x1d78, 0x1d78, HB_Letter_Modifier},
+  {0x1d79, 0x1d9a, HB_Letter_Lowercase},
+  {0x1d9b, 0x1dbf, HB_Letter_Modifier},
+  {0x1dc0, 0x1de6, HB_Mark_NonSpacing},
+  {0x1de7, 0x1dfd, HB_Other_NotAssigned},
+  {0x1dfe, 0x1dff, HB_Mark_NonSpacing},
+  {0x1e00, 0x1e00, HB_Letter_Uppercase},
+  {0x1e01, 0x1e01, HB_Letter_Lowercase},
+  {0x1e02, 0x1e02, HB_Letter_Uppercase},
+  {0x1e03, 0x1e03, HB_Letter_Lowercase},
+  {0x1e04, 0x1e04, HB_Letter_Uppercase},
+  {0x1e05, 0x1e05, HB_Letter_Lowercase},
+  {0x1e06, 0x1e06, HB_Letter_Uppercase},
+  {0x1e07, 0x1e07, HB_Letter_Lowercase},
+  {0x1e08, 0x1e08, HB_Letter_Uppercase},
+  {0x1e09, 0x1e09, HB_Letter_Lowercase},
+  {0x1e0a, 0x1e0a, HB_Letter_Uppercase},
+  {0x1e0b, 0x1e0b, HB_Letter_Lowercase},
+  {0x1e0c, 0x1e0c, HB_Letter_Uppercase},
+  {0x1e0d, 0x1e0d, HB_Letter_Lowercase},
+  {0x1e0e, 0x1e0e, HB_Letter_Uppercase},
+  {0x1e0f, 0x1e0f, HB_Letter_Lowercase},
+  {0x1e10, 0x1e10, HB_Letter_Uppercase},
+  {0x1e11, 0x1e11, HB_Letter_Lowercase},
+  {0x1e12, 0x1e12, HB_Letter_Uppercase},
+  {0x1e13, 0x1e13, HB_Letter_Lowercase},
+  {0x1e14, 0x1e14, HB_Letter_Uppercase},
+  {0x1e15, 0x1e15, HB_Letter_Lowercase},
+  {0x1e16, 0x1e16, HB_Letter_Uppercase},
+  {0x1e17, 0x1e17, HB_Letter_Lowercase},
+  {0x1e18, 0x1e18, HB_Letter_Uppercase},
+  {0x1e19, 0x1e19, HB_Letter_Lowercase},
+  {0x1e1a, 0x1e1a, HB_Letter_Uppercase},
+  {0x1e1b, 0x1e1b, HB_Letter_Lowercase},
+  {0x1e1c, 0x1e1c, HB_Letter_Uppercase},
+  {0x1e1d, 0x1e1d, HB_Letter_Lowercase},
+  {0x1e1e, 0x1e1e, HB_Letter_Uppercase},
+  {0x1e1f, 0x1e1f, HB_Letter_Lowercase},
+  {0x1e20, 0x1e20, HB_Letter_Uppercase},
+  {0x1e21, 0x1e21, HB_Letter_Lowercase},
+  {0x1e22, 0x1e22, HB_Letter_Uppercase},
+  {0x1e23, 0x1e23, HB_Letter_Lowercase},
+  {0x1e24, 0x1e24, HB_Letter_Uppercase},
+  {0x1e25, 0x1e25, HB_Letter_Lowercase},
+  {0x1e26, 0x1e26, HB_Letter_Uppercase},
+  {0x1e27, 0x1e27, HB_Letter_Lowercase},
+  {0x1e28, 0x1e28, HB_Letter_Uppercase},
+  {0x1e29, 0x1e29, HB_Letter_Lowercase},
+  {0x1e2a, 0x1e2a, HB_Letter_Uppercase},
+  {0x1e2b, 0x1e2b, HB_Letter_Lowercase},
+  {0x1e2c, 0x1e2c, HB_Letter_Uppercase},
+  {0x1e2d, 0x1e2d, HB_Letter_Lowercase},
+  {0x1e2e, 0x1e2e, HB_Letter_Uppercase},
+  {0x1e2f, 0x1e2f, HB_Letter_Lowercase},
+  {0x1e30, 0x1e30, HB_Letter_Uppercase},
+  {0x1e31, 0x1e31, HB_Letter_Lowercase},
+  {0x1e32, 0x1e32, HB_Letter_Uppercase},
+  {0x1e33, 0x1e33, HB_Letter_Lowercase},
+  {0x1e34, 0x1e34, HB_Letter_Uppercase},
+  {0x1e35, 0x1e35, HB_Letter_Lowercase},
+  {0x1e36, 0x1e36, HB_Letter_Uppercase},
+  {0x1e37, 0x1e37, HB_Letter_Lowercase},
+  {0x1e38, 0x1e38, HB_Letter_Uppercase},
+  {0x1e39, 0x1e39, HB_Letter_Lowercase},
+  {0x1e3a, 0x1e3a, HB_Letter_Uppercase},
+  {0x1e3b, 0x1e3b, HB_Letter_Lowercase},
+  {0x1e3c, 0x1e3c, HB_Letter_Uppercase},
+  {0x1e3d, 0x1e3d, HB_Letter_Lowercase},
+  {0x1e3e, 0x1e3e, HB_Letter_Uppercase},
+  {0x1e3f, 0x1e3f, HB_Letter_Lowercase},
+  {0x1e40, 0x1e40, HB_Letter_Uppercase},
+  {0x1e41, 0x1e41, HB_Letter_Lowercase},
+  {0x1e42, 0x1e42, HB_Letter_Uppercase},
+  {0x1e43, 0x1e43, HB_Letter_Lowercase},
+  {0x1e44, 0x1e44, HB_Letter_Uppercase},
+  {0x1e45, 0x1e45, HB_Letter_Lowercase},
+  {0x1e46, 0x1e46, HB_Letter_Uppercase},
+  {0x1e47, 0x1e47, HB_Letter_Lowercase},
+  {0x1e48, 0x1e48, HB_Letter_Uppercase},
+  {0x1e49, 0x1e49, HB_Letter_Lowercase},
+  {0x1e4a, 0x1e4a, HB_Letter_Uppercase},
+  {0x1e4b, 0x1e4b, HB_Letter_Lowercase},
+  {0x1e4c, 0x1e4c, HB_Letter_Uppercase},
+  {0x1e4d, 0x1e4d, HB_Letter_Lowercase},
+  {0x1e4e, 0x1e4e, HB_Letter_Uppercase},
+  {0x1e4f, 0x1e4f, HB_Letter_Lowercase},
+  {0x1e50, 0x1e50, HB_Letter_Uppercase},
+  {0x1e51, 0x1e51, HB_Letter_Lowercase},
+  {0x1e52, 0x1e52, HB_Letter_Uppercase},
+  {0x1e53, 0x1e53, HB_Letter_Lowercase},
+  {0x1e54, 0x1e54, HB_Letter_Uppercase},
+  {0x1e55, 0x1e55, HB_Letter_Lowercase},
+  {0x1e56, 0x1e56, HB_Letter_Uppercase},
+  {0x1e57, 0x1e57, HB_Letter_Lowercase},
+  {0x1e58, 0x1e58, HB_Letter_Uppercase},
+  {0x1e59, 0x1e59, HB_Letter_Lowercase},
+  {0x1e5a, 0x1e5a, HB_Letter_Uppercase},
+  {0x1e5b, 0x1e5b, HB_Letter_Lowercase},
+  {0x1e5c, 0x1e5c, HB_Letter_Uppercase},
+  {0x1e5d, 0x1e5d, HB_Letter_Lowercase},
+  {0x1e5e, 0x1e5e, HB_Letter_Uppercase},
+  {0x1e5f, 0x1e5f, HB_Letter_Lowercase},
+  {0x1e60, 0x1e60, HB_Letter_Uppercase},
+  {0x1e61, 0x1e61, HB_Letter_Lowercase},
+  {0x1e62, 0x1e62, HB_Letter_Uppercase},
+  {0x1e63, 0x1e63, HB_Letter_Lowercase},
+  {0x1e64, 0x1e64, HB_Letter_Uppercase},
+  {0x1e65, 0x1e65, HB_Letter_Lowercase},
+  {0x1e66, 0x1e66, HB_Letter_Uppercase},
+  {0x1e67, 0x1e67, HB_Letter_Lowercase},
+  {0x1e68, 0x1e68, HB_Letter_Uppercase},
+  {0x1e69, 0x1e69, HB_Letter_Lowercase},
+  {0x1e6a, 0x1e6a, HB_Letter_Uppercase},
+  {0x1e6b, 0x1e6b, HB_Letter_Lowercase},
+  {0x1e6c, 0x1e6c, HB_Letter_Uppercase},
+  {0x1e6d, 0x1e6d, HB_Letter_Lowercase},
+  {0x1e6e, 0x1e6e, HB_Letter_Uppercase},
+  {0x1e6f, 0x1e6f, HB_Letter_Lowercase},
+  {0x1e70, 0x1e70, HB_Letter_Uppercase},
+  {0x1e71, 0x1e71, HB_Letter_Lowercase},
+  {0x1e72, 0x1e72, HB_Letter_Uppercase},
+  {0x1e73, 0x1e73, HB_Letter_Lowercase},
+  {0x1e74, 0x1e74, HB_Letter_Uppercase},
+  {0x1e75, 0x1e75, HB_Letter_Lowercase},
+  {0x1e76, 0x1e76, HB_Letter_Uppercase},
+  {0x1e77, 0x1e77, HB_Letter_Lowercase},
+  {0x1e78, 0x1e78, HB_Letter_Uppercase},
+  {0x1e79, 0x1e79, HB_Letter_Lowercase},
+  {0x1e7a, 0x1e7a, HB_Letter_Uppercase},
+  {0x1e7b, 0x1e7b, HB_Letter_Lowercase},
+  {0x1e7c, 0x1e7c, HB_Letter_Uppercase},
+  {0x1e7d, 0x1e7d, HB_Letter_Lowercase},
+  {0x1e7e, 0x1e7e, HB_Letter_Uppercase},
+  {0x1e7f, 0x1e7f, HB_Letter_Lowercase},
+  {0x1e80, 0x1e80, HB_Letter_Uppercase},
+  {0x1e81, 0x1e81, HB_Letter_Lowercase},
+  {0x1e82, 0x1e82, HB_Letter_Uppercase},
+  {0x1e83, 0x1e83, HB_Letter_Lowercase},
+  {0x1e84, 0x1e84, HB_Letter_Uppercase},
+  {0x1e85, 0x1e85, HB_Letter_Lowercase},
+  {0x1e86, 0x1e86, HB_Letter_Uppercase},
+  {0x1e87, 0x1e87, HB_Letter_Lowercase},
+  {0x1e88, 0x1e88, HB_Letter_Uppercase},
+  {0x1e89, 0x1e89, HB_Letter_Lowercase},
+  {0x1e8a, 0x1e8a, HB_Letter_Uppercase},
+  {0x1e8b, 0x1e8b, HB_Letter_Lowercase},
+  {0x1e8c, 0x1e8c, HB_Letter_Uppercase},
+  {0x1e8d, 0x1e8d, HB_Letter_Lowercase},
+  {0x1e8e, 0x1e8e, HB_Letter_Uppercase},
+  {0x1e8f, 0x1e8f, HB_Letter_Lowercase},
+  {0x1e90, 0x1e90, HB_Letter_Uppercase},
+  {0x1e91, 0x1e91, HB_Letter_Lowercase},
+  {0x1e92, 0x1e92, HB_Letter_Uppercase},
+  {0x1e93, 0x1e93, HB_Letter_Lowercase},
+  {0x1e94, 0x1e94, HB_Letter_Uppercase},
+  {0x1e95, 0x1e9d, HB_Letter_Lowercase},
+  {0x1e9e, 0x1e9e, HB_Letter_Uppercase},
+  {0x1e9f, 0x1e9f, HB_Letter_Lowercase},
+  {0x1ea0, 0x1ea0, HB_Letter_Uppercase},
+  {0x1ea1, 0x1ea1, HB_Letter_Lowercase},
+  {0x1ea2, 0x1ea2, HB_Letter_Uppercase},
+  {0x1ea3, 0x1ea3, HB_Letter_Lowercase},
+  {0x1ea4, 0x1ea4, HB_Letter_Uppercase},
+  {0x1ea5, 0x1ea5, HB_Letter_Lowercase},
+  {0x1ea6, 0x1ea6, HB_Letter_Uppercase},
+  {0x1ea7, 0x1ea7, HB_Letter_Lowercase},
+  {0x1ea8, 0x1ea8, HB_Letter_Uppercase},
+  {0x1ea9, 0x1ea9, HB_Letter_Lowercase},
+  {0x1eaa, 0x1eaa, HB_Letter_Uppercase},
+  {0x1eab, 0x1eab, HB_Letter_Lowercase},
+  {0x1eac, 0x1eac, HB_Letter_Uppercase},
+  {0x1ead, 0x1ead, HB_Letter_Lowercase},
+  {0x1eae, 0x1eae, HB_Letter_Uppercase},
+  {0x1eaf, 0x1eaf, HB_Letter_Lowercase},
+  {0x1eb0, 0x1eb0, HB_Letter_Uppercase},
+  {0x1eb1, 0x1eb1, HB_Letter_Lowercase},
+  {0x1eb2, 0x1eb2, HB_Letter_Uppercase},
+  {0x1eb3, 0x1eb3, HB_Letter_Lowercase},
+  {0x1eb4, 0x1eb4, HB_Letter_Uppercase},
+  {0x1eb5, 0x1eb5, HB_Letter_Lowercase},
+  {0x1eb6, 0x1eb6, HB_Letter_Uppercase},
+  {0x1eb7, 0x1eb7, HB_Letter_Lowercase},
+  {0x1eb8, 0x1eb8, HB_Letter_Uppercase},
+  {0x1eb9, 0x1eb9, HB_Letter_Lowercase},
+  {0x1eba, 0x1eba, HB_Letter_Uppercase},
+  {0x1ebb, 0x1ebb, HB_Letter_Lowercase},
+  {0x1ebc, 0x1ebc, HB_Letter_Uppercase},
+  {0x1ebd, 0x1ebd, HB_Letter_Lowercase},
+  {0x1ebe, 0x1ebe, HB_Letter_Uppercase},
+  {0x1ebf, 0x1ebf, HB_Letter_Lowercase},
+  {0x1ec0, 0x1ec0, HB_Letter_Uppercase},
+  {0x1ec1, 0x1ec1, HB_Letter_Lowercase},
+  {0x1ec2, 0x1ec2, HB_Letter_Uppercase},
+  {0x1ec3, 0x1ec3, HB_Letter_Lowercase},
+  {0x1ec4, 0x1ec4, HB_Letter_Uppercase},
+  {0x1ec5, 0x1ec5, HB_Letter_Lowercase},
+  {0x1ec6, 0x1ec6, HB_Letter_Uppercase},
+  {0x1ec7, 0x1ec7, HB_Letter_Lowercase},
+  {0x1ec8, 0x1ec8, HB_Letter_Uppercase},
+  {0x1ec9, 0x1ec9, HB_Letter_Lowercase},
+  {0x1eca, 0x1eca, HB_Letter_Uppercase},
+  {0x1ecb, 0x1ecb, HB_Letter_Lowercase},
+  {0x1ecc, 0x1ecc, HB_Letter_Uppercase},
+  {0x1ecd, 0x1ecd, HB_Letter_Lowercase},
+  {0x1ece, 0x1ece, HB_Letter_Uppercase},
+  {0x1ecf, 0x1ecf, HB_Letter_Lowercase},
+  {0x1ed0, 0x1ed0, HB_Letter_Uppercase},
+  {0x1ed1, 0x1ed1, HB_Letter_Lowercase},
+  {0x1ed2, 0x1ed2, HB_Letter_Uppercase},
+  {0x1ed3, 0x1ed3, HB_Letter_Lowercase},
+  {0x1ed4, 0x1ed4, HB_Letter_Uppercase},
+  {0x1ed5, 0x1ed5, HB_Letter_Lowercase},
+  {0x1ed6, 0x1ed6, HB_Letter_Uppercase},
+  {0x1ed7, 0x1ed7, HB_Letter_Lowercase},
+  {0x1ed8, 0x1ed8, HB_Letter_Uppercase},
+  {0x1ed9, 0x1ed9, HB_Letter_Lowercase},
+  {0x1eda, 0x1eda, HB_Letter_Uppercase},
+  {0x1edb, 0x1edb, HB_Letter_Lowercase},
+  {0x1edc, 0x1edc, HB_Letter_Uppercase},
+  {0x1edd, 0x1edd, HB_Letter_Lowercase},
+  {0x1ede, 0x1ede, HB_Letter_Uppercase},
+  {0x1edf, 0x1edf, HB_Letter_Lowercase},
+  {0x1ee0, 0x1ee0, HB_Letter_Uppercase},
+  {0x1ee1, 0x1ee1, HB_Letter_Lowercase},
+  {0x1ee2, 0x1ee2, HB_Letter_Uppercase},
+  {0x1ee3, 0x1ee3, HB_Letter_Lowercase},
+  {0x1ee4, 0x1ee4, HB_Letter_Uppercase},
+  {0x1ee5, 0x1ee5, HB_Letter_Lowercase},
+  {0x1ee6, 0x1ee6, HB_Letter_Uppercase},
+  {0x1ee7, 0x1ee7, HB_Letter_Lowercase},
+  {0x1ee8, 0x1ee8, HB_Letter_Uppercase},
+  {0x1ee9, 0x1ee9, HB_Letter_Lowercase},
+  {0x1eea, 0x1eea, HB_Letter_Uppercase},
+  {0x1eeb, 0x1eeb, HB_Letter_Lowercase},
+  {0x1eec, 0x1eec, HB_Letter_Uppercase},
+  {0x1eed, 0x1eed, HB_Letter_Lowercase},
+  {0x1eee, 0x1eee, HB_Letter_Uppercase},
+  {0x1eef, 0x1eef, HB_Letter_Lowercase},
+  {0x1ef0, 0x1ef0, HB_Letter_Uppercase},
+  {0x1ef1, 0x1ef1, HB_Letter_Lowercase},
+  {0x1ef2, 0x1ef2, HB_Letter_Uppercase},
+  {0x1ef3, 0x1ef3, HB_Letter_Lowercase},
+  {0x1ef4, 0x1ef4, HB_Letter_Uppercase},
+  {0x1ef5, 0x1ef5, HB_Letter_Lowercase},
+  {0x1ef6, 0x1ef6, HB_Letter_Uppercase},
+  {0x1ef7, 0x1ef7, HB_Letter_Lowercase},
+  {0x1ef8, 0x1ef8, HB_Letter_Uppercase},
+  {0x1ef9, 0x1ef9, HB_Letter_Lowercase},
+  {0x1efa, 0x1efa, HB_Letter_Uppercase},
+  {0x1efb, 0x1efb, HB_Letter_Lowercase},
+  {0x1efc, 0x1efc, HB_Letter_Uppercase},
+  {0x1efd, 0x1efd, HB_Letter_Lowercase},
+  {0x1efe, 0x1efe, HB_Letter_Uppercase},
+  {0x1eff, 0x1f07, HB_Letter_Lowercase},
+  {0x1f08, 0x1f0f, HB_Letter_Uppercase},
+  {0x1f10, 0x1f15, HB_Letter_Lowercase},
+  {0x1f16, 0x1f17, HB_Other_NotAssigned},
+  {0x1f18, 0x1f1d, HB_Letter_Uppercase},
+  {0x1f1e, 0x1f1f, HB_Other_NotAssigned},
+  {0x1f20, 0x1f27, HB_Letter_Lowercase},
+  {0x1f28, 0x1f2f, HB_Letter_Uppercase},
+  {0x1f30, 0x1f37, HB_Letter_Lowercase},
+  {0x1f38, 0x1f3f, HB_Letter_Uppercase},
+  {0x1f40, 0x1f45, HB_Letter_Lowercase},
+  {0x1f46, 0x1f47, HB_Other_NotAssigned},
+  {0x1f48, 0x1f4d, HB_Letter_Uppercase},
+  {0x1f4e, 0x1f4f, HB_Other_NotAssigned},
+  {0x1f50, 0x1f57, HB_Letter_Lowercase},
+  {0x1f58, 0x1f58, HB_Other_NotAssigned},
+  {0x1f59, 0x1f59, HB_Letter_Uppercase},
+  {0x1f5a, 0x1f5a, HB_Other_NotAssigned},
+  {0x1f5b, 0x1f5b, HB_Letter_Uppercase},
+  {0x1f5c, 0x1f5c, HB_Other_NotAssigned},
+  {0x1f5d, 0x1f5d, HB_Letter_Uppercase},
+  {0x1f5e, 0x1f5e, HB_Other_NotAssigned},
+  {0x1f5f, 0x1f5f, HB_Letter_Uppercase},
+  {0x1f60, 0x1f67, HB_Letter_Lowercase},
+  {0x1f68, 0x1f6f, HB_Letter_Uppercase},
+  {0x1f70, 0x1f7d, HB_Letter_Lowercase},
+  {0x1f7e, 0x1f7f, HB_Other_NotAssigned},
+  {0x1f80, 0x1f87, HB_Letter_Lowercase},
+  {0x1f88, 0x1f8f, HB_Letter_Titlecase},
+  {0x1f90, 0x1f97, HB_Letter_Lowercase},
+  {0x1f98, 0x1f9f, HB_Letter_Titlecase},
+  {0x1fa0, 0x1fa7, HB_Letter_Lowercase},
+  {0x1fa8, 0x1faf, HB_Letter_Titlecase},
+  {0x1fb0, 0x1fb4, HB_Letter_Lowercase},
+  {0x1fb5, 0x1fb5, HB_Other_NotAssigned},
+  {0x1fb6, 0x1fb7, HB_Letter_Lowercase},
+  {0x1fb8, 0x1fbb, HB_Letter_Uppercase},
+  {0x1fbc, 0x1fbc, HB_Letter_Titlecase},
+  {0x1fbd, 0x1fbd, HB_Symbol_Modifier},
+  {0x1fbe, 0x1fbe, HB_Letter_Lowercase},
+  {0x1fbf, 0x1fc1, HB_Symbol_Modifier},
+  {0x1fc2, 0x1fc4, HB_Letter_Lowercase},
+  {0x1fc5, 0x1fc5, HB_Other_NotAssigned},
+  {0x1fc6, 0x1fc7, HB_Letter_Lowercase},
+  {0x1fc8, 0x1fcb, HB_Letter_Uppercase},
+  {0x1fcc, 0x1fcc, HB_Letter_Titlecase},
+  {0x1fcd, 0x1fcf, HB_Symbol_Modifier},
+  {0x1fd0, 0x1fd3, HB_Letter_Lowercase},
+  {0x1fd4, 0x1fd5, HB_Other_NotAssigned},
+  {0x1fd6, 0x1fd7, HB_Letter_Lowercase},
+  {0x1fd8, 0x1fdb, HB_Letter_Uppercase},
+  {0x1fdc, 0x1fdc, HB_Other_NotAssigned},
+  {0x1fdd, 0x1fdf, HB_Symbol_Modifier},
+  {0x1fe0, 0x1fe7, HB_Letter_Lowercase},
+  {0x1fe8, 0x1fec, HB_Letter_Uppercase},
+  {0x1fed, 0x1fef, HB_Symbol_Modifier},
+  {0x1ff0, 0x1ff1, HB_Other_NotAssigned},
+  {0x1ff2, 0x1ff4, HB_Letter_Lowercase},
+  {0x1ff5, 0x1ff5, HB_Other_NotAssigned},
+  {0x1ff6, 0x1ff7, HB_Letter_Lowercase},
+  {0x1ff8, 0x1ffb, HB_Letter_Uppercase},
+  {0x1ffc, 0x1ffc, HB_Letter_Titlecase},
+  {0x1ffd, 0x1ffe, HB_Symbol_Modifier},
+  {0x1fff, 0x1fff, HB_Other_NotAssigned},
+  {0x2000, 0x200a, HB_Separator_Space},
+  {0x200b, 0x200f, HB_Other_Format},
+  {0x2010, 0x2015, HB_Punctuation_Dash},
+  {0x2016, 0x2017, HB_Punctuation_Other},
+  {0x2018, 0x2018, HB_Punctuation_InitialQuote},
+  {0x2019, 0x2019, HB_Punctuation_FinalQuote},
+  {0x201a, 0x201a, HB_Punctuation_Open},
+  {0x201b, 0x201c, HB_Punctuation_InitialQuote},
+  {0x201d, 0x201d, HB_Punctuation_FinalQuote},
+  {0x201e, 0x201e, HB_Punctuation_Open},
+  {0x201f, 0x201f, HB_Punctuation_InitialQuote},
+  {0x2020, 0x2027, HB_Punctuation_Other},
+  {0x2028, 0x2028, HB_Separator_Line},
+  {0x2029, 0x2029, HB_Separator_Paragraph},
+  {0x202a, 0x202e, HB_Other_Format},
+  {0x202f, 0x202f, HB_Separator_Space},
+  {0x2030, 0x2038, HB_Punctuation_Other},
+  {0x2039, 0x2039, HB_Punctuation_InitialQuote},
+  {0x203a, 0x203a, HB_Punctuation_FinalQuote},
+  {0x203b, 0x203e, HB_Punctuation_Other},
+  {0x203f, 0x2040, HB_Punctuation_Connector},
+  {0x2041, 0x2043, HB_Punctuation_Other},
+  {0x2044, 0x2044, HB_Symbol_Math},
+  {0x2045, 0x2045, HB_Punctuation_Open},
+  {0x2046, 0x2046, HB_Punctuation_Close},
+  {0x2047, 0x2051, HB_Punctuation_Other},
+  {0x2052, 0x2052, HB_Symbol_Math},
+  {0x2053, 0x2053, HB_Punctuation_Other},
+  {0x2054, 0x2054, HB_Punctuation_Connector},
+  {0x2055, 0x205e, HB_Punctuation_Other},
+  {0x205f, 0x205f, HB_Separator_Space},
+  {0x2060, 0x2064, HB_Other_Format},
+  {0x2065, 0x2069, HB_Other_NotAssigned},
+  {0x206a, 0x206f, HB_Other_Format},
+  {0x2070, 0x2070, HB_Number_Other},
+  {0x2071, 0x2071, HB_Letter_Lowercase},
+  {0x2072, 0x2073, HB_Other_NotAssigned},
+  {0x2074, 0x2079, HB_Number_Other},
+  {0x207a, 0x207c, HB_Symbol_Math},
+  {0x207d, 0x207d, HB_Punctuation_Open},
+  {0x207e, 0x207e, HB_Punctuation_Close},
+  {0x207f, 0x207f, HB_Letter_Lowercase},
+  {0x2080, 0x2089, HB_Number_Other},
+  {0x208a, 0x208c, HB_Symbol_Math},
+  {0x208d, 0x208d, HB_Punctuation_Open},
+  {0x208e, 0x208e, HB_Punctuation_Close},
+  {0x208f, 0x208f, HB_Other_NotAssigned},
+  {0x2090, 0x2094, HB_Letter_Modifier},
+  {0x2095, 0x209f, HB_Other_NotAssigned},
+  {0x20a0, 0x20b5, HB_Symbol_Currency},
+  {0x20b6, 0x20cf, HB_Other_NotAssigned},
+  {0x20d0, 0x20dc, HB_Mark_NonSpacing},
+  {0x20dd, 0x20e0, HB_Mark_Enclosing},
+  {0x20e1, 0x20e1, HB_Mark_NonSpacing},
+  {0x20e2, 0x20e4, HB_Mark_Enclosing},
+  {0x20e5, 0x20f0, HB_Mark_NonSpacing},
+  {0x20f1, 0x20ff, HB_Other_NotAssigned},
+  {0x2100, 0x2101, HB_Symbol_Other},
+  {0x2102, 0x2102, HB_Letter_Uppercase},
+  {0x2103, 0x2106, HB_Symbol_Other},
+  {0x2107, 0x2107, HB_Letter_Uppercase},
+  {0x2108, 0x2109, HB_Symbol_Other},
+  {0x210a, 0x210a, HB_Letter_Lowercase},
+  {0x210b, 0x210d, HB_Letter_Uppercase},
+  {0x210e, 0x210f, HB_Letter_Lowercase},
+  {0x2110, 0x2112, HB_Letter_Uppercase},
+  {0x2113, 0x2113, HB_Letter_Lowercase},
+  {0x2114, 0x2114, HB_Symbol_Other},
+  {0x2115, 0x2115, HB_Letter_Uppercase},
+  {0x2116, 0x2118, HB_Symbol_Other},
+  {0x2119, 0x211d, HB_Letter_Uppercase},
+  {0x211e, 0x2123, HB_Symbol_Other},
+  {0x2124, 0x2124, HB_Letter_Uppercase},
+  {0x2125, 0x2125, HB_Symbol_Other},
+  {0x2126, 0x2126, HB_Letter_Uppercase},
+  {0x2127, 0x2127, HB_Symbol_Other},
+  {0x2128, 0x2128, HB_Letter_Uppercase},
+  {0x2129, 0x2129, HB_Symbol_Other},
+  {0x212a, 0x212d, HB_Letter_Uppercase},
+  {0x212e, 0x212e, HB_Symbol_Other},
+  {0x212f, 0x212f, HB_Letter_Lowercase},
+  {0x2130, 0x2133, HB_Letter_Uppercase},
+  {0x2134, 0x2134, HB_Letter_Lowercase},
+  {0x2135, 0x2138, HB_Letter_Other},
+  {0x2139, 0x2139, HB_Letter_Lowercase},
+  {0x213a, 0x213b, HB_Symbol_Other},
+  {0x213c, 0x213d, HB_Letter_Lowercase},
+  {0x213e, 0x213f, HB_Letter_Uppercase},
+  {0x2140, 0x2144, HB_Symbol_Math},
+  {0x2145, 0x2145, HB_Letter_Uppercase},
+  {0x2146, 0x2149, HB_Letter_Lowercase},
+  {0x214a, 0x214a, HB_Symbol_Other},
+  {0x214b, 0x214b, HB_Symbol_Math},
+  {0x214c, 0x214d, HB_Symbol_Other},
+  {0x214e, 0x214e, HB_Letter_Lowercase},
+  {0x214f, 0x214f, HB_Symbol_Other},
+  {0x2150, 0x2152, HB_Other_NotAssigned},
+  {0x2153, 0x215f, HB_Number_Other},
+  {0x2160, 0x2182, HB_Number_Letter},
+  {0x2183, 0x2183, HB_Letter_Uppercase},
+  {0x2184, 0x2184, HB_Letter_Lowercase},
+  {0x2185, 0x2188, HB_Number_Letter},
+  {0x2189, 0x218f, HB_Other_NotAssigned},
+  {0x2190, 0x2194, HB_Symbol_Math},
+  {0x2195, 0x2199, HB_Symbol_Other},
+  {0x219a, 0x219b, HB_Symbol_Math},
+  {0x219c, 0x219f, HB_Symbol_Other},
+  {0x21a0, 0x21a0, HB_Symbol_Math},
+  {0x21a1, 0x21a2, HB_Symbol_Other},
+  {0x21a3, 0x21a3, HB_Symbol_Math},
+  {0x21a4, 0x21a5, HB_Symbol_Other},
+  {0x21a6, 0x21a6, HB_Symbol_Math},
+  {0x21a7, 0x21ad, HB_Symbol_Other},
+  {0x21ae, 0x21ae, HB_Symbol_Math},
+  {0x21af, 0x21cd, HB_Symbol_Other},
+  {0x21ce, 0x21cf, HB_Symbol_Math},
+  {0x21d0, 0x21d1, HB_Symbol_Other},
+  {0x21d2, 0x21d2, HB_Symbol_Math},
+  {0x21d3, 0x21d3, HB_Symbol_Other},
+  {0x21d4, 0x21d4, HB_Symbol_Math},
+  {0x21d5, 0x21f3, HB_Symbol_Other},
+  {0x21f4, 0x22ff, HB_Symbol_Math},
+  {0x2300, 0x2307, HB_Symbol_Other},
+  {0x2308, 0x230b, HB_Symbol_Math},
+  {0x230c, 0x231f, HB_Symbol_Other},
+  {0x2320, 0x2321, HB_Symbol_Math},
+  {0x2322, 0x2328, HB_Symbol_Other},
+  {0x2329, 0x2329, HB_Punctuation_Open},
+  {0x232a, 0x232a, HB_Punctuation_Close},
+  {0x232b, 0x237b, HB_Symbol_Other},
+  {0x237c, 0x237c, HB_Symbol_Math},
+  {0x237d, 0x239a, HB_Symbol_Other},
+  {0x239b, 0x23b3, HB_Symbol_Math},
+  {0x23b4, 0x23db, HB_Symbol_Other},
+  {0x23dc, 0x23e1, HB_Symbol_Math},
+  {0x23e2, 0x23e7, HB_Symbol_Other},
+  {0x23e8, 0x23ff, HB_Other_NotAssigned},
+  {0x2400, 0x2426, HB_Symbol_Other},
+  {0x2427, 0x243f, HB_Other_NotAssigned},
+  {0x2440, 0x244a, HB_Symbol_Other},
+  {0x244b, 0x245f, HB_Other_NotAssigned},
+  {0x2460, 0x249b, HB_Number_Other},
+  {0x249c, 0x24e9, HB_Symbol_Other},
+  {0x24ea, 0x24ff, HB_Number_Other},
+  {0x2500, 0x25b6, HB_Symbol_Other},
+  {0x25b7, 0x25b7, HB_Symbol_Math},
+  {0x25b8, 0x25c0, HB_Symbol_Other},
+  {0x25c1, 0x25c1, HB_Symbol_Math},
+  {0x25c2, 0x25f7, HB_Symbol_Other},
+  {0x25f8, 0x25ff, HB_Symbol_Math},
+  {0x2600, 0x266e, HB_Symbol_Other},
+  {0x266f, 0x266f, HB_Symbol_Math},
+  {0x2670, 0x269d, HB_Symbol_Other},
+  {0x269e, 0x269f, HB_Other_NotAssigned},
+  {0x26a0, 0x26bc, HB_Symbol_Other},
+  {0x26bd, 0x26bf, HB_Other_NotAssigned},
+  {0x26c0, 0x26c3, HB_Symbol_Other},
+  {0x26c4, 0x2700, HB_Other_NotAssigned},
+  {0x2701, 0x2704, HB_Symbol_Other},
+  {0x2705, 0x2705, HB_Other_NotAssigned},
+  {0x2706, 0x2709, HB_Symbol_Other},
+  {0x270a, 0x270b, HB_Other_NotAssigned},
+  {0x270c, 0x2727, HB_Symbol_Other},
+  {0x2728, 0x2728, HB_Other_NotAssigned},
+  {0x2729, 0x274b, HB_Symbol_Other},
+  {0x274c, 0x274c, HB_Other_NotAssigned},
+  {0x274d, 0x274d, HB_Symbol_Other},
+  {0x274e, 0x274e, HB_Other_NotAssigned},
+  {0x274f, 0x2752, HB_Symbol_Other},
+  {0x2753, 0x2755, HB_Other_NotAssigned},
+  {0x2756, 0x2756, HB_Symbol_Other},
+  {0x2757, 0x2757, HB_Other_NotAssigned},
+  {0x2758, 0x275e, HB_Symbol_Other},
+  {0x275f, 0x2760, HB_Other_NotAssigned},
+  {0x2761, 0x2767, HB_Symbol_Other},
+  {0x2768, 0x2768, HB_Punctuation_Open},
+  {0x2769, 0x2769, HB_Punctuation_Close},
+  {0x276a, 0x276a, HB_Punctuation_Open},
+  {0x276b, 0x276b, HB_Punctuation_Close},
+  {0x276c, 0x276c, HB_Punctuation_Open},
+  {0x276d, 0x276d, HB_Punctuation_Close},
+  {0x276e, 0x276e, HB_Punctuation_Open},
+  {0x276f, 0x276f, HB_Punctuation_Close},
+  {0x2770, 0x2770, HB_Punctuation_Open},
+  {0x2771, 0x2771, HB_Punctuation_Close},
+  {0x2772, 0x2772, HB_Punctuation_Open},
+  {0x2773, 0x2773, HB_Punctuation_Close},
+  {0x2774, 0x2774, HB_Punctuation_Open},
+  {0x2775, 0x2775, HB_Punctuation_Close},
+  {0x2776, 0x2793, HB_Number_Other},
+  {0x2794, 0x2794, HB_Symbol_Other},
+  {0x2795, 0x2797, HB_Other_NotAssigned},
+  {0x2798, 0x27af, HB_Symbol_Other},
+  {0x27b0, 0x27b0, HB_Other_NotAssigned},
+  {0x27b1, 0x27be, HB_Symbol_Other},
+  {0x27bf, 0x27bf, HB_Other_NotAssigned},
+  {0x27c0, 0x27c4, HB_Symbol_Math},
+  {0x27c5, 0x27c5, HB_Punctuation_Open},
+  {0x27c6, 0x27c6, HB_Punctuation_Close},
+  {0x27c7, 0x27ca, HB_Symbol_Math},
+  {0x27cb, 0x27cb, HB_Other_NotAssigned},
+  {0x27cc, 0x27cc, HB_Symbol_Math},
+  {0x27cd, 0x27cf, HB_Other_NotAssigned},
+  {0x27d0, 0x27e5, HB_Symbol_Math},
+  {0x27e6, 0x27e6, HB_Punctuation_Open},
+  {0x27e7, 0x27e7, HB_Punctuation_Close},
+  {0x27e8, 0x27e8, HB_Punctuation_Open},
+  {0x27e9, 0x27e9, HB_Punctuation_Close},
+  {0x27ea, 0x27ea, HB_Punctuation_Open},
+  {0x27eb, 0x27eb, HB_Punctuation_Close},
+  {0x27ec, 0x27ec, HB_Punctuation_Open},
+  {0x27ed, 0x27ed, HB_Punctuation_Close},
+  {0x27ee, 0x27ee, HB_Punctuation_Open},
+  {0x27ef, 0x27ef, HB_Punctuation_Close},
+  {0x27f0, 0x27ff, HB_Symbol_Math},
+  {0x2800, 0x28ff, HB_Symbol_Other},
+  {0x2900, 0x2982, HB_Symbol_Math},
+  {0x2983, 0x2983, HB_Punctuation_Open},
+  {0x2984, 0x2984, HB_Punctuation_Close},
+  {0x2985, 0x2985, HB_Punctuation_Open},
+  {0x2986, 0x2986, HB_Punctuation_Close},
+  {0x2987, 0x2987, HB_Punctuation_Open},
+  {0x2988, 0x2988, HB_Punctuation_Close},
+  {0x2989, 0x2989, HB_Punctuation_Open},
+  {0x298a, 0x298a, HB_Punctuation_Close},
+  {0x298b, 0x298b, HB_Punctuation_Open},
+  {0x298c, 0x298c, HB_Punctuation_Close},
+  {0x298d, 0x298d, HB_Punctuation_Open},
+  {0x298e, 0x298e, HB_Punctuation_Close},
+  {0x298f, 0x298f, HB_Punctuation_Open},
+  {0x2990, 0x2990, HB_Punctuation_Close},
+  {0x2991, 0x2991, HB_Punctuation_Open},
+  {0x2992, 0x2992, HB_Punctuation_Close},
+  {0x2993, 0x2993, HB_Punctuation_Open},
+  {0x2994, 0x2994, HB_Punctuation_Close},
+  {0x2995, 0x2995, HB_Punctuation_Open},
+  {0x2996, 0x2996, HB_Punctuation_Close},
+  {0x2997, 0x2997, HB_Punctuation_Open},
+  {0x2998, 0x2998, HB_Punctuation_Close},
+  {0x2999, 0x29d7, HB_Symbol_Math},
+  {0x29d8, 0x29d8, HB_Punctuation_Open},
+  {0x29d9, 0x29d9, HB_Punctuation_Close},
+  {0x29da, 0x29da, HB_Punctuation_Open},
+  {0x29db, 0x29db, HB_Punctuation_Close},
+  {0x29dc, 0x29fb, HB_Symbol_Math},
+  {0x29fc, 0x29fc, HB_Punctuation_Open},
+  {0x29fd, 0x29fd, HB_Punctuation_Close},
+  {0x29fe, 0x2aff, HB_Symbol_Math},
+  {0x2b00, 0x2b2f, HB_Symbol_Other},
+  {0x2b30, 0x2b44, HB_Symbol_Math},
+  {0x2b45, 0x2b46, HB_Symbol_Other},
+  {0x2b47, 0x2b4c, HB_Symbol_Math},
+  {0x2b4d, 0x2b4f, HB_Other_NotAssigned},
+  {0x2b50, 0x2b54, HB_Symbol_Other},
+  {0x2b55, 0x2bff, HB_Other_NotAssigned},
+  {0x2c00, 0x2c2e, HB_Letter_Uppercase},
+  {0x2c2f, 0x2c2f, HB_Other_NotAssigned},
+  {0x2c30, 0x2c5e, HB_Letter_Lowercase},
+  {0x2c5f, 0x2c5f, HB_Other_NotAssigned},
+  {0x2c60, 0x2c60, HB_Letter_Uppercase},
+  {0x2c61, 0x2c61, HB_Letter_Lowercase},
+  {0x2c62, 0x2c64, HB_Letter_Uppercase},
+  {0x2c65, 0x2c66, HB_Letter_Lowercase},
+  {0x2c67, 0x2c67, HB_Letter_Uppercase},
+  {0x2c68, 0x2c68, HB_Letter_Lowercase},
+  {0x2c69, 0x2c69, HB_Letter_Uppercase},
+  {0x2c6a, 0x2c6a, HB_Letter_Lowercase},
+  {0x2c6b, 0x2c6b, HB_Letter_Uppercase},
+  {0x2c6c, 0x2c6c, HB_Letter_Lowercase},
+  {0x2c6d, 0x2c6f, HB_Letter_Uppercase},
+  {0x2c70, 0x2c70, HB_Other_NotAssigned},
+  {0x2c71, 0x2c71, HB_Letter_Lowercase},
+  {0x2c72, 0x2c72, HB_Letter_Uppercase},
+  {0x2c73, 0x2c74, HB_Letter_Lowercase},
+  {0x2c75, 0x2c75, HB_Letter_Uppercase},
+  {0x2c76, 0x2c7c, HB_Letter_Lowercase},
+  {0x2c7d, 0x2c7d, HB_Letter_Modifier},
+  {0x2c7e, 0x2c7f, HB_Other_NotAssigned},
+  {0x2c80, 0x2c80, HB_Letter_Uppercase},
+  {0x2c81, 0x2c81, HB_Letter_Lowercase},
+  {0x2c82, 0x2c82, HB_Letter_Uppercase},
+  {0x2c83, 0x2c83, HB_Letter_Lowercase},
+  {0x2c84, 0x2c84, HB_Letter_Uppercase},
+  {0x2c85, 0x2c85, HB_Letter_Lowercase},
+  {0x2c86, 0x2c86, HB_Letter_Uppercase},
+  {0x2c87, 0x2c87, HB_Letter_Lowercase},
+  {0x2c88, 0x2c88, HB_Letter_Uppercase},
+  {0x2c89, 0x2c89, HB_Letter_Lowercase},
+  {0x2c8a, 0x2c8a, HB_Letter_Uppercase},
+  {0x2c8b, 0x2c8b, HB_Letter_Lowercase},
+  {0x2c8c, 0x2c8c, HB_Letter_Uppercase},
+  {0x2c8d, 0x2c8d, HB_Letter_Lowercase},
+  {0x2c8e, 0x2c8e, HB_Letter_Uppercase},
+  {0x2c8f, 0x2c8f, HB_Letter_Lowercase},
+  {0x2c90, 0x2c90, HB_Letter_Uppercase},
+  {0x2c91, 0x2c91, HB_Letter_Lowercase},
+  {0x2c92, 0x2c92, HB_Letter_Uppercase},
+  {0x2c93, 0x2c93, HB_Letter_Lowercase},
+  {0x2c94, 0x2c94, HB_Letter_Uppercase},
+  {0x2c95, 0x2c95, HB_Letter_Lowercase},
+  {0x2c96, 0x2c96, HB_Letter_Uppercase},
+  {0x2c97, 0x2c97, HB_Letter_Lowercase},
+  {0x2c98, 0x2c98, HB_Letter_Uppercase},
+  {0x2c99, 0x2c99, HB_Letter_Lowercase},
+  {0x2c9a, 0x2c9a, HB_Letter_Uppercase},
+  {0x2c9b, 0x2c9b, HB_Letter_Lowercase},
+  {0x2c9c, 0x2c9c, HB_Letter_Uppercase},
+  {0x2c9d, 0x2c9d, HB_Letter_Lowercase},
+  {0x2c9e, 0x2c9e, HB_Letter_Uppercase},
+  {0x2c9f, 0x2c9f, HB_Letter_Lowercase},
+  {0x2ca0, 0x2ca0, HB_Letter_Uppercase},
+  {0x2ca1, 0x2ca1, HB_Letter_Lowercase},
+  {0x2ca2, 0x2ca2, HB_Letter_Uppercase},
+  {0x2ca3, 0x2ca3, HB_Letter_Lowercase},
+  {0x2ca4, 0x2ca4, HB_Letter_Uppercase},
+  {0x2ca5, 0x2ca5, HB_Letter_Lowercase},
+  {0x2ca6, 0x2ca6, HB_Letter_Uppercase},
+  {0x2ca7, 0x2ca7, HB_Letter_Lowercase},
+  {0x2ca8, 0x2ca8, HB_Letter_Uppercase},
+  {0x2ca9, 0x2ca9, HB_Letter_Lowercase},
+  {0x2caa, 0x2caa, HB_Letter_Uppercase},
+  {0x2cab, 0x2cab, HB_Letter_Lowercase},
+  {0x2cac, 0x2cac, HB_Letter_Uppercase},
+  {0x2cad, 0x2cad, HB_Letter_Lowercase},
+  {0x2cae, 0x2cae, HB_Letter_Uppercase},
+  {0x2caf, 0x2caf, HB_Letter_Lowercase},
+  {0x2cb0, 0x2cb0, HB_Letter_Uppercase},
+  {0x2cb1, 0x2cb1, HB_Letter_Lowercase},
+  {0x2cb2, 0x2cb2, HB_Letter_Uppercase},
+  {0x2cb3, 0x2cb3, HB_Letter_Lowercase},
+  {0x2cb4, 0x2cb4, HB_Letter_Uppercase},
+  {0x2cb5, 0x2cb5, HB_Letter_Lowercase},
+  {0x2cb6, 0x2cb6, HB_Letter_Uppercase},
+  {0x2cb7, 0x2cb7, HB_Letter_Lowercase},
+  {0x2cb8, 0x2cb8, HB_Letter_Uppercase},
+  {0x2cb9, 0x2cb9, HB_Letter_Lowercase},
+  {0x2cba, 0x2cba, HB_Letter_Uppercase},
+  {0x2cbb, 0x2cbb, HB_Letter_Lowercase},
+  {0x2cbc, 0x2cbc, HB_Letter_Uppercase},
+  {0x2cbd, 0x2cbd, HB_Letter_Lowercase},
+  {0x2cbe, 0x2cbe, HB_Letter_Uppercase},
+  {0x2cbf, 0x2cbf, HB_Letter_Lowercase},
+  {0x2cc0, 0x2cc0, HB_Letter_Uppercase},
+  {0x2cc1, 0x2cc1, HB_Letter_Lowercase},
+  {0x2cc2, 0x2cc2, HB_Letter_Uppercase},
+  {0x2cc3, 0x2cc3, HB_Letter_Lowercase},
+  {0x2cc4, 0x2cc4, HB_Letter_Uppercase},
+  {0x2cc5, 0x2cc5, HB_Letter_Lowercase},
+  {0x2cc6, 0x2cc6, HB_Letter_Uppercase},
+  {0x2cc7, 0x2cc7, HB_Letter_Lowercase},
+  {0x2cc8, 0x2cc8, HB_Letter_Uppercase},
+  {0x2cc9, 0x2cc9, HB_Letter_Lowercase},
+  {0x2cca, 0x2cca, HB_Letter_Uppercase},
+  {0x2ccb, 0x2ccb, HB_Letter_Lowercase},
+  {0x2ccc, 0x2ccc, HB_Letter_Uppercase},
+  {0x2ccd, 0x2ccd, HB_Letter_Lowercase},
+  {0x2cce, 0x2cce, HB_Letter_Uppercase},
+  {0x2ccf, 0x2ccf, HB_Letter_Lowercase},
+  {0x2cd0, 0x2cd0, HB_Letter_Uppercase},
+  {0x2cd1, 0x2cd1, HB_Letter_Lowercase},
+  {0x2cd2, 0x2cd2, HB_Letter_Uppercase},
+  {0x2cd3, 0x2cd3, HB_Letter_Lowercase},
+  {0x2cd4, 0x2cd4, HB_Letter_Uppercase},
+  {0x2cd5, 0x2cd5, HB_Letter_Lowercase},
+  {0x2cd6, 0x2cd6, HB_Letter_Uppercase},
+  {0x2cd7, 0x2cd7, HB_Letter_Lowercase},
+  {0x2cd8, 0x2cd8, HB_Letter_Uppercase},
+  {0x2cd9, 0x2cd9, HB_Letter_Lowercase},
+  {0x2cda, 0x2cda, HB_Letter_Uppercase},
+  {0x2cdb, 0x2cdb, HB_Letter_Lowercase},
+  {0x2cdc, 0x2cdc, HB_Letter_Uppercase},
+  {0x2cdd, 0x2cdd, HB_Letter_Lowercase},
+  {0x2cde, 0x2cde, HB_Letter_Uppercase},
+  {0x2cdf, 0x2cdf, HB_Letter_Lowercase},
+  {0x2ce0, 0x2ce0, HB_Letter_Uppercase},
+  {0x2ce1, 0x2ce1, HB_Letter_Lowercase},
+  {0x2ce2, 0x2ce2, HB_Letter_Uppercase},
+  {0x2ce3, 0x2ce4, HB_Letter_Lowercase},
+  {0x2ce5, 0x2cea, HB_Symbol_Other},
+  {0x2ceb, 0x2cf8, HB_Other_NotAssigned},
+  {0x2cf9, 0x2cfc, HB_Punctuation_Other},
+  {0x2cfd, 0x2cfd, HB_Number_Other},
+  {0x2cfe, 0x2cff, HB_Punctuation_Other},
+  {0x2d00, 0x2d25, HB_Letter_Lowercase},
+  {0x2d26, 0x2d2f, HB_Other_NotAssigned},
+  {0x2d30, 0x2d65, HB_Letter_Other},
+  {0x2d66, 0x2d6e, HB_Other_NotAssigned},
+  {0x2d6f, 0x2d6f, HB_Letter_Modifier},
+  {0x2d70, 0x2d7f, HB_Other_NotAssigned},
+  {0x2d80, 0x2d96, HB_Letter_Other},
+  {0x2d97, 0x2d9f, HB_Other_NotAssigned},
+  {0x2da0, 0x2da6, HB_Letter_Other},
+  {0x2da7, 0x2da7, HB_Other_NotAssigned},
+  {0x2da8, 0x2dae, HB_Letter_Other},
+  {0x2daf, 0x2daf, HB_Other_NotAssigned},
+  {0x2db0, 0x2db6, HB_Letter_Other},
+  {0x2db7, 0x2db7, HB_Other_NotAssigned},
+  {0x2db8, 0x2dbe, HB_Letter_Other},
+  {0x2dbf, 0x2dbf, HB_Other_NotAssigned},
+  {0x2dc0, 0x2dc6, HB_Letter_Other},
+  {0x2dc7, 0x2dc7, HB_Other_NotAssigned},
+  {0x2dc8, 0x2dce, HB_Letter_Other},
+  {0x2dcf, 0x2dcf, HB_Other_NotAssigned},
+  {0x2dd0, 0x2dd6, HB_Letter_Other},
+  {0x2dd7, 0x2dd7, HB_Other_NotAssigned},
+  {0x2dd8, 0x2dde, HB_Letter_Other},
+  {0x2ddf, 0x2ddf, HB_Other_NotAssigned},
+  {0x2de0, 0x2dff, HB_Mark_NonSpacing},
+  {0x2e00, 0x2e01, HB_Punctuation_Other},
+  {0x2e02, 0x2e02, HB_Punctuation_InitialQuote},
+  {0x2e03, 0x2e03, HB_Punctuation_FinalQuote},
+  {0x2e04, 0x2e04, HB_Punctuation_InitialQuote},
+  {0x2e05, 0x2e05, HB_Punctuation_FinalQuote},
+  {0x2e06, 0x2e08, HB_Punctuation_Other},
+  {0x2e09, 0x2e09, HB_Punctuation_InitialQuote},
+  {0x2e0a, 0x2e0a, HB_Punctuation_FinalQuote},
+  {0x2e0b, 0x2e0b, HB_Punctuation_Other},
+  {0x2e0c, 0x2e0c, HB_Punctuation_InitialQuote},
+  {0x2e0d, 0x2e0d, HB_Punctuation_FinalQuote},
+  {0x2e0e, 0x2e16, HB_Punctuation_Other},
+  {0x2e17, 0x2e17, HB_Punctuation_Dash},
+  {0x2e18, 0x2e19, HB_Punctuation_Other},
+  {0x2e1a, 0x2e1a, HB_Punctuation_Dash},
+  {0x2e1b, 0x2e1b, HB_Punctuation_Other},
+  {0x2e1c, 0x2e1c, HB_Punctuation_InitialQuote},
+  {0x2e1d, 0x2e1d, HB_Punctuation_FinalQuote},
+  {0x2e1e, 0x2e1f, HB_Punctuation_Other},
+  {0x2e20, 0x2e20, HB_Punctuation_InitialQuote},
+  {0x2e21, 0x2e21, HB_Punctuation_FinalQuote},
+  {0x2e22, 0x2e22, HB_Punctuation_Open},
+  {0x2e23, 0x2e23, HB_Punctuation_Close},
+  {0x2e24, 0x2e24, HB_Punctuation_Open},
+  {0x2e25, 0x2e25, HB_Punctuation_Close},
+  {0x2e26, 0x2e26, HB_Punctuation_Open},
+  {0x2e27, 0x2e27, HB_Punctuation_Close},
+  {0x2e28, 0x2e28, HB_Punctuation_Open},
+  {0x2e29, 0x2e29, HB_Punctuation_Close},
+  {0x2e2a, 0x2e2e, HB_Punctuation_Other},
+  {0x2e2f, 0x2e2f, HB_Letter_Modifier},
+  {0x2e30, 0x2e30, HB_Punctuation_Other},
+  {0x2e31, 0x2e7f, HB_Other_NotAssigned},
+  {0x2e80, 0x2e99, HB_Symbol_Other},
+  {0x2e9a, 0x2e9a, HB_Other_NotAssigned},
+  {0x2e9b, 0x2ef3, HB_Symbol_Other},
+  {0x2ef4, 0x2eff, HB_Other_NotAssigned},
+  {0x2f00, 0x2fd5, HB_Symbol_Other},
+  {0x2fd6, 0x2fef, HB_Other_NotAssigned},
+  {0x2ff0, 0x2ffb, HB_Symbol_Other},
+  {0x2ffc, 0x2fff, HB_Other_NotAssigned},
+  {0x3000, 0x3000, HB_Separator_Space},
+  {0x3001, 0x3003, HB_Punctuation_Other},
+  {0x3004, 0x3004, HB_Symbol_Other},
+  {0x3005, 0x3005, HB_Letter_Modifier},
+  {0x3006, 0x3006, HB_Letter_Other},
+  {0x3007, 0x3007, HB_Number_Letter},
+  {0x3008, 0x3008, HB_Punctuation_Open},
+  {0x3009, 0x3009, HB_Punctuation_Close},
+  {0x300a, 0x300a, HB_Punctuation_Open},
+  {0x300b, 0x300b, HB_Punctuation_Close},
+  {0x300c, 0x300c, HB_Punctuation_Open},
+  {0x300d, 0x300d, HB_Punctuation_Close},
+  {0x300e, 0x300e, HB_Punctuation_Open},
+  {0x300f, 0x300f, HB_Punctuation_Close},
+  {0x3010, 0x3010, HB_Punctuation_Open},
+  {0x3011, 0x3011, HB_Punctuation_Close},
+  {0x3012, 0x3013, HB_Symbol_Other},
+  {0x3014, 0x3014, HB_Punctuation_Open},
+  {0x3015, 0x3015, HB_Punctuation_Close},
+  {0x3016, 0x3016, HB_Punctuation_Open},
+  {0x3017, 0x3017, HB_Punctuation_Close},
+  {0x3018, 0x3018, HB_Punctuation_Open},
+  {0x3019, 0x3019, HB_Punctuation_Close},
+  {0x301a, 0x301a, HB_Punctuation_Open},
+  {0x301b, 0x301b, HB_Punctuation_Close},
+  {0x301c, 0x301c, HB_Punctuation_Dash},
+  {0x301d, 0x301d, HB_Punctuation_Open},
+  {0x301e, 0x301f, HB_Punctuation_Close},
+  {0x3020, 0x3020, HB_Symbol_Other},
+  {0x3021, 0x3029, HB_Number_Letter},
+  {0x302a, 0x302f, HB_Mark_NonSpacing},
+  {0x3030, 0x3030, HB_Punctuation_Dash},
+  {0x3031, 0x3035, HB_Letter_Modifier},
+  {0x3036, 0x3037, HB_Symbol_Other},
+  {0x3038, 0x303a, HB_Number_Letter},
+  {0x303b, 0x303b, HB_Letter_Modifier},
+  {0x303c, 0x303c, HB_Letter_Other},
+  {0x303d, 0x303d, HB_Punctuation_Other},
+  {0x303e, 0x303f, HB_Symbol_Other},
+  {0x3040, 0x3040, HB_Other_NotAssigned},
+  {0x3041, 0x3096, HB_Letter_Other},
+  {0x3097, 0x3098, HB_Other_NotAssigned},
+  {0x3099, 0x309a, HB_Mark_NonSpacing},
+  {0x309b, 0x309c, HB_Symbol_Modifier},
+  {0x309d, 0x309e, HB_Letter_Modifier},
+  {0x309f, 0x309f, HB_Letter_Other},
+  {0x30a0, 0x30a0, HB_Punctuation_Dash},
+  {0x30a1, 0x30fa, HB_Letter_Other},
+  {0x30fb, 0x30fb, HB_Punctuation_Other},
+  {0x30fc, 0x30fe, HB_Letter_Modifier},
+  {0x30ff, 0x30ff, HB_Letter_Other},
+  {0x3100, 0x3104, HB_Other_NotAssigned},
+  {0x3105, 0x312d, HB_Letter_Other},
+  {0x312e, 0x3130, HB_Other_NotAssigned},
+  {0x3131, 0x318e, HB_Letter_Other},
+  {0x318f, 0x318f, HB_Other_NotAssigned},
+  {0x3190, 0x3191, HB_Symbol_Other},
+  {0x3192, 0x3195, HB_Number_Other},
+  {0x3196, 0x319f, HB_Symbol_Other},
+  {0x31a0, 0x31b7, HB_Letter_Other},
+  {0x31b8, 0x31bf, HB_Other_NotAssigned},
+  {0x31c0, 0x31e3, HB_Symbol_Other},
+  {0x31e4, 0x31ef, HB_Other_NotAssigned},
+  {0x31f0, 0x31ff, HB_Letter_Other},
+  {0x3200, 0x321e, HB_Symbol_Other},
+  {0x321f, 0x321f, HB_Other_NotAssigned},
+  {0x3220, 0x3229, HB_Number_Other},
+  {0x322a, 0x3243, HB_Symbol_Other},
+  {0x3244, 0x324f, HB_Other_NotAssigned},
+  {0x3250, 0x3250, HB_Symbol_Other},
+  {0x3251, 0x325f, HB_Number_Other},
+  {0x3260, 0x327f, HB_Symbol_Other},
+  {0x3280, 0x3289, HB_Number_Other},
+  {0x328a, 0x32b0, HB_Symbol_Other},
+  {0x32b1, 0x32bf, HB_Number_Other},
+  {0x32c0, 0x32fe, HB_Symbol_Other},
+  {0x32ff, 0x32ff, HB_Other_NotAssigned},
+  {0x3300, 0x33ff, HB_Symbol_Other},
+  {0x3400, 0x4db5, HB_Letter_Other},
+  {0x4db6, 0x4dbf, HB_Other_NotAssigned},
+  {0x4dc0, 0x4dff, HB_Symbol_Other},
+  {0x4e00, 0x9fc3, HB_Letter_Other},
+  {0x9fc4, 0x9fff, HB_Other_NotAssigned},
+  {0xa000, 0xa014, HB_Letter_Other},
+  {0xa015, 0xa015, HB_Letter_Modifier},
+  {0xa016, 0xa48c, HB_Letter_Other},
+  {0xa48d, 0xa48f, HB_Other_NotAssigned},
+  {0xa490, 0xa4c6, HB_Symbol_Other},
+  {0xa4c7, 0xa4ff, HB_Other_NotAssigned},
+  {0xa500, 0xa60b, HB_Letter_Other},
+  {0xa60c, 0xa60c, HB_Letter_Modifier},
+  {0xa60d, 0xa60f, HB_Punctuation_Other},
+  {0xa610, 0xa61f, HB_Letter_Other},
+  {0xa620, 0xa629, HB_Number_DecimalDigit},
+  {0xa62a, 0xa62b, HB_Letter_Other},
+  {0xa62c, 0xa63f, HB_Other_NotAssigned},
+  {0xa640, 0xa640, HB_Letter_Uppercase},
+  {0xa641, 0xa641, HB_Letter_Lowercase},
+  {0xa642, 0xa642, HB_Letter_Uppercase},
+  {0xa643, 0xa643, HB_Letter_Lowercase},
+  {0xa644, 0xa644, HB_Letter_Uppercase},
+  {0xa645, 0xa645, HB_Letter_Lowercase},
+  {0xa646, 0xa646, HB_Letter_Uppercase},
+  {0xa647, 0xa647, HB_Letter_Lowercase},
+  {0xa648, 0xa648, HB_Letter_Uppercase},
+  {0xa649, 0xa649, HB_Letter_Lowercase},
+  {0xa64a, 0xa64a, HB_Letter_Uppercase},
+  {0xa64b, 0xa64b, HB_Letter_Lowercase},
+  {0xa64c, 0xa64c, HB_Letter_Uppercase},
+  {0xa64d, 0xa64d, HB_Letter_Lowercase},
+  {0xa64e, 0xa64e, HB_Letter_Uppercase},
+  {0xa64f, 0xa64f, HB_Letter_Lowercase},
+  {0xa650, 0xa650, HB_Letter_Uppercase},
+  {0xa651, 0xa651, HB_Letter_Lowercase},
+  {0xa652, 0xa652, HB_Letter_Uppercase},
+  {0xa653, 0xa653, HB_Letter_Lowercase},
+  {0xa654, 0xa654, HB_Letter_Uppercase},
+  {0xa655, 0xa655, HB_Letter_Lowercase},
+  {0xa656, 0xa656, HB_Letter_Uppercase},
+  {0xa657, 0xa657, HB_Letter_Lowercase},
+  {0xa658, 0xa658, HB_Letter_Uppercase},
+  {0xa659, 0xa659, HB_Letter_Lowercase},
+  {0xa65a, 0xa65a, HB_Letter_Uppercase},
+  {0xa65b, 0xa65b, HB_Letter_Lowercase},
+  {0xa65c, 0xa65c, HB_Letter_Uppercase},
+  {0xa65d, 0xa65d, HB_Letter_Lowercase},
+  {0xa65e, 0xa65e, HB_Letter_Uppercase},
+  {0xa65f, 0xa65f, HB_Letter_Lowercase},
+  {0xa660, 0xa661, HB_Other_NotAssigned},
+  {0xa662, 0xa662, HB_Letter_Uppercase},
+  {0xa663, 0xa663, HB_Letter_Lowercase},
+  {0xa664, 0xa664, HB_Letter_Uppercase},
+  {0xa665, 0xa665, HB_Letter_Lowercase},
+  {0xa666, 0xa666, HB_Letter_Uppercase},
+  {0xa667, 0xa667, HB_Letter_Lowercase},
+  {0xa668, 0xa668, HB_Letter_Uppercase},
+  {0xa669, 0xa669, HB_Letter_Lowercase},
+  {0xa66a, 0xa66a, HB_Letter_Uppercase},
+  {0xa66b, 0xa66b, HB_Letter_Lowercase},
+  {0xa66c, 0xa66c, HB_Letter_Uppercase},
+  {0xa66d, 0xa66d, HB_Letter_Lowercase},
+  {0xa66e, 0xa66e, HB_Letter_Other},
+  {0xa66f, 0xa66f, HB_Mark_NonSpacing},
+  {0xa670, 0xa672, HB_Mark_Enclosing},
+  {0xa673, 0xa673, HB_Punctuation_Other},
+  {0xa674, 0xa67b, HB_Other_NotAssigned},
+  {0xa67c, 0xa67d, HB_Mark_NonSpacing},
+  {0xa67e, 0xa67e, HB_Punctuation_Other},
+  {0xa67f, 0xa67f, HB_Letter_Modifier},
+  {0xa680, 0xa680, HB_Letter_Uppercase},
+  {0xa681, 0xa681, HB_Letter_Lowercase},
+  {0xa682, 0xa682, HB_Letter_Uppercase},
+  {0xa683, 0xa683, HB_Letter_Lowercase},
+  {0xa684, 0xa684, HB_Letter_Uppercase},
+  {0xa685, 0xa685, HB_Letter_Lowercase},
+  {0xa686, 0xa686, HB_Letter_Uppercase},
+  {0xa687, 0xa687, HB_Letter_Lowercase},
+  {0xa688, 0xa688, HB_Letter_Uppercase},
+  {0xa689, 0xa689, HB_Letter_Lowercase},
+  {0xa68a, 0xa68a, HB_Letter_Uppercase},
+  {0xa68b, 0xa68b, HB_Letter_Lowercase},
+  {0xa68c, 0xa68c, HB_Letter_Uppercase},
+  {0xa68d, 0xa68d, HB_Letter_Lowercase},
+  {0xa68e, 0xa68e, HB_Letter_Uppercase},
+  {0xa68f, 0xa68f, HB_Letter_Lowercase},
+  {0xa690, 0xa690, HB_Letter_Uppercase},
+  {0xa691, 0xa691, HB_Letter_Lowercase},
+  {0xa692, 0xa692, HB_Letter_Uppercase},
+  {0xa693, 0xa693, HB_Letter_Lowercase},
+  {0xa694, 0xa694, HB_Letter_Uppercase},
+  {0xa695, 0xa695, HB_Letter_Lowercase},
+  {0xa696, 0xa696, HB_Letter_Uppercase},
+  {0xa697, 0xa697, HB_Letter_Lowercase},
+  {0xa698, 0xa6ff, HB_Other_NotAssigned},
+  {0xa700, 0xa716, HB_Symbol_Modifier},
+  {0xa717, 0xa71f, HB_Letter_Modifier},
+  {0xa720, 0xa721, HB_Symbol_Modifier},
+  {0xa722, 0xa722, HB_Letter_Uppercase},
+  {0xa723, 0xa723, HB_Letter_Lowercase},
+  {0xa724, 0xa724, HB_Letter_Uppercase},
+  {0xa725, 0xa725, HB_Letter_Lowercase},
+  {0xa726, 0xa726, HB_Letter_Uppercase},
+  {0xa727, 0xa727, HB_Letter_Lowercase},
+  {0xa728, 0xa728, HB_Letter_Uppercase},
+  {0xa729, 0xa729, HB_Letter_Lowercase},
+  {0xa72a, 0xa72a, HB_Letter_Uppercase},
+  {0xa72b, 0xa72b, HB_Letter_Lowercase},
+  {0xa72c, 0xa72c, HB_Letter_Uppercase},
+  {0xa72d, 0xa72d, HB_Letter_Lowercase},
+  {0xa72e, 0xa72e, HB_Letter_Uppercase},
+  {0xa72f, 0xa731, HB_Letter_Lowercase},
+  {0xa732, 0xa732, HB_Letter_Uppercase},
+  {0xa733, 0xa733, HB_Letter_Lowercase},
+  {0xa734, 0xa734, HB_Letter_Uppercase},
+  {0xa735, 0xa735, HB_Letter_Lowercase},
+  {0xa736, 0xa736, HB_Letter_Uppercase},
+  {0xa737, 0xa737, HB_Letter_Lowercase},
+  {0xa738, 0xa738, HB_Letter_Uppercase},
+  {0xa739, 0xa739, HB_Letter_Lowercase},
+  {0xa73a, 0xa73a, HB_Letter_Uppercase},
+  {0xa73b, 0xa73b, HB_Letter_Lowercase},
+  {0xa73c, 0xa73c, HB_Letter_Uppercase},
+  {0xa73d, 0xa73d, HB_Letter_Lowercase},
+  {0xa73e, 0xa73e, HB_Letter_Uppercase},
+  {0xa73f, 0xa73f, HB_Letter_Lowercase},
+  {0xa740, 0xa740, HB_Letter_Uppercase},
+  {0xa741, 0xa741, HB_Letter_Lowercase},
+  {0xa742, 0xa742, HB_Letter_Uppercase},
+  {0xa743, 0xa743, HB_Letter_Lowercase},
+  {0xa744, 0xa744, HB_Letter_Uppercase},
+  {0xa745, 0xa745, HB_Letter_Lowercase},
+  {0xa746, 0xa746, HB_Letter_Uppercase},
+  {0xa747, 0xa747, HB_Letter_Lowercase},
+  {0xa748, 0xa748, HB_Letter_Uppercase},
+  {0xa749, 0xa749, HB_Letter_Lowercase},
+  {0xa74a, 0xa74a, HB_Letter_Uppercase},
+  {0xa74b, 0xa74b, HB_Letter_Lowercase},
+  {0xa74c, 0xa74c, HB_Letter_Uppercase},
+  {0xa74d, 0xa74d, HB_Letter_Lowercase},
+  {0xa74e, 0xa74e, HB_Letter_Uppercase},
+  {0xa74f, 0xa74f, HB_Letter_Lowercase},
+  {0xa750, 0xa750, HB_Letter_Uppercase},
+  {0xa751, 0xa751, HB_Letter_Lowercase},
+  {0xa752, 0xa752, HB_Letter_Uppercase},
+  {0xa753, 0xa753, HB_Letter_Lowercase},
+  {0xa754, 0xa754, HB_Letter_Uppercase},
+  {0xa755, 0xa755, HB_Letter_Lowercase},
+  {0xa756, 0xa756, HB_Letter_Uppercase},
+  {0xa757, 0xa757, HB_Letter_Lowercase},
+  {0xa758, 0xa758, HB_Letter_Uppercase},
+  {0xa759, 0xa759, HB_Letter_Lowercase},
+  {0xa75a, 0xa75a, HB_Letter_Uppercase},
+  {0xa75b, 0xa75b, HB_Letter_Lowercase},
+  {0xa75c, 0xa75c, HB_Letter_Uppercase},
+  {0xa75d, 0xa75d, HB_Letter_Lowercase},
+  {0xa75e, 0xa75e, HB_Letter_Uppercase},
+  {0xa75f, 0xa75f, HB_Letter_Lowercase},
+  {0xa760, 0xa760, HB_Letter_Uppercase},
+  {0xa761, 0xa761, HB_Letter_Lowercase},
+  {0xa762, 0xa762, HB_Letter_Uppercase},
+  {0xa763, 0xa763, HB_Letter_Lowercase},
+  {0xa764, 0xa764, HB_Letter_Uppercase},
+  {0xa765, 0xa765, HB_Letter_Lowercase},
+  {0xa766, 0xa766, HB_Letter_Uppercase},
+  {0xa767, 0xa767, HB_Letter_Lowercase},
+  {0xa768, 0xa768, HB_Letter_Uppercase},
+  {0xa769, 0xa769, HB_Letter_Lowercase},
+  {0xa76a, 0xa76a, HB_Letter_Uppercase},
+  {0xa76b, 0xa76b, HB_Letter_Lowercase},
+  {0xa76c, 0xa76c, HB_Letter_Uppercase},
+  {0xa76d, 0xa76d, HB_Letter_Lowercase},
+  {0xa76e, 0xa76e, HB_Letter_Uppercase},
+  {0xa76f, 0xa76f, HB_Letter_Lowercase},
+  {0xa770, 0xa770, HB_Letter_Modifier},
+  {0xa771, 0xa778, HB_Letter_Lowercase},
+  {0xa779, 0xa779, HB_Letter_Uppercase},
+  {0xa77a, 0xa77a, HB_Letter_Lowercase},
+  {0xa77b, 0xa77b, HB_Letter_Uppercase},
+  {0xa77c, 0xa77c, HB_Letter_Lowercase},
+  {0xa77d, 0xa77e, HB_Letter_Uppercase},
+  {0xa77f, 0xa77f, HB_Letter_Lowercase},
+  {0xa780, 0xa780, HB_Letter_Uppercase},
+  {0xa781, 0xa781, HB_Letter_Lowercase},
+  {0xa782, 0xa782, HB_Letter_Uppercase},
+  {0xa783, 0xa783, HB_Letter_Lowercase},
+  {0xa784, 0xa784, HB_Letter_Uppercase},
+  {0xa785, 0xa785, HB_Letter_Lowercase},
+  {0xa786, 0xa786, HB_Letter_Uppercase},
+  {0xa787, 0xa787, HB_Letter_Lowercase},
+  {0xa788, 0xa788, HB_Letter_Modifier},
+  {0xa789, 0xa78a, HB_Symbol_Modifier},
+  {0xa78b, 0xa78b, HB_Letter_Uppercase},
+  {0xa78c, 0xa78c, HB_Letter_Lowercase},
+  {0xa78d, 0xa7fa, HB_Other_NotAssigned},
+  {0xa7fb, 0xa801, HB_Letter_Other},
+  {0xa802, 0xa802, HB_Mark_NonSpacing},
+  {0xa803, 0xa805, HB_Letter_Other},
+  {0xa806, 0xa806, HB_Mark_NonSpacing},
+  {0xa807, 0xa80a, HB_Letter_Other},
+  {0xa80b, 0xa80b, HB_Mark_NonSpacing},
+  {0xa80c, 0xa822, HB_Letter_Other},
+  {0xa823, 0xa824, HB_Mark_SpacingCombining},
+  {0xa825, 0xa826, HB_Mark_NonSpacing},
+  {0xa827, 0xa827, HB_Mark_SpacingCombining},
+  {0xa828, 0xa82b, HB_Symbol_Other},
+  {0xa82c, 0xa83f, HB_Other_NotAssigned},
+  {0xa840, 0xa873, HB_Letter_Other},
+  {0xa874, 0xa877, HB_Punctuation_Other},
+  {0xa878, 0xa87f, HB_Other_NotAssigned},
+  {0xa880, 0xa881, HB_Mark_SpacingCombining},
+  {0xa882, 0xa8b3, HB_Letter_Other},
+  {0xa8b4, 0xa8c3, HB_Mark_SpacingCombining},
+  {0xa8c4, 0xa8c4, HB_Mark_NonSpacing},
+  {0xa8c5, 0xa8cd, HB_Other_NotAssigned},
+  {0xa8ce, 0xa8cf, HB_Punctuation_Other},
+  {0xa8d0, 0xa8d9, HB_Number_DecimalDigit},
+  {0xa8da, 0xa8ff, HB_Other_NotAssigned},
+  {0xa900, 0xa909, HB_Number_DecimalDigit},
+  {0xa90a, 0xa925, HB_Letter_Other},
+  {0xa926, 0xa92d, HB_Mark_NonSpacing},
+  {0xa92e, 0xa92f, HB_Punctuation_Other},
+  {0xa930, 0xa946, HB_Letter_Other},
+  {0xa947, 0xa951, HB_Mark_NonSpacing},
+  {0xa952, 0xa953, HB_Mark_SpacingCombining},
+  {0xa954, 0xa95e, HB_Other_NotAssigned},
+  {0xa95f, 0xa95f, HB_Punctuation_Other},
+  {0xa960, 0xa9ff, HB_Other_NotAssigned},
+  {0xaa00, 0xaa28, HB_Letter_Other},
+  {0xaa29, 0xaa2e, HB_Mark_NonSpacing},
+  {0xaa2f, 0xaa30, HB_Mark_SpacingCombining},
+  {0xaa31, 0xaa32, HB_Mark_NonSpacing},
+  {0xaa33, 0xaa34, HB_Mark_SpacingCombining},
+  {0xaa35, 0xaa36, HB_Mark_NonSpacing},
+  {0xaa37, 0xaa3f, HB_Other_NotAssigned},
+  {0xaa40, 0xaa42, HB_Letter_Other},
+  {0xaa43, 0xaa43, HB_Mark_NonSpacing},
+  {0xaa44, 0xaa4b, HB_Letter_Other},
+  {0xaa4c, 0xaa4c, HB_Mark_NonSpacing},
+  {0xaa4d, 0xaa4d, HB_Mark_SpacingCombining},
+  {0xaa4e, 0xaa4f, HB_Other_NotAssigned},
+  {0xaa50, 0xaa59, HB_Number_DecimalDigit},
+  {0xaa5a, 0xaa5b, HB_Other_NotAssigned},
+  {0xaa5c, 0xaa5f, HB_Punctuation_Other},
+  {0xaa60, 0xabff, HB_Other_NotAssigned},
+  {0xac00, 0xd7a3, HB_Letter_Other},
+  {0xd7a4, 0xd7ff, HB_Other_NotAssigned},
+  {0xd800, 0xdfff, HB_Other_Surrogate},
+  {0xe000, 0xf8ff, HB_Other_PrivateUse},
+  {0xf900, 0xfa2d, HB_Letter_Other},
+  {0xfa2e, 0xfa2f, HB_Other_NotAssigned},
+  {0xfa30, 0xfa6a, HB_Letter_Other},
+  {0xfa6b, 0xfa6f, HB_Other_NotAssigned},
+  {0xfa70, 0xfad9, HB_Letter_Other},
+  {0xfada, 0xfaff, HB_Other_NotAssigned},
+  {0xfb00, 0xfb06, HB_Letter_Lowercase},
+  {0xfb07, 0xfb12, HB_Other_NotAssigned},
+  {0xfb13, 0xfb17, HB_Letter_Lowercase},
+  {0xfb18, 0xfb1c, HB_Other_NotAssigned},
+  {0xfb1d, 0xfb1d, HB_Letter_Other},
+  {0xfb1e, 0xfb1e, HB_Mark_NonSpacing},
+  {0xfb1f, 0xfb28, HB_Letter_Other},
+  {0xfb29, 0xfb29, HB_Symbol_Math},
+  {0xfb2a, 0xfb36, HB_Letter_Other},
+  {0xfb37, 0xfb37, HB_Other_NotAssigned},
+  {0xfb38, 0xfb3c, HB_Letter_Other},
+  {0xfb3d, 0xfb3d, HB_Other_NotAssigned},
+  {0xfb3e, 0xfb3e, HB_Letter_Other},
+  {0xfb3f, 0xfb3f, HB_Other_NotAssigned},
+  {0xfb40, 0xfb41, HB_Letter_Other},
+  {0xfb42, 0xfb42, HB_Other_NotAssigned},
+  {0xfb43, 0xfb44, HB_Letter_Other},
+  {0xfb45, 0xfb45, HB_Other_NotAssigned},
+  {0xfb46, 0xfbb1, HB_Letter_Other},
+  {0xfbb2, 0xfbd2, HB_Other_NotAssigned},
+  {0xfbd3, 0xfd3d, HB_Letter_Other},
+  {0xfd3e, 0xfd3e, HB_Punctuation_Open},
+  {0xfd3f, 0xfd3f, HB_Punctuation_Close},
+  {0xfd40, 0xfd4f, HB_Other_NotAssigned},
+  {0xfd50, 0xfd8f, HB_Letter_Other},
+  {0xfd90, 0xfd91, HB_Other_NotAssigned},
+  {0xfd92, 0xfdc7, HB_Letter_Other},
+  {0xfdc8, 0xfdef, HB_Other_NotAssigned},
+  {0xfdf0, 0xfdfb, HB_Letter_Other},
+  {0xfdfc, 0xfdfc, HB_Symbol_Currency},
+  {0xfdfd, 0xfdfd, HB_Symbol_Other},
+  {0xfdfe, 0xfdff, HB_Other_NotAssigned},
+  {0xfe00, 0xfe0f, HB_Mark_NonSpacing},
+  {0xfe10, 0xfe16, HB_Punctuation_Other},
+  {0xfe17, 0xfe17, HB_Punctuation_Open},
+  {0xfe18, 0xfe18, HB_Punctuation_Close},
+  {0xfe19, 0xfe19, HB_Punctuation_Other},
+  {0xfe1a, 0xfe1f, HB_Other_NotAssigned},
+  {0xfe20, 0xfe26, HB_Mark_NonSpacing},
+  {0xfe27, 0xfe2f, HB_Other_NotAssigned},
+  {0xfe30, 0xfe30, HB_Punctuation_Other},
+  {0xfe31, 0xfe32, HB_Punctuation_Dash},
+  {0xfe33, 0xfe34, HB_Punctuation_Connector},
+  {0xfe35, 0xfe35, HB_Punctuation_Open},
+  {0xfe36, 0xfe36, HB_Punctuation_Close},
+  {0xfe37, 0xfe37, HB_Punctuation_Open},
+  {0xfe38, 0xfe38, HB_Punctuation_Close},
+  {0xfe39, 0xfe39, HB_Punctuation_Open},
+  {0xfe3a, 0xfe3a, HB_Punctuation_Close},
+  {0xfe3b, 0xfe3b, HB_Punctuation_Open},
+  {0xfe3c, 0xfe3c, HB_Punctuation_Close},
+  {0xfe3d, 0xfe3d, HB_Punctuation_Open},
+  {0xfe3e, 0xfe3e, HB_Punctuation_Close},
+  {0xfe3f, 0xfe3f, HB_Punctuation_Open},
+  {0xfe40, 0xfe40, HB_Punctuation_Close},
+  {0xfe41, 0xfe41, HB_Punctuation_Open},
+  {0xfe42, 0xfe42, HB_Punctuation_Close},
+  {0xfe43, 0xfe43, HB_Punctuation_Open},
+  {0xfe44, 0xfe44, HB_Punctuation_Close},
+  {0xfe45, 0xfe46, HB_Punctuation_Other},
+  {0xfe47, 0xfe47, HB_Punctuation_Open},
+  {0xfe48, 0xfe48, HB_Punctuation_Close},
+  {0xfe49, 0xfe4c, HB_Punctuation_Other},
+  {0xfe4d, 0xfe4f, HB_Punctuation_Connector},
+  {0xfe50, 0xfe52, HB_Punctuation_Other},
+  {0xfe53, 0xfe53, HB_Other_NotAssigned},
+  {0xfe54, 0xfe57, HB_Punctuation_Other},
+  {0xfe58, 0xfe58, HB_Punctuation_Dash},
+  {0xfe59, 0xfe59, HB_Punctuation_Open},
+  {0xfe5a, 0xfe5a, HB_Punctuation_Close},
+  {0xfe5b, 0xfe5b, HB_Punctuation_Open},
+  {0xfe5c, 0xfe5c, HB_Punctuation_Close},
+  {0xfe5d, 0xfe5d, HB_Punctuation_Open},
+  {0xfe5e, 0xfe5e, HB_Punctuation_Close},
+  {0xfe5f, 0xfe61, HB_Punctuation_Other},
+  {0xfe62, 0xfe62, HB_Symbol_Math},
+  {0xfe63, 0xfe63, HB_Punctuation_Dash},
+  {0xfe64, 0xfe66, HB_Symbol_Math},
+  {0xfe67, 0xfe67, HB_Other_NotAssigned},
+  {0xfe68, 0xfe68, HB_Punctuation_Other},
+  {0xfe69, 0xfe69, HB_Symbol_Currency},
+  {0xfe6a, 0xfe6b, HB_Punctuation_Other},
+  {0xfe6c, 0xfe6f, HB_Other_NotAssigned},
+  {0xfe70, 0xfe74, HB_Letter_Other},
+  {0xfe75, 0xfe75, HB_Other_NotAssigned},
+  {0xfe76, 0xfefc, HB_Letter_Other},
+  {0xfefd, 0xfefe, HB_Other_NotAssigned},
+  {0xfeff, 0xfeff, HB_Other_Format},
+  {0xff00, 0xff00, HB_Other_NotAssigned},
+  {0xff01, 0xff03, HB_Punctuation_Other},
+  {0xff04, 0xff04, HB_Symbol_Currency},
+  {0xff05, 0xff07, HB_Punctuation_Other},
+  {0xff08, 0xff08, HB_Punctuation_Open},
+  {0xff09, 0xff09, HB_Punctuation_Close},
+  {0xff0a, 0xff0a, HB_Punctuation_Other},
+  {0xff0b, 0xff0b, HB_Symbol_Math},
+  {0xff0c, 0xff0c, HB_Punctuation_Other},
+  {0xff0d, 0xff0d, HB_Punctuation_Dash},
+  {0xff0e, 0xff0f, HB_Punctuation_Other},
+  {0xff10, 0xff19, HB_Number_DecimalDigit},
+  {0xff1a, 0xff1b, HB_Punctuation_Other},
+  {0xff1c, 0xff1e, HB_Symbol_Math},
+  {0xff1f, 0xff20, HB_Punctuation_Other},
+  {0xff21, 0xff3a, HB_Letter_Uppercase},
+  {0xff3b, 0xff3b, HB_Punctuation_Open},
+  {0xff3c, 0xff3c, HB_Punctuation_Other},
+  {0xff3d, 0xff3d, HB_Punctuation_Close},
+  {0xff3e, 0xff3e, HB_Symbol_Modifier},
+  {0xff3f, 0xff3f, HB_Punctuation_Connector},
+  {0xff40, 0xff40, HB_Symbol_Modifier},
+  {0xff41, 0xff5a, HB_Letter_Lowercase},
+  {0xff5b, 0xff5b, HB_Punctuation_Open},
+  {0xff5c, 0xff5c, HB_Symbol_Math},
+  {0xff5d, 0xff5d, HB_Punctuation_Close},
+  {0xff5e, 0xff5e, HB_Symbol_Math},
+  {0xff5f, 0xff5f, HB_Punctuation_Open},
+  {0xff60, 0xff60, HB_Punctuation_Close},
+  {0xff61, 0xff61, HB_Punctuation_Other},
+  {0xff62, 0xff62, HB_Punctuation_Open},
+  {0xff63, 0xff63, HB_Punctuation_Close},
+  {0xff64, 0xff65, HB_Punctuation_Other},
+  {0xff66, 0xff6f, HB_Letter_Other},
+  {0xff70, 0xff70, HB_Letter_Modifier},
+  {0xff71, 0xff9d, HB_Letter_Other},
+  {0xff9e, 0xff9f, HB_Letter_Modifier},
+  {0xffa0, 0xffbe, HB_Letter_Other},
+  {0xffbf, 0xffc1, HB_Other_NotAssigned},
+  {0xffc2, 0xffc7, HB_Letter_Other},
+  {0xffc8, 0xffc9, HB_Other_NotAssigned},
+  {0xffca, 0xffcf, HB_Letter_Other},
+  {0xffd0, 0xffd1, HB_Other_NotAssigned},
+  {0xffd2, 0xffd7, HB_Letter_Other},
+  {0xffd8, 0xffd9, HB_Other_NotAssigned},
+  {0xffda, 0xffdc, HB_Letter_Other},
+  {0xffdd, 0xffdf, HB_Other_NotAssigned},
+  {0xffe0, 0xffe1, HB_Symbol_Currency},
+  {0xffe2, 0xffe2, HB_Symbol_Math},
+  {0xffe3, 0xffe3, HB_Symbol_Modifier},
+  {0xffe4, 0xffe4, HB_Symbol_Other},
+  {0xffe5, 0xffe6, HB_Symbol_Currency},
+  {0xffe7, 0xffe7, HB_Other_NotAssigned},
+  {0xffe8, 0xffe8, HB_Symbol_Other},
+  {0xffe9, 0xffec, HB_Symbol_Math},
+  {0xffed, 0xffee, HB_Symbol_Other},
+  {0xffef, 0xfff8, HB_Other_NotAssigned},
+  {0xfff9, 0xfffb, HB_Other_Format},
+  {0xfffc, 0xfffd, HB_Symbol_Other},
+  {0xfffe, 0xffff, HB_Other_NotAssigned},
+  {0x10000, 0x1000b, HB_Letter_Other},
+  {0x1000c, 0x1000c, HB_Other_NotAssigned},
+  {0x1000d, 0x10026, HB_Letter_Other},
+  {0x10027, 0x10027, HB_Other_NotAssigned},
+  {0x10028, 0x1003a, HB_Letter_Other},
+  {0x1003b, 0x1003b, HB_Other_NotAssigned},
+  {0x1003c, 0x1003d, HB_Letter_Other},
+  {0x1003e, 0x1003e, HB_Other_NotAssigned},
+  {0x1003f, 0x1004d, HB_Letter_Other},
+  {0x1004e, 0x1004f, HB_Other_NotAssigned},
+  {0x10050, 0x1005d, HB_Letter_Other},
+  {0x1005e, 0x1007f, HB_Other_NotAssigned},
+  {0x10080, 0x100fa, HB_Letter_Other},
+  {0x100fb, 0x100ff, HB_Other_NotAssigned},
+  {0x10100, 0x10101, HB_Punctuation_Other},
+  {0x10102, 0x10102, HB_Symbol_Other},
+  {0x10103, 0x10106, HB_Other_NotAssigned},
+  {0x10107, 0x10133, HB_Number_Other},
+  {0x10134, 0x10136, HB_Other_NotAssigned},
+  {0x10137, 0x1013f, HB_Symbol_Other},
+  {0x10140, 0x10174, HB_Number_Letter},
+  {0x10175, 0x10178, HB_Number_Other},
+  {0x10179, 0x10189, HB_Symbol_Other},
+  {0x1018a, 0x1018a, HB_Number_Other},
+  {0x1018b, 0x1018f, HB_Other_NotAssigned},
+  {0x10190, 0x1019b, HB_Symbol_Other},
+  {0x1019c, 0x101cf, HB_Other_NotAssigned},
+  {0x101d0, 0x101fc, HB_Symbol_Other},
+  {0x101fd, 0x101fd, HB_Mark_NonSpacing},
+  {0x101fe, 0x1027f, HB_Other_NotAssigned},
+  {0x10280, 0x1029c, HB_Letter_Other},
+  {0x1029d, 0x1029f, HB_Other_NotAssigned},
+  {0x102a0, 0x102d0, HB_Letter_Other},
+  {0x102d1, 0x102ff, HB_Other_NotAssigned},
+  {0x10300, 0x1031e, HB_Letter_Other},
+  {0x1031f, 0x1031f, HB_Other_NotAssigned},
+  {0x10320, 0x10323, HB_Number_Other},
+  {0x10324, 0x1032f, HB_Other_NotAssigned},
+  {0x10330, 0x10340, HB_Letter_Other},
+  {0x10341, 0x10341, HB_Number_Letter},
+  {0x10342, 0x10349, HB_Letter_Other},
+  {0x1034a, 0x1034a, HB_Number_Letter},
+  {0x1034b, 0x1037f, HB_Other_NotAssigned},
+  {0x10380, 0x1039d, HB_Letter_Other},
+  {0x1039e, 0x1039e, HB_Other_NotAssigned},
+  {0x1039f, 0x1039f, HB_Punctuation_Other},
+  {0x103a0, 0x103c3, HB_Letter_Other},
+  {0x103c4, 0x103c7, HB_Other_NotAssigned},
+  {0x103c8, 0x103cf, HB_Letter_Other},
+  {0x103d0, 0x103d0, HB_Punctuation_Other},
+  {0x103d1, 0x103d5, HB_Number_Letter},
+  {0x103d6, 0x103ff, HB_Other_NotAssigned},
+  {0x10400, 0x10427, HB_Letter_Uppercase},
+  {0x10428, 0x1044f, HB_Letter_Lowercase},
+  {0x10450, 0x1049d, HB_Letter_Other},
+  {0x1049e, 0x1049f, HB_Other_NotAssigned},
+  {0x104a0, 0x104a9, HB_Number_DecimalDigit},
+  {0x104aa, 0x107ff, HB_Other_NotAssigned},
+  {0x10800, 0x10805, HB_Letter_Other},
+  {0x10806, 0x10807, HB_Other_NotAssigned},
+  {0x10808, 0x10808, HB_Letter_Other},
+  {0x10809, 0x10809, HB_Other_NotAssigned},
+  {0x1080a, 0x10835, HB_Letter_Other},
+  {0x10836, 0x10836, HB_Other_NotAssigned},
+  {0x10837, 0x10838, HB_Letter_Other},
+  {0x10839, 0x1083b, HB_Other_NotAssigned},
+  {0x1083c, 0x1083c, HB_Letter_Other},
+  {0x1083d, 0x1083e, HB_Other_NotAssigned},
+  {0x1083f, 0x1083f, HB_Letter_Other},
+  {0x10840, 0x108ff, HB_Other_NotAssigned},
+  {0x10900, 0x10915, HB_Letter_Other},
+  {0x10916, 0x10919, HB_Number_Other},
+  {0x1091a, 0x1091e, HB_Other_NotAssigned},
+  {0x1091f, 0x1091f, HB_Punctuation_Other},
+  {0x10920, 0x10939, HB_Letter_Other},
+  {0x1093a, 0x1093e, HB_Other_NotAssigned},
+  {0x1093f, 0x1093f, HB_Punctuation_Other},
+  {0x10940, 0x109ff, HB_Other_NotAssigned},
+  {0x10a00, 0x10a00, HB_Letter_Other},
+  {0x10a01, 0x10a03, HB_Mark_NonSpacing},
+  {0x10a04, 0x10a04, HB_Other_NotAssigned},
+  {0x10a05, 0x10a06, HB_Mark_NonSpacing},
+  {0x10a07, 0x10a0b, HB_Other_NotAssigned},
+  {0x10a0c, 0x10a0f, HB_Mark_NonSpacing},
+  {0x10a10, 0x10a13, HB_Letter_Other},
+  {0x10a14, 0x10a14, HB_Other_NotAssigned},
+  {0x10a15, 0x10a17, HB_Letter_Other},
+  {0x10a18, 0x10a18, HB_Other_NotAssigned},
+  {0x10a19, 0x10a33, HB_Letter_Other},
+  {0x10a34, 0x10a37, HB_Other_NotAssigned},
+  {0x10a38, 0x10a3a, HB_Mark_NonSpacing},
+  {0x10a3b, 0x10a3e, HB_Other_NotAssigned},
+  {0x10a3f, 0x10a3f, HB_Mark_NonSpacing},
+  {0x10a40, 0x10a47, HB_Number_Other},
+  {0x10a48, 0x10a4f, HB_Other_NotAssigned},
+  {0x10a50, 0x10a58, HB_Punctuation_Other},
+  {0x10a59, 0x11fff, HB_Other_NotAssigned},
+  {0x12000, 0x1236e, HB_Letter_Other},
+  {0x1236f, 0x123ff, HB_Other_NotAssigned},
+  {0x12400, 0x12462, HB_Number_Letter},
+  {0x12463, 0x1246f, HB_Other_NotAssigned},
+  {0x12470, 0x12473, HB_Punctuation_Other},
+  {0x12474, 0x1cfff, HB_Other_NotAssigned},
+  {0x1d000, 0x1d0f5, HB_Symbol_Other},
+  {0x1d0f6, 0x1d0ff, HB_Other_NotAssigned},
+  {0x1d100, 0x1d126, HB_Symbol_Other},
+  {0x1d127, 0x1d128, HB_Other_NotAssigned},
+  {0x1d129, 0x1d164, HB_Symbol_Other},
+  {0x1d165, 0x1d166, HB_Mark_SpacingCombining},
+  {0x1d167, 0x1d169, HB_Mark_NonSpacing},
+  {0x1d16a, 0x1d16c, HB_Symbol_Other},
+  {0x1d16d, 0x1d172, HB_Mark_SpacingCombining},
+  {0x1d173, 0x1d17a, HB_Other_Format},
+  {0x1d17b, 0x1d182, HB_Mark_NonSpacing},
+  {0x1d183, 0x1d184, HB_Symbol_Other},
+  {0x1d185, 0x1d18b, HB_Mark_NonSpacing},
+  {0x1d18c, 0x1d1a9, HB_Symbol_Other},
+  {0x1d1aa, 0x1d1ad, HB_Mark_NonSpacing},
+  {0x1d1ae, 0x1d1dd, HB_Symbol_Other},
+  {0x1d1de, 0x1d1ff, HB_Other_NotAssigned},
+  {0x1d200, 0x1d241, HB_Symbol_Other},
+  {0x1d242, 0x1d244, HB_Mark_NonSpacing},
+  {0x1d245, 0x1d245, HB_Symbol_Other},
+  {0x1d246, 0x1d2ff, HB_Other_NotAssigned},
+  {0x1d300, 0x1d356, HB_Symbol_Other},
+  {0x1d357, 0x1d35f, HB_Other_NotAssigned},
+  {0x1d360, 0x1d371, HB_Number_Other},
+  {0x1d372, 0x1d3ff, HB_Other_NotAssigned},
+  {0x1d400, 0x1d419, HB_Letter_Uppercase},
+  {0x1d41a, 0x1d433, HB_Letter_Lowercase},
+  {0x1d434, 0x1d44d, HB_Letter_Uppercase},
+  {0x1d44e, 0x1d454, HB_Letter_Lowercase},
+  {0x1d455, 0x1d455, HB_Other_NotAssigned},
+  {0x1d456, 0x1d467, HB_Letter_Lowercase},
+  {0x1d468, 0x1d481, HB_Letter_Uppercase},
+  {0x1d482, 0x1d49b, HB_Letter_Lowercase},
+  {0x1d49c, 0x1d49c, HB_Letter_Uppercase},
+  {0x1d49d, 0x1d49d, HB_Other_NotAssigned},
+  {0x1d49e, 0x1d49f, HB_Letter_Uppercase},
+  {0x1d4a0, 0x1d4a1, HB_Other_NotAssigned},
+  {0x1d4a2, 0x1d4a2, HB_Letter_Uppercase},
+  {0x1d4a3, 0x1d4a4, HB_Other_NotAssigned},
+  {0x1d4a5, 0x1d4a6, HB_Letter_Uppercase},
+  {0x1d4a7, 0x1d4a8, HB_Other_NotAssigned},
+  {0x1d4a9, 0x1d4ac, HB_Letter_Uppercase},
+  {0x1d4ad, 0x1d4ad, HB_Other_NotAssigned},
+  {0x1d4ae, 0x1d4b5, HB_Letter_Uppercase},
+  {0x1d4b6, 0x1d4b9, HB_Letter_Lowercase},
+  {0x1d4ba, 0x1d4ba, HB_Other_NotAssigned},
+  {0x1d4bb, 0x1d4bb, HB_Letter_Lowercase},
+  {0x1d4bc, 0x1d4bc, HB_Other_NotAssigned},
+  {0x1d4bd, 0x1d4c3, HB_Letter_Lowercase},
+  {0x1d4c4, 0x1d4c4, HB_Other_NotAssigned},
+  {0x1d4c5, 0x1d4cf, HB_Letter_Lowercase},
+  {0x1d4d0, 0x1d4e9, HB_Letter_Uppercase},
+  {0x1d4ea, 0x1d503, HB_Letter_Lowercase},
+  {0x1d504, 0x1d505, HB_Letter_Uppercase},
+  {0x1d506, 0x1d506, HB_Other_NotAssigned},
+  {0x1d507, 0x1d50a, HB_Letter_Uppercase},
+  {0x1d50b, 0x1d50c, HB_Other_NotAssigned},
+  {0x1d50d, 0x1d514, HB_Letter_Uppercase},
+  {0x1d515, 0x1d515, HB_Other_NotAssigned},
+  {0x1d516, 0x1d51c, HB_Letter_Uppercase},
+  {0x1d51d, 0x1d51d, HB_Other_NotAssigned},
+  {0x1d51e, 0x1d537, HB_Letter_Lowercase},
+  {0x1d538, 0x1d539, HB_Letter_Uppercase},
+  {0x1d53a, 0x1d53a, HB_Other_NotAssigned},
+  {0x1d53b, 0x1d53e, HB_Letter_Uppercase},
+  {0x1d53f, 0x1d53f, HB_Other_NotAssigned},
+  {0x1d540, 0x1d544, HB_Letter_Uppercase},
+  {0x1d545, 0x1d545, HB_Other_NotAssigned},
+  {0x1d546, 0x1d546, HB_Letter_Uppercase},
+  {0x1d547, 0x1d549, HB_Other_NotAssigned},
+  {0x1d54a, 0x1d550, HB_Letter_Uppercase},
+  {0x1d551, 0x1d551, HB_Other_NotAssigned},
+  {0x1d552, 0x1d56b, HB_Letter_Lowercase},
+  {0x1d56c, 0x1d585, HB_Letter_Uppercase},
+  {0x1d586, 0x1d59f, HB_Letter_Lowercase},
+  {0x1d5a0, 0x1d5b9, HB_Letter_Uppercase},
+  {0x1d5ba, 0x1d5d3, HB_Letter_Lowercase},
+  {0x1d5d4, 0x1d5ed, HB_Letter_Uppercase},
+  {0x1d5ee, 0x1d607, HB_Letter_Lowercase},
+  {0x1d608, 0x1d621, HB_Letter_Uppercase},
+  {0x1d622, 0x1d63b, HB_Letter_Lowercase},
+  {0x1d63c, 0x1d655, HB_Letter_Uppercase},
+  {0x1d656, 0x1d66f, HB_Letter_Lowercase},
+  {0x1d670, 0x1d689, HB_Letter_Uppercase},
+  {0x1d68a, 0x1d6a5, HB_Letter_Lowercase},
+  {0x1d6a6, 0x1d6a7, HB_Other_NotAssigned},
+  {0x1d6a8, 0x1d6c0, HB_Letter_Uppercase},
+  {0x1d6c1, 0x1d6c1, HB_Symbol_Math},
+  {0x1d6c2, 0x1d6da, HB_Letter_Lowercase},
+  {0x1d6db, 0x1d6db, HB_Symbol_Math},
+  {0x1d6dc, 0x1d6e1, HB_Letter_Lowercase},
+  {0x1d6e2, 0x1d6fa, HB_Letter_Uppercase},
+  {0x1d6fb, 0x1d6fb, HB_Symbol_Math},
+  {0x1d6fc, 0x1d714, HB_Letter_Lowercase},
+  {0x1d715, 0x1d715, HB_Symbol_Math},
+  {0x1d716, 0x1d71b, HB_Letter_Lowercase},
+  {0x1d71c, 0x1d734, HB_Letter_Uppercase},
+  {0x1d735, 0x1d735, HB_Symbol_Math},
+  {0x1d736, 0x1d74e, HB_Letter_Lowercase},
+  {0x1d74f, 0x1d74f, HB_Symbol_Math},
+  {0x1d750, 0x1d755, HB_Letter_Lowercase},
+  {0x1d756, 0x1d76e, HB_Letter_Uppercase},
+  {0x1d76f, 0x1d76f, HB_Symbol_Math},
+  {0x1d770, 0x1d788, HB_Letter_Lowercase},
+  {0x1d789, 0x1d789, HB_Symbol_Math},
+  {0x1d78a, 0x1d78f, HB_Letter_Lowercase},
+  {0x1d790, 0x1d7a8, HB_Letter_Uppercase},
+  {0x1d7a9, 0x1d7a9, HB_Symbol_Math},
+  {0x1d7aa, 0x1d7c2, HB_Letter_Lowercase},
+  {0x1d7c3, 0x1d7c3, HB_Symbol_Math},
+  {0x1d7c4, 0x1d7c9, HB_Letter_Lowercase},
+  {0x1d7ca, 0x1d7ca, HB_Letter_Uppercase},
+  {0x1d7cb, 0x1d7cb, HB_Letter_Lowercase},
+  {0x1d7cc, 0x1d7cd, HB_Other_NotAssigned},
+  {0x1d7ce, 0x1d7ff, HB_Number_DecimalDigit},
+  {0x1d800, 0x1efff, HB_Other_NotAssigned},
+  {0x1f000, 0x1f02b, HB_Symbol_Other},
+  {0x1f02c, 0x1f02f, HB_Other_NotAssigned},
+  {0x1f030, 0x1f093, HB_Symbol_Other},
+  {0x1f094, 0x1ffff, HB_Other_NotAssigned},
+  {0x20000, 0x2a6d6, HB_Letter_Other},
+  {0x2a6d7, 0x2f7ff, HB_Other_NotAssigned},
+  {0x2f800, 0x2fa1d, HB_Letter_Other},
+  {0x2fa1e, 0xe0000, HB_Other_NotAssigned},
+  {0xe0001, 0xe0001, HB_Other_Format},
+  {0xe0002, 0xe001f, HB_Other_NotAssigned},
+  {0xe0020, 0xe007f, HB_Other_Format},
+  {0xe0080, 0xe00ff, HB_Other_NotAssigned},
+  {0xe0100, 0xe01ef, HB_Mark_NonSpacing},
+  {0xe01f0, 0xeffff, HB_Other_NotAssigned},
+  {0xf0000, 0xffffd, HB_Other_PrivateUse},
+  {0xffffe, 0xfffff, HB_Other_NotAssigned},
+  {0x100000, 0x10fffd, HB_Other_PrivateUse},
+  {0x10fffe, 0x10ffff, HB_Other_NotAssigned},
+};
+
+static const unsigned category_properties_count = 2849;
+
+#endif  // CATEGORY_PROPERTIES_H_
diff -rupN orginal/scribus/harfbuzz/tables/combining-properties.h patched/scribus/harfbuzz/tables/combining-properties.h
--- orginal/scribus/harfbuzz/tables/combining-properties.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/tables/combining-properties.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,247 @@
+// Generated from Unicode tables
+
+#ifndef COMBINING_PROPERTIES_H_
+#define COMBINING_PROPERTIES_H_
+
+#include <stdint.h>
+struct combining_property {
+  uint32_t range_start;
+  uint32_t range_end;
+  uint8_t klass;
+};
+
+static const struct combining_property combining_properties[] = {
+  {0x300, 0x314, 230},
+  {0x315, 0x315, 232},
+  {0x316, 0x319, 220},
+  {0x31a, 0x31a, 232},
+  {0x31b, 0x31b, 216},
+  {0x31c, 0x320, 220},
+  {0x321, 0x322, 202},
+  {0x323, 0x326, 220},
+  {0x327, 0x328, 202},
+  {0x329, 0x333, 220},
+  {0x334, 0x338, 1},
+  {0x339, 0x33c, 220},
+  {0x33d, 0x344, 230},
+  {0x345, 0x345, 240},
+  {0x346, 0x346, 230},
+  {0x347, 0x349, 220},
+  {0x34a, 0x34c, 230},
+  {0x34d, 0x34e, 220},
+  {0x350, 0x352, 230},
+  {0x353, 0x356, 220},
+  {0x357, 0x357, 230},
+  {0x358, 0x358, 232},
+  {0x359, 0x35a, 220},
+  {0x35b, 0x35b, 230},
+  {0x35c, 0x35c, 233},
+  {0x35d, 0x35e, 234},
+  {0x35f, 0x35f, 233},
+  {0x360, 0x361, 234},
+  {0x362, 0x362, 233},
+  {0x363, 0x36f, 230},
+  {0x483, 0x487, 230},
+  {0x591, 0x591, 220},
+  {0x592, 0x595, 230},
+  {0x596, 0x596, 220},
+  {0x597, 0x599, 230},
+  {0x59a, 0x59a, 222},
+  {0x59b, 0x59b, 220},
+  {0x59c, 0x5a1, 230},
+  {0x5a2, 0x5a7, 220},
+  {0x5a8, 0x5a9, 230},
+  {0x5aa, 0x5aa, 220},
+  {0x5ab, 0x5ac, 230},
+  {0x5ad, 0x5ad, 222},
+  {0x5ae, 0x5ae, 228},
+  {0x5af, 0x5af, 230},
+  {0x5b0, 0x5b0, 10},
+  {0x5b1, 0x5b1, 11},
+  {0x5b2, 0x5b2, 12},
+  {0x5b3, 0x5b3, 13},
+  {0x5b4, 0x5b4, 14},
+  {0x5b5, 0x5b5, 15},
+  {0x5b6, 0x5b6, 16},
+  {0x5b7, 0x5b7, 17},
+  {0x5b8, 0x5b8, 18},
+  {0x5b9, 0x5ba, 19},
+  {0x5bb, 0x5bb, 20},
+  {0x5bc, 0x5bc, 21},
+  {0x5bd, 0x5bd, 22},
+  {0x5bf, 0x5bf, 23},
+  {0x5c1, 0x5c1, 24},
+  {0x5c2, 0x5c2, 25},
+  {0x5c4, 0x5c4, 230},
+  {0x5c5, 0x5c5, 220},
+  {0x5c7, 0x5c7, 18},
+  {0x610, 0x617, 230},
+  {0x618, 0x618, 30},
+  {0x619, 0x619, 31},
+  {0x61a, 0x61a, 32},
+  {0x64b, 0x64b, 27},
+  {0x64c, 0x64c, 28},
+  {0x64d, 0x64d, 29},
+  {0x64e, 0x64e, 30},
+  {0x64f, 0x64f, 31},
+  {0x650, 0x650, 32},
+  {0x651, 0x651, 33},
+  {0x652, 0x652, 34},
+  {0x653, 0x654, 230},
+  {0x655, 0x656, 220},
+  {0x657, 0x65b, 230},
+  {0x65c, 0x65c, 220},
+  {0x65d, 0x65e, 230},
+  {0x670, 0x670, 35},
+  {0x6d6, 0x6dc, 230},
+  {0x6df, 0x6e2, 230},
+  {0x6e3, 0x6e3, 220},
+  {0x6e4, 0x6e4, 230},
+  {0x6e7, 0x6e8, 230},
+  {0x6ea, 0x6ea, 220},
+  {0x6eb, 0x6ec, 230},
+  {0x6ed, 0x6ed, 220},
+  {0x711, 0x711, 36},
+  {0x730, 0x730, 230},
+  {0x731, 0x731, 220},
+  {0x732, 0x733, 230},
+  {0x734, 0x734, 220},
+  {0x735, 0x736, 230},
+  {0x737, 0x739, 220},
+  {0x73a, 0x73a, 230},
+  {0x73b, 0x73c, 220},
+  {0x73d, 0x73d, 230},
+  {0x73e, 0x73e, 220},
+  {0x73f, 0x741, 230},
+  {0x742, 0x742, 220},
+  {0x743, 0x743, 230},
+  {0x744, 0x744, 220},
+  {0x745, 0x745, 230},
+  {0x746, 0x746, 220},
+  {0x747, 0x747, 230},
+  {0x748, 0x748, 220},
+  {0x749, 0x74a, 230},
+  {0x7eb, 0x7f1, 230},
+  {0x7f2, 0x7f2, 220},
+  {0x7f3, 0x7f3, 230},
+  {0x93c, 0x93c, 7},
+  {0x94d, 0x94d, 9},
+  {0x951, 0x951, 230},
+  {0x952, 0x952, 220},
+  {0x953, 0x954, 230},
+  {0x9bc, 0x9bc, 7},
+  {0x9cd, 0x9cd, 9},
+  {0xa3c, 0xa3c, 7},
+  {0xa4d, 0xa4d, 9},
+  {0xabc, 0xabc, 7},
+  {0xacd, 0xacd, 9},
+  {0xb3c, 0xb3c, 7},
+  {0xb4d, 0xb4d, 9},
+  {0xbcd, 0xbcd, 9},
+  {0xc4d, 0xc4d, 9},
+  {0xc55, 0xc55, 84},
+  {0xc56, 0xc56, 91},
+  {0xcbc, 0xcbc, 7},
+  {0xccd, 0xccd, 9},
+  {0xd4d, 0xd4d, 9},
+  {0xdca, 0xdca, 9},
+  {0xe38, 0xe39, 103},
+  {0xe3a, 0xe3a, 9},
+  {0xe48, 0xe4b, 107},
+  {0xeb8, 0xeb9, 118},
+  {0xec8, 0xecb, 122},
+  {0xf18, 0xf19, 220},
+  {0xf35, 0xf35, 220},
+  {0xf37, 0xf37, 220},
+  {0xf39, 0xf39, 216},
+  {0xf71, 0xf71, 129},
+  {0xf72, 0xf72, 130},
+  {0xf74, 0xf74, 132},
+  {0xf7a, 0xf7d, 130},
+  {0xf80, 0xf80, 130},
+  {0xf82, 0xf83, 230},
+  {0xf84, 0xf84, 9},
+  {0xf86, 0xf87, 230},
+  {0xfc6, 0xfc6, 220},
+  {0x1037, 0x1037, 7},
+  {0x1039, 0x103a, 9},
+  {0x108d, 0x108d, 220},
+  {0x135f, 0x135f, 230},
+  {0x1714, 0x1714, 9},
+  {0x1734, 0x1734, 9},
+  {0x17d2, 0x17d2, 9},
+  {0x17dd, 0x17dd, 230},
+  {0x18a9, 0x18a9, 228},
+  {0x1939, 0x1939, 222},
+  {0x193a, 0x193a, 230},
+  {0x193b, 0x193b, 220},
+  {0x1a17, 0x1a17, 230},
+  {0x1a18, 0x1a18, 220},
+  {0x1b34, 0x1b34, 7},
+  {0x1b44, 0x1b44, 9},
+  {0x1b6b, 0x1b6b, 230},
+  {0x1b6c, 0x1b6c, 220},
+  {0x1b6d, 0x1b73, 230},
+  {0x1baa, 0x1baa, 9},
+  {0x1c37, 0x1c37, 7},
+  {0x1dc0, 0x1dc1, 230},
+  {0x1dc2, 0x1dc2, 220},
+  {0x1dc3, 0x1dc9, 230},
+  {0x1dca, 0x1dca, 220},
+  {0x1dcb, 0x1dcc, 230},
+  {0x1dcd, 0x1dcd, 234},
+  {0x1dce, 0x1dce, 214},
+  {0x1dcf, 0x1dcf, 220},
+  {0x1dd0, 0x1dd0, 202},
+  {0x1dd1, 0x1de6, 230},
+  {0x1dfe, 0x1dfe, 230},
+  {0x1dff, 0x1dff, 220},
+  {0x20d0, 0x20d1, 230},
+  {0x20d2, 0x20d3, 1},
+  {0x20d4, 0x20d7, 230},
+  {0x20d8, 0x20da, 1},
+  {0x20db, 0x20dc, 230},
+  {0x20e1, 0x20e1, 230},
+  {0x20e5, 0x20e6, 1},
+  {0x20e7, 0x20e7, 230},
+  {0x20e8, 0x20e8, 220},
+  {0x20e9, 0x20e9, 230},
+  {0x20ea, 0x20eb, 1},
+  {0x20ec, 0x20ef, 220},
+  {0x20f0, 0x20f0, 230},
+  {0x2de0, 0x2dff, 230},
+  {0x302a, 0x302a, 218},
+  {0x302b, 0x302b, 228},
+  {0x302c, 0x302c, 232},
+  {0x302d, 0x302d, 222},
+  {0x302e, 0x302f, 224},
+  {0x3099, 0x309a, 8},
+  {0xa66f, 0xa66f, 230},
+  {0xa67c, 0xa67d, 230},
+  {0xa806, 0xa806, 9},
+  {0xa8c4, 0xa8c4, 9},
+  {0xa92b, 0xa92d, 220},
+  {0xa953, 0xa953, 9},
+  {0xfb1e, 0xfb1e, 26},
+  {0xfe20, 0xfe26, 230},
+  {0x101fd, 0x101fd, 220},
+  {0x10a0d, 0x10a0d, 220},
+  {0x10a0f, 0x10a0f, 230},
+  {0x10a38, 0x10a38, 230},
+  {0x10a39, 0x10a39, 1},
+  {0x10a3a, 0x10a3a, 220},
+  {0x10a3f, 0x10a3f, 9},
+  {0x1d165, 0x1d166, 216},
+  {0x1d167, 0x1d169, 1},
+  {0x1d16d, 0x1d16d, 226},
+  {0x1d16e, 0x1d172, 216},
+  {0x1d17b, 0x1d182, 220},
+  {0x1d185, 0x1d189, 230},
+  {0x1d18a, 0x1d18b, 220},
+  {0x1d1aa, 0x1d1ad, 230},
+  {0x1d242, 0x1d244, 230},
+};
+
+static const unsigned combining_properties_count = 229;
+
+#endif  // COMBINING_PROPERTIES_H_
diff -rupN orginal/scribus/harfbuzz/tables/grapheme-break-properties.h patched/scribus/harfbuzz/tables/grapheme-break-properties.h
--- orginal/scribus/harfbuzz/tables/grapheme-break-properties.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/tables/grapheme-break-properties.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,1174 @@
+// Generated from Unicode Grapheme break tables
+
+#ifndef GRAPHEME_BREAK_PROPERTY_H_
+#define GRAPHEME_BREAK_PROPERTY_H_
+
+#include <stdint.h>
+#include "harfbuzz-external.h"
+
+struct grapheme_break_property {
+  uint32_t range_start;
+  uint32_t range_end;
+  HB_GraphemeClass klass;
+};
+
+static const struct grapheme_break_property grapheme_break_properties[] = {
+  {0x0, 0x9, HB_Grapheme_Control},
+  {0xa, 0xa, HB_Grapheme_LF},
+  {0xb, 0xc, HB_Grapheme_Control},
+  {0xd, 0xd, HB_Grapheme_CR},
+  {0xe, 0x1f, HB_Grapheme_Control},
+  {0x7f, 0x9f, HB_Grapheme_Control},
+  {0xad, 0xad, HB_Grapheme_Control},
+  {0x300, 0x36f, HB_Grapheme_Extend},
+  {0x483, 0x487, HB_Grapheme_Extend},
+  {0x488, 0x489, HB_Grapheme_Extend},
+  {0x591, 0x5bd, HB_Grapheme_Extend},
+  {0x5bf, 0x5bf, HB_Grapheme_Extend},
+  {0x5c1, 0x5c2, HB_Grapheme_Extend},
+  {0x5c4, 0x5c5, HB_Grapheme_Extend},
+  {0x5c7, 0x5c7, HB_Grapheme_Extend},
+  {0x600, 0x603, HB_Grapheme_Control},
+  {0x610, 0x61a, HB_Grapheme_Extend},
+  {0x64b, 0x65e, HB_Grapheme_Extend},
+  {0x670, 0x670, HB_Grapheme_Extend},
+  {0x6d6, 0x6dc, HB_Grapheme_Extend},
+  {0x6dd, 0x6dd, HB_Grapheme_Control},
+  {0x6de, 0x6de, HB_Grapheme_Extend},
+  {0x6df, 0x6e4, HB_Grapheme_Extend},
+  {0x6e7, 0x6e8, HB_Grapheme_Extend},
+  {0x6ea, 0x6ed, HB_Grapheme_Extend},
+  {0x70f, 0x70f, HB_Grapheme_Control},
+  {0x711, 0x711, HB_Grapheme_Extend},
+  {0x730, 0x74a, HB_Grapheme_Extend},
+  {0x7a6, 0x7b0, HB_Grapheme_Extend},
+  {0x7eb, 0x7f3, HB_Grapheme_Extend},
+  {0x816, 0x819, HB_Grapheme_Extend},
+  {0x81b, 0x823, HB_Grapheme_Extend},
+  {0x825, 0x827, HB_Grapheme_Extend},
+  {0x829, 0x82d, HB_Grapheme_Extend},
+  {0x900, 0x902, HB_Grapheme_Extend},
+  {0x903, 0x903, HB_Grapheme_Other},
+  {0x93c, 0x93c, HB_Grapheme_Extend},
+  {0x93e, 0x940, HB_Grapheme_Other},
+  {0x941, 0x948, HB_Grapheme_Extend},
+  {0x949, 0x94c, HB_Grapheme_Other},
+  {0x94d, 0x94d, HB_Grapheme_Extend},
+  {0x94e, 0x94e, HB_Grapheme_Other},
+  {0x951, 0x955, HB_Grapheme_Extend},
+  {0x962, 0x963, HB_Grapheme_Extend},
+  {0x981, 0x981, HB_Grapheme_Extend},
+  {0x982, 0x983, HB_Grapheme_Other},
+  {0x9bc, 0x9bc, HB_Grapheme_Extend},
+  {0x9be, 0x9be, HB_Grapheme_Extend},
+  {0x9bf, 0x9c0, HB_Grapheme_Other},
+  {0x9c1, 0x9c4, HB_Grapheme_Extend},
+  {0x9c7, 0x9c8, HB_Grapheme_Other},
+  {0x9cb, 0x9cc, HB_Grapheme_Other},
+  {0x9cd, 0x9cd, HB_Grapheme_Extend},
+  {0x9d7, 0x9d7, HB_Grapheme_Extend},
+  {0x9e2, 0x9e3, HB_Grapheme_Extend},
+  {0xa01, 0xa02, HB_Grapheme_Extend},
+  {0xa03, 0xa03, HB_Grapheme_Other},
+  {0xa3c, 0xa3c, HB_Grapheme_Extend},
+  {0xa3e, 0xa40, HB_Grapheme_Other},
+  {0xa41, 0xa42, HB_Grapheme_Extend},
+  {0xa47, 0xa48, HB_Grapheme_Extend},
+  {0xa4b, 0xa4d, HB_Grapheme_Extend},
+  {0xa51, 0xa51, HB_Grapheme_Extend},
+  {0xa70, 0xa71, HB_Grapheme_Extend},
+  {0xa75, 0xa75, HB_Grapheme_Extend},
+  {0xa81, 0xa82, HB_Grapheme_Extend},
+  {0xa83, 0xa83, HB_Grapheme_Other},
+  {0xabc, 0xabc, HB_Grapheme_Extend},
+  {0xabe, 0xac0, HB_Grapheme_Other},
+  {0xac1, 0xac5, HB_Grapheme_Extend},
+  {0xac7, 0xac8, HB_Grapheme_Extend},
+  {0xac9, 0xac9, HB_Grapheme_Other},
+  {0xacb, 0xacc, HB_Grapheme_Other},
+  {0xacd, 0xacd, HB_Grapheme_Extend},
+  {0xae2, 0xae3, HB_Grapheme_Extend},
+  {0xb01, 0xb01, HB_Grapheme_Extend},
+  {0xb02, 0xb03, HB_Grapheme_Other},
+  {0xb3c, 0xb3c, HB_Grapheme_Extend},
+  {0xb3e, 0xb3e, HB_Grapheme_Extend},
+  {0xb3f, 0xb3f, HB_Grapheme_Extend},
+  {0xb40, 0xb40, HB_Grapheme_Other},
+  {0xb41, 0xb44, HB_Grapheme_Extend},
+  {0xb47, 0xb48, HB_Grapheme_Other},
+  {0xb4b, 0xb4c, HB_Grapheme_Other},
+  {0xb4d, 0xb4d, HB_Grapheme_Extend},
+  {0xb56, 0xb56, HB_Grapheme_Extend},
+  {0xb57, 0xb57, HB_Grapheme_Extend},
+  {0xb62, 0xb63, HB_Grapheme_Extend},
+  {0xb82, 0xb82, HB_Grapheme_Extend},
+  {0xbbe, 0xbbe, HB_Grapheme_Extend},
+  {0xbbf, 0xbbf, HB_Grapheme_Other},
+  {0xbc0, 0xbc0, HB_Grapheme_Extend},
+  {0xbc1, 0xbc2, HB_Grapheme_Other},
+  {0xbc6, 0xbc8, HB_Grapheme_Other},
+  {0xbca, 0xbcc, HB_Grapheme_Other},
+  {0xbcd, 0xbcd, HB_Grapheme_Extend},
+  {0xbd7, 0xbd7, HB_Grapheme_Extend},
+  {0xc01, 0xc03, HB_Grapheme_Other},
+  {0xc3e, 0xc40, HB_Grapheme_Extend},
+  {0xc41, 0xc44, HB_Grapheme_Other},
+  {0xc46, 0xc48, HB_Grapheme_Extend},
+  {0xc4a, 0xc4d, HB_Grapheme_Extend},
+  {0xc55, 0xc56, HB_Grapheme_Extend},
+  {0xc62, 0xc63, HB_Grapheme_Extend},
+  {0xc82, 0xc83, HB_Grapheme_Other},
+  {0xcbc, 0xcbc, HB_Grapheme_Extend},
+  {0xcbe, 0xcbe, HB_Grapheme_Other},
+  {0xcbf, 0xcbf, HB_Grapheme_Extend},
+  {0xcc0, 0xcc1, HB_Grapheme_Other},
+  {0xcc2, 0xcc2, HB_Grapheme_Extend},
+  {0xcc3, 0xcc4, HB_Grapheme_Other},
+  {0xcc6, 0xcc6, HB_Grapheme_Extend},
+  {0xcc7, 0xcc8, HB_Grapheme_Other},
+  {0xcca, 0xccb, HB_Grapheme_Other},
+  {0xccc, 0xccd, HB_Grapheme_Extend},
+  {0xcd5, 0xcd6, HB_Grapheme_Extend},
+  {0xce2, 0xce3, HB_Grapheme_Extend},
+  {0xd02, 0xd03, HB_Grapheme_Other},
+  {0xd3e, 0xd3e, HB_Grapheme_Extend},
+  {0xd3f, 0xd40, HB_Grapheme_Other},
+  {0xd41, 0xd44, HB_Grapheme_Extend},
+  {0xd46, 0xd48, HB_Grapheme_Other},
+  {0xd4a, 0xd4c, HB_Grapheme_Other},
+  {0xd4d, 0xd4d, HB_Grapheme_Extend},
+  {0xd57, 0xd57, HB_Grapheme_Extend},
+  {0xd62, 0xd63, HB_Grapheme_Extend},
+  {0xd82, 0xd83, HB_Grapheme_Other},
+  {0xdca, 0xdca, HB_Grapheme_Extend},
+  {0xdcf, 0xdcf, HB_Grapheme_Extend},
+  {0xdd0, 0xdd1, HB_Grapheme_Other},
+  {0xdd2, 0xdd4, HB_Grapheme_Extend},
+  {0xdd6, 0xdd6, HB_Grapheme_Extend},
+  {0xdd8, 0xdde, HB_Grapheme_Other},
+  {0xddf, 0xddf, HB_Grapheme_Extend},
+  {0xdf2, 0xdf3, HB_Grapheme_Other},
+  {0xe30, 0xe30, HB_Grapheme_Extend},
+  {0xe31, 0xe31, HB_Grapheme_Extend},
+  {0xe32, 0xe33, HB_Grapheme_Extend},
+  {0xe34, 0xe3a, HB_Grapheme_Extend},
+  {0xe40, 0xe44, HB_Grapheme_Other},
+  {0xe45, 0xe45, HB_Grapheme_Extend},
+  {0xe47, 0xe4e, HB_Grapheme_Extend},
+  {0xeb0, 0xeb0, HB_Grapheme_Extend},
+  {0xeb1, 0xeb1, HB_Grapheme_Extend},
+  {0xeb2, 0xeb3, HB_Grapheme_Extend},
+  {0xeb4, 0xeb9, HB_Grapheme_Extend},
+  {0xebb, 0xebc, HB_Grapheme_Extend},
+  {0xec0, 0xec4, HB_Grapheme_Other},
+  {0xec8, 0xecd, HB_Grapheme_Extend},
+  {0xf18, 0xf19, HB_Grapheme_Extend},
+  {0xf35, 0xf35, HB_Grapheme_Extend},
+  {0xf37, 0xf37, HB_Grapheme_Extend},
+  {0xf39, 0xf39, HB_Grapheme_Extend},
+  {0xf3e, 0xf3f, HB_Grapheme_Other},
+  {0xf71, 0xf7e, HB_Grapheme_Extend},
+  {0xf7f, 0xf7f, HB_Grapheme_Other},
+  {0xf80, 0xf84, HB_Grapheme_Extend},
+  {0xf86, 0xf87, HB_Grapheme_Extend},
+  {0xf90, 0xf97, HB_Grapheme_Extend},
+  {0xf99, 0xfbc, HB_Grapheme_Extend},
+  {0xfc6, 0xfc6, HB_Grapheme_Extend},
+  {0x102b, 0x102c, HB_Grapheme_Other},
+  {0x102d, 0x1030, HB_Grapheme_Extend},
+  {0x1031, 0x1031, HB_Grapheme_Other},
+  {0x1032, 0x1037, HB_Grapheme_Extend},
+  {0x1038, 0x1038, HB_Grapheme_Other},
+  {0x1039, 0x103a, HB_Grapheme_Extend},
+  {0x103b, 0x103c, HB_Grapheme_Other},
+  {0x103d, 0x103e, HB_Grapheme_Extend},
+  {0x1056, 0x1057, HB_Grapheme_Other},
+  {0x1058, 0x1059, HB_Grapheme_Extend},
+  {0x105e, 0x1060, HB_Grapheme_Extend},
+  {0x1062, 0x1064, HB_Grapheme_Other},
+  {0x1067, 0x106d, HB_Grapheme_Other},
+  {0x1071, 0x1074, HB_Grapheme_Extend},
+  {0x1082, 0x1082, HB_Grapheme_Extend},
+  {0x1083, 0x1084, HB_Grapheme_Other},
+  {0x1085, 0x1086, HB_Grapheme_Extend},
+  {0x1087, 0x108c, HB_Grapheme_Other},
+  {0x108d, 0x108d, HB_Grapheme_Extend},
+  {0x108f, 0x108f, HB_Grapheme_Other},
+  {0x109a, 0x109c, HB_Grapheme_Other},
+  {0x109d, 0x109d, HB_Grapheme_Extend},
+  {0x1100, 0x115f, HB_Grapheme_L},
+  {0x1160, 0x11a7, HB_Grapheme_V},
+  {0x11a8, 0x11ff, HB_Grapheme_T},
+  {0x135f, 0x135f, HB_Grapheme_Extend},
+  {0x1712, 0x1714, HB_Grapheme_Extend},
+  {0x1732, 0x1734, HB_Grapheme_Extend},
+  {0x1752, 0x1753, HB_Grapheme_Extend},
+  {0x1772, 0x1773, HB_Grapheme_Extend},
+  {0x17b4, 0x17b5, HB_Grapheme_Control},
+  {0x17b6, 0x17b6, HB_Grapheme_Other},
+  {0x17b7, 0x17bd, HB_Grapheme_Extend},
+  {0x17be, 0x17c5, HB_Grapheme_Other},
+  {0x17c6, 0x17c6, HB_Grapheme_Extend},
+  {0x17c7, 0x17c8, HB_Grapheme_Other},
+  {0x17c9, 0x17d3, HB_Grapheme_Extend},
+  {0x17dd, 0x17dd, HB_Grapheme_Extend},
+  {0x180b, 0x180d, HB_Grapheme_Extend},
+  {0x18a9, 0x18a9, HB_Grapheme_Extend},
+  {0x1920, 0x1922, HB_Grapheme_Extend},
+  {0x1923, 0x1926, HB_Grapheme_Other},
+  {0x1927, 0x1928, HB_Grapheme_Extend},
+  {0x1929, 0x192b, HB_Grapheme_Other},
+  {0x1930, 0x1931, HB_Grapheme_Other},
+  {0x1932, 0x1932, HB_Grapheme_Extend},
+  {0x1933, 0x1938, HB_Grapheme_Other},
+  {0x1939, 0x193b, HB_Grapheme_Extend},
+  {0x19b0, 0x19c0, HB_Grapheme_Other},
+  {0x19c8, 0x19c9, HB_Grapheme_Other},
+  {0x1a17, 0x1a18, HB_Grapheme_Extend},
+  {0x1a19, 0x1a1b, HB_Grapheme_Other},
+  {0x1a55, 0x1a55, HB_Grapheme_Other},
+  {0x1a56, 0x1a56, HB_Grapheme_Extend},
+  {0x1a57, 0x1a57, HB_Grapheme_Other},
+  {0x1a58, 0x1a5e, HB_Grapheme_Extend},
+  {0x1a60, 0x1a60, HB_Grapheme_Extend},
+  {0x1a61, 0x1a61, HB_Grapheme_Other},
+  {0x1a62, 0x1a62, HB_Grapheme_Extend},
+  {0x1a63, 0x1a64, HB_Grapheme_Other},
+  {0x1a65, 0x1a6c, HB_Grapheme_Extend},
+  {0x1a6d, 0x1a72, HB_Grapheme_Other},
+  {0x1a73, 0x1a7c, HB_Grapheme_Extend},
+  {0x1a7f, 0x1a7f, HB_Grapheme_Extend},
+  {0x1b00, 0x1b03, HB_Grapheme_Extend},
+  {0x1b04, 0x1b04, HB_Grapheme_Other},
+  {0x1b34, 0x1b34, HB_Grapheme_Extend},
+  {0x1b35, 0x1b35, HB_Grapheme_Other},
+  {0x1b36, 0x1b3a, HB_Grapheme_Extend},
+  {0x1b3b, 0x1b3b, HB_Grapheme_Other},
+  {0x1b3c, 0x1b3c, HB_Grapheme_Extend},
+  {0x1b3d, 0x1b41, HB_Grapheme_Other},
+  {0x1b42, 0x1b42, HB_Grapheme_Extend},
+  {0x1b43, 0x1b44, HB_Grapheme_Other},
+  {0x1b6b, 0x1b73, HB_Grapheme_Extend},
+  {0x1b80, 0x1b81, HB_Grapheme_Extend},
+  {0x1b82, 0x1b82, HB_Grapheme_Other},
+  {0x1ba1, 0x1ba1, HB_Grapheme_Other},
+  {0x1ba2, 0x1ba5, HB_Grapheme_Extend},
+  {0x1ba6, 0x1ba7, HB_Grapheme_Other},
+  {0x1ba8, 0x1ba9, HB_Grapheme_Extend},
+  {0x1baa, 0x1baa, HB_Grapheme_Other},
+  {0x1c24, 0x1c2b, HB_Grapheme_Other},
+  {0x1c2c, 0x1c33, HB_Grapheme_Extend},
+  {0x1c34, 0x1c35, HB_Grapheme_Other},
+  {0x1c36, 0x1c37, HB_Grapheme_Extend},
+  {0x1cd0, 0x1cd2, HB_Grapheme_Extend},
+  {0x1cd4, 0x1ce0, HB_Grapheme_Extend},
+  {0x1ce1, 0x1ce1, HB_Grapheme_Other},
+  {0x1ce2, 0x1ce8, HB_Grapheme_Extend},
+  {0x1ced, 0x1ced, HB_Grapheme_Extend},
+  {0x1cf2, 0x1cf2, HB_Grapheme_Other},
+  {0x1dc0, 0x1de6, HB_Grapheme_Extend},
+  {0x1dfd, 0x1dff, HB_Grapheme_Extend},
+  {0x200b, 0x200b, HB_Grapheme_Control},
+  {0x200c, 0x200d, HB_Grapheme_Extend},
+  {0x200e, 0x200f, HB_Grapheme_Control},
+  {0x2028, 0x2028, HB_Grapheme_Control},
+  {0x2029, 0x2029, HB_Grapheme_Control},
+  {0x202a, 0x202e, HB_Grapheme_Control},
+  {0x2060, 0x2064, HB_Grapheme_Control},
+  {0x206a, 0x206f, HB_Grapheme_Control},
+  {0x20d0, 0x20dc, HB_Grapheme_Extend},
+  {0x20dd, 0x20e0, HB_Grapheme_Extend},
+  {0x20e1, 0x20e1, HB_Grapheme_Extend},
+  {0x20e2, 0x20e4, HB_Grapheme_Extend},
+  {0x20e5, 0x20f0, HB_Grapheme_Extend},
+  {0x2cef, 0x2cf1, HB_Grapheme_Extend},
+  {0x2de0, 0x2dff, HB_Grapheme_Extend},
+  {0x302a, 0x302f, HB_Grapheme_Extend},
+  {0x3099, 0x309a, HB_Grapheme_Extend},
+  {0xa66f, 0xa66f, HB_Grapheme_Extend},
+  {0xa670, 0xa672, HB_Grapheme_Extend},
+  {0xa67c, 0xa67d, HB_Grapheme_Extend},
+  {0xa6f0, 0xa6f1, HB_Grapheme_Extend},
+  {0xa802, 0xa802, HB_Grapheme_Extend},
+  {0xa806, 0xa806, HB_Grapheme_Extend},
+  {0xa80b, 0xa80b, HB_Grapheme_Extend},
+  {0xa823, 0xa824, HB_Grapheme_Other},
+  {0xa825, 0xa826, HB_Grapheme_Extend},
+  {0xa827, 0xa827, HB_Grapheme_Other},
+  {0xa880, 0xa881, HB_Grapheme_Other},
+  {0xa8b4, 0xa8c3, HB_Grapheme_Other},
+  {0xa8c4, 0xa8c4, HB_Grapheme_Extend},
+  {0xa8e0, 0xa8f1, HB_Grapheme_Extend},
+  {0xa926, 0xa92d, HB_Grapheme_Extend},
+  {0xa947, 0xa951, HB_Grapheme_Extend},
+  {0xa952, 0xa953, HB_Grapheme_Other},
+  {0xa960, 0xa97c, HB_Grapheme_L},
+  {0xa980, 0xa982, HB_Grapheme_Extend},
+  {0xa983, 0xa983, HB_Grapheme_Other},
+  {0xa9b3, 0xa9b3, HB_Grapheme_Extend},
+  {0xa9b4, 0xa9b5, HB_Grapheme_Other},
+  {0xa9b6, 0xa9b9, HB_Grapheme_Extend},
+  {0xa9ba, 0xa9bb, HB_Grapheme_Other},
+  {0xa9bc, 0xa9bc, HB_Grapheme_Extend},
+  {0xa9bd, 0xa9c0, HB_Grapheme_Other},
+  {0xaa29, 0xaa2e, HB_Grapheme_Extend},
+  {0xaa2f, 0xaa30, HB_Grapheme_Other},
+  {0xaa31, 0xaa32, HB_Grapheme_Extend},
+  {0xaa33, 0xaa34, HB_Grapheme_Other},
+  {0xaa35, 0xaa36, HB_Grapheme_Extend},
+  {0xaa43, 0xaa43, HB_Grapheme_Extend},
+  {0xaa4c, 0xaa4c, HB_Grapheme_Extend},
+  {0xaa4d, 0xaa4d, HB_Grapheme_Other},
+  {0xaa7b, 0xaa7b, HB_Grapheme_Other},
+  {0xaab0, 0xaab0, HB_Grapheme_Extend},
+  {0xaab2, 0xaab4, HB_Grapheme_Extend},
+  {0xaab5, 0xaab6, HB_Grapheme_Other},
+  {0xaab7, 0xaab8, HB_Grapheme_Extend},
+  {0xaab9, 0xaab9, HB_Grapheme_Other},
+  {0xaabb, 0xaabc, HB_Grapheme_Other},
+  {0xaabe, 0xaabf, HB_Grapheme_Extend},
+  {0xaac1, 0xaac1, HB_Grapheme_Extend},
+  {0xabe3, 0xabe4, HB_Grapheme_Other},
+  {0xabe5, 0xabe5, HB_Grapheme_Extend},
+  {0xabe6, 0xabe7, HB_Grapheme_Other},
+  {0xabe8, 0xabe8, HB_Grapheme_Extend},
+  {0xabe9, 0xabea, HB_Grapheme_Other},
+  {0xabec, 0xabec, HB_Grapheme_Other},
+  {0xabed, 0xabed, HB_Grapheme_Extend},
+  {0xac00, 0xac00, HB_Grapheme_LV},
+  {0xac01, 0xac1b, HB_Grapheme_LVT},
+  {0xac1c, 0xac1c, HB_Grapheme_LV},
+  {0xac1d, 0xac37, HB_Grapheme_LVT},
+  {0xac38, 0xac38, HB_Grapheme_LV},
+  {0xac39, 0xac53, HB_Grapheme_LVT},
+  {0xac54, 0xac54, HB_Grapheme_LV},
+  {0xac55, 0xac6f, HB_Grapheme_LVT},
+  {0xac70, 0xac70, HB_Grapheme_LV},
+  {0xac71, 0xac8b, HB_Grapheme_LVT},
+  {0xac8c, 0xac8c, HB_Grapheme_LV},
+  {0xac8d, 0xaca7, HB_Grapheme_LVT},
+  {0xaca8, 0xaca8, HB_Grapheme_LV},
+  {0xaca9, 0xacc3, HB_Grapheme_LVT},
+  {0xacc4, 0xacc4, HB_Grapheme_LV},
+  {0xacc5, 0xacdf, HB_Grapheme_LVT},
+  {0xace0, 0xace0, HB_Grapheme_LV},
+  {0xace1, 0xacfb, HB_Grapheme_LVT},
+  {0xacfc, 0xacfc, HB_Grapheme_LV},
+  {0xacfd, 0xad17, HB_Grapheme_LVT},
+  {0xad18, 0xad18, HB_Grapheme_LV},
+  {0xad19, 0xad33, HB_Grapheme_LVT},
+  {0xad34, 0xad34, HB_Grapheme_LV},
+  {0xad35, 0xad4f, HB_Grapheme_LVT},
+  {0xad50, 0xad50, HB_Grapheme_LV},
+  {0xad51, 0xad6b, HB_Grapheme_LVT},
+  {0xad6c, 0xad6c, HB_Grapheme_LV},
+  {0xad6d, 0xad87, HB_Grapheme_LVT},
+  {0xad88, 0xad88, HB_Grapheme_LV},
+  {0xad89, 0xada3, HB_Grapheme_LVT},
+  {0xada4, 0xada4, HB_Grapheme_LV},
+  {0xada5, 0xadbf, HB_Grapheme_LVT},
+  {0xadc0, 0xadc0, HB_Grapheme_LV},
+  {0xadc1, 0xaddb, HB_Grapheme_LVT},
+  {0xaddc, 0xaddc, HB_Grapheme_LV},
+  {0xaddd, 0xadf7, HB_Grapheme_LVT},
+  {0xadf8, 0xadf8, HB_Grapheme_LV},
+  {0xadf9, 0xae13, HB_Grapheme_LVT},
+  {0xae14, 0xae14, HB_Grapheme_LV},
+  {0xae15, 0xae2f, HB_Grapheme_LVT},
+  {0xae30, 0xae30, HB_Grapheme_LV},
+  {0xae31, 0xae4b, HB_Grapheme_LVT},
+  {0xae4c, 0xae4c, HB_Grapheme_LV},
+  {0xae4d, 0xae67, HB_Grapheme_LVT},
+  {0xae68, 0xae68, HB_Grapheme_LV},
+  {0xae69, 0xae83, HB_Grapheme_LVT},
+  {0xae84, 0xae84, HB_Grapheme_LV},
+  {0xae85, 0xae9f, HB_Grapheme_LVT},
+  {0xaea0, 0xaea0, HB_Grapheme_LV},
+  {0xaea1, 0xaebb, HB_Grapheme_LVT},
+  {0xaebc, 0xaebc, HB_Grapheme_LV},
+  {0xaebd, 0xaed7, HB_Grapheme_LVT},
+  {0xaed8, 0xaed8, HB_Grapheme_LV},
+  {0xaed9, 0xaef3, HB_Grapheme_LVT},
+  {0xaef4, 0xaef4, HB_Grapheme_LV},
+  {0xaef5, 0xaf0f, HB_Grapheme_LVT},
+  {0xaf10, 0xaf10, HB_Grapheme_LV},
+  {0xaf11, 0xaf2b, HB_Grapheme_LVT},
+  {0xaf2c, 0xaf2c, HB_Grapheme_LV},
+  {0xaf2d, 0xaf47, HB_Grapheme_LVT},
+  {0xaf48, 0xaf48, HB_Grapheme_LV},
+  {0xaf49, 0xaf63, HB_Grapheme_LVT},
+  {0xaf64, 0xaf64, HB_Grapheme_LV},
+  {0xaf65, 0xaf7f, HB_Grapheme_LVT},
+  {0xaf80, 0xaf80, HB_Grapheme_LV},
+  {0xaf81, 0xaf9b, HB_Grapheme_LVT},
+  {0xaf9c, 0xaf9c, HB_Grapheme_LV},
+  {0xaf9d, 0xafb7, HB_Grapheme_LVT},
+  {0xafb8, 0xafb8, HB_Grapheme_LV},
+  {0xafb9, 0xafd3, HB_Grapheme_LVT},
+  {0xafd4, 0xafd4, HB_Grapheme_LV},
+  {0xafd5, 0xafef, HB_Grapheme_LVT},
+  {0xaff0, 0xaff0, HB_Grapheme_LV},
+  {0xaff1, 0xb00b, HB_Grapheme_LVT},
+  {0xb00c, 0xb00c, HB_Grapheme_LV},
+  {0xb00d, 0xb027, HB_Grapheme_LVT},
+  {0xb028, 0xb028, HB_Grapheme_LV},
+  {0xb029, 0xb043, HB_Grapheme_LVT},
+  {0xb044, 0xb044, HB_Grapheme_LV},
+  {0xb045, 0xb05f, HB_Grapheme_LVT},
+  {0xb060, 0xb060, HB_Grapheme_LV},
+  {0xb061, 0xb07b, HB_Grapheme_LVT},
+  {0xb07c, 0xb07c, HB_Grapheme_LV},
+  {0xb07d, 0xb097, HB_Grapheme_LVT},
+  {0xb098, 0xb098, HB_Grapheme_LV},
+  {0xb099, 0xb0b3, HB_Grapheme_LVT},
+  {0xb0b4, 0xb0b4, HB_Grapheme_LV},
+  {0xb0b5, 0xb0cf, HB_Grapheme_LVT},
+  {0xb0d0, 0xb0d0, HB_Grapheme_LV},
+  {0xb0d1, 0xb0eb, HB_Grapheme_LVT},
+  {0xb0ec, 0xb0ec, HB_Grapheme_LV},
+  {0xb0ed, 0xb107, HB_Grapheme_LVT},
+  {0xb108, 0xb108, HB_Grapheme_LV},
+  {0xb109, 0xb123, HB_Grapheme_LVT},
+  {0xb124, 0xb124, HB_Grapheme_LV},
+  {0xb125, 0xb13f, HB_Grapheme_LVT},
+  {0xb140, 0xb140, HB_Grapheme_LV},
+  {0xb141, 0xb15b, HB_Grapheme_LVT},
+  {0xb15c, 0xb15c, HB_Grapheme_LV},
+  {0xb15d, 0xb177, HB_Grapheme_LVT},
+  {0xb178, 0xb178, HB_Grapheme_LV},
+  {0xb179, 0xb193, HB_Grapheme_LVT},
+  {0xb194, 0xb194, HB_Grapheme_LV},
+  {0xb195, 0xb1af, HB_Grapheme_LVT},
+  {0xb1b0, 0xb1b0, HB_Grapheme_LV},
+  {0xb1b1, 0xb1cb, HB_Grapheme_LVT},
+  {0xb1cc, 0xb1cc, HB_Grapheme_LV},
+  {0xb1cd, 0xb1e7, HB_Grapheme_LVT},
+  {0xb1e8, 0xb1e8, HB_Grapheme_LV},
+  {0xb1e9, 0xb203, HB_Grapheme_LVT},
+  {0xb204, 0xb204, HB_Grapheme_LV},
+  {0xb205, 0xb21f, HB_Grapheme_LVT},
+  {0xb220, 0xb220, HB_Grapheme_LV},
+  {0xb221, 0xb23b, HB_Grapheme_LVT},
+  {0xb23c, 0xb23c, HB_Grapheme_LV},
+  {0xb23d, 0xb257, HB_Grapheme_LVT},
+  {0xb258, 0xb258, HB_Grapheme_LV},
+  {0xb259, 0xb273, HB_Grapheme_LVT},
+  {0xb274, 0xb274, HB_Grapheme_LV},
+  {0xb275, 0xb28f, HB_Grapheme_LVT},
+  {0xb290, 0xb290, HB_Grapheme_LV},
+  {0xb291, 0xb2ab, HB_Grapheme_LVT},
+  {0xb2ac, 0xb2ac, HB_Grapheme_LV},
+  {0xb2ad, 0xb2c7, HB_Grapheme_LVT},
+  {0xb2c8, 0xb2c8, HB_Grapheme_LV},
+  {0xb2c9, 0xb2e3, HB_Grapheme_LVT},
+  {0xb2e4, 0xb2e4, HB_Grapheme_LV},
+  {0xb2e5, 0xb2ff, HB_Grapheme_LVT},
+  {0xb300, 0xb300, HB_Grapheme_LV},
+  {0xb301, 0xb31b, HB_Grapheme_LVT},
+  {0xb31c, 0xb31c, HB_Grapheme_LV},
+  {0xb31d, 0xb337, HB_Grapheme_LVT},
+  {0xb338, 0xb338, HB_Grapheme_LV},
+  {0xb339, 0xb353, HB_Grapheme_LVT},
+  {0xb354, 0xb354, HB_Grapheme_LV},
+  {0xb355, 0xb36f, HB_Grapheme_LVT},
+  {0xb370, 0xb370, HB_Grapheme_LV},
+  {0xb371, 0xb38b, HB_Grapheme_LVT},
+  {0xb38c, 0xb38c, HB_Grapheme_LV},
+  {0xb38d, 0xb3a7, HB_Grapheme_LVT},
+  {0xb3a8, 0xb3a8, HB_Grapheme_LV},
+  {0xb3a9, 0xb3c3, HB_Grapheme_LVT},
+  {0xb3c4, 0xb3c4, HB_Grapheme_LV},
+  {0xb3c5, 0xb3df, HB_Grapheme_LVT},
+  {0xb3e0, 0xb3e0, HB_Grapheme_LV},
+  {0xb3e1, 0xb3fb, HB_Grapheme_LVT},
+  {0xb3fc, 0xb3fc, HB_Grapheme_LV},
+  {0xb3fd, 0xb417, HB_Grapheme_LVT},
+  {0xb418, 0xb418, HB_Grapheme_LV},
+  {0xb419, 0xb433, HB_Grapheme_LVT},
+  {0xb434, 0xb434, HB_Grapheme_LV},
+  {0xb435, 0xb44f, HB_Grapheme_LVT},
+  {0xb450, 0xb450, HB_Grapheme_LV},
+  {0xb451, 0xb46b, HB_Grapheme_LVT},
+  {0xb46c, 0xb46c, HB_Grapheme_LV},
+  {0xb46d, 0xb487, HB_Grapheme_LVT},
+  {0xb488, 0xb488, HB_Grapheme_LV},
+  {0xb489, 0xb4a3, HB_Grapheme_LVT},
+  {0xb4a4, 0xb4a4, HB_Grapheme_LV},
+  {0xb4a5, 0xb4bf, HB_Grapheme_LVT},
+  {0xb4c0, 0xb4c0, HB_Grapheme_LV},
+  {0xb4c1, 0xb4db, HB_Grapheme_LVT},
+  {0xb4dc, 0xb4dc, HB_Grapheme_LV},
+  {0xb4dd, 0xb4f7, HB_Grapheme_LVT},
+  {0xb4f8, 0xb4f8, HB_Grapheme_LV},
+  {0xb4f9, 0xb513, HB_Grapheme_LVT},
+  {0xb514, 0xb514, HB_Grapheme_LV},
+  {0xb515, 0xb52f, HB_Grapheme_LVT},
+  {0xb530, 0xb530, HB_Grapheme_LV},
+  {0xb531, 0xb54b, HB_Grapheme_LVT},
+  {0xb54c, 0xb54c, HB_Grapheme_LV},
+  {0xb54d, 0xb567, HB_Grapheme_LVT},
+  {0xb568, 0xb568, HB_Grapheme_LV},
+  {0xb569, 0xb583, HB_Grapheme_LVT},
+  {0xb584, 0xb584, HB_Grapheme_LV},
+  {0xb585, 0xb59f, HB_Grapheme_LVT},
+  {0xb5a0, 0xb5a0, HB_Grapheme_LV},
+  {0xb5a1, 0xb5bb, HB_Grapheme_LVT},
+  {0xb5bc, 0xb5bc, HB_Grapheme_LV},
+  {0xb5bd, 0xb5d7, HB_Grapheme_LVT},
+  {0xb5d8, 0xb5d8, HB_Grapheme_LV},
+  {0xb5d9, 0xb5f3, HB_Grapheme_LVT},
+  {0xb5f4, 0xb5f4, HB_Grapheme_LV},
+  {0xb5f5, 0xb60f, HB_Grapheme_LVT},
+  {0xb610, 0xb610, HB_Grapheme_LV},
+  {0xb611, 0xb62b, HB_Grapheme_LVT},
+  {0xb62c, 0xb62c, HB_Grapheme_LV},
+  {0xb62d, 0xb647, HB_Grapheme_LVT},
+  {0xb648, 0xb648, HB_Grapheme_LV},
+  {0xb649, 0xb663, HB_Grapheme_LVT},
+  {0xb664, 0xb664, HB_Grapheme_LV},
+  {0xb665, 0xb67f, HB_Grapheme_LVT},
+  {0xb680, 0xb680, HB_Grapheme_LV},
+  {0xb681, 0xb69b, HB_Grapheme_LVT},
+  {0xb69c, 0xb69c, HB_Grapheme_LV},
+  {0xb69d, 0xb6b7, HB_Grapheme_LVT},
+  {0xb6b8, 0xb6b8, HB_Grapheme_LV},
+  {0xb6b9, 0xb6d3, HB_Grapheme_LVT},
+  {0xb6d4, 0xb6d4, HB_Grapheme_LV},
+  {0xb6d5, 0xb6ef, HB_Grapheme_LVT},
+  {0xb6f0, 0xb6f0, HB_Grapheme_LV},
+  {0xb6f1, 0xb70b, HB_Grapheme_LVT},
+  {0xb70c, 0xb70c, HB_Grapheme_LV},
+  {0xb70d, 0xb727, HB_Grapheme_LVT},
+  {0xb728, 0xb728, HB_Grapheme_LV},
+  {0xb729, 0xb743, HB_Grapheme_LVT},
+  {0xb744, 0xb744, HB_Grapheme_LV},
+  {0xb745, 0xb75f, HB_Grapheme_LVT},
+  {0xb760, 0xb760, HB_Grapheme_LV},
+  {0xb761, 0xb77b, HB_Grapheme_LVT},
+  {0xb77c, 0xb77c, HB_Grapheme_LV},
+  {0xb77d, 0xb797, HB_Grapheme_LVT},
+  {0xb798, 0xb798, HB_Grapheme_LV},
+  {0xb799, 0xb7b3, HB_Grapheme_LVT},
+  {0xb7b4, 0xb7b4, HB_Grapheme_LV},
+  {0xb7b5, 0xb7cf, HB_Grapheme_LVT},
+  {0xb7d0, 0xb7d0, HB_Grapheme_LV},
+  {0xb7d1, 0xb7eb, HB_Grapheme_LVT},
+  {0xb7ec, 0xb7ec, HB_Grapheme_LV},
+  {0xb7ed, 0xb807, HB_Grapheme_LVT},
+  {0xb808, 0xb808, HB_Grapheme_LV},
+  {0xb809, 0xb823, HB_Grapheme_LVT},
+  {0xb824, 0xb824, HB_Grapheme_LV},
+  {0xb825, 0xb83f, HB_Grapheme_LVT},
+  {0xb840, 0xb840, HB_Grapheme_LV},
+  {0xb841, 0xb85b, HB_Grapheme_LVT},
+  {0xb85c, 0xb85c, HB_Grapheme_LV},
+  {0xb85d, 0xb877, HB_Grapheme_LVT},
+  {0xb878, 0xb878, HB_Grapheme_LV},
+  {0xb879, 0xb893, HB_Grapheme_LVT},
+  {0xb894, 0xb894, HB_Grapheme_LV},
+  {0xb895, 0xb8af, HB_Grapheme_LVT},
+  {0xb8b0, 0xb8b0, HB_Grapheme_LV},
+  {0xb8b1, 0xb8cb, HB_Grapheme_LVT},
+  {0xb8cc, 0xb8cc, HB_Grapheme_LV},
+  {0xb8cd, 0xb8e7, HB_Grapheme_LVT},
+  {0xb8e8, 0xb8e8, HB_Grapheme_LV},
+  {0xb8e9, 0xb903, HB_Grapheme_LVT},
+  {0xb904, 0xb904, HB_Grapheme_LV},
+  {0xb905, 0xb91f, HB_Grapheme_LVT},
+  {0xb920, 0xb920, HB_Grapheme_LV},
+  {0xb921, 0xb93b, HB_Grapheme_LVT},
+  {0xb93c, 0xb93c, HB_Grapheme_LV},
+  {0xb93d, 0xb957, HB_Grapheme_LVT},
+  {0xb958, 0xb958, HB_Grapheme_LV},
+  {0xb959, 0xb973, HB_Grapheme_LVT},
+  {0xb974, 0xb974, HB_Grapheme_LV},
+  {0xb975, 0xb98f, HB_Grapheme_LVT},
+  {0xb990, 0xb990, HB_Grapheme_LV},
+  {0xb991, 0xb9ab, HB_Grapheme_LVT},
+  {0xb9ac, 0xb9ac, HB_Grapheme_LV},
+  {0xb9ad, 0xb9c7, HB_Grapheme_LVT},
+  {0xb9c8, 0xb9c8, HB_Grapheme_LV},
+  {0xb9c9, 0xb9e3, HB_Grapheme_LVT},
+  {0xb9e4, 0xb9e4, HB_Grapheme_LV},
+  {0xb9e5, 0xb9ff, HB_Grapheme_LVT},
+  {0xba00, 0xba00, HB_Grapheme_LV},
+  {0xba01, 0xba1b, HB_Grapheme_LVT},
+  {0xba1c, 0xba1c, HB_Grapheme_LV},
+  {0xba1d, 0xba37, HB_Grapheme_LVT},
+  {0xba38, 0xba38, HB_Grapheme_LV},
+  {0xba39, 0xba53, HB_Grapheme_LVT},
+  {0xba54, 0xba54, HB_Grapheme_LV},
+  {0xba55, 0xba6f, HB_Grapheme_LVT},
+  {0xba70, 0xba70, HB_Grapheme_LV},
+  {0xba71, 0xba8b, HB_Grapheme_LVT},
+  {0xba8c, 0xba8c, HB_Grapheme_LV},
+  {0xba8d, 0xbaa7, HB_Grapheme_LVT},
+  {0xbaa8, 0xbaa8, HB_Grapheme_LV},
+  {0xbaa9, 0xbac3, HB_Grapheme_LVT},
+  {0xbac4, 0xbac4, HB_Grapheme_LV},
+  {0xbac5, 0xbadf, HB_Grapheme_LVT},
+  {0xbae0, 0xbae0, HB_Grapheme_LV},
+  {0xbae1, 0xbafb, HB_Grapheme_LVT},
+  {0xbafc, 0xbafc, HB_Grapheme_LV},
+  {0xbafd, 0xbb17, HB_Grapheme_LVT},
+  {0xbb18, 0xbb18, HB_Grapheme_LV},
+  {0xbb19, 0xbb33, HB_Grapheme_LVT},
+  {0xbb34, 0xbb34, HB_Grapheme_LV},
+  {0xbb35, 0xbb4f, HB_Grapheme_LVT},
+  {0xbb50, 0xbb50, HB_Grapheme_LV},
+  {0xbb51, 0xbb6b, HB_Grapheme_LVT},
+  {0xbb6c, 0xbb6c, HB_Grapheme_LV},
+  {0xbb6d, 0xbb87, HB_Grapheme_LVT},
+  {0xbb88, 0xbb88, HB_Grapheme_LV},
+  {0xbb89, 0xbba3, HB_Grapheme_LVT},
+  {0xbba4, 0xbba4, HB_Grapheme_LV},
+  {0xbba5, 0xbbbf, HB_Grapheme_LVT},
+  {0xbbc0, 0xbbc0, HB_Grapheme_LV},
+  {0xbbc1, 0xbbdb, HB_Grapheme_LVT},
+  {0xbbdc, 0xbbdc, HB_Grapheme_LV},
+  {0xbbdd, 0xbbf7, HB_Grapheme_LVT},
+  {0xbbf8, 0xbbf8, HB_Grapheme_LV},
+  {0xbbf9, 0xbc13, HB_Grapheme_LVT},
+  {0xbc14, 0xbc14, HB_Grapheme_LV},
+  {0xbc15, 0xbc2f, HB_Grapheme_LVT},
+  {0xbc30, 0xbc30, HB_Grapheme_LV},
+  {0xbc31, 0xbc4b, HB_Grapheme_LVT},
+  {0xbc4c, 0xbc4c, HB_Grapheme_LV},
+  {0xbc4d, 0xbc67, HB_Grapheme_LVT},
+  {0xbc68, 0xbc68, HB_Grapheme_LV},
+  {0xbc69, 0xbc83, HB_Grapheme_LVT},
+  {0xbc84, 0xbc84, HB_Grapheme_LV},
+  {0xbc85, 0xbc9f, HB_Grapheme_LVT},
+  {0xbca0, 0xbca0, HB_Grapheme_LV},
+  {0xbca1, 0xbcbb, HB_Grapheme_LVT},
+  {0xbcbc, 0xbcbc, HB_Grapheme_LV},
+  {0xbcbd, 0xbcd7, HB_Grapheme_LVT},
+  {0xbcd8, 0xbcd8, HB_Grapheme_LV},
+  {0xbcd9, 0xbcf3, HB_Grapheme_LVT},
+  {0xbcf4, 0xbcf4, HB_Grapheme_LV},
+  {0xbcf5, 0xbd0f, HB_Grapheme_LVT},
+  {0xbd10, 0xbd10, HB_Grapheme_LV},
+  {0xbd11, 0xbd2b, HB_Grapheme_LVT},
+  {0xbd2c, 0xbd2c, HB_Grapheme_LV},
+  {0xbd2d, 0xbd47, HB_Grapheme_LVT},
+  {0xbd48, 0xbd48, HB_Grapheme_LV},
+  {0xbd49, 0xbd63, HB_Grapheme_LVT},
+  {0xbd64, 0xbd64, HB_Grapheme_LV},
+  {0xbd65, 0xbd7f, HB_Grapheme_LVT},
+  {0xbd80, 0xbd80, HB_Grapheme_LV},
+  {0xbd81, 0xbd9b, HB_Grapheme_LVT},
+  {0xbd9c, 0xbd9c, HB_Grapheme_LV},
+  {0xbd9d, 0xbdb7, HB_Grapheme_LVT},
+  {0xbdb8, 0xbdb8, HB_Grapheme_LV},
+  {0xbdb9, 0xbdd3, HB_Grapheme_LVT},
+  {0xbdd4, 0xbdd4, HB_Grapheme_LV},
+  {0xbdd5, 0xbdef, HB_Grapheme_LVT},
+  {0xbdf0, 0xbdf0, HB_Grapheme_LV},
+  {0xbdf1, 0xbe0b, HB_Grapheme_LVT},
+  {0xbe0c, 0xbe0c, HB_Grapheme_LV},
+  {0xbe0d, 0xbe27, HB_Grapheme_LVT},
+  {0xbe28, 0xbe28, HB_Grapheme_LV},
+  {0xbe29, 0xbe43, HB_Grapheme_LVT},
+  {0xbe44, 0xbe44, HB_Grapheme_LV},
+  {0xbe45, 0xbe5f, HB_Grapheme_LVT},
+  {0xbe60, 0xbe60, HB_Grapheme_LV},
+  {0xbe61, 0xbe7b, HB_Grapheme_LVT},
+  {0xbe7c, 0xbe7c, HB_Grapheme_LV},
+  {0xbe7d, 0xbe97, HB_Grapheme_LVT},
+  {0xbe98, 0xbe98, HB_Grapheme_LV},
+  {0xbe99, 0xbeb3, HB_Grapheme_LVT},
+  {0xbeb4, 0xbeb4, HB_Grapheme_LV},
+  {0xbeb5, 0xbecf, HB_Grapheme_LVT},
+  {0xbed0, 0xbed0, HB_Grapheme_LV},
+  {0xbed1, 0xbeeb, HB_Grapheme_LVT},
+  {0xbeec, 0xbeec, HB_Grapheme_LV},
+  {0xbeed, 0xbf07, HB_Grapheme_LVT},
+  {0xbf08, 0xbf08, HB_Grapheme_LV},
+  {0xbf09, 0xbf23, HB_Grapheme_LVT},
+  {0xbf24, 0xbf24, HB_Grapheme_LV},
+  {0xbf25, 0xbf3f, HB_Grapheme_LVT},
+  {0xbf40, 0xbf40, HB_Grapheme_LV},
+  {0xbf41, 0xbf5b, HB_Grapheme_LVT},
+  {0xbf5c, 0xbf5c, HB_Grapheme_LV},
+  {0xbf5d, 0xbf77, HB_Grapheme_LVT},
+  {0xbf78, 0xbf78, HB_Grapheme_LV},
+  {0xbf79, 0xbf93, HB_Grapheme_LVT},
+  {0xbf94, 0xbf94, HB_Grapheme_LV},
+  {0xbf95, 0xbfaf, HB_Grapheme_LVT},
+  {0xbfb0, 0xbfb0, HB_Grapheme_LV},
+  {0xbfb1, 0xbfcb, HB_Grapheme_LVT},
+  {0xbfcc, 0xbfcc, HB_Grapheme_LV},
+  {0xbfcd, 0xbfe7, HB_Grapheme_LVT},
+  {0xbfe8, 0xbfe8, HB_Grapheme_LV},
+  {0xbfe9, 0xc003, HB_Grapheme_LVT},
+  {0xc004, 0xc004, HB_Grapheme_LV},
+  {0xc005, 0xc01f, HB_Grapheme_LVT},
+  {0xc020, 0xc020, HB_Grapheme_LV},
+  {0xc021, 0xc03b, HB_Grapheme_LVT},
+  {0xc03c, 0xc03c, HB_Grapheme_LV},
+  {0xc03d, 0xc057, HB_Grapheme_LVT},
+  {0xc058, 0xc058, HB_Grapheme_LV},
+  {0xc059, 0xc073, HB_Grapheme_LVT},
+  {0xc074, 0xc074, HB_Grapheme_LV},
+  {0xc075, 0xc08f, HB_Grapheme_LVT},
+  {0xc090, 0xc090, HB_Grapheme_LV},
+  {0xc091, 0xc0ab, HB_Grapheme_LVT},
+  {0xc0ac, 0xc0ac, HB_Grapheme_LV},
+  {0xc0ad, 0xc0c7, HB_Grapheme_LVT},
+  {0xc0c8, 0xc0c8, HB_Grapheme_LV},
+  {0xc0c9, 0xc0e3, HB_Grapheme_LVT},
+  {0xc0e4, 0xc0e4, HB_Grapheme_LV},
+  {0xc0e5, 0xc0ff, HB_Grapheme_LVT},
+  {0xc100, 0xc100, HB_Grapheme_LV},
+  {0xc101, 0xc11b, HB_Grapheme_LVT},
+  {0xc11c, 0xc11c, HB_Grapheme_LV},
+  {0xc11d, 0xc137, HB_Grapheme_LVT},
+  {0xc138, 0xc138, HB_Grapheme_LV},
+  {0xc139, 0xc153, HB_Grapheme_LVT},
+  {0xc154, 0xc154, HB_Grapheme_LV},
+  {0xc155, 0xc16f, HB_Grapheme_LVT},
+  {0xc170, 0xc170, HB_Grapheme_LV},
+  {0xc171, 0xc18b, HB_Grapheme_LVT},
+  {0xc18c, 0xc18c, HB_Grapheme_LV},
+  {0xc18d, 0xc1a7, HB_Grapheme_LVT},
+  {0xc1a8, 0xc1a8, HB_Grapheme_LV},
+  {0xc1a9, 0xc1c3, HB_Grapheme_LVT},
+  {0xc1c4, 0xc1c4, HB_Grapheme_LV},
+  {0xc1c5, 0xc1df, HB_Grapheme_LVT},
+  {0xc1e0, 0xc1e0, HB_Grapheme_LV},
+  {0xc1e1, 0xc1fb, HB_Grapheme_LVT},
+  {0xc1fc, 0xc1fc, HB_Grapheme_LV},
+  {0xc1fd, 0xc217, HB_Grapheme_LVT},
+  {0xc218, 0xc218, HB_Grapheme_LV},
+  {0xc219, 0xc233, HB_Grapheme_LVT},
+  {0xc234, 0xc234, HB_Grapheme_LV},
+  {0xc235, 0xc24f, HB_Grapheme_LVT},
+  {0xc250, 0xc250, HB_Grapheme_LV},
+  {0xc251, 0xc26b, HB_Grapheme_LVT},
+  {0xc26c, 0xc26c, HB_Grapheme_LV},
+  {0xc26d, 0xc287, HB_Grapheme_LVT},
+  {0xc288, 0xc288, HB_Grapheme_LV},
+  {0xc289, 0xc2a3, HB_Grapheme_LVT},
+  {0xc2a4, 0xc2a4, HB_Grapheme_LV},
+  {0xc2a5, 0xc2bf, HB_Grapheme_LVT},
+  {0xc2c0, 0xc2c0, HB_Grapheme_LV},
+  {0xc2c1, 0xc2db, HB_Grapheme_LVT},
+  {0xc2dc, 0xc2dc, HB_Grapheme_LV},
+  {0xc2dd, 0xc2f7, HB_Grapheme_LVT},
+  {0xc2f8, 0xc2f8, HB_Grapheme_LV},
+  {0xc2f9, 0xc313, HB_Grapheme_LVT},
+  {0xc314, 0xc314, HB_Grapheme_LV},
+  {0xc315, 0xc32f, HB_Grapheme_LVT},
+  {0xc330, 0xc330, HB_Grapheme_LV},
+  {0xc331, 0xc34b, HB_Grapheme_LVT},
+  {0xc34c, 0xc34c, HB_Grapheme_LV},
+  {0xc34d, 0xc367, HB_Grapheme_LVT},
+  {0xc368, 0xc368, HB_Grapheme_LV},
+  {0xc369, 0xc383, HB_Grapheme_LVT},
+  {0xc384, 0xc384, HB_Grapheme_LV},
+  {0xc385, 0xc39f, HB_Grapheme_LVT},
+  {0xc3a0, 0xc3a0, HB_Grapheme_LV},
+  {0xc3a1, 0xc3bb, HB_Grapheme_LVT},
+  {0xc3bc, 0xc3bc, HB_Grapheme_LV},
+  {0xc3bd, 0xc3d7, HB_Grapheme_LVT},
+  {0xc3d8, 0xc3d8, HB_Grapheme_LV},
+  {0xc3d9, 0xc3f3, HB_Grapheme_LVT},
+  {0xc3f4, 0xc3f4, HB_Grapheme_LV},
+  {0xc3f5, 0xc40f, HB_Grapheme_LVT},
+  {0xc410, 0xc410, HB_Grapheme_LV},
+  {0xc411, 0xc42b, HB_Grapheme_LVT},
+  {0xc42c, 0xc42c, HB_Grapheme_LV},
+  {0xc42d, 0xc447, HB_Grapheme_LVT},
+  {0xc448, 0xc448, HB_Grapheme_LV},
+  {0xc449, 0xc463, HB_Grapheme_LVT},
+  {0xc464, 0xc464, HB_Grapheme_LV},
+  {0xc465, 0xc47f, HB_Grapheme_LVT},
+  {0xc480, 0xc480, HB_Grapheme_LV},
+  {0xc481, 0xc49b, HB_Grapheme_LVT},
+  {0xc49c, 0xc49c, HB_Grapheme_LV},
+  {0xc49d, 0xc4b7, HB_Grapheme_LVT},
+  {0xc4b8, 0xc4b8, HB_Grapheme_LV},
+  {0xc4b9, 0xc4d3, HB_Grapheme_LVT},
+  {0xc4d4, 0xc4d4, HB_Grapheme_LV},
+  {0xc4d5, 0xc4ef, HB_Grapheme_LVT},
+  {0xc4f0, 0xc4f0, HB_Grapheme_LV},
+  {0xc4f1, 0xc50b, HB_Grapheme_LVT},
+  {0xc50c, 0xc50c, HB_Grapheme_LV},
+  {0xc50d, 0xc527, HB_Grapheme_LVT},
+  {0xc528, 0xc528, HB_Grapheme_LV},
+  {0xc529, 0xc543, HB_Grapheme_LVT},
+  {0xc544, 0xc544, HB_Grapheme_LV},
+  {0xc545, 0xc55f, HB_Grapheme_LVT},
+  {0xc560, 0xc560, HB_Grapheme_LV},
+  {0xc561, 0xc57b, HB_Grapheme_LVT},
+  {0xc57c, 0xc57c, HB_Grapheme_LV},
+  {0xc57d, 0xc597, HB_Grapheme_LVT},
+  {0xc598, 0xc598, HB_Grapheme_LV},
+  {0xc599, 0xc5b3, HB_Grapheme_LVT},
+  {0xc5b4, 0xc5b4, HB_Grapheme_LV},
+  {0xc5b5, 0xc5cf, HB_Grapheme_LVT},
+  {0xc5d0, 0xc5d0, HB_Grapheme_LV},
+  {0xc5d1, 0xc5eb, HB_Grapheme_LVT},
+  {0xc5ec, 0xc5ec, HB_Grapheme_LV},
+  {0xc5ed, 0xc607, HB_Grapheme_LVT},
+  {0xc608, 0xc608, HB_Grapheme_LV},
+  {0xc609, 0xc623, HB_Grapheme_LVT},
+  {0xc624, 0xc624, HB_Grapheme_LV},
+  {0xc625, 0xc63f, HB_Grapheme_LVT},
+  {0xc640, 0xc640, HB_Grapheme_LV},
+  {0xc641, 0xc65b, HB_Grapheme_LVT},
+  {0xc65c, 0xc65c, HB_Grapheme_LV},
+  {0xc65d, 0xc677, HB_Grapheme_LVT},
+  {0xc678, 0xc678, HB_Grapheme_LV},
+  {0xc679, 0xc693, HB_Grapheme_LVT},
+  {0xc694, 0xc694, HB_Grapheme_LV},
+  {0xc695, 0xc6af, HB_Grapheme_LVT},
+  {0xc6b0, 0xc6b0, HB_Grapheme_LV},
+  {0xc6b1, 0xc6cb, HB_Grapheme_LVT},
+  {0xc6cc, 0xc6cc, HB_Grapheme_LV},
+  {0xc6cd, 0xc6e7, HB_Grapheme_LVT},
+  {0xc6e8, 0xc6e8, HB_Grapheme_LV},
+  {0xc6e9, 0xc703, HB_Grapheme_LVT},
+  {0xc704, 0xc704, HB_Grapheme_LV},
+  {0xc705, 0xc71f, HB_Grapheme_LVT},
+  {0xc720, 0xc720, HB_Grapheme_LV},
+  {0xc721, 0xc73b, HB_Grapheme_LVT},
+  {0xc73c, 0xc73c, HB_Grapheme_LV},
+  {0xc73d, 0xc757, HB_Grapheme_LVT},
+  {0xc758, 0xc758, HB_Grapheme_LV},
+  {0xc759, 0xc773, HB_Grapheme_LVT},
+  {0xc774, 0xc774, HB_Grapheme_LV},
+  {0xc775, 0xc78f, HB_Grapheme_LVT},
+  {0xc790, 0xc790, HB_Grapheme_LV},
+  {0xc791, 0xc7ab, HB_Grapheme_LVT},
+  {0xc7ac, 0xc7ac, HB_Grapheme_LV},
+  {0xc7ad, 0xc7c7, HB_Grapheme_LVT},
+  {0xc7c8, 0xc7c8, HB_Grapheme_LV},
+  {0xc7c9, 0xc7e3, HB_Grapheme_LVT},
+  {0xc7e4, 0xc7e4, HB_Grapheme_LV},
+  {0xc7e5, 0xc7ff, HB_Grapheme_LVT},
+  {0xc800, 0xc800, HB_Grapheme_LV},
+  {0xc801, 0xc81b, HB_Grapheme_LVT},
+  {0xc81c, 0xc81c, HB_Grapheme_LV},
+  {0xc81d, 0xc837, HB_Grapheme_LVT},
+  {0xc838, 0xc838, HB_Grapheme_LV},
+  {0xc839, 0xc853, HB_Grapheme_LVT},
+  {0xc854, 0xc854, HB_Grapheme_LV},
+  {0xc855, 0xc86f, HB_Grapheme_LVT},
+  {0xc870, 0xc870, HB_Grapheme_LV},
+  {0xc871, 0xc88b, HB_Grapheme_LVT},
+  {0xc88c, 0xc88c, HB_Grapheme_LV},
+  {0xc88d, 0xc8a7, HB_Grapheme_LVT},
+  {0xc8a8, 0xc8a8, HB_Grapheme_LV},
+  {0xc8a9, 0xc8c3, HB_Grapheme_LVT},
+  {0xc8c4, 0xc8c4, HB_Grapheme_LV},
+  {0xc8c5, 0xc8df, HB_Grapheme_LVT},
+  {0xc8e0, 0xc8e0, HB_Grapheme_LV},
+  {0xc8e1, 0xc8fb, HB_Grapheme_LVT},
+  {0xc8fc, 0xc8fc, HB_Grapheme_LV},
+  {0xc8fd, 0xc917, HB_Grapheme_LVT},
+  {0xc918, 0xc918, HB_Grapheme_LV},
+  {0xc919, 0xc933, HB_Grapheme_LVT},
+  {0xc934, 0xc934, HB_Grapheme_LV},
+  {0xc935, 0xc94f, HB_Grapheme_LVT},
+  {0xc950, 0xc950, HB_Grapheme_LV},
+  {0xc951, 0xc96b, HB_Grapheme_LVT},
+  {0xc96c, 0xc96c, HB_Grapheme_LV},
+  {0xc96d, 0xc987, HB_Grapheme_LVT},
+  {0xc988, 0xc988, HB_Grapheme_LV},
+  {0xc989, 0xc9a3, HB_Grapheme_LVT},
+  {0xc9a4, 0xc9a4, HB_Grapheme_LV},
+  {0xc9a5, 0xc9bf, HB_Grapheme_LVT},
+  {0xc9c0, 0xc9c0, HB_Grapheme_LV},
+  {0xc9c1, 0xc9db, HB_Grapheme_LVT},
+  {0xc9dc, 0xc9dc, HB_Grapheme_LV},
+  {0xc9dd, 0xc9f7, HB_Grapheme_LVT},
+  {0xc9f8, 0xc9f8, HB_Grapheme_LV},
+  {0xc9f9, 0xca13, HB_Grapheme_LVT},
+  {0xca14, 0xca14, HB_Grapheme_LV},
+  {0xca15, 0xca2f, HB_Grapheme_LVT},
+  {0xca30, 0xca30, HB_Grapheme_LV},
+  {0xca31, 0xca4b, HB_Grapheme_LVT},
+  {0xca4c, 0xca4c, HB_Grapheme_LV},
+  {0xca4d, 0xca67, HB_Grapheme_LVT},
+  {0xca68, 0xca68, HB_Grapheme_LV},
+  {0xca69, 0xca83, HB_Grapheme_LVT},
+  {0xca84, 0xca84, HB_Grapheme_LV},
+  {0xca85, 0xca9f, HB_Grapheme_LVT},
+  {0xcaa0, 0xcaa0, HB_Grapheme_LV},
+  {0xcaa1, 0xcabb, HB_Grapheme_LVT},
+  {0xcabc, 0xcabc, HB_Grapheme_LV},
+  {0xcabd, 0xcad7, HB_Grapheme_LVT},
+  {0xcad8, 0xcad8, HB_Grapheme_LV},
+  {0xcad9, 0xcaf3, HB_Grapheme_LVT},
+  {0xcaf4, 0xcaf4, HB_Grapheme_LV},
+  {0xcaf5, 0xcb0f, HB_Grapheme_LVT},
+  {0xcb10, 0xcb10, HB_Grapheme_LV},
+  {0xcb11, 0xcb2b, HB_Grapheme_LVT},
+  {0xcb2c, 0xcb2c, HB_Grapheme_LV},
+  {0xcb2d, 0xcb47, HB_Grapheme_LVT},
+  {0xcb48, 0xcb48, HB_Grapheme_LV},
+  {0xcb49, 0xcb63, HB_Grapheme_LVT},
+  {0xcb64, 0xcb64, HB_Grapheme_LV},
+  {0xcb65, 0xcb7f, HB_Grapheme_LVT},
+  {0xcb80, 0xcb80, HB_Grapheme_LV},
+  {0xcb81, 0xcb9b, HB_Grapheme_LVT},
+  {0xcb9c, 0xcb9c, HB_Grapheme_LV},
+  {0xcb9d, 0xcbb7, HB_Grapheme_LVT},
+  {0xcbb8, 0xcbb8, HB_Grapheme_LV},
+  {0xcbb9, 0xcbd3, HB_Grapheme_LVT},
+  {0xcbd4, 0xcbd4, HB_Grapheme_LV},
+  {0xcbd5, 0xcbef, HB_Grapheme_LVT},
+  {0xcbf0, 0xcbf0, HB_Grapheme_LV},
+  {0xcbf1, 0xcc0b, HB_Grapheme_LVT},
+  {0xcc0c, 0xcc0c, HB_Grapheme_LV},
+  {0xcc0d, 0xcc27, HB_Grapheme_LVT},
+  {0xcc28, 0xcc28, HB_Grapheme_LV},
+  {0xcc29, 0xcc43, HB_Grapheme_LVT},
+  {0xcc44, 0xcc44, HB_Grapheme_LV},
+  {0xcc45, 0xcc5f, HB_Grapheme_LVT},
+  {0xcc60, 0xcc60, HB_Grapheme_LV},
+  {0xcc61, 0xcc7b, HB_Grapheme_LVT},
+  {0xcc7c, 0xcc7c, HB_Grapheme_LV},
+  {0xcc7d, 0xcc97, HB_Grapheme_LVT},
+  {0xcc98, 0xcc98, HB_Grapheme_LV},
+  {0xcc99, 0xccb3, HB_Grapheme_LVT},
+  {0xccb4, 0xccb4, HB_Grapheme_LV},
+  {0xccb5, 0xcccf, HB_Grapheme_LVT},
+  {0xccd0, 0xccd0, HB_Grapheme_LV},
+  {0xccd1, 0xcceb, HB_Grapheme_LVT},
+  {0xccec, 0xccec, HB_Grapheme_LV},
+  {0xcced, 0xcd07, HB_Grapheme_LVT},
+  {0xcd08, 0xcd08, HB_Grapheme_LV},
+  {0xcd09, 0xcd23, HB_Grapheme_LVT},
+  {0xcd24, 0xcd24, HB_Grapheme_LV},
+  {0xcd25, 0xcd3f, HB_Grapheme_LVT},
+  {0xcd40, 0xcd40, HB_Grapheme_LV},
+  {0xcd41, 0xcd5b, HB_Grapheme_LVT},
+  {0xcd5c, 0xcd5c, HB_Grapheme_LV},
+  {0xcd5d, 0xcd77, HB_Grapheme_LVT},
+  {0xcd78, 0xcd78, HB_Grapheme_LV},
+  {0xcd79, 0xcd93, HB_Grapheme_LVT},
+  {0xcd94, 0xcd94, HB_Grapheme_LV},
+  {0xcd95, 0xcdaf, HB_Grapheme_LVT},
+  {0xcdb0, 0xcdb0, HB_Grapheme_LV},
+  {0xcdb1, 0xcdcb, HB_Grapheme_LVT},
+  {0xcdcc, 0xcdcc, HB_Grapheme_LV},
+  {0xcdcd, 0xcde7, HB_Grapheme_LVT},
+  {0xcde8, 0xcde8, HB_Grapheme_LV},
+  {0xcde9, 0xce03, HB_Grapheme_LVT},
+  {0xce04, 0xce04, HB_Grapheme_LV},
+  {0xce05, 0xce1f, HB_Grapheme_LVT},
+  {0xce20, 0xce20, HB_Grapheme_LV},
+  {0xce21, 0xce3b, HB_Grapheme_LVT},
+  {0xce3c, 0xce3c, HB_Grapheme_LV},
+  {0xce3d, 0xce57, HB_Grapheme_LVT},
+  {0xce58, 0xce58, HB_Grapheme_LV},
+  {0xce59, 0xce73, HB_Grapheme_LVT},
+  {0xce74, 0xce74, HB_Grapheme_LV},
+  {0xce75, 0xce8f, HB_Grapheme_LVT},
+  {0xce90, 0xce90, HB_Grapheme_LV},
+  {0xce91, 0xceab, HB_Grapheme_LVT},
+  {0xceac, 0xceac, HB_Grapheme_LV},
+  {0xcead, 0xcec7, HB_Grapheme_LVT},
+  {0xcec8, 0xcec8, HB_Grapheme_LV},
+  {0xcec9, 0xcee3, HB_Grapheme_LVT},
+  {0xcee4, 0xcee4, HB_Grapheme_LV},
+  {0xcee5, 0xceff, HB_Grapheme_LVT},
+  {0xcf00, 0xcf00, HB_Grapheme_LV},
+  {0xcf01, 0xcf1b, HB_Grapheme_LVT},
+  {0xcf1c, 0xcf1c, HB_Grapheme_LV},
+  {0xcf1d, 0xcf37, HB_Grapheme_LVT},
+  {0xcf38, 0xcf38, HB_Grapheme_LV},
+  {0xcf39, 0xcf53, HB_Grapheme_LVT},
+  {0xcf54, 0xcf54, HB_Grapheme_LV},
+  {0xcf55, 0xcf6f, HB_Grapheme_LVT},
+  {0xcf70, 0xcf70, HB_Grapheme_LV},
+  {0xcf71, 0xcf8b, HB_Grapheme_LVT},
+  {0xcf8c, 0xcf8c, HB_Grapheme_LV},
+  {0xcf8d, 0xcfa7, HB_Grapheme_LVT},
+  {0xcfa8, 0xcfa8, HB_Grapheme_LV},
+  {0xcfa9, 0xcfc3, HB_Grapheme_LVT},
+  {0xcfc4, 0xcfc4, HB_Grapheme_LV},
+  {0xcfc5, 0xcfdf, HB_Grapheme_LVT},
+  {0xcfe0, 0xcfe0, HB_Grapheme_LV},
+  {0xcfe1, 0xcffb, HB_Grapheme_LVT},
+  {0xcffc, 0xcffc, HB_Grapheme_LV},
+  {0xcffd, 0xd017, HB_Grapheme_LVT},
+  {0xd018, 0xd018, HB_Grapheme_LV},
+  {0xd019, 0xd033, HB_Grapheme_LVT},
+  {0xd034, 0xd034, HB_Grapheme_LV},
+  {0xd035, 0xd04f, HB_Grapheme_LVT},
+  {0xd050, 0xd050, HB_Grapheme_LV},
+  {0xd051, 0xd06b, HB_Grapheme_LVT},
+  {0xd06c, 0xd06c, HB_Grapheme_LV},
+  {0xd06d, 0xd087, HB_Grapheme_LVT},
+  {0xd088, 0xd088, HB_Grapheme_LV},
+  {0xd089, 0xd0a3, HB_Grapheme_LVT},
+  {0xd0a4, 0xd0a4, HB_Grapheme_LV},
+  {0xd0a5, 0xd0bf, HB_Grapheme_LVT},
+  {0xd0c0, 0xd0c0, HB_Grapheme_LV},
+  {0xd0c1, 0xd0db, HB_Grapheme_LVT},
+  {0xd0dc, 0xd0dc, HB_Grapheme_LV},
+  {0xd0dd, 0xd0f7, HB_Grapheme_LVT},
+  {0xd0f8, 0xd0f8, HB_Grapheme_LV},
+  {0xd0f9, 0xd113, HB_Grapheme_LVT},
+  {0xd114, 0xd114, HB_Grapheme_LV},
+  {0xd115, 0xd12f, HB_Grapheme_LVT},
+  {0xd130, 0xd130, HB_Grapheme_LV},
+  {0xd131, 0xd14b, HB_Grapheme_LVT},
+  {0xd14c, 0xd14c, HB_Grapheme_LV},
+  {0xd14d, 0xd167, HB_Grapheme_LVT},
+  {0xd168, 0xd168, HB_Grapheme_LV},
+  {0xd169, 0xd183, HB_Grapheme_LVT},
+  {0xd184, 0xd184, HB_Grapheme_LV},
+  {0xd185, 0xd19f, HB_Grapheme_LVT},
+  {0xd1a0, 0xd1a0, HB_Grapheme_LV},
+  {0xd1a1, 0xd1bb, HB_Grapheme_LVT},
+  {0xd1bc, 0xd1bc, HB_Grapheme_LV},
+  {0xd1bd, 0xd1d7, HB_Grapheme_LVT},
+  {0xd1d8, 0xd1d8, HB_Grapheme_LV},
+  {0xd1d9, 0xd1f3, HB_Grapheme_LVT},
+  {0xd1f4, 0xd1f4, HB_Grapheme_LV},
+  {0xd1f5, 0xd20f, HB_Grapheme_LVT},
+  {0xd210, 0xd210, HB_Grapheme_LV},
+  {0xd211, 0xd22b, HB_Grapheme_LVT},
+  {0xd22c, 0xd22c, HB_Grapheme_LV},
+  {0xd22d, 0xd247, HB_Grapheme_LVT},
+  {0xd248, 0xd248, HB_Grapheme_LV},
+  {0xd249, 0xd263, HB_Grapheme_LVT},
+  {0xd264, 0xd264, HB_Grapheme_LV},
+  {0xd265, 0xd27f, HB_Grapheme_LVT},
+  {0xd280, 0xd280, HB_Grapheme_LV},
+  {0xd281, 0xd29b, HB_Grapheme_LVT},
+  {0xd29c, 0xd29c, HB_Grapheme_LV},
+  {0xd29d, 0xd2b7, HB_Grapheme_LVT},
+  {0xd2b8, 0xd2b8, HB_Grapheme_LV},
+  {0xd2b9, 0xd2d3, HB_Grapheme_LVT},
+  {0xd2d4, 0xd2d4, HB_Grapheme_LV},
+  {0xd2d5, 0xd2ef, HB_Grapheme_LVT},
+  {0xd2f0, 0xd2f0, HB_Grapheme_LV},
+  {0xd2f1, 0xd30b, HB_Grapheme_LVT},
+  {0xd30c, 0xd30c, HB_Grapheme_LV},
+  {0xd30d, 0xd327, HB_Grapheme_LVT},
+  {0xd328, 0xd328, HB_Grapheme_LV},
+  {0xd329, 0xd343, HB_Grapheme_LVT},
+  {0xd344, 0xd344, HB_Grapheme_LV},
+  {0xd345, 0xd35f, HB_Grapheme_LVT},
+  {0xd360, 0xd360, HB_Grapheme_LV},
+  {0xd361, 0xd37b, HB_Grapheme_LVT},
+  {0xd37c, 0xd37c, HB_Grapheme_LV},
+  {0xd37d, 0xd397, HB_Grapheme_LVT},
+  {0xd398, 0xd398, HB_Grapheme_LV},
+  {0xd399, 0xd3b3, HB_Grapheme_LVT},
+  {0xd3b4, 0xd3b4, HB_Grapheme_LV},
+  {0xd3b5, 0xd3cf, HB_Grapheme_LVT},
+  {0xd3d0, 0xd3d0, HB_Grapheme_LV},
+  {0xd3d1, 0xd3eb, HB_Grapheme_LVT},
+  {0xd3ec, 0xd3ec, HB_Grapheme_LV},
+  {0xd3ed, 0xd407, HB_Grapheme_LVT},
+  {0xd408, 0xd408, HB_Grapheme_LV},
+  {0xd409, 0xd423, HB_Grapheme_LVT},
+  {0xd424, 0xd424, HB_Grapheme_LV},
+  {0xd425, 0xd43f, HB_Grapheme_LVT},
+  {0xd440, 0xd440, HB_Grapheme_LV},
+  {0xd441, 0xd45b, HB_Grapheme_LVT},
+  {0xd45c, 0xd45c, HB_Grapheme_LV},
+  {0xd45d, 0xd477, HB_Grapheme_LVT},
+  {0xd478, 0xd478, HB_Grapheme_LV},
+  {0xd479, 0xd493, HB_Grapheme_LVT},
+  {0xd494, 0xd494, HB_Grapheme_LV},
+  {0xd495, 0xd4af, HB_Grapheme_LVT},
+  {0xd4b0, 0xd4b0, HB_Grapheme_LV},
+  {0xd4b1, 0xd4cb, HB_Grapheme_LVT},
+  {0xd4cc, 0xd4cc, HB_Grapheme_LV},
+  {0xd4cd, 0xd4e7, HB_Grapheme_LVT},
+  {0xd4e8, 0xd4e8, HB_Grapheme_LV},
+  {0xd4e9, 0xd503, HB_Grapheme_LVT},
+  {0xd504, 0xd504, HB_Grapheme_LV},
+  {0xd505, 0xd51f, HB_Grapheme_LVT},
+  {0xd520, 0xd520, HB_Grapheme_LV},
+  {0xd521, 0xd53b, HB_Grapheme_LVT},
+  {0xd53c, 0xd53c, HB_Grapheme_LV},
+  {0xd53d, 0xd557, HB_Grapheme_LVT},
+  {0xd558, 0xd558, HB_Grapheme_LV},
+  {0xd559, 0xd573, HB_Grapheme_LVT},
+  {0xd574, 0xd574, HB_Grapheme_LV},
+  {0xd575, 0xd58f, HB_Grapheme_LVT},
+  {0xd590, 0xd590, HB_Grapheme_LV},
+  {0xd591, 0xd5ab, HB_Grapheme_LVT},
+  {0xd5ac, 0xd5ac, HB_Grapheme_LV},
+  {0xd5ad, 0xd5c7, HB_Grapheme_LVT},
+  {0xd5c8, 0xd5c8, HB_Grapheme_LV},
+  {0xd5c9, 0xd5e3, HB_Grapheme_LVT},
+  {0xd5e4, 0xd5e4, HB_Grapheme_LV},
+  {0xd5e5, 0xd5ff, HB_Grapheme_LVT},
+  {0xd600, 0xd600, HB_Grapheme_LV},
+  {0xd601, 0xd61b, HB_Grapheme_LVT},
+  {0xd61c, 0xd61c, HB_Grapheme_LV},
+  {0xd61d, 0xd637, HB_Grapheme_LVT},
+  {0xd638, 0xd638, HB_Grapheme_LV},
+  {0xd639, 0xd653, HB_Grapheme_LVT},
+  {0xd654, 0xd654, HB_Grapheme_LV},
+  {0xd655, 0xd66f, HB_Grapheme_LVT},
+  {0xd670, 0xd670, HB_Grapheme_LV},
+  {0xd671, 0xd68b, HB_Grapheme_LVT},
+  {0xd68c, 0xd68c, HB_Grapheme_LV},
+  {0xd68d, 0xd6a7, HB_Grapheme_LVT},
+  {0xd6a8, 0xd6a8, HB_Grapheme_LV},
+  {0xd6a9, 0xd6c3, HB_Grapheme_LVT},
+  {0xd6c4, 0xd6c4, HB_Grapheme_LV},
+  {0xd6c5, 0xd6df, HB_Grapheme_LVT},
+  {0xd6e0, 0xd6e0, HB_Grapheme_LV},
+  {0xd6e1, 0xd6fb, HB_Grapheme_LVT},
+  {0xd6fc, 0xd6fc, HB_Grapheme_LV},
+  {0xd6fd, 0xd717, HB_Grapheme_LVT},
+  {0xd718, 0xd718, HB_Grapheme_LV},
+  {0xd719, 0xd733, HB_Grapheme_LVT},
+  {0xd734, 0xd734, HB_Grapheme_LV},
+  {0xd735, 0xd74f, HB_Grapheme_LVT},
+  {0xd750, 0xd750, HB_Grapheme_LV},
+  {0xd751, 0xd76b, HB_Grapheme_LVT},
+  {0xd76c, 0xd76c, HB_Grapheme_LV},
+  {0xd76d, 0xd787, HB_Grapheme_LVT},
+  {0xd788, 0xd788, HB_Grapheme_LV},
+  {0xd789, 0xd7a3, HB_Grapheme_LVT},
+  {0xd7b0, 0xd7c6, HB_Grapheme_V},
+  {0xd7cb, 0xd7fb, HB_Grapheme_T},
+  {0xfb1e, 0xfb1e, HB_Grapheme_Extend},
+  {0xfe00, 0xfe0f, HB_Grapheme_Extend},
+  {0xfe20, 0xfe26, HB_Grapheme_Extend},
+  {0xfeff, 0xfeff, HB_Grapheme_Control},
+  {0xff9e, 0xff9f, HB_Grapheme_Extend},
+  {0xfff9, 0xfffb, HB_Grapheme_Control},
+  {0x101fd, 0x101fd, HB_Grapheme_Extend},
+  {0x10a01, 0x10a03, HB_Grapheme_Extend},
+  {0x10a05, 0x10a06, HB_Grapheme_Extend},
+  {0x10a0c, 0x10a0f, HB_Grapheme_Extend},
+  {0x10a38, 0x10a3a, HB_Grapheme_Extend},
+  {0x10a3f, 0x10a3f, HB_Grapheme_Extend},
+  {0x11080, 0x11081, HB_Grapheme_Extend},
+  {0x11082, 0x11082, HB_Grapheme_Other},
+  {0x110b0, 0x110b2, HB_Grapheme_Other},
+  {0x110b3, 0x110b6, HB_Grapheme_Extend},
+  {0x110b7, 0x110b8, HB_Grapheme_Other},
+  {0x110b9, 0x110ba, HB_Grapheme_Extend},
+  {0x110bd, 0x110bd, HB_Grapheme_Control},
+  {0x1d165, 0x1d165, HB_Grapheme_Extend},
+  {0x1d166, 0x1d166, HB_Grapheme_Other},
+  {0x1d167, 0x1d169, HB_Grapheme_Extend},
+  {0x1d16d, 0x1d16d, HB_Grapheme_Other},
+  {0x1d16e, 0x1d172, HB_Grapheme_Extend},
+  {0x1d173, 0x1d17a, HB_Grapheme_Control},
+  {0x1d17b, 0x1d182, HB_Grapheme_Extend},
+  {0x1d185, 0x1d18b, HB_Grapheme_Extend},
+  {0x1d1aa, 0x1d1ad, HB_Grapheme_Extend},
+  {0x1d242, 0x1d244, HB_Grapheme_Extend},
+  {0xe0001, 0xe0001, HB_Grapheme_Control},
+  {0xe0020, 0xe007f, HB_Grapheme_Control},
+  {0xe0100, 0xe01ef, HB_Grapheme_Extend},
+};
+
+static const unsigned grapheme_break_properties_count = 1154;
+
+#endif  // GRAPHEME_BREAK_PROPERTY_H_
diff -rupN orginal/scribus/harfbuzz/tables/mirroring-properties.h patched/scribus/harfbuzz/tables/mirroring-properties.h
--- orginal/scribus/harfbuzz/tables/mirroring-properties.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/tables/mirroring-properties.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,379 @@
+// Generated from Unicode Bidi Mirroring tables
+
+#ifndef MIRRORING_PROPERTY_H_
+#define MIRRORING_PROPERTY_H_
+
+#include <stdint.h>
+struct mirroring_property {
+  uint32_t a;
+  uint32_t b;
+};
+
+static const struct mirroring_property mirroring_properties[] = {
+  {0x28, 0x29},
+  {0x29, 0x28},
+  {0x3c, 0x3e},
+  {0x3e, 0x3c},
+  {0x5b, 0x5d},
+  {0x5d, 0x5b},
+  {0x7b, 0x7d},
+  {0x7d, 0x7b},
+  {0xab, 0xbb},
+  {0xbb, 0xab},
+  {0xf3a, 0xf3b},
+  {0xf3b, 0xf3a},
+  {0xf3c, 0xf3d},
+  {0xf3d, 0xf3c},
+  {0x169b, 0x169c},
+  {0x169c, 0x169b},
+  {0x2039, 0x203a},
+  {0x203a, 0x2039},
+  {0x2045, 0x2046},
+  {0x2046, 0x2045},
+  {0x207d, 0x207e},
+  {0x207e, 0x207d},
+  {0x208d, 0x208e},
+  {0x208e, 0x208d},
+  {0x2208, 0x220b},
+  {0x2209, 0x220c},
+  {0x220a, 0x220d},
+  {0x220b, 0x2208},
+  {0x220c, 0x2209},
+  {0x220d, 0x220a},
+  {0x2215, 0x29f5},
+  {0x223c, 0x223d},
+  {0x223d, 0x223c},
+  {0x2243, 0x22cd},
+  {0x2252, 0x2253},
+  {0x2253, 0x2252},
+  {0x2254, 0x2255},
+  {0x2255, 0x2254},
+  {0x2264, 0x2265},
+  {0x2265, 0x2264},
+  {0x2266, 0x2267},
+  {0x2267, 0x2266},
+  {0x2268, 0x2269},
+  {0x2269, 0x2268},
+  {0x226a, 0x226b},
+  {0x226b, 0x226a},
+  {0x226e, 0x226f},
+  {0x226f, 0x226e},
+  {0x2270, 0x2271},
+  {0x2271, 0x2270},
+  {0x2272, 0x2273},
+  {0x2273, 0x2272},
+  {0x2274, 0x2275},
+  {0x2275, 0x2274},
+  {0x2276, 0x2277},
+  {0x2277, 0x2276},
+  {0x2278, 0x2279},
+  {0x2279, 0x2278},
+  {0x227a, 0x227b},
+  {0x227b, 0x227a},
+  {0x227c, 0x227d},
+  {0x227d, 0x227c},
+  {0x227e, 0x227f},
+  {0x227f, 0x227e},
+  {0x2280, 0x2281},
+  {0x2281, 0x2280},
+  {0x2282, 0x2283},
+  {0x2283, 0x2282},
+  {0x2284, 0x2285},
+  {0x2285, 0x2284},
+  {0x2286, 0x2287},
+  {0x2287, 0x2286},
+  {0x2288, 0x2289},
+  {0x2289, 0x2288},
+  {0x228a, 0x228b},
+  {0x228b, 0x228a},
+  {0x228f, 0x2290},
+  {0x2290, 0x228f},
+  {0x2291, 0x2292},
+  {0x2292, 0x2291},
+  {0x2298, 0x29b8},
+  {0x22a2, 0x22a3},
+  {0x22a3, 0x22a2},
+  {0x22a6, 0x2ade},
+  {0x22a8, 0x2ae4},
+  {0x22a9, 0x2ae3},
+  {0x22ab, 0x2ae5},
+  {0x22b0, 0x22b1},
+  {0x22b1, 0x22b0},
+  {0x22b2, 0x22b3},
+  {0x22b3, 0x22b2},
+  {0x22b4, 0x22b5},
+  {0x22b5, 0x22b4},
+  {0x22b6, 0x22b7},
+  {0x22b7, 0x22b6},
+  {0x22c9, 0x22ca},
+  {0x22ca, 0x22c9},
+  {0x22cb, 0x22cc},
+  {0x22cc, 0x22cb},
+  {0x22cd, 0x2243},
+  {0x22d0, 0x22d1},
+  {0x22d1, 0x22d0},
+  {0x22d6, 0x22d7},
+  {0x22d7, 0x22d6},
+  {0x22d8, 0x22d9},
+  {0x22d9, 0x22d8},
+  {0x22da, 0x22db},
+  {0x22db, 0x22da},
+  {0x22dc, 0x22dd},
+  {0x22dd, 0x22dc},
+  {0x22de, 0x22df},
+  {0x22df, 0x22de},
+  {0x22e0, 0x22e1},
+  {0x22e1, 0x22e0},
+  {0x22e2, 0x22e3},
+  {0x22e3, 0x22e2},
+  {0x22e4, 0x22e5},
+  {0x22e5, 0x22e4},
+  {0x22e6, 0x22e7},
+  {0x22e7, 0x22e6},
+  {0x22e8, 0x22e9},
+  {0x22e9, 0x22e8},
+  {0x22ea, 0x22eb},
+  {0x22eb, 0x22ea},
+  {0x22ec, 0x22ed},
+  {0x22ed, 0x22ec},
+  {0x22f0, 0x22f1},
+  {0x22f1, 0x22f0},
+  {0x22f2, 0x22fa},
+  {0x22f3, 0x22fb},
+  {0x22f4, 0x22fc},
+  {0x22f6, 0x22fd},
+  {0x22f7, 0x22fe},
+  {0x22fa, 0x22f2},
+  {0x22fb, 0x22f3},
+  {0x22fc, 0x22f4},
+  {0x22fd, 0x22f6},
+  {0x22fe, 0x22f7},
+  {0x2308, 0x2309},
+  {0x2309, 0x2308},
+  {0x230a, 0x230b},
+  {0x230b, 0x230a},
+  {0x2329, 0x232a},
+  {0x232a, 0x2329},
+  {0x2768, 0x2769},
+  {0x2769, 0x2768},
+  {0x276a, 0x276b},
+  {0x276b, 0x276a},
+  {0x276c, 0x276d},
+  {0x276d, 0x276c},
+  {0x276e, 0x276f},
+  {0x276f, 0x276e},
+  {0x2770, 0x2771},
+  {0x2771, 0x2770},
+  {0x2772, 0x2773},
+  {0x2773, 0x2772},
+  {0x2774, 0x2775},
+  {0x2775, 0x2774},
+  {0x27c3, 0x27c4},
+  {0x27c4, 0x27c3},
+  {0x27c5, 0x27c6},
+  {0x27c6, 0x27c5},
+  {0x27c8, 0x27c9},
+  {0x27c9, 0x27c8},
+  {0x27d5, 0x27d6},
+  {0x27d6, 0x27d5},
+  {0x27dd, 0x27de},
+  {0x27de, 0x27dd},
+  {0x27e2, 0x27e3},
+  {0x27e3, 0x27e2},
+  {0x27e4, 0x27e5},
+  {0x27e5, 0x27e4},
+  {0x27e6, 0x27e7},
+  {0x27e7, 0x27e6},
+  {0x27e8, 0x27e9},
+  {0x27e9, 0x27e8},
+  {0x27ea, 0x27eb},
+  {0x27eb, 0x27ea},
+  {0x27ec, 0x27ed},
+  {0x27ed, 0x27ec},
+  {0x27ee, 0x27ef},
+  {0x27ef, 0x27ee},
+  {0x2983, 0x2984},
+  {0x2984, 0x2983},
+  {0x2985, 0x2986},
+  {0x2986, 0x2985},
+  {0x2987, 0x2988},
+  {0x2988, 0x2987},
+  {0x2989, 0x298a},
+  {0x298a, 0x2989},
+  {0x298b, 0x298c},
+  {0x298c, 0x298b},
+  {0x298d, 0x2990},
+  {0x298e, 0x298f},
+  {0x298f, 0x298e},
+  {0x2990, 0x298d},
+  {0x2991, 0x2992},
+  {0x2992, 0x2991},
+  {0x2993, 0x2994},
+  {0x2994, 0x2993},
+  {0x2995, 0x2996},
+  {0x2996, 0x2995},
+  {0x2997, 0x2998},
+  {0x2998, 0x2997},
+  {0x29b8, 0x2298},
+  {0x29c0, 0x29c1},
+  {0x29c1, 0x29c0},
+  {0x29c4, 0x29c5},
+  {0x29c5, 0x29c4},
+  {0x29cf, 0x29d0},
+  {0x29d0, 0x29cf},
+  {0x29d1, 0x29d2},
+  {0x29d2, 0x29d1},
+  {0x29d4, 0x29d5},
+  {0x29d5, 0x29d4},
+  {0x29d8, 0x29d9},
+  {0x29d9, 0x29d8},
+  {0x29da, 0x29db},
+  {0x29db, 0x29da},
+  {0x29f5, 0x2215},
+  {0x29f8, 0x29f9},
+  {0x29f9, 0x29f8},
+  {0x29fc, 0x29fd},
+  {0x29fd, 0x29fc},
+  {0x2a2b, 0x2a2c},
+  {0x2a2c, 0x2a2b},
+  {0x2a2d, 0x2a2e},
+  {0x2a2e, 0x2a2d},
+  {0x2a34, 0x2a35},
+  {0x2a35, 0x2a34},
+  {0x2a3c, 0x2a3d},
+  {0x2a3d, 0x2a3c},
+  {0x2a64, 0x2a65},
+  {0x2a65, 0x2a64},
+  {0x2a79, 0x2a7a},
+  {0x2a7a, 0x2a79},
+  {0x2a7d, 0x2a7e},
+  {0x2a7e, 0x2a7d},
+  {0x2a7f, 0x2a80},
+  {0x2a80, 0x2a7f},
+  {0x2a81, 0x2a82},
+  {0x2a82, 0x2a81},
+  {0x2a83, 0x2a84},
+  {0x2a84, 0x2a83},
+  {0x2a8b, 0x2a8c},
+  {0x2a8c, 0x2a8b},
+  {0x2a91, 0x2a92},
+  {0x2a92, 0x2a91},
+  {0x2a93, 0x2a94},
+  {0x2a94, 0x2a93},
+  {0x2a95, 0x2a96},
+  {0x2a96, 0x2a95},
+  {0x2a97, 0x2a98},
+  {0x2a98, 0x2a97},
+  {0x2a99, 0x2a9a},
+  {0x2a9a, 0x2a99},
+  {0x2a9b, 0x2a9c},
+  {0x2a9c, 0x2a9b},
+  {0x2aa1, 0x2aa2},
+  {0x2aa2, 0x2aa1},
+  {0x2aa6, 0x2aa7},
+  {0x2aa7, 0x2aa6},
+  {0x2aa8, 0x2aa9},
+  {0x2aa9, 0x2aa8},
+  {0x2aaa, 0x2aab},
+  {0x2aab, 0x2aaa},
+  {0x2aac, 0x2aad},
+  {0x2aad, 0x2aac},
+  {0x2aaf, 0x2ab0},
+  {0x2ab0, 0x2aaf},
+  {0x2ab3, 0x2ab4},
+  {0x2ab4, 0x2ab3},
+  {0x2abb, 0x2abc},
+  {0x2abc, 0x2abb},
+  {0x2abd, 0x2abe},
+  {0x2abe, 0x2abd},
+  {0x2abf, 0x2ac0},
+  {0x2ac0, 0x2abf},
+  {0x2ac1, 0x2ac2},
+  {0x2ac2, 0x2ac1},
+  {0x2ac3, 0x2ac4},
+  {0x2ac4, 0x2ac3},
+  {0x2ac5, 0x2ac6},
+  {0x2ac6, 0x2ac5},
+  {0x2acd, 0x2ace},
+  {0x2ace, 0x2acd},
+  {0x2acf, 0x2ad0},
+  {0x2ad0, 0x2acf},
+  {0x2ad1, 0x2ad2},
+  {0x2ad2, 0x2ad1},
+  {0x2ad3, 0x2ad4},
+  {0x2ad4, 0x2ad3},
+  {0x2ad5, 0x2ad6},
+  {0x2ad6, 0x2ad5},
+  {0x2ade, 0x22a6},
+  {0x2ae3, 0x22a9},
+  {0x2ae4, 0x22a8},
+  {0x2ae5, 0x22ab},
+  {0x2aec, 0x2aed},
+  {0x2aed, 0x2aec},
+  {0x2af7, 0x2af8},
+  {0x2af8, 0x2af7},
+  {0x2af9, 0x2afa},
+  {0x2afa, 0x2af9},
+  {0x2e02, 0x2e03},
+  {0x2e03, 0x2e02},
+  {0x2e04, 0x2e05},
+  {0x2e05, 0x2e04},
+  {0x2e09, 0x2e0a},
+  {0x2e0a, 0x2e09},
+  {0x2e0c, 0x2e0d},
+  {0x2e0d, 0x2e0c},
+  {0x2e1c, 0x2e1d},
+  {0x2e1d, 0x2e1c},
+  {0x2e20, 0x2e21},
+  {0x2e21, 0x2e20},
+  {0x2e22, 0x2e23},
+  {0x2e23, 0x2e22},
+  {0x2e24, 0x2e25},
+  {0x2e25, 0x2e24},
+  {0x2e26, 0x2e27},
+  {0x2e27, 0x2e26},
+  {0x2e28, 0x2e29},
+  {0x2e29, 0x2e28},
+  {0x3008, 0x3009},
+  {0x3009, 0x3008},
+  {0x300a, 0x300b},
+  {0x300b, 0x300a},
+  {0x300c, 0x300d},
+  {0x300d, 0x300c},
+  {0x300e, 0x300f},
+  {0x300f, 0x300e},
+  {0x3010, 0x3011},
+  {0x3011, 0x3010},
+  {0x3014, 0x3015},
+  {0x3015, 0x3014},
+  {0x3016, 0x3017},
+  {0x3017, 0x3016},
+  {0x3018, 0x3019},
+  {0x3019, 0x3018},
+  {0x301a, 0x301b},
+  {0x301b, 0x301a},
+  {0xfe59, 0xfe5a},
+  {0xfe5a, 0xfe59},
+  {0xfe5b, 0xfe5c},
+  {0xfe5c, 0xfe5b},
+  {0xfe5d, 0xfe5e},
+  {0xfe5e, 0xfe5d},
+  {0xfe64, 0xfe65},
+  {0xfe65, 0xfe64},
+  {0xff08, 0xff09},
+  {0xff09, 0xff08},
+  {0xff1c, 0xff1e},
+  {0xff1e, 0xff1c},
+  {0xff3b, 0xff3d},
+  {0xff3d, 0xff3b},
+  {0xff5b, 0xff5d},
+  {0xff5d, 0xff5b},
+  {0xff5f, 0xff60},
+  {0xff60, 0xff5f},
+  {0xff62, 0xff63},
+  {0xff63, 0xff62},
+};
+
+static const unsigned mirroring_properties_count = 362;
+
+#endif  // MIRRORING_PROPERTY_H_
diff -rupN orginal/scribus/harfbuzz/tables/script-properties.h patched/scribus/harfbuzz/tables/script-properties.h
--- orginal/scribus/harfbuzz/tables/script-properties.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/harfbuzz/tables/script-properties.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,297 @@
+// Generated from Unicode script tables
+
+#ifndef SCRIPT_PROPERTIES_H_
+#define SCRIPT_PROPERTIES_H_
+
+#include <stdint.h>
+#include "harfbuzz-shaper.h"
+
+struct script_property {
+  uint32_t range_start;
+  uint32_t range_end;
+  HB_Script script;
+};
+
+static const struct script_property script_properties[] = {
+  {0x300, 0x36f, HB_Script_Inherited},
+  {0x370, 0x373, HB_Script_Greek},
+  {0x375, 0x377, HB_Script_Greek},
+  {0x37a, 0x37d, HB_Script_Greek},
+  {0x384, 0x384, HB_Script_Greek},
+  {0x386, 0x386, HB_Script_Greek},
+  {0x388, 0x38a, HB_Script_Greek},
+  {0x38c, 0x38c, HB_Script_Greek},
+  {0x38e, 0x3a1, HB_Script_Greek},
+  {0x3a3, 0x3e1, HB_Script_Greek},
+  {0x3f0, 0x3ff, HB_Script_Greek},
+  {0x400, 0x523, HB_Script_Cyrillic},
+  {0x531, 0x556, HB_Script_Armenian},
+  {0x559, 0x55f, HB_Script_Armenian},
+  {0x561, 0x587, HB_Script_Armenian},
+  {0x58a, 0x58a, HB_Script_Armenian},
+  {0x591, 0x5c7, HB_Script_Hebrew},
+  {0x5d0, 0x5ea, HB_Script_Hebrew},
+  {0x5f0, 0x5f4, HB_Script_Hebrew},
+  {0x606, 0x60b, HB_Script_Arabic},
+  {0x60d, 0x61a, HB_Script_Arabic},
+  {0x61e, 0x61e, HB_Script_Arabic},
+  {0x621, 0x63f, HB_Script_Arabic},
+  {0x641, 0x64a, HB_Script_Arabic},
+  {0x64b, 0x655, HB_Script_Inherited},
+  {0x656, 0x65e, HB_Script_Arabic},
+  {0x66a, 0x66f, HB_Script_Arabic},
+  {0x670, 0x670, HB_Script_Inherited},
+  {0x671, 0x6dc, HB_Script_Arabic},
+  {0x6de, 0x6ff, HB_Script_Arabic},
+  {0x700, 0x70d, HB_Script_Syriac},
+  {0x70f, 0x74a, HB_Script_Syriac},
+  {0x74d, 0x74f, HB_Script_Syriac},
+  {0x750, 0x77f, HB_Script_Arabic},
+  {0x780, 0x7b1, HB_Script_Thaana},
+  {0x901, 0x939, HB_Script_Devanagari},
+  {0x93c, 0x94d, HB_Script_Devanagari},
+  {0x950, 0x950, HB_Script_Devanagari},
+  {0x951, 0x952, HB_Script_Inherited},
+  {0x953, 0x954, HB_Script_Devanagari},
+  {0x958, 0x963, HB_Script_Devanagari},
+  {0x966, 0x96f, HB_Script_Devanagari},
+  {0x971, 0x972, HB_Script_Devanagari},
+  {0x97b, 0x97f, HB_Script_Devanagari},
+  {0x981, 0x983, HB_Script_Bengali},
+  {0x985, 0x98c, HB_Script_Bengali},
+  {0x98f, 0x990, HB_Script_Bengali},
+  {0x993, 0x9a8, HB_Script_Bengali},
+  {0x9aa, 0x9b0, HB_Script_Bengali},
+  {0x9b2, 0x9b2, HB_Script_Bengali},
+  {0x9b6, 0x9b9, HB_Script_Bengali},
+  {0x9bc, 0x9c4, HB_Script_Bengali},
+  {0x9c7, 0x9c8, HB_Script_Bengali},
+  {0x9cb, 0x9ce, HB_Script_Bengali},
+  {0x9d7, 0x9d7, HB_Script_Bengali},
+  {0x9dc, 0x9dd, HB_Script_Bengali},
+  {0x9df, 0x9e3, HB_Script_Bengali},
+  {0x9e6, 0x9fa, HB_Script_Bengali},
+  {0xa01, 0xa03, HB_Script_Gurmukhi},
+  {0xa05, 0xa0a, HB_Script_Gurmukhi},
+  {0xa0f, 0xa10, HB_Script_Gurmukhi},
+  {0xa13, 0xa28, HB_Script_Gurmukhi},
+  {0xa2a, 0xa30, HB_Script_Gurmukhi},
+  {0xa32, 0xa33, HB_Script_Gurmukhi},
+  {0xa35, 0xa36, HB_Script_Gurmukhi},
+  {0xa38, 0xa39, HB_Script_Gurmukhi},
+  {0xa3c, 0xa3c, HB_Script_Gurmukhi},
+  {0xa3e, 0xa42, HB_Script_Gurmukhi},
+  {0xa47, 0xa48, HB_Script_Gurmukhi},
+  {0xa4b, 0xa4d, HB_Script_Gurmukhi},
+  {0xa51, 0xa51, HB_Script_Gurmukhi},
+  {0xa59, 0xa5c, HB_Script_Gurmukhi},
+  {0xa5e, 0xa5e, HB_Script_Gurmukhi},
+  {0xa66, 0xa75, HB_Script_Gurmukhi},
+  {0xa81, 0xa83, HB_Script_Gujarati},
+  {0xa85, 0xa8d, HB_Script_Gujarati},
+  {0xa8f, 0xa91, HB_Script_Gujarati},
+  {0xa93, 0xaa8, HB_Script_Gujarati},
+  {0xaaa, 0xab0, HB_Script_Gujarati},
+  {0xab2, 0xab3, HB_Script_Gujarati},
+  {0xab5, 0xab9, HB_Script_Gujarati},
+  {0xabc, 0xac5, HB_Script_Gujarati},
+  {0xac7, 0xac9, HB_Script_Gujarati},
+  {0xacb, 0xacd, HB_Script_Gujarati},
+  {0xad0, 0xad0, HB_Script_Gujarati},
+  {0xae0, 0xae3, HB_Script_Gujarati},
+  {0xae6, 0xaef, HB_Script_Gujarati},
+  {0xaf1, 0xaf1, HB_Script_Gujarati},
+  {0xb01, 0xb03, HB_Script_Oriya},
+  {0xb05, 0xb0c, HB_Script_Oriya},
+  {0xb0f, 0xb10, HB_Script_Oriya},
+  {0xb13, 0xb28, HB_Script_Oriya},
+  {0xb2a, 0xb30, HB_Script_Oriya},
+  {0xb32, 0xb33, HB_Script_Oriya},
+  {0xb35, 0xb39, HB_Script_Oriya},
+  {0xb3c, 0xb44, HB_Script_Oriya},
+  {0xb47, 0xb48, HB_Script_Oriya},
+  {0xb4b, 0xb4d, HB_Script_Oriya},
+  {0xb56, 0xb57, HB_Script_Oriya},
+  {0xb5c, 0xb5d, HB_Script_Oriya},
+  {0xb5f, 0xb63, HB_Script_Oriya},
+  {0xb66, 0xb71, HB_Script_Oriya},
+  {0xb82, 0xb83, HB_Script_Tamil},
+  {0xb85, 0xb8a, HB_Script_Tamil},
+  {0xb8e, 0xb90, HB_Script_Tamil},
+  {0xb92, 0xb95, HB_Script_Tamil},
+  {0xb99, 0xb9a, HB_Script_Tamil},
+  {0xb9c, 0xb9c, HB_Script_Tamil},
+  {0xb9e, 0xb9f, HB_Script_Tamil},
+  {0xba3, 0xba4, HB_Script_Tamil},
+  {0xba8, 0xbaa, HB_Script_Tamil},
+  {0xbae, 0xbb9, HB_Script_Tamil},
+  {0xbbe, 0xbc2, HB_Script_Tamil},
+  {0xbc6, 0xbc8, HB_Script_Tamil},
+  {0xbca, 0xbcd, HB_Script_Tamil},
+  {0xbd0, 0xbd0, HB_Script_Tamil},
+  {0xbd7, 0xbd7, HB_Script_Tamil},
+  {0xbe6, 0xbfa, HB_Script_Tamil},
+  {0xc01, 0xc03, HB_Script_Telugu},
+  {0xc05, 0xc0c, HB_Script_Telugu},
+  {0xc0e, 0xc10, HB_Script_Telugu},
+  {0xc12, 0xc28, HB_Script_Telugu},
+  {0xc2a, 0xc33, HB_Script_Telugu},
+  {0xc35, 0xc39, HB_Script_Telugu},
+  {0xc3d, 0xc44, HB_Script_Telugu},
+  {0xc46, 0xc48, HB_Script_Telugu},
+  {0xc4a, 0xc4d, HB_Script_Telugu},
+  {0xc55, 0xc56, HB_Script_Telugu},
+  {0xc58, 0xc59, HB_Script_Telugu},
+  {0xc60, 0xc63, HB_Script_Telugu},
+  {0xc66, 0xc6f, HB_Script_Telugu},
+  {0xc78, 0xc7f, HB_Script_Telugu},
+  {0xc82, 0xc83, HB_Script_Kannada},
+  {0xc85, 0xc8c, HB_Script_Kannada},
+  {0xc8e, 0xc90, HB_Script_Kannada},
+  {0xc92, 0xca8, HB_Script_Kannada},
+  {0xcaa, 0xcb3, HB_Script_Kannada},
+  {0xcb5, 0xcb9, HB_Script_Kannada},
+  {0xcbc, 0xcc4, HB_Script_Kannada},
+  {0xcc6, 0xcc8, HB_Script_Kannada},
+  {0xcca, 0xccd, HB_Script_Kannada},
+  {0xcd5, 0xcd6, HB_Script_Kannada},
+  {0xcde, 0xcde, HB_Script_Kannada},
+  {0xce0, 0xce3, HB_Script_Kannada},
+  {0xce6, 0xcef, HB_Script_Kannada},
+  {0xd02, 0xd03, HB_Script_Malayalam},
+  {0xd05, 0xd0c, HB_Script_Malayalam},
+  {0xd0e, 0xd10, HB_Script_Malayalam},
+  {0xd12, 0xd28, HB_Script_Malayalam},
+  {0xd2a, 0xd39, HB_Script_Malayalam},
+  {0xd3d, 0xd44, HB_Script_Malayalam},
+  {0xd46, 0xd48, HB_Script_Malayalam},
+  {0xd4a, 0xd4d, HB_Script_Malayalam},
+  {0xd57, 0xd57, HB_Script_Malayalam},
+  {0xd60, 0xd63, HB_Script_Malayalam},
+  {0xd66, 0xd75, HB_Script_Malayalam},
+  {0xd79, 0xd7f, HB_Script_Malayalam},
+  {0xd82, 0xd83, HB_Script_Sinhala},
+  {0xd85, 0xd96, HB_Script_Sinhala},
+  {0xd9a, 0xdb1, HB_Script_Sinhala},
+  {0xdb3, 0xdbb, HB_Script_Sinhala},
+  {0xdbd, 0xdbd, HB_Script_Sinhala},
+  {0xdc0, 0xdc6, HB_Script_Sinhala},
+  {0xdca, 0xdca, HB_Script_Sinhala},
+  {0xdcf, 0xdd4, HB_Script_Sinhala},
+  {0xdd6, 0xdd6, HB_Script_Sinhala},
+  {0xdd8, 0xddf, HB_Script_Sinhala},
+  {0xdf2, 0xdf4, HB_Script_Sinhala},
+  {0xe01, 0xe3a, HB_Script_Thai},
+  {0xe40, 0xe5b, HB_Script_Thai},
+  {0xe81, 0xe82, HB_Script_Lao},
+  {0xe84, 0xe84, HB_Script_Lao},
+  {0xe87, 0xe88, HB_Script_Lao},
+  {0xe8a, 0xe8a, HB_Script_Lao},
+  {0xe8d, 0xe8d, HB_Script_Lao},
+  {0xe94, 0xe97, HB_Script_Lao},
+  {0xe99, 0xe9f, HB_Script_Lao},
+  {0xea1, 0xea3, HB_Script_Lao},
+  {0xea5, 0xea5, HB_Script_Lao},
+  {0xea7, 0xea7, HB_Script_Lao},
+  {0xeaa, 0xeab, HB_Script_Lao},
+  {0xead, 0xeb9, HB_Script_Lao},
+  {0xebb, 0xebd, HB_Script_Lao},
+  {0xec0, 0xec4, HB_Script_Lao},
+  {0xec6, 0xec6, HB_Script_Lao},
+  {0xec8, 0xecd, HB_Script_Lao},
+  {0xed0, 0xed9, HB_Script_Lao},
+  {0xedc, 0xedd, HB_Script_Lao},
+  {0xf00, 0xf47, HB_Script_Tibetan},
+  {0xf49, 0xf6c, HB_Script_Tibetan},
+  {0xf71, 0xf8b, HB_Script_Tibetan},
+  {0xf90, 0xf97, HB_Script_Tibetan},
+  {0xf99, 0xfbc, HB_Script_Tibetan},
+  {0xfbe, 0xfcc, HB_Script_Tibetan},
+  {0xfce, 0xfd4, HB_Script_Tibetan},
+  {0x1000, 0x1099, HB_Script_Myanmar},
+  {0x109e, 0x109f, HB_Script_Myanmar},
+  {0x10a0, 0x10c5, HB_Script_Georgian},
+  {0x10d0, 0x10fa, HB_Script_Georgian},
+  {0x10fc, 0x10fc, HB_Script_Georgian},
+  {0x1100, 0x1159, HB_Script_Hangul},
+  {0x115f, 0x11a2, HB_Script_Hangul},
+  {0x11a8, 0x11f9, HB_Script_Hangul},
+  {0x1680, 0x169c, HB_Script_Ogham},
+  {0x16a0, 0x16ea, HB_Script_Runic},
+  {0x16ee, 0x16f0, HB_Script_Runic},
+  {0x1780, 0x17dd, HB_Script_Khmer},
+  {0x17e0, 0x17e9, HB_Script_Khmer},
+  {0x17f0, 0x17f9, HB_Script_Khmer},
+  {0x19e0, 0x19ff, HB_Script_Khmer},
+  {0x1d26, 0x1d2a, HB_Script_Greek},
+  {0x1d2b, 0x1d2b, HB_Script_Cyrillic},
+  {0x1d5d, 0x1d61, HB_Script_Greek},
+  {0x1d66, 0x1d6a, HB_Script_Greek},
+  {0x1d78, 0x1d78, HB_Script_Cyrillic},
+  {0x1dbf, 0x1dbf, HB_Script_Greek},
+  {0x1dc0, 0x1de6, HB_Script_Inherited},
+  {0x1dfe, 0x1dff, HB_Script_Inherited},
+  {0x1f00, 0x1f15, HB_Script_Greek},
+  {0x1f18, 0x1f1d, HB_Script_Greek},
+  {0x1f20, 0x1f45, HB_Script_Greek},
+  {0x1f48, 0x1f4d, HB_Script_Greek},
+  {0x1f50, 0x1f57, HB_Script_Greek},
+  {0x1f59, 0x1f59, HB_Script_Greek},
+  {0x1f5b, 0x1f5b, HB_Script_Greek},
+  {0x1f5d, 0x1f5d, HB_Script_Greek},
+  {0x1f5f, 0x1f7d, HB_Script_Greek},
+  {0x1f80, 0x1fb4, HB_Script_Greek},
+  {0x1fb6, 0x1fc4, HB_Script_Greek},
+  {0x1fc6, 0x1fd3, HB_Script_Greek},
+  {0x1fd6, 0x1fdb, HB_Script_Greek},
+  {0x1fdd, 0x1fef, HB_Script_Greek},
+  {0x1ff2, 0x1ff4, HB_Script_Greek},
+  {0x1ff6, 0x1ffe, HB_Script_Greek},
+  {0x200c, 0x200d, HB_Script_Inherited},
+  {0x20d0, 0x20f0, HB_Script_Inherited},
+  {0x2126, 0x2126, HB_Script_Greek},
+  {0x2d00, 0x2d25, HB_Script_Georgian},
+  {0x2de0, 0x2dff, HB_Script_Cyrillic},
+  {0x302a, 0x302f, HB_Script_Inherited},
+  {0x3099, 0x309a, HB_Script_Inherited},
+  {0x3131, 0x318e, HB_Script_Hangul},
+  {0x3200, 0x321e, HB_Script_Hangul},
+  {0x3260, 0x327e, HB_Script_Hangul},
+  {0xa640, 0xa65f, HB_Script_Cyrillic},
+  {0xa662, 0xa673, HB_Script_Cyrillic},
+  {0xa67c, 0xa697, HB_Script_Cyrillic},
+  {0xac00, 0xd7a3, HB_Script_Hangul},
+  {0xfb13, 0xfb17, HB_Script_Armenian},
+  {0xfb1d, 0xfb36, HB_Script_Hebrew},
+  {0xfb38, 0xfb3c, HB_Script_Hebrew},
+  {0xfb3e, 0xfb3e, HB_Script_Hebrew},
+  {0xfb40, 0xfb41, HB_Script_Hebrew},
+  {0xfb43, 0xfb44, HB_Script_Hebrew},
+  {0xfb46, 0xfb4f, HB_Script_Hebrew},
+  {0xfb50, 0xfbb1, HB_Script_Arabic},
+  {0xfbd3, 0xfd3d, HB_Script_Arabic},
+  {0xfd50, 0xfd8f, HB_Script_Arabic},
+  {0xfd92, 0xfdc7, HB_Script_Arabic},
+  {0xfdf0, 0xfdfc, HB_Script_Arabic},
+  {0xfe00, 0xfe0f, HB_Script_Inherited},
+  {0xfe20, 0xfe26, HB_Script_Inherited},
+  {0xfe70, 0xfe74, HB_Script_Arabic},
+  {0xfe76, 0xfefc, HB_Script_Arabic},
+  {0xffa0, 0xffbe, HB_Script_Hangul},
+  {0xffc2, 0xffc7, HB_Script_Hangul},
+  {0xffca, 0xffcf, HB_Script_Hangul},
+  {0xffd2, 0xffd7, HB_Script_Hangul},
+  {0xffda, 0xffdc, HB_Script_Hangul},
+  {0x10140, 0x1018a, HB_Script_Greek},
+  {0x101fd, 0x101fd, HB_Script_Inherited},
+  {0x1d167, 0x1d169, HB_Script_Inherited},
+  {0x1d17b, 0x1d182, HB_Script_Inherited},
+  {0x1d185, 0x1d18b, HB_Script_Inherited},
+  {0x1d1aa, 0x1d1ad, HB_Script_Inherited},
+  {0x1d200, 0x1d245, HB_Script_Greek},
+  {0xe0100, 0xe01ef, HB_Script_Inherited},
+};
+
+static const unsigned script_properties_count = 277;
+
+#endif  // SCRIPT_PROPERTIES_H_
diff -rupN orginal/scribus/pageitem.cpp patched/scribus/pageitem.cpp
--- orginal/scribus/pageitem.cpp	2013-02-24 16:57:03.000000000 +0300
+++ patched/scribus/pageitem.cpp	2014-05-02 18:50:04.991034360 +0300
@@ -78,6 +78,7 @@ for which a new license (GPL+exception)
 #ifdef HAVE_CAIRO
 	#include <cairo.h>
 #endif
+#include "shaper.h"
 
 using namespace std;
 
@@ -1815,6 +1816,12 @@ double PageItem::layoutGlyphs(const Char
 	double retval = 0.0;
 	double asce = style.font().ascent(style.fontSize() / 10.0);
 	int chst = style.effects() & 1919;
+#if BIDI_LAYOUT
+    bool reset_xadvance = chars[0].unicode() > 256 && layout.xadvance == 0; //HACK for vowel marks
+    if(layout.glyph == 0) //we couldn't get this glyph with harfbuzz (why?)
+    {
+        reset_xadvance = false;    
+#endif
 /*	if (chars[0] == SpecialChars::ZWSPACE ||
 		chars[0] == SpecialChars::ZWNBSPACE ||
 		chars[0] == SpecialChars::NBSPACE ||
@@ -1832,7 +1839,9 @@ double PageItem::layoutGlyphs(const Char
 	{
 		layout.glyph = style.font().char2CMap(chars[0].unicode());
 	}
-	
+#if BIDI_LAYOUT
+    }
+#endif    	
 	double tracking = 0.0;
 	if ( (style.effects() & ScStyle_StartOfLine) == 0)
 		tracking = style.fontSize() * style.tracking() / 10000.0;
@@ -1897,6 +1906,10 @@ double PageItem::layoutGlyphs(const Char
 	{
 		layout.xadvance = style.font().glyphWidth(layout.glyph, style.fontSize() / 10) * layout.scaleH;
 		layout.yadvance = style.font().glyphBBox(layout.glyph, style.fontSize() / 10).ascent * layout.scaleV;
+#if BIDI_LAYOUT
+        if(reset_xadvance)
+            layout.xadvance = 0;
+#endif
 	}
 	if (layout.xadvance > 0)
 		layout.xadvance += tracking;
diff -rupN orginal/scribus/pageitem_textframe.cpp patched/scribus/pageitem_textframe.cpp
--- orginal/scribus/pageitem_textframe.cpp	2013-04-13 20:01:01.000000000 +0300
+++ patched/scribus/pageitem_textframe.cpp	2014-05-02 19:03:59.136100167 +0300
@@ -992,6 +992,256 @@ static double opticalRightMargin(const S
 	return 0.0;
 }
 
+#include "shaper.h"
+#if BIDI_LAYOUT
+#include <QLinkedList>
+#include "fribidi/fribidi.h"
+#ifndef SCRIBUS_BIDI_HEADERS
+#define SCRIBUS_BIDI_HEADERS
+struct LayoutLine;
+/**
+    This code is a hack that applies bidi reordering after the layout method has done its business.
+    BidiInfo will Figure out embedding levels (using GNU FriBidi) and supply ranges for runs (uni-directional segments of text).
+    This information is used to drive the bidi-reordering process, which involves:   
+        * Detecting positions of new lines
+        * Reordering each line using the BidiInfo
+    This should get proper bidirectional display, but this is not enough for full bidi support:
+        * We need to shape arabic characters (and other languages that require it, if any): 
+            * For this we need HarfBuzz
+        * We need extra work so that selections and editing are done correctly.
+            * See section "Supporting Text Manipulation" on http://java.sun.com/j2se/1.5.0/docs/guide/2d/spec/j2d-fonts.html#wp68590
+    -hasenj                   
+*/
+class BidiInfo
+{
+    private:
+        QString qString;
+        QVector<uint> qUtf32; // included for RAII
+        FriBidiChar *inputString;
+        FriBidiStrIndex inputLength;
+        FriBidiParType baseDir;
+        FriBidiLevel *embeddingLevels;
+        FriBidiCharType *bidiTypes;        
+    public:
+        BidiInfo(StoryText *itemText);
+        ~BidiInfo();
+        bool isRtlEmbedding(int index);
+        bool isLtrEmbedding(int index);
+        bool nextRunOfLevel(int level, int start, int limit, int *out_start, int *out_end);
+        int levelAt(int index){ return embeddingLevels[index]; }
+        FriBidiChar * getInputString() { return inputString; }
+        QUtf32 getUtf32() { return qUtf32; }   
+        bool isRtlBase() { return baseDir == FRIBIDI_PAR_RTL; }  
+        FriBidiParType getBaseDir() { return baseDir; }                   
+};
+struct LayoutLine
+{
+    int startIndex;
+    int endIndex;
+    LayoutLine()
+    {
+        startIndex = 0;
+        endIndex = 0;
+    }
+    LayoutLine(LineSpec line)
+    {
+        startIndex = line.firstItem;
+        endIndex = line.lastItem + 1; //lastItem is inclusive
+    }
+};
+#endif
+/**
+    Let fribidi work its magic.
+    This will give us the embedding levels, allowing us to grab directional runs
+*/
+BidiInfo::BidiInfo(StoryText *itemText) : 
+    qString(itemText->text(0, itemText->length())),
+    qUtf32(qString.toUcs4()),
+    inputString(qUtf32.data()),
+    inputLength(qString.length()),
+    baseDir(FRIBIDI_PAR_LTR),
+    embeddingLevels(0), 
+    bidiTypes(0)
+{
+    embeddingLevels = new FriBidiLevel[inputLength]; //don't forget to delete me
+    bidiTypes = new FriBidiCharType[inputLength]; //ditto
+    fribidi_get_bidi_types (inputString, inputLength, bidiTypes);
+    baseDir = fribidi_get_par_direction(bidiTypes, inputLength);
+    FriBidiLevel ok = fribidi_get_par_embedding_levels(bidiTypes, inputLength, &baseDir, embeddingLevels);
+    if(ok == 0) 
+    {
+        qDebug() << "BIDI ERROR"; // XXX: how do we panic?
+    }
+}
+BidiInfo::~BidiInfo()
+{
+    delete[] embeddingLevels;
+    delete[] bidiTypes;
+}
+/**
+    Does character at index have an RTL embedding level?
+*/
+bool BidiInfo::isRtlEmbedding(int index)
+{
+    return embeddingLevels[index] % 2 == 1; // odd embedding levels are part of an RTL run
+}
+/**
+    Does character at index have an LTR embedding level?
+*/
+bool BidiInfo::isLtrEmbedding(int index)
+{
+    return !(isRtlEmbedding(index));
+}
+void mirrorItem(ScText *item)
+{
+    if(item->ch.hasMirrored())
+    {
+        item->glyph.glyph = item->font().char2CMap(item->ch.mirroredChar());
+    }
+}
+/**
+    EXPERIMENTAL
+
+    Reverse the layout of a sequence of glyphs. 
+
+    This is probably a naive approach, but at least we can 
+    learn a few more things about glyph layout, hopefully
+
+    @param itemText: the text we want to reverse a segment of
+    @param startIndex: start of segment to reverse
+    @param endIndex: end of segment to reverse (exclusive, of course!)
+
+    how it works: swaps the glyphs (originally I thought of swapping positions, but then
+    I figured it's better to just swap the glyphs, since it's much less than the position info!)
+    FIXME: This is probably wrong, it results in an ScText item to have a glyph not of its own    
+ */
+bool reverseGlyphLayout(StoryText *itemText, int startIndex, int endIndex)
+{
+    if(startIndex > itemText->length() || endIndex > itemText->length())
+    {
+        qDebug() << "out of range";
+        return false;
+    }
+    int length = endIndex - startIndex;
+    for(int i = 0; i < length / 2; i++)
+    {
+        ScText *first = itemText->item(i + startIndex);
+        ScText *second = itemText->item(endIndex - 1 - i);
+        mirrorItem(first);
+        mirrorItem(second);        
+        GlyphLayout tmp = first->glyph;
+        first->glyph = second->glyph;
+        second->glyph = tmp;
+    }
+    return true;
+}
+/**
+    Get the first range for the embedding level `level` between `(start, limit)` 
+    If such a range is found, it outputs it to (out_start, out_end), and returns true.
+    If none is found, then we return false, and (out_start, out_end) is undefined
+*/
+bool BidiInfo::nextRunOfLevel(int level, int start, int limit, int* out_start, int* out_end)
+{
+    *out_start = *out_end = -1;
+    for(int index = start; index < limit; index++)
+    {
+        if(embeddingLevels[index] >= level)
+        {
+            *out_start = index;
+            break;
+        }
+    }
+    if(*out_start == -1) return false;
+    for(int index = *out_start; index < limit; index++)
+    {
+        if(embeddingLevels[index] < level)
+        {
+            *out_end = index;
+            break;
+        }
+    }
+    if(*out_end == -1) *out_end = limit;
+    assert(*out_end > *out_start);
+    return true;
+}
+/**
+    The bidi needs to be applied to one line at a time. This method expects you to tell it
+    where a line starts and ends
+    Call this function when you determine the start and end of a line. It will examine 
+    the given range and look for RTL runs and reverse them.
+    @param itemText: ojbect representing the text of the scribus text-frame
+    @param bidi: holds the bidi information about the text
+*/
+void doBidiReordering(StoryText *itemText, BidiInfo *bidi, int lineStart, int lineEnd, bool inner=false)
+{
+    int max_level = bidi->levelAt(lineStart);
+    int min_odd_level = max_level + 1;
+    for(int i = lineStart; i < lineEnd; i++)
+    {
+        int level = bidi->levelAt(i);
+        if(level > max_level) max_level = level;
+        if(level % 2 == 1 && level < min_odd_level) min_odd_level = level;
+    }
+    for(int level = max_level; level >= min_odd_level; level--)
+    {
+        int start = lineStart;
+        int end = start;
+        while(true)
+        {
+            if(bidi->nextRunOfLevel(level, end, lineEnd, &start, &end))
+            {
+                reverseGlyphLayout(itemText, start, end);
+            }
+            else
+            {
+                break;
+            }
+        }
+    }
+}
+/**
+    Applies bidi reordering to each line in a parapgraph.
+    @param layoutLines: tells us the line boundaries
+*/
+void doBidiParagraph(StoryText *itemText, BidiInfo *bidi, QLinkedList<LayoutLine> layoutLines)
+{
+    while(!layoutLines.isEmpty())
+    {
+        LayoutLine line = layoutLines.takeFirst();
+        // HACK:last space seems to be ignored/suppressed, this results in a character to be missing from the end of the line
+        //      when an RTL run crosses a line boundary, because the character was swaped with an invisible space
+        //      To circumvent this situation, we ignore the last character from the line if it's a space. This should not cause
+        //      any problem, even if it turned out that the space wasn't suppressed
+        //
+        if(itemText->item(line.endIndex-1)->ch == ' ') {
+                line.endIndex--;
+        }
+        doBidiReordering(itemText, bidi, line.startIndex, line.endIndex);
+    }
+}
+/**
+    This function takes off where PageItem_TextFrame::layout (thinks) it's done.
+    Inject a call to this method somewhere at the tail of the layout method
+*/
+void doBidiPostProcess(StoryText* itemText, BidiInfo *bidi, QLinkedList<LayoutLine> layoutLines)
+{
+    doBidiParagraph(itemText, bidi, layoutLines);
+}
+/**
+    selects the glyphs for the text before the layout method does
+ */
+void preShapeText(StoryText *itemText, BidiInfo *bidi, int start=0)
+{
+    QVector<uint> ustr = bidi->getUtf32();
+    while(start < itemText->length())
+    {
+        int end = nextScriptRun(ustr, start);
+        shapeGlyphs(itemText, start, end);
+        start = end;
+    }
+}
+#endif
+
 static double findRealOverflowEnd(const QRegion& shape, QRect pt, double maxX)
 {
 	while (!regionContainsRect(shape, pt) && pt.right() < maxX)
@@ -1078,7 +1328,11 @@ void PageItem_TextFrame::layout()
 	current.init(Width, Height, extra, lineCorr);
 	current.initColumns(columnWidth(), ColGap);
 	current.hyphenCount = 0;
-
+#if BIDI_LAYOUT
+    BidiInfo bidiInfo(&itemText); //FIXME: this treats the whole text as one paragraph
+    preShapeText(&itemText, &bidiInfo, firstInFrame());
+    QLinkedList<LayoutLine> layoutLines; //used to keep track of line boundaries
+#endif
 	//hold Y position of last computed line of text (with glyphs descent)
 	//for moving next line if glyphs are higher than that
 	double lastLineY = 0;
@@ -2145,6 +2399,10 @@ void PageItem_TextFrame::layout()
 					current.breakLine(itemText, style, firstLineOffset(), a);
 					EndX = current.endOfLine(cl, style.rightMargin(), maxYAsc, maxYDesc);
 					current.finishLine(EndX);
+#if BIDI_LAYOUT
+                    //bidi-line-break [dup#1]
+                    layoutLines << LayoutLine(current.line);					
+#endif					
 					//addLine = true;
 					assert(current.addLine);
 					//current.startOfCol = false;
@@ -2222,7 +2480,10 @@ void PageItem_TextFrame::layout()
 						//current.xPos = current.breakXPos;
 						EndX = current.endOfLine(cl, current.rightMargin, maxYAsc, maxYDesc);
 						current.finishLine(EndX);
-						
+#if BIDI_LAYOUT
+                    //bidi-line-break [dup#2]
+                    layoutLines << LayoutLine(current.line);					
+#endif						
 						hyphWidth = 0.0;
 						if ((hl->effects() & ScStyle_HyphenationPossible) || hl->ch == SpecialChars::SHYPHEN)
 						{
@@ -2456,7 +2717,10 @@ void PageItem_TextFrame::layout()
 
 			EndX = current.endOfLine(cl, style.rightMargin(), maxYAsc, maxYDesc);
 			current.finishLine(EndX);
-
+#if BIDI_LAYOUT
+                    //bidi-line-break [dup#3]
+                    layoutLines << LayoutLine(current.line);					
+#endif	
 			if (opticalMargins & ParagraphStyle::OM_RightHangingPunct)
 				current.line.width += opticalRightMargin(itemText, current.line);
 			
@@ -2495,6 +2759,9 @@ void PageItem_TextFrame::layout()
 			itemText.appendLine(current.line);
 			current.startOfCol = false;
 		}
+#if BIDI_LAYOUT
+    doBidiPostProcess(&itemText, &bidiInfo, layoutLines);
+#endif	
 	}
 	MaxChars = itemText.length();
 	invalid = false;
@@ -2509,7 +2776,10 @@ void PageItem_TextFrame::layout()
 //	qDebug("textframe: len=%d, done relayout", itemText.length());
 	return;
 			
-NoRoom:     
+NoRoom:
+#if BIDI_LAYOUT
+    doBidiPostProcess(&itemText, &bidiInfo, layoutLines); // XXX dup#2
+#endif     
 	invalid = false;
 	PageItem_TextFrame * next = dynamic_cast<PageItem_TextFrame*>(NextBox);
 	if (next != NULL)
diff -rupN orginal/scribus/shaper.cpp patched/scribus/shaper.cpp
--- orginal/scribus/shaper.cpp	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/shaper.cpp	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,245 @@
+/**
+    HarfBuzz glue
+
+    Author: Hasen il Judy 
+ */
+
+#include <QString>
+#include <QVector>
+#include <QDebug>
+
+#include "shaper.h"
+#include "fonts/ftface.h"
+#include "fonts/scface.h"
+
+//pointless proxy
+HB_Script charScript(uint cp)
+{
+    return code_point_to_script(cp);
+}
+
+/**
+    The HB_Script of the given utf32 string
+
+    @param pos: (optional, output) the position of the first script character (after skipping past Inherited)
+ */
+HB_Script stringScript(QVector<uint> ustr, int *pos)
+{
+    HB_Script script = charScript(ustr[0]);
+
+    if(pos)
+    {
+        *pos = 0;
+    }
+
+    if(script == HB_Script_Inherited) 
+    {
+        //oh no, generic script! grab the first
+        //script we can find
+        int i = 0;
+        for(i = 0; i < ustr.size(); i++)
+        {
+            HB_Script script_candidate = charScript(ustr[i]);
+            if(script_candidate != HB_Script_Inherited)
+            {
+                script = script_candidate;
+                break;
+            }
+        }
+        if(pos)
+        {
+            *pos = i;
+        }
+
+    }
+
+    //even after the loop!
+    if(script == HB_Script_Inherited)
+    {
+        script = HB_Script_Common;
+    }
+    return script;
+}
+
+int nextScriptRun(QUtf32 ustr, int start)
+{
+    HB_Script script = charScript(ustr[start]);
+    int index = start;
+
+    while(index < ustr.size())
+    {
+        index++;
+        HB_Script current_script = charScript(ustr[index]);
+        if(current_script != script && current_script != HB_Script_Inherited) //inherited is considered to be part of the same script run
+        {
+            break;
+        }
+    }
+    return index;
+}
+
+/**
+    The FT_Face should be initialized already in scribus, but I can't access it!!!
+
+    based on tests/fuzzing/fuzz.cc
+ */
+ShaperFontInfo::ShaperFontInfo(ScFace scface, qreal size)
+{
+    face = 0;
+    FT_Library library = 0;
+    // XXX: deal with error
+    bool error = FT_Init_FreeType(&library);
+    if(error)
+    {
+        qDebug() << "error initing FT library";
+    }
+    // qDebug() << "font file:" << scface.fontFilePath();
+    error = FT_New_Face(library, 
+            scface.fontFilePath().toUtf8().data(), 
+            scface.faceIndex(), &face);
+    if(error)
+    {
+        qDebug() << "error loading FT font?";
+    }
+    error = FT_Set_Char_Size(face, 0, 10, 72, 72); // XXX: not sure what should I put here!! fonts/ftface puts 10 for the size, why?
+    if(error)
+    {
+        qDebug() << "error setting font size";
+    }
+    hbFace = HB_NewFace(face, hb_freetype_table_sfnt_get);
+    hbFont.klass = &hb_freetype_class;
+    hbFont.userData = face;
+    hbFont.x_ppem  = face->size->metrics.x_ppem;
+    hbFont.y_ppem  = face->size->metrics.y_ppem;
+    hbFont.x_scale = face->size->metrics.x_scale;
+    hbFont.y_scale = face->size->metrics.y_scale;
+}
+
+ShaperFontInfo::~ShaperFontInfo()
+{
+    FT_Done_Face(face);
+}
+
+// fonts/ftface uses this thing (uniEM) to get the proper xadvance, 
+// I'm really *not* sure how I should use it, right now it's unused
+qreal ShaperFontInfo::uniEM()
+{
+    return static_cast<qreal>(face->units_per_EM);
+}
+
+/**
+    based on tests/fuzzing/fuzz.cc
+ */
+ShaperItemInfo::ShaperItemInfo(ShaperFontInfo *font)
+{
+    shaper_item.kerning_applied = true;
+    shaper_item.string = (HB_UChar16 *) str;
+    shaper_item.stringLength = maxLength;
+    shaper_item.item.bidiLevel = 1;
+    shaper_item.shaperFlags = 0;
+    shaper_item.font = font->get_HB_Font();
+    shaper_item.face = font->get_HB_Face();
+    shaper_item.glyphIndicesPresent = false;
+    shaper_item.initialGlyphCount = 0;
+
+    shaper_item.glyphs = new HB_Glyph[maxLength];
+    shaper_item.attributes = new HB_GlyphAttributes[maxLength];
+    shaper_item.advances = new HB_Fixed[maxLength];
+    shaper_item.offsets = new HB_FixedPoint[maxLength];
+    shaper_item.log_clusters = new unsigned short[maxLength];
+    shaper_item.num_glyphs = maxLength; // XXX really?
+}
+
+ShaperItemInfo::~ShaperItemInfo()
+{
+    delete[] shaper_item.glyphs;
+    delete[] shaper_item.attributes;
+    delete[] shaper_item.advances;
+    delete[] shaper_item.offsets;
+    delete[] shaper_item.log_clusters;
+}
+
+
+/**
+    Do the shaping for this string.
+
+    Assume str is an item, i.e. same script across the entire string
+ */
+ShaperOutput ShaperItemInfo::shapeItem(QString str)
+{
+    if(str.length() == 0)
+        return ShaperOutput();
+
+    QVector<uint> ustr = str.toUcs4(); //XXX let stringScript work with utf16
+
+    shaper_item.string = str.utf16();
+    shaper_item.stringLength = str.length();
+    shaper_item.item.script = stringScript(ustr, 0);
+    shaper_item.item.pos = 0;
+    shaper_item.item.length = str.length();
+
+    HB_ShapeItem(&shaper_item);
+
+    return ShaperOutput(&shaper_item);
+}
+
+/**
+    Use HarfBuzz to shape segment in question
+ */
+void shapeGlyphs(StoryText *itemText, int startIndex, int endIndex)
+{
+    if(startIndex < 0 || endIndex < 1) { return; }
+
+    QString text = itemText->text(startIndex, endIndex-startIndex); //this one takes pos, len
+
+    ScText * scitem = itemText->item(startIndex);
+    ScFace scface = scitem->font();
+    qreal size = scitem->fontSize();
+    
+    ShaperFontInfo font(scface, size / 10.0);
+    ShaperItemInfo shaper(&font);
+    ShaperOutput out = shaper.shapeItem(text); //HarfBuzz Magic
+
+    //out.glyphs has our glyphs
+    for(uint i = 0; i < out.num_glyphs; i++)
+    {
+        GlyphLayout &glyph = itemText->item(startIndex + i)->glyph;
+        glyph.glyph = out.glyphs[i];
+
+        // XXX: I can't figure out how to use the advances returned by harfbuzz
+        //      to position the glyphs, so I'm going to ask the scribus font
+        //      class to get the advances for me, then I'll handle marks as
+        //      a special case where there's no advance
+        //
+        //      Please somebody FIXME
+        //
+        glyph.xadvance = scface.glyphWidth(glyph.glyph, size); //works .. sorta!!
+
+        if(out.attributes[i].mark) //HACK vowel marks
+        {
+            glyph.xadvance = 0;
+        }
+
+        //debugging
+        // qDebug() << "glyphs[" << i << "] =" << out.glyphs[i];
+        // qDebug() << "advance[" << i << "] =" << out.advances[i];
+    }
+
+    if(out.num_glyphs < (uint)text.length())
+    {
+        // There were some ligatures, so zero-out the extra characters at the end of this run
+        for(int i = out.num_glyphs; i < text.length(); i++)
+        {
+            GlyphLayout &glyph = itemText->item(startIndex + i)->glyph;
+            glyph.glyph = scface.char2CMap(QChar::Nbsp);
+            glyph.xadvance = 0;
+        }
+
+    }
+}
+
+bool isCommonScript(QString str)
+{
+    return stringScript(str.toUcs4()) == HB_Script_Common; 
+}
+
diff -rupN orginal/scribus/shaper.h patched/scribus/shaper.h
--- orginal/scribus/shaper.h	1970-01-01 03:00:00.000000000 +0300
+++ patched/scribus/shaper.h	2010-03-16 09:26:59.000000000 +0300
@@ -0,0 +1,104 @@
+#define BIDI_LAYOUT 1    
+
+#if BIDI_LAYOUT
+#ifndef SHAPER_H
+#define SHAPER_H
+
+
+#include "pageitem_textframe.h"
+extern "C" {
+#include "harfbuzz/harfbuzz-shaper.h"
+#include "harfbuzz/harfbuzz-unicode.h"
+#include "harfbuzz/harfbuzz-freetype.h"
+}
+
+HB_Script charScript(uint cp);
+HB_Script stringScript(QVector<uint> ustr, int* out_pos=0);
+bool isCommonScript(QString str);
+
+typedef QVector<uint> QUtf32; 
+
+void shapeGlyphs(StoryText *itemText, int startIndex, int endIndex);
+int nextScriptRun(QUtf32 ustr, int start=0);
+
+/**
+    This is an attempt to encapsulate and streamline the font stuff
+    in the harfbuzz API with freetype
+ */
+class ShaperFontInfo
+{
+private:
+    HB_Face hbFace;
+    HB_FontRec hbFont;
+    FT_Face face;
+
+public:    
+    /**
+        The FT_Face should be initialized already in scribus
+
+        based on tests/fuzzing/fuzz.cc
+     */
+    ShaperFontInfo(ScFace face, qreal size);
+    ~ShaperFontInfo();
+    qreal uniEM();
+
+    HB_Font get_HB_Font() {
+        return &hbFont;
+    }
+
+    HB_Face get_HB_Face() {
+        return hbFace;
+    }
+};
+
+
+struct ShaperOutput
+{
+    hb_uint32 num_glyphs;
+    HB_Glyph* glyphs;
+    HB_GlyphAttributes* attributes;
+    HB_Fixed* advances;
+    HB_FixedPoint* offsets;
+    ushort* log_clusters;
+
+    ShaperOutput()
+    {
+        num_glyphs = 0;
+        glyphs = 0;
+        attributes = 0;
+        advances = 0;
+        offsets = 0;
+        log_clusters = 0;
+    }
+
+    ShaperOutput(HB_ShaperItem *item)
+    {
+        num_glyphs = item->num_glyphs;
+        glyphs = item->glyphs;
+        attributes = item->attributes;
+        advances = item->advances;
+        offsets = item->offsets;
+        log_clusters = item->log_clusters;
+    }
+
+};
+
+/**
+    Attempt to simplify and streamline the HarfBuzz shaper item stuff
+ */
+class ShaperItemInfo
+{
+private:
+    HB_ShaperItem shaper_item;
+    static const int maxLength = 1024;
+    uint8_t str[maxLength];
+
+public:
+    ShaperItemInfo(ShaperFontInfo *font);
+    ~ShaperItemInfo();
+    ShaperOutput shapeItem(QString str);
+};
+
+#endif
+#endif
+
